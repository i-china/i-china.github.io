<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favico.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/favicon.ico?v=5.1.4" color="#222">





  <meta name="keywords" content="Python,">





  <link rel="alternate" href="/atom.xml" title="iFaithFreedom" type="application/atom+xml">






<meta name="description" content="Python">
<meta name="keywords" content="Python">
<meta property="og:type" content="article">
<meta property="og:title" content="Python">
<meta property="og:url" content="http://yoursite.com/2019/08/09/Python-Note/index.html">
<meta property="og:site_name" content="iFaithFreedom">
<meta property="og:description" content="Python">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-08-29T13:02:42.021Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Python">
<meta name="twitter:description" content="Python">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/08/09/Python-Note/">





  <title>Python | iFaithFreedom</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>


    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">iFaithFreedom</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">文能提笔安天下，武能上马定乾坤</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/09/Python-Note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="<center> Hale Lv </center>">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="iFaithFreedom">
    </span>

    
      <header class="post-header">
	
		<i class="fa fa-heartbeat" aria-hidden="true">  </i>
		<font color="808080"> 热度 </font>
	
        
        
          <h1 class="post-title" itemprop="name headline">Python</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-09T18:59:15+08:00">
                2019-08-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/Django/" itemprop="url" rel="index">
                    <span itemprop="name">Django</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  54.9k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  222
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <center> Python </center>

<a id="more"></a>

<h2 id="Python-编程基础"><a href="#Python-编程基础" class="headerlink" title="Python 编程基础"></a>Python 编程基础</h2><pre><code>[编译型和解释型](http://c.biancheng.net/uploads/allimg/190211/2-1Z2111G33L03.gif)
领域：
    Web应用开发：
        通过mod_wsgi模块，apache可运行python的web程序，Python定义WSGI标准应用接口协调HTTP服务器与基于Python的Web程序之间的通信。Web框架：Django、TurboGears、web2py等
    操作系统管理、自动化运维开发：
        例：Ubunut的Ubiquity安装器、RedHat、Fedora的Anaconda安装器等
    游戏开发：
        支持更多的特性和数据类型，例：文明
    编写服务器软件：
        支持各种网络协议，可编写服务器软件及网络爬虫，例：第三方库Twisted
    科学计算：
        NumPy、SciPy、Matplotlip等
3和2的区别：
    print函数代替print语句
    默认使用UTF-8编码
    除法运算
    异常
    八进制字面量表示
    不等于运算符
    数据类型
Python 2to3：自动将Python2.x代码转换为Pyhton3.x代码</code></pre><p>安装<br>    Linux 两种方式：<br>        1. 命令行安装<br>            apt update<br>            apt install python3.6<br>            unlink /usr/bin/python        //    取消旧python的映射<br>            ln -s /usr/bin/python3.6 /usr/bin/python        // python3环境的路径和版本要写正确<br>        2. 源码安装<br>            下载：    wget python3.6下载路径<br>            压缩：    tar -zxvf python3.6.tgz<br>            编译：    ./configure –prefix=/usr/local/    make    make install</p>
<h3 id="第一个python"><a href="#第一个python" class="headerlink" title="第一个python"></a>第一个python</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">代码编写</span><br><span class="line">	两种方式：</span><br><span class="line">		1. 在提示符 &gt;&gt;&gt; 直接输入： print(&quot;hello world&quot;)</span><br><span class="line">		2. 文本编辑器编写并执行python程序</span><br><span class="line">			vim hi.python</span><br><span class="line">				print(&quot;hello world&quot;)</span><br><span class="line">			python hi.python</span><br><span class="line">			</span><br><span class="line">注释：</span><br><span class="line">	单行注释： #  </span><br><span class="line">	多行注释： 1. &apos;&apos;&apos;  xxx...xxx &apos;&apos;&apos;	2. &quot;&quot;&quot; xxx...xxx &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">中文编码声明注释：</span><br><span class="line">	1. # -*-coding:utf-8 -*-	2. # coding=utf-8</span><br><span class="line">	</span><br><span class="line">缩进规则：</span><br><span class="line">	冒号(:)和代码缩进</span><br><span class="line"></span><br><span class="line">编码规范(PEP8)</span><br><span class="line">	PEP: Python Enhancement Proposal, 8代表Pyton代码的样式指南</span><br><span class="line">		1. 每个import语句只导入一个模块，避免导入多个</span><br><span class="line">		2. 不在行为加分号，不将两条命令放一行</span><br><span class="line">		3. 每行不超80字符，如超，用小括号连接</span><br><span class="line">		4. 用空行增强可读性，顶级定义空两行，方法定义空一行</span><br><span class="line">		5. 使用空格分隔 运算符、函数参数</span><br><span class="line"></span><br><span class="line">Python标识符命名规范</span><br><span class="line">	1. 字符、下划线、数字，数字不开头</span><br><span class="line">	2. 不与保留子相同</span><br><span class="line">	3. 不包含空格、@、%、$等特殊字符</span><br><span class="line">	4. 严格区分大小写</span><br><span class="line">	5. 下划线开头有特殊意义</span><br><span class="line">		单下划线： 不能直接访问的类属性，无法通过 from ... import * 的方式导入</span><br><span class="line">		双下划线： 类的私有成员</span><br><span class="line">		双下划线开头和结尾： 专用标识符</span><br><span class="line"></span><br><span class="line">关键字(保留子)</span><br><span class="line">	查看方式：</span><br><span class="line">		import keyword</span><br><span class="line">		keyword.kwlist</span><br><span class="line"></span><br><span class="line">内置函数</span><br><span class="line">	[内置函数](https://docs.python.org/zh-cn/3/library/functions.html)</span><br></pre></td></tr></table></figure>

<h2 id="变量类型和运算符"><a href="#变量类型和运算符" class="headerlink" title="变量类型和运算符"></a>变量类型和运算符</h2><p>数值类型(整形、浮点型、复数)<br>    整形：<br>        二进制：1 和 0 组成， 0b|0B<br>        八进制：0～7 ， 0o|0O<br>        十进制：普通的整数，不以0开头<br>        十六进制：0～9 + A～F， 0x|0X<br>    浮点型：<br>        十进制形式：eg：3.14<br>        科学计数：eg：2.3e2<br>    复数：<br>        虚部用j|J表示</p>
<p>字符串(长字符串、原始字符串)<br>    长字符串：<br>        三个引号：单引号、双引号<br>    原始字符串：<br>        需要’&#39;进行转义</p>
<p>bytes类型<br>    由多个字节组成，以字节为单位进行操作，只负责以字节(二进制格式)序列来记录数据<br>    将字符串转换为 bytes对象的三种方式：<br>        1. 如内容是ASCII，在字符串之前添加 b 构建字节串值<br>        2. 调用 bytes() 函数<br>        3. 调用字符串本身的 encode() 方法</p>
<p>bool布尔类型<br>    真：True ：1<br>    假：False：0 </p>
<p>len() 获取字符串长度或字节数<br>    len(string)： 字符串的字符|字符串长度|一个字符串占用的字节数， string 进行长度统计的字符串</p>
<p>input() 获取用户输入的字符串<br>    将用户输入的内容放到字符串中，返回一个字符串中</p>
<p>print() 高级用法<br>    同时输出多个变量： eg：print(value,…sep=’’,end=’\n’,file=sys.stdout,flush=False)</p>
<p>格式化字符串(格式化输出)<br>    对各种类型的数据进行格式化输出<br>        print()函数包含三部分：<br>            1. 格式化字符串，相当于字符串模版<br>            2. 固定使用” % “ 作为分隔符<br>            3. 对应的变量，多个用’()’括号括起来<br>    转换说明符：<br>        %d， %i ：    十进制的整数<br>        %o        ：    八进制的整数<br>        %x，%X    ：    十六进制整数<br>        %e        ：    科学计数的浮点数<br>        %E        ：    科学计数的浮点数<br>        %f，%F    ：    十进制的浮点数<br>        %g        ：    智能选择%f或%e格式<br>        %G        ：    智能选择%F或%E格式<br>        %c        ：    格式化字符及其ASCII码<br>        %r        ：    使用repr()将变量或表达式转换为字符串<br>        %s        ：    使用str()将变量或字符串转换为字符串</p>
<p>转义字符<br>    \            ：    一行未完，转到下一行继续写<br>    &#39;            ：    单引号<br>    &quot;            ：    双引号<br>    \0            ：    空<br>    \n            ：    换行符<br>    \r            ：    回车符<br>    \t            ：    水平制表符<br>    \a            ：    响铃<br>    \b            ：    退格<br>    \            ：    反斜线<br>    \0dd        ：    八进制数，dd代表字符，eg：\012代表换行<br>    \xhh        ：    十六进制数，hh代表字符，eg：\x0a 代表换行</p>
<p>数据类型转换<br>    int(x)        ：    将x转换为整数类型<br>    lloat(x)    ：    转为浮点型<br>    complex(real,[,imag])    ： 创建一个复数<br>    str(x)        ：    转为字符串<br>    repr(x)        ：    转为表达式字符串<br>    eval(x)        ：    计算字符串中有效python表达式，返回一个对象<br>    chr(x)        ：    将整数x转为一个字符<br>    ord(x)        ：    将字符x转为对应的整数值<br>    hex(x)        ：    将整数x转为十六进制字符串<br>    oct(x)        ：    整数x转为八进制字符串</p>
<p>算术运算符<br>    +    ：    加<br>    -    ：    减<br>    *    ：    乘<br>    /    :    除<br>    %    :    取余，返回除法的余数<br>    //    :    整除，返回商的整数部分<br>    **    :    幂，返回x的y次方    eg：2**4，    16</p>
<p>赋值运算符<br>    =    ： 基本赋值<br>    扩展后的赋值运算符：<br>        +=    ：    加赋值<br>        -=    ：    减赋值<br>        <em>=    ：    乘赋值<br>        /=    ：    除赋值<br>        %=    ：    取余赋值<br>        *</em>=    ：    幂赋值<br>        //=    ：    取整数赋值<br>        |=    ：    按位或赋值<br>        ^=    ：    按位与赋值<br>        &lt;&lt;=    ：    左移赋值<br>        &gt;&gt;=    ：    右移赋值</p>
<p>位运算符<br>    &amp;    ：    按位与<br>    |    ：    按位或<br>    ^    ：    按位异或<br>    ～    ：    按位取反<br>    &lt;&lt;    ：    按位左移<br>    &gt;&gt;    ：    按位右移<br>    <a href="http://c.biancheng.net/view/2184.html" target="_blank" rel="noopener">详细说明</a></p>
<p>比较运算符<br>    &gt;        ：    大于<br>    &gt;=        ：    大于等于<br>    &lt;        ：    小于<br>    &lt;=        ：    小于等于<br>    ==        ：    等于<br>    !=        ：    不等于<br>    is        ：    判断两个变量引用的对象是否相同，不同返回False<br>    is not    ：    判断两个变量引用的对象是否不相同，不同返回True<br>        比较运算符 == 和 is 的区别：<br>            == ： 比较两个变量的值是否相等。<br>            is ： 对比两个变量引用的是否是同一个对象    </p>
<p>逻辑运算符<br>    and        ：    与    两个都为True，为True，否则为False<br>    or        ：    或    一个为True，为True，两都为False，则为False<br>    not        ：    非    只需一个为True，则为False</p>
<p>三目运算符(三元)<br>    先对逻辑表达式求值，如果为True，则返回True_statements的值，如为False，则返回False_statements的值<br>        A = 5    B = 3<br>        st = “A大于B” if A &gt; B else “A小于B”</p>
<p>运算符优先级<br>    <a href="http://c.biancheng.net/view/2190.html" target="_blank" rel="noopener">优先级</a></p>
<h2 id="列表、元组、字典、集合"><a href="#列表、元组、字典、集合" class="headerlink" title="列表、元组、字典、集合"></a>列表、元组、字典、集合</h2><pre><code>内置的四种常用数据结构： 列表(list)、 元组(tuple)、 字典(dict)、 集合(set)
列表和元组不同和相同：
    相同：按顺序保存元素
    不同：元组不可修改，列表可修改
字典和集合的相同和不同：
    相同：数据是无序的
    不同：字典可用key-value形式保存数据</code></pre><p>序列<br>    序列：一块可存放多个值的连续内容空间，值按一定顺序排列，可通过值位置的编号(索引)访问他们<br>        序列包括：字符串、列表、元祖、集合、字典。    字典和集合不支持索引、切片、相加、相乘等操作<br>            字符串是一种常见的序列，可直接通过索引访问字符串内的字符<br>            索引值从0开始递增，支持索引值负数，从右向左计数<br>        序列切片：是访问序列中元素的另一种方法，可访问一定范围内的元素，通过切片，生成新的序列<br>            snmae[start ：end ：step]<br>                sname：表示序列的名称<br>                start：表示切片开始索引位置，默认为0，从开头进行切片<br>                end：  表示切片的结束位置，若不指定，默认为序列的长度<br>                step： 表示隔几个存储位置取一次元素<br>        序列相加：两种相同类型的序列使用 “ + “ 运算符做相加操作，但不去重<br>            相同类型：指 + 两侧都是序列类型，都为元组 或 都为字符串<br>        序列相乘：<br>            使用数字n乘以一个序列生成新的序列，eg : print(‘hi’ * 3)<br>        检查元素是否包含在序列中：使用 in 关键字<br>            value in sequence    ： value 要检查的元素，sequence 指定的序列<br>        序列相关的内置函数：<br>            len()            ：    计算序列的长度，即返回序列中包含多少个元素<br>            max()            ：    最大元素<br>            min()            ：    最小元素<br>            list()            ：    将序列转为列表<br>            str()            ：    将序列转为字符串<br>            sum()            ：    计算元素和<br>            sorted()        ：    对元素排序<br>            reversted()        ：    反向序列中的元素<br>            enumerate()        ：    将序列组合为一个索引序列，用在for循环中</p>
<h3 id="list列表"><a href="#list列表" class="headerlink" title="list列表"></a>list列表</h3><pre><code>python没有数组，有列表。 列表将所有元素放在一对中括号中[],相邻元素用逗号隔开，eg：[var1,var2,...varn]，个数不限，支持的数据类型即可。可以是：整数、实数、字符串、列表、元组、浮点数等
    type([&apos;xxx&apos;,xxx,[xxx,&apos;xxx&apos;],xxx]) ：查看数据类型，数据类型为list，即为：列表
创建列表
    使用 = 运算符创建列表， 使用赋值运算符 = 直接将列表赋值给变量
                listname = [element1, element2,... elementn]
    使用list()函数创建列表：
        list() 将 元组、区间等对象转换为 列表
            a_tuple = (&apos;name&apos;,23)
            a_list = list(a_tuple)    
访问列表元素
    通过列表的索引获取指定的元素 或 直接使用 print() 函数
        list_str[n]        |        print(list_str)
删除列表
    使用 del 语句删除
        del list_str    </code></pre><p>列表添加元素的三种方法<br>    1. append()：在列表的末尾追加元素，传递列表或元组，视为一个元素，直接添加到列表中，形成包含列表和元组<br>        list_str.append(obj)<br>    2. extend()：不将被追加的列表或元组当作一个整体，只追加列表中的元素<br>        list_str.extend(obj)<br>    3. insert()：在列表中间增加元素<br>        list_str.insert(index，obj)    ： index 将元素插入到列表中指定位置处的索引值，将插入的对象视为一个整体</p>
<p>列表删除元素的三种方法<br>    删除元素的三种场景：<br>        1. 根据元素位置的索引值，用del语句<br>        2. 元素的位置删除，用 list提供的remove 方法<br>        3. 删除所有元素，用list提供的clear方法<br>    删除元素的3中方法：<br>        1. 根据索引值删除元素,类删除列表，用del语句<br>            del list_str[n:m]<br>        2. 根据元素值删除元素<br>            remove 删除第一个和指定值相同的元素，如没有，则显示ValueError错误，删除前判断是否存在，长于count()方法组合使用<br>        3. 删除列表所有元素<br>            clear()    : 清空列表的所有元素<br>                    list_str.clear() </p>
<p>list列表修改元素<br>    列表的元素类变量，可对列表的元素赋值，即可修改列表的元素<br>        通过索引到列表元素赋值，可用正数索引，也可用负数索引<br>            list_str = list(rang(1,5))<br>            list_str[1:3] = [‘a’,’b’]<br>                可用步长</p>
<p>list常用方法(count、index、pop、reverse、sort)<br>    交互模式：查看列表包含的所有方法： dir(list)<br>    count()    ：统计列表中某个元素出现的次数<br>        listname.count(obj)<br>    index() ：定位某个元素在列表中出现的位置，即索引<br>        listname.index(obj,start,end)    : start、end：指定范围内搜索元素<br>    pop()    ：移除列表中指定索引处的元素，若不指定，默认移除列表中最后一个元素<br>        listname.pop(index)<br>    reverse() ：反转列表中的元素<br>        listname.reverse()<br>    sort() ：对列表元素进行排序<br>        listname.sort(key=None,reserse=False)<br>            key ： 指定每个元素提取用于比较的健，key=str.lower：不区分大小写<br>            reserse ：是否需要反转排序，默认False表示从小到大。True为从大到小排序</p>
<h3 id="tuple元组"><a href="#tuple元组" class="headerlink" title="tuple元组"></a>tuple元组</h3><pre><code>按特定顺序排序的元素，序列不可变。不可边的列表，保存不可变的内容，用()定义，用，逗号分隔。元组可存储整数、实数、字符串、列表、元组等任何类型的数据
(&apos;xxx&apos;,[x,xx,&apos;xxx&apos;],(x,xx,xxx))
创建元组
    1. 使用 &quot;=&quot; 运算符直接创建元组
        tupe_str = (x,xx,xxx)
    2. 使用tuple()函数创建元组
        tuple(data)
            list_str = [x,&apos;xx&apos;,xxx]
            tuple_str = tuple(list_str)
访问元组元素
    使用元组各元素的索引值获取
        tuple_str[n]
修改元组元素
    元组不可改变序列，元素不可单独修改。
    修改方法：
        1. 对元组重新赋值：
            tuple_str = (x,xx,&apos;xxx&apos;)
            tuple_str = (&apos;x&apos;,&apos;xx&apos;,xxx)
        2. 通过连接多个元组的方式向元组中添加新元素
            tuple_str = (x,&apos;xx&apos;,xxx)
            tuple_str + (&apos;y&apos;,yy,&apos;yyy&apos;)
            元组连接的必须是元组，否则抛出：TypeError 错误
删除元组
    使用 del 语句删除：
        tuple_str = (&apos;x&apos;,xx,&apos;xxx&apos;)
        del(tuple_str)
元组使用场景：
    1. 元组作为很多内置函数和序列类型方法的返回值存在，使用某些函数或方法，如返回元组类型，对元组进行处理。
    2. 元组比列表访问和处理速度更快，如 对指定元素访问，且不修改时，使用元组
    3. 元组在映射(和集合的成员)中可做 健 使用，列表不行。 

元组和列表的区别：
    同属序列类型，按照顺序存放在一组数据，数据类型不受限制
    数据修改：
        列表可修改
        元组不可修改
    字节：元组比列表少16个字节
        列表是动态的，存储指针指向对应的元素 占用8个字节，元素可变，需要额外存储已经分配的长度大小
        元组，长度固定，存储元素不可变，存储空间是固定的。</code></pre><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><pre><code>dict ： 类列表，数据的集合，可变序列类型。无序可变序列，内容以 键值对 形式存放
特征：
    通过键来读取元素
    任意数据类型的无需集合
    可变的，可任意嵌套
    键必须是唯一
    键必须不可变

创建字典
    1. 花括号 { }
        每个元素包含2部分： 键 : 值， 键和值用冒号分割，相邻元素用逗号分割，大括号{}包含
        eg : dict_str = {&apos;name&apos;:&apos;hale&apos;,&apos;age&apos;:23}
            同一字典 键值 必须唯一，键值可以是整数、字符串、元组
    2. 通过 fromkeys() 创建字典
        创建所有键值为空的字典
        eg:    dict_str = dict.formkeys(list, value=None)
            各个键对应的值为空None， 通常用初始化字典，设置value的默认值
    3. 通过 dict() 映射函数创建字典
        eg： dict_str = dict(one=1,tow=2,thre=2)
             dict_str = [(&apos;one&apos;,1),(&apos;toe&apos;,2)]
             dict_str = [[&apos;one&apos;,1],[&apos;tow&apos;,2]]
             dict_str = ((&apos;one&apos;.1),(&apos;two&apos;,2))
             dict_str = [&apos;one&apos;,&apos;two&apos;,&apos;three&apos;]
访问字典
    通过 键 访问对应的元素值。 但字典元素是无序的
        eg： dict_str[&apos;one&apos;]
             dict_str.get(key[,default])    // 通过 get 方法获取指定键的值
                dict_str.get(&apos;two&apos;)
            使用get() 方法，可为其设置默认值
删除字典
    使用 del 语句 删除字典
        eg： del(dict_str)</code></pre><p>字典基本操作(添加、修改、删除键值对)<br>    字典无需<br>    操作字典的方法：<br>        1. 向现有字典添加键值对<br>        2. 修改现有字典中的键值对<br>        3. 删除指定键值对<br>        4. 判断是否存在指定键值对</p>
<pre><code>字典添加键值对
    dict[key] = value
        dict ： 表示字典名称
        key  ： 要添加元素的键，不可重复
        value： 要添加的值。支持的数据类型

修改键值对
    不是修改某一键值对的键和值，只修改值
    如 新添加的元素的键已存在，替换原键对应的值

删除键值对
    del 
        eg：del dict_str[&apos;one&apos;]

判断是否存在
    使用 in 或者 not in 运算符
        eg：&apos;one&apos; in dict_str        |        &apos;two&apos; not in dict_str</code></pre><p>字典方法攻略<br>    keys() 、values() 、 items()<br>        keys() ：返回字典中的所有键<br>            dict_str.keys()<br>        values() ： 返回字典中所有键对应的值<br>            dict_str.values()<br>        items() ： 返回字典中所有的键值对<br>            dict_str.items()<br>    返回数据的两个方法：<br>        list()    ： 将返回的数据转换为 列表<br>            list(dict_str.keys())<br>        利用多重赋值，李彤循环结构将键或值分别赋给不同的变量<br>            for k in dict_str.keys():<br>                print(k,end=’ ‘)<br>            for v in dict_str.values():<br>                …v<br>            for k,v in dict_str.items():<br>                print(‘key: ‘,k,’value: ‘,v)</p>
<pre><code>copy() 方法
    返回一个具有相同键值对的新字典
        dict_str.copy()            // copy 将字典 的数据 拷贝给 字典other
            拷贝原理，有深、有浅。 copy为深拷贝

update() 方法
    使用一个字典所包含的键值对更新已有的字典
        如果已存在的键值对，原value会被覆盖，如不存在，即添加

pop() 方法
    获取指定 key 对应的 value，并删除这个键值对
        dict_stc.pop(&apos;key&apos;)

popitem()
    随机弹出字典中的一个键值对，弹出字典最后一个键值对，底层存储的最后一个键值对
        dict_str.popitem()

setdefault() 方法
    根据 key 获取对应 value 的值，如获取的key在字典中不存在，会设置默认的value，然后返回该key对应的value
        dict_str.setdefault(&apos;one&apos;,23)

使用字典格式化字符串
    在字符串模板中按 key 指定变量， 然后通过字典为字符串模板中的 key 设置值 
        字符串模板中使用key
            people = &apos;name: %(name)s , price: %(price)0.2f, sex: %(sex)s&apos;
            object = {&apos;name&apos;:&apos;Hale&apos;,&apos;price&apos;:23,&apos;sex&apos;:&apos;man&apos;}
            print(people % object)</code></pre><p>Set 集合<br>    保存不重复的元素，集合中的元素是唯一的，set集合是无序的<br>    集合将所有元素放在一堆大括号中{}，元素用 ‘,’ 分割<br>        {key,key2,keyN}<br>        只能存储不可变的数据类型，即 整形、浮点型、字符串、元组。 不可以存储 列表、字典、集合。<br>    两种集合类型：<br>        1. set 类型的集合 ： 可做 添加、删除元素的操作<br>        2. frozenset 集合 ：    不可以</p>
<pre><code>创建set集合
    2种方式：
        1. 使用 {} 创建 ：直接将集合赋值给变量
            set_str = {key,key1,keyn...}

        2. set()函数创建
            set_str = set(iteration)
                iteration : 表示字符串、列表、元组、range对象等数据

访问set集合元素
    访问集合元素使用循环结构
        for key in set_str:
            print(key,end=&apos; &apos;)

删除set集合
    del()
        del(set_str)
集合常用操作：向集合中添加、删除元素。以及集合之间做交集、并集、差集等运算。</code></pre><p>set集合基本操作(添加、删除、交集、并集、差集)<br>    向set集合中添加元素<br>        set_str.add(element)<br>            只能是数字、字符串、元组或布尔类型，不能添加列表、字典、集合等可变数据<br>    从set集合删除元素<br>        set_str.remove(element)<br>            如删除不存在的，抛出 KeyError错误<br>                如不想提示KetError错误，可使用discard()方法</p>
<p>set集合做交集、并集、差集运算<br>    交集： &amp;    取两集合公共的元素        set1 &amp; set2<br>    并集： |    取两集合全部的元素        set1 | set2<br>    差集： -    取一个集合中另一集合没有的元素    set1 - set2<br>    对称差集： ^    取集合A和B中不属于A&amp;B的元素  set1 ^ set2</p>
<p>set集合方法<br>    dir(set)<br>        add、clear、copy、difference、difference_update、discard、intersection、intersection_update、isdisjoint、issubset、i是superset、pop、remove、symmetric_difference、symmetric_difference_update、union、update</p>
<p>frozenset 集合(set 集合不可变版本)<br>    特点：<br>        1. 当集合元素不需要改变时，使用frozenset代替set更安全<br>        2. API不需要改变时，必须用frozenset代替set。如 集合元素不可变，set只能包含frozenset<br>            s = set()<br>            f = frozenset(‘key’)<br>            s.add(f)</p>
<p>深入底层字典和集合<br>    字典和集合是进行过性能高度优化的数据结构<br>        字典和集合的工作原理：<br>            数据机构<br>                字典和集合的内部结构都是一张哈希表<br>                    对字典：表存储了哈希值(hash)、键和值<br>                    对集合：哈希表内只存储单一的元素<br>    哈希表插入数据<br>    哈希表查找数据<br>    哈希表删除元素</p>
<h2 id="字符串常用方法详解"><a href="#字符串常用方法详解" class="headerlink" title="字符串常用方法详解"></a>字符串常用方法详解</h2><pre><code>拼接字符串、截取字符串、格式化字符串</code></pre><h3 id="字符串拼接-拼接数字"><a href="#字符串拼接-拼接数字" class="headerlink" title="字符串拼接(+拼接数字)"></a>字符串拼接(+拼接数字)</h3><pre><code>使用加号 (+) 作为字符串的拼接运算符
字符串拼接数字
    先将数字转换为 字符串
        数字转换为字符串： str()    repr()
            直接拼接字符串和数字，会报错</code></pre><p>截取字符串(字符串切片)<br>    通过索引来操作字符：<br>        string[index]                // index 表示索引值，从0开始递增，最后一个为-1<br>    使用范围获取字符串的中间值：<br>        string[start: end: step]<br>            string : 要截取的字符串<br>            start : 要截取的第一个字符所在的索引，默认为0<br>            end ：要截取最后一个字符所在的索引。如不指定，默认字符串的长度<br>            step ：从start字符开始，step 距离获取一个字符，end索引出的字符。step默认值为1<br>                支持用 in 运算符判断是hi否包含某个子串</p>
<p>split() : 分割字符串<br>    将一个字符串按照指定的分隔符切分成多个子串，字串被保存在列表中，不包含分隔符<br>        str.split(sep,maxsplit)<br>                1. str：要分割的字符串<br>                2. set：指定分隔符，默认使用空字符分割<br>                3. maxsplit：可选参数，指定分割的次数，如不指定，次数不限</p>
<p>join() ：合并字符串<br>    将列表(或元组)中多个字符串采用固定的分隔符连接在一起<br>        join_str = str.join(iterable)<br>            1. join_str : 合并后生成的新字符串<br>            2. str ： 指定合并时的分隔符<br>            3. iterator： 做合并操作的源字符串数据，允许：列表、元组等</p>
<p>count() ：统计字符串出现的次数<br>    用于检索指定字符串在另一个字符中出现的次数，如检索的字符串不存在，返回 0，否则返回出现的次数<br>        str.count(sub[,start[,end]])<br>            1. str : 原字符串<br>            2. sub : 要检索的字符串<br>            3. start : 起始位置<br>            4. end : 终止位置</p>
<p>find() ：检测字符串中是否包含某字串<br>    检索字符串中是否包含目标字符串，如包含：出现第一次该字符串的索引，返回-1<br>        1. str：原字符串<br>        2. sub：目标字符串<br>        3. start： 起始位置，若不指定，默认从头开始索引<br>        4. end ：结束位置，若不指定，一直检索到结尾<br>    rfind() ：字符串从右边开始检索</p>
<p>index() ：检测字符串中是否包含某子串<br>    检索是否包含指定的字符串，若指定的字符串不存在，抛出异常<br>        str.index(sub[,start[,end]])<br>            1. str : 原字符串<br>            2. sub : 子字符串<br>            3. start : 起始位置，默认从头开始<br>            4. end : 结束位置，默认到结尾</p>
<p>startswith() 和 endswith<br>    startswith() ： 检索字符串是否以指定字符串开头，是返回True，反之False<br>        str.startswith(sub[,start[,end]])<br>            1. str ： 原字符串<br>            2. sub ： 要检索的字串<br>            3. start ：起始位置，默认从头开始<br>            4. end ： 结束索引<br>    end.swith(sub[,start[,end]]) : 是否以指定字符结尾，是返回True，反之Flase<br>        str.endswith(sub[,start[,end]])<br>            1. str : 原字符串<br>            2. sub : 检索的字符串<br>            3. start : 起始位置<br>            4. end : 结束位置</p>
<h3 id="字符串大小写转换的三种函数"><a href="#字符串大小写转换的三种函数" class="headerlink" title="字符串大小写转换的三种函数"></a>字符串大小写转换的三种函数</h3><pre><code>title()    : 将字符串中每个单词的首字符转为大写，其他转为小写
    str.title()
        str 要进行转换的字符串
lower() : 将字符串所有大写字符转为小写
    str.lower()
upper() : 将字符串所有小写字母转为大写
    str.upper()</code></pre><p>去除字符串中空格(删除指定字符)的3种方法<br>    去除字符串中的空格和特殊字符<br>        特殊字符： 制表符 \t、回车符 \r 、换行符 \n<br>    strip()     lstrip()     rstrip()<br>    1. strip()    :    删除字符串前后(左右两侧)的空格或特殊字符<br>        str.strip([chars])<br>            str : 原字符串<br>            chars ：指定要删除的字符，可同时指定多个，若不指定，默认为空格、制表符、回车符、换行符等特殊字符<br>    2. lstrip() :    删除字符左边的空格或特殊字符<br>        str.lstrip([chars])<br>    3. rstrip() :    删除字符右边的空格或特殊字符<br>        str.rstrip([chars])</p>
<p>format() 格式化输出<br>    str.format(args)<br>        str : 指定字符串显示样式<br>        args: 指定要进行格式化转换的项，如多项，逗号分割<br>            str 格式：<br>                { [index][:[fill] align] [sign] [#] [width] [.precision] [type] ]}<br>                    index :  指定 ；后边设置的格式要作用到args中第几个数据，索引值从0开始<br>                    fill : 指定空白处填充的字符<br>                    align : 指定数据的对齐方式<br>                        &lt; :    左对齐<br>                        &gt; : 右对齐<br>                        = : 右对齐，放在填充内容的最左侧，只对数字类型有效<br>                        ^ : 居中，和width参数一起使用<br>                    sign：<br>                        +    ：<br>                        -    ：<br>                        空格：<br>                        #    ：<br>                    width ：指定输出数据时所占的宽度<br>                    .precision : 指定保留的小数位数<br>                    type ：指定输出数据的具体类型<br>                        s    ： 字符串<br>                        d    ： 十进制整数<br>                        c    ： 将十进制整数自动转换为对应的Unicode字符<br>                        e|E    ： 转为科学技术后，再格式化输出<br>                        g|G    ： 自动再e|f E|F 中切换<br>                        b    ： 将十进制自动转换为二进制，再格式化<br>                        o    ： 转为八进制，再格式化<br>                        x|X    ： 转为十六进制<br>                        f|F    ： 转为浮点数<br>                        %    ： 显示百分比，默认小数点后6位</p>
<p>encode() 和 decode() 字符串编码转换<br>    2中常用字符串类型： str 、bytes。 str：Unicode 。 bytes：二进制数据。使用encode 和decode 进行转换<br>    encode() : 将str类型转换为bytes类型，成为 编码<br>        str.encode([encoding=”utf-8”][,errors=”strict”])<br>            str ：要进行转换的字符串<br>            encoding=”utf-8” : 采用的字符编码，默认位utf-8 中文：gb2312<br>            errors=”strict”     : 指定错误处理方法：<br>                    strict :    遇到非法字符就抛出异常<br>                    ignore :    忽略非法字符<br>                    replace:    用 “?” 替换非法字符<br>                    xmlcharrefreplace: 使用xml的字符引用</p>
<pre><code>decode() ： 将bytes类型的二进制数据转换为str类型，过程称为&quot;解码&quot;
    bytes.decode([encoding=&quot;utf-8&quot;][,errors=&quot;strict&quot;])
        bytes : 要进行转换的二进制数据
        encoding=&quot;utf-8&quot;: 解码时采用的字符编码
        errors=&quot;strict&quot;</code></pre><p>dir() 和 help() 帮助函数<br>    dir() : 列出指定类或模块名包含的全部内容，包括函数、方法、类、变量等<br>    help() : 查看某个函数或方法的帮助文档</p>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><pre><code>两种基本流程控制结构： 分支结构、循环结构
    分支结构： 实现根本条件来选择性地执行某段代码
    循环结构： 实现根据循环条件重复执行某段代码
    if语句：分支
    while、for in 循环
        break 和 continue 控制程序的循环结构</code></pre><h3 id="if条件语句可分3中形式："><a href="#if条件语句可分3中形式：" class="headerlink" title="if条件语句可分3中形式："></a>if条件语句可分3中形式：</h3><pre><code>    if、if else、 if elif else
        if 表达式：
            代码块
        if 表达式：
            代码块 1
        else：
            代码块 2
        if 表达式 1：
            代码块 1
        elif 表达式 2：
            代码块 2
        elif 表达式 3：
            代码块 3
            ...
        else :
            代码块 n

if 表达式真假值判断方法：
    if 表达式的值 是 布尔值，要么是真 True，假为False
    假 False： False、None、0、 &quot;&quot; 、()、[]、{}

if else 语句用法规范
    1. 代码块不要忘记缩进
    2. if 代码块不要随意缩进
    3. if 表达式不要遗忘冒号

if 语句嵌套
    if condition 1:
        if condition 2:
            code1
        else:
            code2

if condition 1:
    if condition 2:
        code 1
    else: 
        code 2
else:
    if condition 3:
        code 3
    else:
        code 4

pass 语句及作用
    占位

assert 断言函数及用法
    对于对一个bool表达式进行断言，如为True，继续向下执行，否则引发 AssertionError错误
    会让程序奔溃，测试、调试的辅助工具
    eg： age = input(&apos;enter age&apos;)
        age = int(age)
        assert 30 &lt; age &lt; 100
        print(&apos;your age at 30 ~ 100&apos;)</code></pre><h3 id="while-循环语句"><a href="#while-循环语句" class="headerlink" title="while 循环语句"></a>while 循环语句</h3><pre><code>如果条件condition为真，一直重复执行代码块
while 条件表达式：
    代码块
    执行流程：判断条件表达式的值，如果为True 真，执行代码块语句，执行完毕，重新判断条件表达式的值是否为真，如为真，继续执行代码块，直到表达式的值为假False，才终止循环

使用while循环遍历列表和元组
    列表和元组有索引，通过while循环、列表和元组的索引来遍历列表和元组中的所有元素
        eg： tuple_str = (&apos;name&apos;,&apos;age&apos;,&apos;sex&apos;)
            i = 0
            while(i &lt; len(tuple_str)):
                print(tuple_str[i])
                i += 1</code></pre><h3 id="for循环用法"><a href="#for循环用法" class="headerlink" title="for循环用法"></a>for循环用法</h3><pre><code>循环语句有2种，while 和for 
    用于遍历字符串、列表、元组、字典、集合等序列类型
        for 迭代变量 in 字符串|列表|元组|字典|集合：
            代码块
        迭代变量：用来存放从序列类型变量中读取的元素，一般不再循环中对迭代变量赋值，代码块值具有相同缩进格式的多行代码。也称为循环体

for 进行数值循环
    如 0 ～100 的累加
    r = 0;
    for i in range(101):
        r += i
    print(r)
range() : 生成一系列连续的整数，用于for循环中
        range(start,end,step)
            1. start : 计数的初始值，默认从0开始
            2. end : 计数的计数值，不能省略
            3. step : 指定步长，两个数之间的间隔，如省略，默认为1
                for i in range(1,10,2):
                    print(i,end=&apos; &apos;)

for循环遍历列表和元组
    列表或元组有几个元素，for循环的循环体就执行几次，迭代变量会依次被赋值为元素的值
isinstance() 函数用于判断某个变量是否为指定类型的实例

for 循环遍历字典
    1. items()    ： 返回字典中所有key-value对的列表
    2. keys()    ： 所有key的列表
    3. values()    ： 所有value 的列表</code></pre><p>循环结构中else用法<br>    while 和 for循环，可都跟 else 代码块，作用：当循环条件为False，程序最先执行else代码块的代码<br>    for 循环可使用else代码块，当for把所有元素遍历一次后，会执行else代码块，</p>
<p>for 和while 循环嵌套<br>    for 和 while 可循环嵌套<br>        for i in range(1,10):<br>            j = 0<br>            while j &lt; 3:<br>                print(“i %d, j %d”,(i,j))<br>                j += 1<br>    循环可以两层或者更多层嵌套    </p>
<p>列表推导式for表达式<br>    利用range区间、元组、列表、字典、集合等数据类型，快速生成一个列表<br>    [表达式 for 迭代变量 in 可迭代对象 [if 条件表达式]]<br>        for 迭代变量 in 可迭代对象<br>            表达式</p>
<p>元组推导式<br>    利用range区间、元组、列表、字典、集合等，生成一个列表<br>    (表达式 for 迭代变量 in 可迭代对象[if 条件表达式])<br>    使用元组推导式获得新元组或新元组中的元素，有三种方式：<br>        1. 使用tuple()，直接将生成器对象转换为元组<br>            a = (x for x in range(1,10))<br>                print(tuple(a))<br>        2. 使用for循环遍历生成器对象，获得各个元素<br>            a = (x for x in range(1,10))<br>            for i in a:<br>                print(i,end=’ ‘)<br>            print(tuple(a))<br>        3. 使用 <strong>next</strong>() 方法遍历生成器对象，获得各个元素<br>            a = (x for x in range(3))<br>            print(a.<strong>next</strong>())<br>            a = tuple(a)<br>        无论是for循环遍历生成器对象，还是<strong>next</strong>()遍历，遍历后原生成器对象不复存</p>
<p>字典推导式<br>    使用字典推导式可以借助列表、元组、字典、集合以及range区间，快速生成复合需求的字典<br>        {表达式 for 迭代变量 in 可迭代对象 [if 条件表达式]}<br>            []    扩起来的可省略</p>
<p>集合推导式<br>    集合推导式可借助 列表、元组、字典、集合以及range区间，快速生成符合需求的集合<br>        {表达式 for 迭代变量 in 可迭代对象 [if 条件表达式]}<br>    集合推导式和字典推导式的区别：<br>        如果表达式以键值对(key:value)的形式，则是字典推导式，反之是集合推导式</p>
<p>zip函数用法<br>    可把两个列表 压缩 为一个zip对象(可迭代对象)，可使用一个循环并行遍历两个列表<br>        a = [‘a’,’c’,’dd’]<br>        b = [1,3,2]<br>        [x for x in zip(a,b)]<br>        zip函数压缩得到的可迭代对象所包含的元素是由原列表元素组成的元组</p>
<p>reversed 函数及用法<br>    反向遍历，可接收各种序列(元组、列表、区间等)，返回一个反序排列的法代器<br>        reversed()可对列表、元组进行反转</p>
<p>sorted函数及用法<br>    与reversed 函数类似，接收一个可迭代对象作为参数，返回一个对元素排序的列表<br>        不会改变传入的可迭代对象，而是返回新的、排序好的列表<br>            sorted 可传入一个 reverse 参数，也可传入一个 key 参数</p>
<p>2种强制离开循环体的方法：<br>    1. continue    ： 可跳过执行本次循环体中剩余的代码，转而执行下一次的循环<br>    2. break ： 完全终止当前循环</p>
<h2 id="函数和lambda表达式"><a href="#函数和lambda表达式" class="headerlink" title="函数和lambda表达式"></a>函数和lambda表达式</h2><h3 id="函数是执行特定任务的一段代码，通过一段代码定义成函数，并为该函数指定一个函数名，可多次调用。可代码复用"><a href="#函数是执行特定任务的一段代码，通过一段代码定义成函数，并为该函数指定一个函数名，可多次调用。可代码复用" class="headerlink" title="函数是执行特定任务的一段代码，通过一段代码定义成函数，并为该函数指定一个函数名，可多次调用。可代码复用"></a>函数是执行特定任务的一段代码，通过一段代码定义成函数，并为该函数指定一个函数名，可多次调用。可代码复用</h3><pre><code>lambda表达式：可作为表达式、函数参数或函数返回值，可让代码更简洁。

函数(函数定义、函数调用)
    函数定义需注意3点：
        1. 函数需要几个关键的需要动态变化的数据，这些数据被定义成函数的参数
        2. 函数需要传几个重要的数据(就是调用该函数的人希望得到的数据)，这些数据被定义成返回值。 
        3. 函数的内部实现过程。</code></pre><h3 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h3><pre><code>def 函数名(形参列表):
    // 由零条到多条可执行语句组成的代码块
    [return 返回值]
        函数名：函数名是合法的标识符，单词的字符全小写，但此语单词用下划线分隔
        形参列表：定义该函数可接收的参数。形参列表由多个形参名组成，多个用逗号隔开，定义函数指定了形参列表，就必须传入相应的参数值，谁调用函数谁负责为形参赋值。</code></pre><p>函数的调用<br>    调用函数就是执行函数<br>        函数名(形参值)<br>        函数名：是调用的函数的名称，形参值：指当初创建函数传入的各个形参的值。即创建函数有多少个形参，就传入多少个值，顺序必须和创建函数一致。函数名后的小括号不能省略。</p>
<p>为函数提供说明文档<br>    使用内置的 help()函数查看帮助文档。 很重要<br>        可为函数编写说明文档， 写在函数声明之后、函数体之前。<br>        可通过help()函数查看，也可通过函数的 <strong>doc</strong> 属性访问函数的说明文档<br>            def hi():<br>                ‘’’<br>                    这是说明文档的内容，输出 hi<br>                ‘’’<br>                print(‘hi’)<br>        使用help()函数查看该函数的说明文档<br>            help(hi)</p>
<h3 id="函数值传递和引用传递-包括形式参数和实际参数的区别"><a href="#函数值传递和引用传递-包括形式参数和实际参数的区别" class="headerlink" title="函数值传递和引用传递(包括形式参数和实际参数的区别)"></a>函数值传递和引用传递(包括形式参数和实际参数的区别)</h3><pre><code>函数参数作用：传递数据给函数，令其对接收的数据做具体的操作处理
    形式参数(形参) 和 实际参数(实参)的区别：
        形式参数：在定义函数时，函数名后面括号中的参数就是形式参数
            def hi(name):
                print(name)
        实际参数：在调用函数时，函数名后面括号中的参数成为实际参数，函数的调用者给函数的参数。
            name = &apos;hale&apos;
            hi(name)
函数参数的传递方式分为2种：值传递和引用(地址)传递
    1. 值传递：参数类型不可变类型(字符串、数字、元组)
    2. 引用(地址)传递： 实参类型为可变类型(列表、字典)
    值传递和引用传递的区别：
        函数参数进行值传递后，如形参的值改变，不影响实参的值。
        函数参数进行引用传递后，若改变形参的值，实参的值也一同改变
            def name(name):

            name(&apos;hale&apos;)

            def name(name):

            name = [&apos;adam&apos;]</code></pre><h3 id="函数参数传递机制"><a href="#函数参数传递机制" class="headerlink" title="函数参数传递机制"></a>函数参数传递机制</h3><pre><code>1.值传递：实际是将实际参数值的副本(复制品)传入函数，本身不受影响
    值传递会在主程序和swap函数分配两块栈区，用于保存局部变量，实际上在swap 函数战区产生了两个变量，并将主程序栈区的两个变量赋值给swap栈区的两个参数：即对swap函数的两个变量进行初始化。系统存在两个变量，只是存在于不同的栈区中。</code></pre><p>函数参数的引用传递<br>    如实际参数的数据类型是可变对象(列表、字典)，函数参数的传递方式将采用引用传递方式。但引用传递方式的底层实现，采用的依然是值传递的方式<br>    程序创建了一个字典对象，定义了一个引用变量，其实就是一个指针 指向字典对象， 此时内存中有两个东西：对象本身和只想该对象的引用变量，<br>    <a href="http://c.biancheng.net/view/2258.html" target="_blank" rel="noopener">具体内容点击</a></p>
<pre><code>结论：
    1. 不管类型的参数，对参数直接使用 = 符号复制是没用的，使用 = 符号复制不能改变参数
    2. 如函数修改数据，则通过把数据包装成列表、字典等可变对象，然后把列表、字典等对象作为参数传入函数，在函数中通过列表、字典的方法，可改变数据。</code></pre><p>python 位置参数<br>    也称 必备参数，指必须按照正确的顺序将实际参数传到函数中，调用函数时传入实际参数的数量和位置必须和定义函数保持一致。<br>    实参和形参数量必须一致<br>        如数量不一致抛出 TypeError异常<br>    实参和形参位置必须一致<br>        若不一致，会出现两中结果：<br>            1. 抛出 TypeError 异常<br>            2. 产生的结果和预期不符</p>
<p>函数关键字参数用法<br>    指使用形式参数的名字来确定输入的参数值，此方式指定函数参数，不需要位置一致，只需参数名正确即可！<br>        def obj(name,age):</p>
<pre><code>obj(age,name)</code></pre><h3 id="函数默认参数设置"><a href="#函数默认参数设置" class="headerlink" title="函数默认参数设置"></a>函数默认参数设置</h3><pre><code>在定义函数时，直接给形式参数指定默认值
    def 函数名(...，形参名 = 默认值)：
        代码块
在调用函数时关键字参数必须位于位置参数的后面，在定义函数时指定了默认值的参数(关键字参数)必须在没有默认值的参数之后</code></pre><p>可变参数函数用法<br>    可变参数：不定长参数，传入函数中的实际参数是任意个数。主要形式：<br>        1. 可变参数：形参前添加一个 ‘ * ‘<br>            <em>parameter<br>                parameter 表示形参名，可接收任意多个实际参数，并放到一个元组中<br>            def kebian(name,</em>obj):<br>                for i in obj:<br>                    print(b)<br>            kebian(‘hale’,’judy’,’jally’)<br>            obj 参数可传入多个字符串作为参数值，本质就是一个元组，将参数的多个值集成一个元组<br>            可变的形参可处于形参列表的任意位置<br>        2. 可变参数：形参前添加两个 ‘ * ‘<br>            <strong>parameter<br>                parameter 表示形参名，可接任意多个以关键字参数赋值的实际参数，并放到一个字典中。<br>            def obj(name,age,sex, *height,</strong>weight):<br>                print(name,age,sex)<br>            obj(‘hale’,’jally’,’judy’,100,200,110,220)<br>                前三为普通参数，两个字符串收集成元组，最后两个关键字收集为字典</p>
<pre><code>逆向参数收集
    指在程序已有列表、元组、字典等对象，把他们的元素 拆开 后传给函数的参数。需在传入的列表、元组参数前添加一个星号，在字典参数前添加两个星号
        def obj(name,age):
        objs = [&apos;hale&apos;,23]
        obj(objs)
    可变参数，如程序将一个元组传给参数，使用逆向收集
        def obj(name,*ages):
            print(name)
            print(ages)
        ages = (12,23,32)
        obj(&apos;hale&apos;,*ages)</code></pre><p>return 函数返回值<br>    用def 创建函数时，可用return 指定返回的值，该返回值可是任意类型，但return在同意函数值可出现一次，只要执行，就会结束函数。<br>        return [返回值]<br>            指定返回值后，在调用函数时，将该函数赋值给一个变量，用变量保存函数的返回值，也可将函数作为其他函数的实际参数<br>        def name(names):<br>            pass<br>        def age(name(name)):<br>            pass</p>
<p>函数返回多个值的方法<br>    将多个值包装成列表后返回，也可直接返回多个值，自动将多个返回值封装成元组</p>
<p>函数递归<br>    在函数体内调用它本身，递归包含了一种隐式的循环。重复执行某段代码，<br>    递归调用，必须在某个时刻函数的返回值是确定的，否则死循环。 递归一定要向已知方向进行<br>        def fn(n):<br>            if n = 10:<br>                return 1<br>            elif n = 20:<br>                return 2<br>            else :<br>                return fn(n+2) - 2*fn(n + 1)</p>
<h3 id="变量作用域-全局和局部"><a href="#变量作用域-全局和局部" class="headerlink" title="变量作用域(全局和局部)"></a>变量作用域(全局和局部)</h3><pre><code>变量的有效范围：全局和局部
    局部变量：指在函数内部定义并使用的变量，只在函数内部有效
        在执行函数时，为该函数分配一块&quot;临时内存空间&quot;，所有局部变量保存在临时变量中，执行完后，释放内存空间，局部变量失效。离开此函数不能再访问，否则抛出NameError
        def name():
            i_name = &apos;Hale&apos;
        name()
    全局变量：指能作用于函数内部的变量，可在各个函数外部使用，也可在各函数内部使用
        定义方式：
            1. 在函数体外的变量，一定为全局变量：
                i_name = &apos;Hale&apos;
                def name():
                    print(i_name)
            2. 在函数体内定义使用 global 关键字对变量修饰，即为全局变量
                def name():
                    global your_name = &apos;Judy&apos;
获取指定作用域范围中的变量
    1. globals() : 该函数返回全局范围内所有变量组成的 变量字典
    2. locals() : 返回当前局部范围内所有变量组成的 变量字典
    3. vars(object) : 获取在制定对象范围内所有变量组成的 变量字典 如不传入 object 参数， vars 和 locals 作用完全相同
globals 和 locals 的区别：
    1. local 获取当前局部范围内所有变量组成的 变量字典， 如全局范围内(在函数外)调用locals 函数，获取全局范围内所有变量组成的 变量字典。 而 globals 无论在哪，获取的都是全局的变量字典
    2. 一般，locals 和 globals 获取的 变量字典 只被访问，不被修改。实际上都可被修改，修改改变全局变量本身。 locals 获取的局部范围内的 变量字典 不会影响局部变量

全局变量和局部变量的遮蔽现象
    全局变量所有函数体内被访问，若函数体中定义了与全局变量同名的变量，会发生遮蔽。
两种方式避免遮蔽：
    1. 访问被遮蔽的全局变量， globals 函数来实现
    2. 在函数中声明全局变量， 使用global 语句来声明全局变量</code></pre><p>局部函数及用法(包含 nonlocal 关键字)<br>    在函数体内定义函数，被放在函数体内的函数称为 局部函数<br>        默认情况下，局部函数对外隐藏，在封闭函数内有效，封闭函数返回局部函数，以便在其他作用域中使用局部函数<br>        局部函数内的变量会遮蔽他所在函数内的局部变量<br>        在函数体内声明的变量，赋值语句不是定义新的局部变量，而是访问他所在函数体内的局部变量。<br>        nonlocal 关键字， 可声明访问赋值语句只是访问该函数内的局部变量</p>
<h3 id="函数高级用法"><a href="#函数高级用法" class="headerlink" title="函数高级用法"></a>函数高级用法</h3><pre><code>函数本身是一个对象，即可用于赋值，也可用作其他函数的参数，还可作为其他函数的返回值
使用函数变量
    所有函数都是 function 对象，即可把函数本省赋值给变量，就像把整数、浮点数、列表、元组赋值给变量一样
使用函数作为函数形参
    若调用函数能动态传入 某些逻辑代码，就需要在函数中定义函数形参，即可在调用该函数时传入不同的函数作为参数
使用函数作为返回值
    使用函数作为其他函数的返回值</code></pre><h3 id="lambda-表达式及用法"><a href="#lambda-表达式及用法" class="headerlink" title="lambda 表达式及用法"></a>lambda 表达式及用法</h3><pre><code>使用 lambda 表达式代替局部函数
    lambda [parameter_list] : 表达式
        lambda 几个要点：
            1. lambda 必须使用lambda 关键字定义
            2. 在 lambda 关键字后、冒号左边的参数列表，可没有参数，也可有多个，多个用逗号隔开，冒号右边是该lambda表达式的返回值
            本质：就是匿名的、单行函数体的函数
                lambda x，y ：x + y 
                --------------------
                def add (x , y):
                    return x + y
    lambda 两个用途：
        1. 单行函数： 使用lambda 可省去定义函数的过程，代码更简洁
        2. 不需要多次复用的代码，lambda表达式使用完后立即释放，提高了性能</code></pre><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><pre><code>封装、继承、多态</code></pre><h3 id="面向对象：-一切皆对象"><a href="#面向对象：-一切皆对象" class="headerlink" title="面向对象： 一切皆对象"></a>面向对象： 一切皆对象</h3><pre><code>面向对象编程(Object-oriented Programming, OOP)，是一种封装代码的方法
    代码封装：隐藏实现功能的具体代码，仅留接口
    分为两部分描述：
        1. 表面特征： 颜色、外观等
        2. 行为：爬、运动
        所有变量都是对象，
    面向对象相关术语：
        类： 即模版，可创建出多个具体实例。称为：类的实例化
        对象： 创造出的实例，称为对象
        属性： 类中所有变量 称为属性
        方法： 类中所有函数 称为方法</code></pre><p>定义类<br>    类：仅充当图纸，根据图纸创造对象。 先定义、在创建类的实物对象，通过实例对象实现特定的功能。类名：每个单词首字母大写，单词与单词不能有分隔符<br>    创建类使用 class 关键字<br>        class 类名：<br>            N个类属性<br>            N个类方法</p>
<pre><code>__init__()类构造方法
    用于创建对象使用，没创建一个类的实例对象时，会自动调用它。
        def __init__(self,...):
            代码块
        可包含多个参数，但必须包含 self 此参数，必须作为第一个，类的构造方法至少要一个self参数，self 不需要手动传递参数,python自动给 self传值。
        class Person {
            &apos;&apos;&apos; commit &apos;&apos;&apos;
            def __init__(self):
                print(&apos;构造方法&apos;)
        }</code></pre><h3 id="类对象的创建和使用"><a href="#类对象的创建和使用" class="headerlink" title="类对象的创建和使用"></a>类对象的创建和使用</h3><pre><code>class 语句只创建类，需手动创建类的对象，创建类对象的过程称为类的实例化
    类名(参数)
    class Person {
        def __init__(self,name,age):
            self.name = name
            self.age = age
    }
    p = Person(&apos;Hale&apos;,23)

类对象的使用
    作用：
        1. 操作对象的实例变量，即访问、修改实例对象的值，以及给对象添加、删除实例变量
        2. 调用对象的方法。
    类对象访问变量或方法
        使用已创建好的对象访问类中的实例变量
            对象名.变量名
        使用类对象调用类中方法
            对象名.方法名(参数)
            对象与变量名及方法名 用 &apos; . &apos; 连接
    给类对象动态添加变量
        为已创建好的对象动态增加实例变量，只要为它的新变量赋值
            xxx.yyy = [&apos;xxxx&apos;,&apos;xxxx&apos;]
        删除变量：
            del xxx.yyy
    给类对象动态添加方法
        如果希望动态增加的方法能自动绑定到第一个参数，可借助于types模块下的MethodType 进行包装

self 用法
    python 类方法中的self 参数相当于 C++中的 this 指针
    同一个类可产生多个对象，当某个对象调用类方法时，该对象会把自身的引用作为第一个参数自动传给该方法，python自动绑定类方法的第一个参数指向调用该方法的对象，即解释器知道操作哪个对象的方法
    对构造方法，self 参数 代表 该 构造方法 正在初始化的对象
    class Obj {
        def __ini__(self):
            pass
        def __name(self):
            pass
        def __jump(self):
            self.name()
    }
        当self参数作为对象的默认引用时，可访问self参数，也可当成实例方法的返回值
        class ReturnSelf {
            def obj(self):
                if hasattr(self,&apos;age&apos;):
                    self.age += 1
                else: 
                    self.age = 1
                return self
        }
        rs = ReturnSelf()        // 实例化</code></pre><p>类变量和实例变量(类属性和实例属性)<br>    类中定义的属性和方法，在外部，无法调用。 可把类看做独立的作用域，称为 类命名空间，类属性定义在类命令空间内的变量<br>        类属性 可分为： 类属性也称类变量，和 实例属性也称实例变量<br>        类变量： 指定义在类中，但在各个类方法外的变量，类变量的特点是：所有类的实例化和对象都可共享类变量的值，即类变量可在所有实例化对象中作为公用资源<br>            类变量推荐直接用类名访问，也可用对象名访问<br>                改变类变量的值会作用于该类所有的实例化对象</p>
<p>实例变量(实例属性)<br>    指：定义在类的方法中的属性，特点：只作用于调用方法的对象<br>        实例变量只能通过对象名访问，无法通过类名直接访问<br>            class Obj {<br>                name = ‘hale’<br>                age = 23<br>                def change(self,name,age):<br>                    self.name = name<br>                    self.age = age<br>            }<br>            one = Obj()<br>            one.change(‘judy’,24)<br>            print(one.name,one.age)            //    Judy 24<br>            print(Obj.name,Obj.age)            //    Hale 23</p>
<p>实例方法、静态方法和类方法详解<br>    分为： 类方法、实例方法、静态方法</p>
<pre><code>类实例方法
    实例方法： 至少需要包含一个self参数，用于绑定调用此方法的实例对象，可用类对象、也可用类名调用
        p = Person{}
        p.say(&apos;xxx&apos;)
        Person.say(person,&apos;xxx&apos;)

类方法
    类方法： 至少包含一个参数，名为： cls， 自动将类本身绑定给 cls 参数， cls命名不规定，可随意命名
    类方法需要使用 @classmethod 修饰
        class Obj:
            # @classmethod 修饰的方法是类方法
            @classmethod 
            def name(cls):
                print(&apos;Class Method:&apos;,cls)
        如没有 @classmethod ，会将 name方法认定为 实例方法，而不是类方法

类静态方法
    静态方法和函数唯一区别： 静态方法定义在类空间，而函数定义在程序所在的空间中
    静态方法没有类似 self cls 特殊的参数，因此不会对包含的参数做任何类或对象的绑定。此方法中无法调用任何类和对象的属性和方法，其和类关系不大
    静态方法使用 @staticmethod 修饰
        class Obj:
            @staticmethod
            def name(p):
                print(&apos;static Method&apos;, p)
    静态方法的调用：可用类名，也可用类对象
        Obj.name(&apos;Class Name&apos;)
        o = Obj()
        b.name(&apos;Class Object&apos;)</code></pre><p>类调用实例方法<br>    # 定义全局空间的foo函数<br>    def foo():<br>        pass<br>    # 全局空间的bar变量<br>    bar = 20<br>    class Obj:<br>        # 定义Obj空间的bar变量<br>        def foo():<br>            pass<br>        bar = 200<br>    # 调用Obj空间的函数和变量<br>    foo()<br>    Obj.foo()</p>
<p>总结： python类可调用实例方法，使用类调用实例方法，不会自动为方法的第一个参数self绑定参数值，程序必须显式为参数self传参，称为：未绑定方法</p>
<p>property 函数：定义属性<br>    属性名 = property(fget=NOne, fset=None, fdel=None, doc=None)<br>        fget：制定获取该属性值的类方法， fset：指定设置该属性值的方法， fdel：指定删除该属性值的方法，doc： 提供说明此函数的作用<br>        类似property 函数合成的属性被称为计算属性，并不存储任何状态，值通过某种算法得到，当程序对该值赋值时，被赋的值也会被存储到其他实例变量中</p>
<p>@parperty 装饰器<br>    既保护类的封装特性，又可以用 对象.属性 操作类属性，除了 property 函数，还提供 @property 装饰器，可直接通过方法名来访问方法，<br>    @preperty<br>    def 方法名(self)<br>        代码块<br>    要想实现修改 xx 属性的值，还为xx属性添加 setter方法，可用 setter装饰器<br>        @方法名.setter<br>        def 方法名(self,value):<br>            代码块<br>    可用 deleter 装饰器 删除指定属性<br>        @方法名.deleter<br>        def 方法名(self):<br>            代码块</p>
<p>@函数装饰器及用法<br>    内置的函数装饰器：    @staticmethod    @classmethod    @property<br>    自定义函数装饰器：<br>        1. 将被修饰的函数(函数B) 作为参数传给 @ 符号引用的函数(函数A)<br>        2. 将函数B替换(装饰) 成第一步的返回值</p>
<h3 id="封装机制及实现方法"><a href="#封装机制及实现方法" class="headerlink" title="封装机制及实现方法"></a>封装机制及实现方法</h3><pre><code>目的：
    隐藏类的实现细节
    使用预定义方法访问，可加入控制逻辑，限制对属性的不合理访问
    进行数据检查，保证完整性
    便于修改，提高可维护性
实现封装的两方面：
    1. 将对象的属性和实现细节隐藏起来，不可直接访问
    2. 暴露方法，对属性安全访问和操作
定义：
    类的成员命名以双下划线开头，就能隐藏
    class User:
        def __hide(self):
            pass
        def getname(self):
            return self.__name</code></pre><h3 id="继承机制及作用"><a href="#继承机制及作用" class="headerlink" title="继承机制及作用"></a>继承机制及作用</h3><pre><code>实现继承的类称为 子类， 被继承的类称为 父类，也叫 基类、超类
子类继承父来的语法：在定义类时，将多个父类放在子类后的圆括号内
    class 类名(父类1，父类2,...):
        类定义部分
Python是多继承机制，一个类可继承多个父类
    object 类是所有类的父类，直接父类、间接父类
    子类是对父类的扩展，子类是一种特殊的父类
    从子类的角度看，子类扩展(extend)类父类，从父类的角度看，父类派生出(derive)出子类，
    class Fruit:
        def name(self):
            pass
    class Animal:
        def name(self):
    class Obj(Fruit,Animal):
        pass</code></pre><p>父类方法重写<br>    子类与父类同名的方法为方法重写(Override)，也叫方法覆盖<br>    使用未绑定方法调用被重写的方法</p>
<p>super()函数：调用父类的构造方法<br>    子类继承父类的构造方法，如子类有多个直接父类，优先选择最前面父类的构造方法<br>    如果子类重写了父类的构造方法，子类的构造方法必须调用父类的构造方法<br>        子类调用父类构造方法的2种方式：<br>            1. 使用未绑定，构造方法是实例方法，可通过此方式来调用<br>            2. 使用super()函数调用父类的构造方法<br>                当子类继承多个父类时，super()只调用第一个父类的构造方法，其他父类构造方法只能使用 未绑定 的方式调用</p>
<p><strong>slots(两侧得都有两下划线)</strong>: 限制类实例动态添加属性和方法<br>    <strong>slots</strong> 属性的值是一个元组，该元组的所有元素列出了该类的实例允许动态添加的所有属性名和方法名</p>
<p>type(): 动态创建类<br>    type 可指定三个参数：<br>        1. 参数一： 创建的类名<br>        2. 参数二： 该类继承的父类集合，使用元组指定多个父类<br>        3. 参数三： 该字典对象为该类绑定的类变量和方法</p>
<p>MetaClass 元类<br>    创建类的来，即创建类后，再由类来创建实例进行应用，使用元类可在创建类时动态修改类定义<br>    定义元类： 类名以MetaClass 结尾，元类需要定义并实现 <em>new</em>()方法，一定要有返回值<br>        <strong>new</strong>()方法作用： 使用class定义新类时，如指定了元类，<strong>new</strong>方法会被自动执行</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><pre><code>同一变量完全可在不同的时间应用不同的对象，当同一变量在调用同一方法，可呈现多种行为
    class Bird:
        def move(self,filed):
            print(&apos;bird %s&apos; % filed)
    class Dog:
        def move(self,filed):
            print(&apos;dog %s&apos; % field)
    b = Bird()
    b.move(&apos;sky&apos;)
    d = Dog()
    d.move(&apos;road&apos;)</code></pre><p>枚举类定义和使用<br>    定义方式：<br>        1. 使用Enum 列出多个枚举值来创建枚举类<br>        2. 通过继承Enum 基类来派生枚举类<br>        import enum<br>        s = enum.Enum(‘name’,(‘hale’,’judy’,’jally’))<br>    可通过枚举类变量名或枚举值来访问指定枚举对象<br>    <strong>members</strong> 属性，返回一个dict字典，包含了该枚举的所有实例，遍历 <strong>members</strong>属性访问枚举的所有实例</p>
<pre><code>枚举构造器
    可定义构造器，为枚举定义构造器后，在定义枚举实例时，必须为构造器参数设置值</code></pre><h2 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h2><h3 id="异常机制主要依赖try、except、else、finally、raise-五个关键字"><a href="#异常机制主要依赖try、except、else、finally、raise-五个关键字" class="headerlink" title="异常机制主要依赖try、except、else、finally、raise 五个关键字"></a>异常机制主要依赖try、except、else、finally、raise 五个关键字</h3><pre><code>    1. try 关键字后的代码块简称 try块，放置 引发异常的代码
    2. 在except 后对应的是异常类型和一个代码块，表明该 except 块处理这种类型的daimakaui    
    3. 多个except 后放一个 else 块，程序不出现异常还是执行 else 块
    4. finally 块用于回收在 try 打开的无力资源，异常机制保证 finally 块总被执行
    5. raise 用于引发实际的异常，可单独作为语句使用，引发具体异常对象

常见异常类型
    语法错误 和 运行时错误
        语法错误：
            解析代码是出现的错误，报出 SyntaxError 语法错误
        运行时错误：
            逻辑错误
    常见异常类型
        AssertionError ： 当assert 关键字后的条件为假时，程序停止并抛出此异常
        AttributeError ： 试图访问的对象属性不存在时，抛出
        IndexError       ： 索引超出序列范围
        KeyError       ： 字典中查找一个不存在的关键字时
        NameError       ： 尝试访问一个未声明的变量时
        TypeError       ： 不同类型数据之间的无效操作
        ZeroDivisionError ： 除法运算中除数为 0 引发此异常</code></pre><h3 id="异常处理机制-1"><a href="#异常处理机制-1" class="headerlink" title="异常处理机制"></a>异常处理机制</h3><p>try except 异常处理<br>    try:<br>        可能产生异常的代码块<br>    except ([Error1,Error2,…]) [as e]:        // ErrorN 表明处理异常的具体类型<br>        处理异常的代码块1<br>    except ([Error3,Error4,…]) [as e]:        // as e 表示将异常类型赋值给变量 e<br>        处理异常的代码块2<br>    执行流程：<br>        1. 先执行 try 中的代码块，如出现异常，自动生成异常对象，提交给Python解释器，称为引发异常<br>        2. 解释器收到异常，寻找处理该异常对象的except块，如找到合适的except块，则把异常对象交给except块，如找不到，则终止。<br>            try:<br>                name = input(‘Enter name’)<br>            except (ValueError, ArithmeticError):<br>                print(‘error’)<br>            except :<br>                print(‘no error’)<br>    访问异常信息<br>        通过except块添加 as e 来访问异常对象的相关信息，当解释器决定调用某个except块来处理该异常对象时，会将异常对象赋值给except 块后的异常变量<br>        异常对象包含的属性和方法：<br>            args ： 返回异常的错误编号和描述字符串<br>            errno ： 返回异常的错误编号<br>            strerror ： 返回异常的描述字符串<br>            with_traceback() ： 处理异常的传播轨迹信息</p>
<pre><code>异常类的继承体系
    异常类派生于 BaseException，
    [继承关系](http://c.biancheng.net/uploads/allimg/190215/2-1Z2151H054Q0.gif)
    BaseException 主要子类是 Exception，不管是系统的异常类，还是用户自定义的异常类，都应该从Exception派生
        1. 如发生数值类型错误，则调用ValueError 对应的except块处理该异常
        2. 如发生逻辑错误： 2/0，则调用ArthmeticError 对应的except块处理该异常
        3. 如运行时发生其他异常，异常对象是Exception类或其他子类的实例，则调用Exception对应的except块处理该异常
        注： 先捕获小异常，再捕获大异常。</code></pre><p>try except else 异常处理结构<br>    作用：指定当try块中没有发现异常时要执行的代码，若try中发现异常，则else块中的语句不会执行<br>        try:<br>            r = 20 / int(input(‘enter num’))<br>        except ValueError:<br>            pass<br>        except ArithmeticError:<br>            pass<br>        else:<br>            print(‘no error’)</p>
<p>try except finally : 资源回收<br>    完整异常处理语法结构：<br>        try:<br>            xxx<br>        except SubException as e:<br>            xxx<br>        except SubException as e:<br>            xxx<br>        else:<br>            xxx<br>        finally:<br>            xxx<br>        在异常处理语法结构中，只有try块是必须的<br>            1. 如没有try块，就没有except 和 finally 块<br>            2. except 和 finally 块可选，可同时出现，也可出现其一<br>            3. 可有多个except块，但捕获父类异常的except块位于捕获子类异常的后面<br>            4. 不能只有try块，没有except  finally块<br>            5. 多个except 位于try块后，finally块位于所有except块之后<br>        不要在finally块中使用如return 或 raise 等导致方法终止的语句，若在finally中使用return 或 raise 语句，会导致 try 块、except、中的return、raise语句失效</p>
<h3 id="raise-用法"><a href="#raise-用法" class="headerlink" title="raise 用法"></a>raise 用法</h3><pre><code>    如需自行引发异常，则使用raise语句
        raise [exceptionName [(reason)]]
    raise 语句三种用法
        1. raise： 单独一个raise。 引发当前上下文中捕获的异常，如在except中，引发 RuntimeError异常
        2. raise异常类名称： 指定异常类的默认实例
        3. raise异常类名称： 引发指定异常的同时，附带异常的描述信息
raise 不需要参数
    class Demo:
        def __init__(self,init_price):
            self.init_price = init_price
        def bid(self,bid_price):
            try:
                xxx
            except Exception as e:
                xxx
                raise 

except 和 raise 同时使用
    实现通过多个方法协作处理同一个异常，可在except中结合raise语句来完成
        try:
            xx
        except Exception as e:
            raise AuctionException(&apos;error message by self&apos;)
            raise AuctionException(e)
        对异常的处理分为两个部分：
            1. 应用后台需要通过日志来记录异常发生的详细情况
            2. 根据异常向应用使用者传达某种提示
    用户自定义异常对原始异常进行包装
        raise AuctionException(e)
        被称为： 异常包装或异常转译
自定义异常类
    自定义异常需继承Exception 基类 或Exception的子类，
    class AuctionException(Exception):
        pass</code></pre><h3 id="sys-exc-info-获取异常信息"><a href="#sys-exc-info-获取异常信息" class="headerlink" title="sys.exc_info(): 获取异常信息"></a>sys.exc_info(): 获取异常信息</h3><pre><code>捕获异常的2种方式获得更多的异常信息：
    1. 使用 sys 模块中的 exc_info 方法
    2. 使用 traceback 模块中的相关函数
两个方法返回异常全部信息：exc_info 和 last_traceback 
        exc_info ： 将当前的异常信息以元组的形式返回，该元组包含三个元素， type、value、traceback
                type： 异常类型的名称
                value： 捕获到的异常实例
                traceback： 是一个traceback 对象
                    try:
                        pass
                    except:
                        print(sys.exc_info())</code></pre><h3 id="traceback模块：-获取异常信息"><a href="#traceback模块：-获取异常信息" class="headerlink" title="traceback模块： 获取异常信息"></a>traceback模块： 获取异常信息</h3><pre><code>使用traceback 模块查看异常传播轨迹，现将traceback模块引入，提供两个方法：
    1. traceback.print_exec() ： 将异常传播轨迹信息输出到控制台或指定文件中
    2. format_exc()    ： 将异常传播轨迹信息转换为 字符串
print_exception(etype,value,tb[,limit[,file]])
    三个参数用于分别指定异常的信息：
        etype ： 指定异常类型
        value ： 指定异常值
        tb ： 指定异常的traceback 信息
print_exc([limit[,file]])
    print_exc 自动处理except块所捕获的异常，涉及两个参数
        1. limit ： 限制显式异常传播的层数
        2. file  ： 指定将异常传播轨迹信息输出到指定文件中，如不指定该参数，默认输出到控制台
        import traceback
        def xxx():
            raise SelfException(&apos;by self&apos;)
        try:
            xxx()
        except:
                traceback.print_exec(file=open(&apos;log.txt&apos;,&apos;a&apos;))</code></pre><h3 id="自定义异常类及用法"><a href="#自定义异常类及用法" class="headerlink" title="自定义异常类及用法"></a>自定义异常类及用法</h3><pre><code>自定义一个异常类，通常应继承自 Exception类，直接继承Exception。也可继承自从Exception 继承而来的类，间接继承Exception
[异常继承图](http://c.biancheng.net/uploads/allimg/190819/2-1ZQ9154321244.gif)</code></pre><p>异常机制使用细节<br>    成功的异常处理4个小目标<br>        1. 使程序代码混乱最小化<br>        2. 捕获并保留诊断信息<br>        3. 通知合适的人员<br>        4. 采用合适的方式结束异常活动<br>    不要过度使用异常<br>        1. 把异常和普通错误混淆<br>        2. 使用异常处理代替流程控制<br>        3. 不要使用过于庞大的try块<br>        4. 不要忽略捕获到的异常</p>
<p>assert 调试程序<br>    assert 条件表达式 [,描述信息]<br>        assert 语句作用： 当条件表示式为真时，什么也不做，如果为假，则assert抛出 AssertionError异常<br>            age = input(‘enter age’)<br>            name = input(‘enter name’)<br>            assert 20 &lt; age &lt; 100 , ‘age at 20 ~ 100’<br>    assert 可与  try except 异常处理语句配合使用<br>        try:<br>            age = input(‘enter age’)<br>            assert 20 &lt; age &lt; 100 , ‘age at 20 ~ 100’<br>        except AssertionError as e:<br>            print(‘age is error’)</p>
<h2 id="类特殊成员-属性和方法"><a href="#类特殊成员-属性和方法" class="headerlink" title="类特殊成员(属性和方法"></a>类特殊成员(属性和方法</h2><h3 id="特殊：-方法名、属性名前后添加双下划线。-可重写或调用方法来实现特殊的功能"><a href="#特殊：-方法名、属性名前后添加双下划线。-可重写或调用方法来实现特殊的功能" class="headerlink" title="特殊： 方法名、属性名前后添加双下划线。 可重写或调用方法来实现特殊的功能"></a>特殊： 方法名、属性名前后添加双下划线。 可重写或调用方法来实现特殊的功能</h3><pre><code>如： 构造方法： __init__ ，通过重写类中的此方法实现自己的初始化逻辑
__repr__()方法 ： 显式属性
__del__方法：    销毁对象
__dir__用法 ： 列出对象的所有属性(方法)名
__dict__属性： 查看对象内部所有属性名和属性值组成的字典
setattr() , getattr() , hasattr()
issubclass , isinstance ： 检查类型
__call__
__getitem__ , __setitem__ , __delitem__ , __len__, __contains__
__iter__ , __reversed__ ：实现迭代器
生成器详解

__repr__()方法： 显式属性
    class xxx:
        def __init__(self,xx,xxx):
            self.xx = xx
            self.xxx = xxx
    x = xxx(&apos;xx&apos;,&apos;xxx&apos;)
__repr__(): 所有的类都是object类的子类，所以所有的对象都具有 __repr__()方法
    此方法：用于实现： 当程序直接打印该对象时，系统输出该对象的 自我描述 信息，用来告诉外界该对象具有的状态信息
    此方法返回该对象实现类的 &quot;类名+object at + 内存地址&quot;，如
    class obj:
            def __init__(self,xx,xxx):
                self.xx = xxx
                self.xxx = xxx
            def __repr__(self):
                return &quot;self.xx&quot; + self.xx + \
                    ,&quot;self.xxx&quot; + self.xxx 
    x = obj(&apos;xx&apos;,&apos;xxx&apos;)
重写__repr__() 总是返回该对象的所有令人感兴趣的信息所组成的字符串，如下格式的字符串
    类名 [field1 = 值1， filed1 = 值2 ,...]

__del__方法： 销毁对象
    与 __init__() 方法对象， __init__() 方法用于初始化对象，  __del__() 方法用于销毁python对象，在任何对象被系统收回之时，会自动调用该对象的 __del__() 方法
如不需要一个对象时，必须把对象占用的内存空间释放，称为垃圾回收(GC, Garbage Collector)
    Python 采用自动引用计数(ARC) 方式来回收对象所占用的空间
    当对象被垃圾回收时，自动调用该对象的 __del__方法，当对象的引用计数变为0时，对象才会被回收
    class Obj:
        del __init__(self,xx):
            self.xx = xx
        def __del__(self):
            pass
    o = Obj(&apos;xx&apos;)
    x = o
    del x
若父类提供 __del__()方法，则系统重写 __del__() 方法时必须显式调用父类的 __del__()方法，保证合理回收父类实例的部分属性

__dir__用法：列出对象的所有属性(方法)名
    用于列出该对象内部的所有属性包活方法名，该方法将会返回包含所有属性方法名的序列
    当程序对某个对象执行 dir 函数时，将该对象的__dir__() 方法返回值进行排序，然后包装成 列表
    class obj:
        def __init__(self,xxx):
            self.xxx = xxx
        def info():
            pass 
    x = obj
    print(x.__dir__())
        不仅输出对对象定义的xxx 、info属性和方法，还有系统内置的属性和方法，如 __repr__, __del__方法

__dict__属性： 查看对象内部所有属性名和属性值组成的字典
    即可看对象的所有内部状态，也可通过字典语法来访问或修改指定属性的值
        class obj:
            def __init__(self,xxx):
                self.xxx = xxx
        x = obj
        print(x.__dict__)
        print(x.__dict__(xxx))</code></pre><h3 id="setattr-getattr-hasattr-函数用法"><a href="#setattr-getattr-hasattr-函数用法" class="headerlink" title="setattr(), getattr(), hasattr() 函数用法"></a>setattr(), getattr(), hasattr() 函数用法</h3><pre><code>动态检测对象是否包含某些属性或方法相关的函数：
    1. hasattr(obj,name) : 检查obj对象是否包含名为 name 的属性或方法
    2. getattr(object,name[,default]) : 获取object对象中名为 name 的属性的属性值
    3. setattr(obj,name,value,/) : 将obj对象的 name 属性设为 value
        class obj:
            def __init__(self,xx,xxx):
                self.xx = xx
                self.xxx = xxx
            def info():
                pass
        x = obj
        print(hasattr(x,&apos;xxx&apos;))        // True
        print(getattr(x,&apos;xxx&apos;))        // True
        setattr(x,&apos;xx&apos;,&apos;yy&apos;)
        print(x.xx)
setattr() 可改变 对象的属性值，若对象设置的属性不存在，可添加属性</code></pre><h3 id="issubclass-和-isinstance-函数-：-检查类型"><a href="#issubclass-和-isinstance-函数-：-检查类型" class="headerlink" title="issubclass 和 isinstance 函数 ： 检查类型"></a>issubclass 和 isinstance 函数 ： 检查类型</h3><pre><code>issubclass(cls, clsss_or_tuple) : 检查cls是否为后一个类或元组包含的多个类中任意类的子类
isinstance(obj, class_or_tuple) : 检查obj是否为后一个类或元组包含的多个类中任意类的对象
区别：
    issubclass 第一个参数是类名，判断是否为子类
    isinstance 第一个是变量，判断是否为该类或子类的实例                         
    第二参数都可使用 元组
__base__属性 ： 通过该属性可查看该类的所有直接父类，该属性返回所有直接父类组成的元组
    class x:
        pass
    class xx:
        pass
    class xxx(x,xx):
        pass
    print(x.__base__)
    print(xx.__base__)

__subclasses__()方法 ： 查看该类的所有直接子类，返回该类的所有组成的列表
    print(x.__subclasses__()

__call__方法
    hasattr 函数判断指定属性或方法是否存在，  __call__属性： 进一步判断该属性或方法是否可调用
    class x:
        def __init__(self,xx,xxx):
            self.xx = xx
            self.xxx = xxx
        def ValidLogin(self):
            pass
    x = x(&apos;xx&apos;,&apos;xxx&apos;)
    print(x.xx,&apos;__call__&apos;)
    print(x.xxx,&apos;__call__&apos;)

__getitem__ , __setitem__ , __delitem__ , __len__ , __contains__ 
    序列的特征 可包含多个元素，相关的特殊方法：
        __len__(self)    ： 返回值决定序列中元素的个数
        __getitem__(self,key) ： 获取指定索引对应的元素，key是整数值或slice对象，会引发 KeyError异常
        __contains__(self,item) ： 判断序列是否包含指定元素
        __setitem__(self,key,value) ： 指定设置索引对应的元素，key 是整数值或slice对象，否则引发 KeyError异常
        __delitem__(self,key) ： 删除指定索引对应的元素
    def xx(key):
        if not isinstace(key,int) : raise TypeError(&apos;must int&apos;)
        if key &lt; 0 : raise IndexError(&apos;is ini&apos;)
    class xxx:
        def __init__(self):
            self.__changed = {}
            self.deleted = []
        def __len__(self):
            pass
        def __getitem__(self,key):
            pass
        def __setitem__(self,key,value):
            pass
        def __delitem(self,key):
            pass</code></pre><h3 id="iter-和-reversed-：实现迭代器"><a href="#iter-和-reversed-：实现迭代器" class="headerlink" title="iter 和 reversed ：实现迭代器"></a><strong>iter</strong> 和 <strong>reversed</strong> ：实现迭代器</h3><pre><code>for循环遍历列表、元组和字典等对象都是可迭代的，都属于迭代器
实现迭代器，需实现两个方法：
    1. __iter__(self) : 该方法返回一个迭代器，必须包含一个 __next__() 方法，返回迭代器的下一个元素
    2. __reversed__(self) : 为内奸的reversed 反转函数提供支持，对指定迭代器执行反转时
class  x:
    def __init__(self,len):
        self.first = 0
        self.sec = 1
        self.__len = len
    def __next__(self):
        if self.__len == 0:
            raise StopIteration
            self.first, self.sec = self.sec, self.first + self.sec
            self.__len -= 1
            return self.first
    def __iter__(self):
        return self</code></pre><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><pre><code>生成器与迭代器的区别在于： 迭代器通常是先定义一个迭代器类，通过创建实例来创建迭代器。 生成器：先定义一个包含 yield 语句的函数，然后通过调用该函数来创建生成器
创建生成器
    创建生成器的步骤：
        1. 定义一个包含 yield 语句的函数
        2. 调用第一步创建的函数得到生成器
            def xxx(val,step):
                xx = 0 
                for i in range(val):
                    xx += i * step
                    yield xx
        yield xx 语句的作用：
            1. 每次返回一个值，类return 语句
            2. 冻结执行，每次执行到yield 语句时会被暂停</code></pre><h3 id="两种方式创建生成器："><a href="#两种方式创建生成器：" class="headerlink" title="两种方式创建生成器："></a>两种方式创建生成器：</h3><pre><code>    1. 使用 for 循环的生成器推导式
    2. 调用带 yield 语句的生成器函数
生成器的方法：
    1. 外部程序通过 send 方法发送数据
    2. 生成器函数使用 yield 语句接收收据
生成器两个常用方法：
    1. close ：用于停止生成器
    2. throw ：用于在生成器内部(yield语句内) 引发一个异常</code></pre><h2 id="模块和包"><a href="#模块和包" class="headerlink" title="模块和包"></a>模块和包</h2><h3 id="常用-sys、OS-、-traceback-三个模块"><a href="#常用-sys、OS-、-traceback-三个模块" class="headerlink" title="常用 sys、OS 、 traceback 三个模块"></a>常用 sys、OS 、 traceback 三个模块</h3><pre><code>模块化编程
    模块： Modules， 模块就是Python程序，
        代码的可重复性体现在，编写好模块后，需用到该模块中的某个功能(由变量、函数、类实现)，无需重复性工作，直接导入该模块即可使用该功能
    封装特性的结构：
        1. 容器： 例 列表、元组、字符串、字典等，都是对数据的封装
        2. 函数： 对Python代码的封装
        3. 类： 对方法和属性的封装，对函数和数据的封装
    语法格式：
        模块名.函数</code></pre><h3 id="导入模块：-import"><a href="#导入模块：-import" class="headerlink" title="导入模块： import"></a>导入模块： import</h3><pre><code>    1. import 模块名1 [as 别名] , 模块名2 [as 别名2],... : 
        导入指定模块中的所有成员(变量、函数、类等)。 当使用模块中的成员时，需要该模块名(或别名)作为前缀
    2. from 模块名 import 成员名1 [as 别名1], 成员名2 [as 别名2] ,... :
        只会导入模块中指定的成员，非全部成员，使用该成员时，无需任何前缀，直接使用成员名或别名
        第二种from 模块名 import * ： 可导入指定模块中的所有成员

import 模块名 as 别名
    1. 导入整个模块： import sys
    2. 导入整个模块，指定别名： import sys as s
    3. 导入多个模块： import sys，os
    4. 导入多个模块，同时指定别名： import sys as s, os as o

from 模块名 import 成员名 as 别名
    1. 导入模块的成员 ： from sys import argv
    2. 导入模块成员，指定别名 ： from sys import argv as v
    3. 导入模块成员，一次导入多个成员 ： from sys import argv ， winver
    4. 导入多个模块，指定别名 ： from sys import argv as v， winver as w

    不推荐使用 from import 导入模块所有成员</code></pre><h3 id="自定义模块"><a href="#自定义模块" class="headerlink" title="自定义模块"></a>自定义模块</h3><pre><code>    模块文件的文件名是它的模块名，如 xxx.py 的模块名就是 xxx
自定义模块编写测试代码
    如直接运行模块文件，程序会执行该模块的函数，如其他程序导入该模块，不应该执行该模块的函数
    要实现这个效果，需借助 python 内置的 __name__ 变量，当直接运行模块时， name 变量的值为 __main__; 而将模块被导入其他程序并运行该程序，处于模块中 __name__ 变量的值就编程类模块名。 如希望函数只有在直接运行模块文件时才执行，则可增加判断，即只有当 __name__ == &apos;__main__&apos; 时才调用函数

__name__ == &apos;__main__&apos; :
    __name__ :内置的系统变量，用于标识所在模块的模块名，
    作用： 确保只有单独运行该模块时，此表达式才成立，才可以进入此判断语法，执行其中的测试代码，反之，如只是作为模块导入到其他程序文件中， 则此表达式不成立，若运行，不执行判断语句汇中的代码</code></pre><h3 id="导入模块的三种方式"><a href="#导入模块的三种方式" class="headerlink" title="导入模块的三种方式"></a>导入模块的三种方式</h3><pre><code>当时用import 语句导入模块后，会按顺序查找指定的模块文件
    1. 当前目录，即当前执行的程序程序文件所在目录下查找
    2. 到Pythonpath 环境变量下的每个目录下查找
    3. 到python 默认的安装目录下查找
自定义的模块：
    1. 向sys.path 中临时添加模块文件存储位置的完整路径
    2. 将模块放在sys.path 变量中已包含的模块加载路径中
    3. 设置系统环境变量
导入模块方式一： 临时添加模块完整路径
导入模块方式二： 将模块保存到指定位置
导入模块方式三： 设置环境变量
    linux 设置环境变量：    
        vim ~/.bash_profile 
            PATHONPATH=.:/pythondir/python_module
            export PYTHONPATH</code></pre><h3 id="导入模块的本质"><a href="#导入模块的本质" class="headerlink" title="导入模块的本质"></a>导入模块的本质</h3><pre><code>    将xxx.py 中的全部代码加载到内存并执行，然后将整个模块内容赋值给与模块同名的变量，该变量的类型是module，而在该模块中定义的所有程序单元都相当于该module对象的成员
    导入同一模块多次，只执行一次

__all__ 变量
    将变量的值设置为一个列表，只有该列表中的成员才会被暴露出来
        def xx():
            pass
        def xxx():
            pass
        __all__ = [&apos;xx&apos;,&apos;xxx&apos;]
    意义：为模块定义开放的公公接口，只有 __all__变量列出的成员，
    如使用模块内__all__ 列表之外的成员，两种解决方法
        1. import 模块名  导入模块， 通过模块名前缀来调用模块内的成员
        2. from 模块名 import 成员 ，导入指定成员

包： 存放多个模块的文件夹
    包：就是文件夹，必须存在名为 &quot;__init__.py&quot; 的文件
        每个包的目录下必须建立一个 __init__.py 的模块，可为空模块
        作用： 将目录当成包来处理</code></pre><h3 id="创建包，导入包"><a href="#创建包，导入包" class="headerlink" title="创建包，导入包"></a>创建包，导入包</h3><pre><code>    包的创建步骤：
        1. 创建文件夹，名称为该包的包名
        2. 文件夹内创建名为 __init__.py 的文件，
    包的导入：
        1. import 包名[.模块名[as 别名]]
            import xx.xxx
        2. from 包名 import 模块名 [as 别名]
            from xx import xxx
        3. from 包名.模块名 import 成员名 [as 别名]
            from xx.xxx import xxxx

__init__.py
    导入包等同于导入包中的__init__.py文件，可在此文件中编写功能代码。 包作用是包含多个模块，因此此文件作用是导入该包内的其他模块

查看模块(变量、函数、类)方法
    2种方式：
        1. dir()
            dir(xxx)
        2. __all__
            xxx.__all__

__doc__属性：查看文档
    help(string.capwords)
    print(string.capwords.__doc__)

__file__属性：查看模块的源文件路径
    import string        
    string.__file__

第三方模块(库)下载和安装(通过pip命令)
    pip install | uninstall | list  模块名</code></pre><h2 id="常见模块"><a href="#常见模块" class="headerlink" title="常见模块"></a>常见模块</h2><pre><code>日期、时间、正则表达式、JSON支持、容器等

sys 模块用法
    和解释器关系密切的标准库，帮助访问和解释器联系密切的变量和函数
    import sys
    [e for e in dir(sys) if not e.startswith(&apos;__&apos;)]        // 双下划线 没有 __all__变量</code></pre><h3 id="sys模块包含全部成员-包括变量、函数等"><a href="#sys模块包含全部成员-包括变量、函数等" class="headerlink" title="sys模块包含全部成员 包括变量、函数等"></a>sys模块包含全部成员 包括变量、函数等</h3><pre><code>    sys成员：
        sys.argv ： 获取运行python 程序的命令行参数
        sys.path ： 一个字符串列表，每个字符串都是一个目录名，使用import导入模块时，解释器从这些目录中查找指定的模块
        sys.exit() ： 引发SystemExit 异常退出程序
        sys.modules ： 返回模块名和载入模块对应关系的字典
        sys.platform ： 是字符串，标识解释器运行平台名称，即操作系统名称
        sys.stdin、sys.stdout、sys.stderr ： 类文件流对象，表示 标准输入、输出、错误
        sys.flags ： 只读属性返回运行py命令时指定的旗标
        sys.getrefcount(object) ： 返回指定对象的引用计数，当objet对象引用计数为0，系统会回收该对象
        sys.getfilesystemencoding(object) ： 返回系统中保存文件所用的字符集
        sys.getrecursionlimit() ： 返回当前支持的递归深度
        sys.getswitchinterval()    ： 返回解释器中线程切换的时间间隔，通过setswitchinterval 函数改变
        sys.implementation ： 返回当前py解释器的实现
        sys.maxsize ： 返回整数支持的最大值，32: 2**31 -1  64: 2**63-1 
        sys.executable ： 返回解释器在从磁盘的存放路径
        sys.byteorder ： 显示本地字节序的指示符
        sys.copyright ： 返回与解释器有关的版权信息
        sys.version ： 返回解释器版本的版本信息
        sys.winver ： 返回解释器的主版本号
sys获取运行参数：
    sys 模块的argv 属性可获取运行py程序的命令行参数，argv是一个列表
        python argv xx.py &quot;xxx&quot;
动态修改模块加载路径：
    import sys
    sys.path.append(&apos;E:\xxx&apos;)</code></pre><h3 id="os-模块及用法"><a href="#os-模块及用法" class="headerlink" title="os 模块及用法"></a>os 模块及用法</h3><pre><code>    代表程序所在的操作系统，用于获取程序运行所在操作系统的相关信息
    import os 
    os.__all__ ： 查看该模块所包含的全部变量和函数
        os.name ：返回依赖模块操作系统的名称，如 posix、nt、java等
        os.environ ： 所有环境变量组的字典
        os.sep ： 路径分隔符
        os.fsencode(filename) ： 对类路径 path-like 的文件名进行编码
        os.fsdecode(filename) ： 对类路径 path-like 的文件名解码
        os.PathLie ： 是类，代表 类路径对象
        os.getenv(key,default=None) ： 指定环境变量的值
        os.getlogin() ： 系统登录用户名。 os.getuid、os.getgroups、os.getgid 等函数，获取用户 ID 、用户组、组ID
        os.getpid() ： 进程ID
        os.getppid() ： 进程的父ID
        os.putenv(key,value) ： 设置环境变量
        os.cpu_count() ： 系统的CPU数量
        os.pathsep ： 系统上多条路径之间的分隔符。如 ； ：
        os.linesep ： 系统的换行符
        os.urandom(size) ： 加密使用、最多由N个字节组成的bytes对象
    os 进程管理函数：
        os.system(command) ： 运行操作系统上的指定命令
        os.abor() ： 生成一个SIGABRT 信号给当前进程，UNIX上默认生成内核转储；windows 退出返回3
        os.execl(path,arg0,arg1,...) ： 一系列功能类似的函数，如： os.execle、os.execlp等
        os.forkpty() ： fork 一个子进程
        os.kill(pid, sig) ： 将sig 信号发送到pid对应的过程，用于结束进程
        os.killpg(pgid,sig) ： 发送到 pgid 对应的进程组
        os.popen(cmd, mode=&apos;r&apos;,buffering=-1) ： 向cmd命令打开读写管道，buffering村冲参数，返回文件对象用于读写字符串，而不是字节
        os.startfile(path,operation) ： 对指定文件使用关联工具执行operation对应的操作

random 模块及用法
    查看该模块所包含的全部变量和函数： import random   random.__all__
    random 模块常用函数：
        random.seed(a=None,version=2) ： 指定种子来初始化伪随机数生成器
        random.randrange(start,stop[,step]) ： 返回从start开始到stop结束，步长为 step的随机数
        random.randin(a,b) ： 生成一个范围为 a &lt;= N &lt;= b 的随机数
        random.choice(seq) ： 从seq 中随机抽取一个元素，如为空，抛 IndexError异常
        random.choices(seq,weights=None,cum_weights=None,k=1) ： 从seq 抽元素，weigths指定被抽取的权重
        random.shuffle(x[,random]) ： 对 x 序列执行洗牌 随机排序 操作
        random.sample(population,k) ： 从population序列中随机抽取k个独立元素
        random.random() ： 生成从包含0.0 到不包含1.0之间的随机浮点数
        random.uniform(a,b) ： 生成一个范围 a ～ b 的随机数
        random.expovariate(lambd) ： 生成呈指数分布的随机数，lambda 参数</code></pre><h3 id="time-模块"><a href="#time-模块" class="headerlink" title="time 模块"></a>time 模块</h3><pre><code>查看time模块包含的全部属性和函数
    import time
    time.__all__        |  [e for e in dir(time) if not e.startswith(&apos;__&apos;)]
        time.struct_time ： 代表一个时间对象，包含9个属性
            tm_year 年
            tm_mon 月    | tm_mday 日    | tm_hour 时    | tm_min 分
            tm.sec 秒    | tm_wday 周    | tm_yday 一年内第几天 | tm_isdst 夏令时
    time 函数：
        time.asctime([t]) ： 将时间元组或struct_time转换为时间字符串
        time.ctime([secs]) ： 以秒数的时间转换时间字符串
        time.gmtime([secs])    ： 将秒数的时间转为 struct_time 对象
        time.localtime([secs]) ： 
        time.mktime(t)
        time.perf_counter()
        time.process_time()
        time.sleep(secs)
        time.strftime(format[,t])
        time.time()
        time.timezone
        time.tzname
        [详细点击](http://c.biancheng.net/view/2420.html)</code></pre><h3 id="json-模块"><a href="#json-模块" class="headerlink" title="json 模块"></a>json 模块</h3><pre><code>JSON： JavaScript Object Notation ，即javascript对象符号，数据交换格式
两种数据结构：    
    1. 由 key-value 对组成的数据结构
    2. 有序集合， 在python中对应于列表
使用JSON语法创建对象：
    object = {
            xxx:xxxx,        // 字符串用双引号包含
            yyy:yyyy,
    }
JSON创建数组：
    arr = [value1,value2,...]

JSON for Python
    JSON 类型转换 Python 类型
        对象(object)                字典(dict)
        数组(array)                    列表(list)
        字符串(string)                字符串(str)    
        整数(number(int))            整数(int)        
        true                        True
        false                        False
        null                        None

    Python类型转换为 JSON类型
        字典(dict)                        对象(object)
        列表(list)和元组(tuple)            数组(array)
        字符串(str)                        字符串(string)
        整形、浮点型、派生的枚举        数值型(number)
        True                            true
        False                            false
        None                            null 
查看模块所有属性和函数： import json -&gt; json.__all__
常用函数和类的功能：
    json.dump(obj,fp,*,skipkeys=False...)    // 将obj对象转换成json字符串输出到fp流中
    json.dumps(obj,*,skipkeys=False,...)    // 将obj对象转换为JSON字符串，并返回该JSON字符串
    json.load(fp,*,cls=NONE,object_hook=None,...)    // 从fp流读取JSON字符串，将其恢复成JSON对象， fp支持write()方法的类文件对象
    json.loads(s,fp,*,encoding=None,cls=None,object_hook=None,...)    // 将JSON字符串s恢复为JSON对象</code></pre><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="Regular-Expression-描述一种字符串匹配的模式，检查一个字符串是否含有某个子串，也可从字符串中提取匹配的子串，或对字符串中匹配的子串执行替换操作，可用来开发数据抓取、网络爬虫等"><a href="#Regular-Expression-描述一种字符串匹配的模式，检查一个字符串是否含有某个子串，也可从字符串中提取匹配的子串，或对字符串中匹配的子串执行替换操作，可用来开发数据抓取、网络爬虫等" class="headerlink" title="Regular Expression 描述一种字符串匹配的模式，检查一个字符串是否含有某个子串，也可从字符串中提取匹配的子串，或对字符串中匹配的子串执行替换操作，可用来开发数据抓取、网络爬虫等"></a>Regular Expression 描述一种字符串匹配的模式，检查一个字符串是否含有某个子串，也可从字符串中提取匹配的子串，或对字符串中匹配的子串执行替换操作，可用来开发数据抓取、网络爬虫等</h3><pre><code>查看该模块所包含的属性和函数： import re -&gt; re.__all__
函数作用：
    re.complie(pattern, flags=0) : 将正则表达式字符串编译成 _sre.SRE_Pattern 对象， 该对象代表正则表达式编译之后在内存中的对象，可缓存并复用正则表达式字符串，如多次使用同一正则表达式字符串，则可先编译它。
        pattern ： 所编译的正则表达式字符串， flags ： 匹配旗标，
    re.match(pattern , string, flags=0) : 从字符串开始位置匹配正则表达式，如匹配不成功，match 函数返回None，
        pattern ： 正则表达式。 string ：匹配的字符串。 flags ： 正则表达式的匹配旗标。
    re.search(pattern, string, flags=0) : 扫描整个字符串，返回字符串中第一处匹配pattern的匹配对象，
        pattern ： 正则表达式。 string ：被匹配的字符串。 flags ： 匹配旗标
    re.findall(pattern, string, flags=0) :  扫描整个字符串，返回字符串中所有匹配pattern的子串组成的列表。 
        pattern ： 正则表达式。 string ：被匹配的字符串。 flags ： 匹配旗标
    re.finditer(pattern, string, flags=0) ： 扫描整个字符串，返回字符串所有匹配pattern 的子串组成的迭代器。
        pattern ： 正则表达式。 string ：被匹配的字符串。 flags ： 匹配旗标
findall、finditer 、search 的区别： search 只返回字符串中第一处匹配pattern的子串，findall和finditer 返回字符串中所有匹配pattern的子串
    re.fullmatch(pattern,string, flags=0) ：要求整个字符串匹配 pattern，如匹配返回包含匹配信息的 _sre.SRE_Match对象，否则 None
    re.sub(pattern,repl,string,count=0,flags=0) ：将string字符串中所有匹配pattern的内容替换成repl
            repl ： 被替换的字符串，可是函数， count 控制替换的次数。
        import re
        date = &apos;2019-08-22&apos;
        print(re.sub(r&apos;-&apos;,&apos;/&apos;,date))
            r&apos;-&apos; ：是原始字符串， r ： 代表原始字符串，通过原始字符串，避免对字符串中的特殊字符转译
                r&apos;(?P&lt;lang&gt;\w+)&apos; : 正则表达式用圆括号表达式创建一个组， &apos;?P&apos; 为该组起名为 lang ， \w+ 是正则表达式的内容，代表一个或多个任意字符，
    re.split(pattern,string, maxsplit=0, flags=0) ： 使用pattern对string进行分割，返回分割得到的多个子串组成的列表，maxsplit 参数控制分割的次数
    re.purge() : 清楚正则表达式缓存
    re.escape(pattern) ：对模式中除ASCII字符、数值、下划线之外的其他字符转义
    re模块中的Match 对象是match 、search方法的返回值，包含了详细的正则表达式匹配信息，包含匹配的位置、子串
    sre.SRE_Match 对象包含如下方法或属性：
        match.group([group1,...]) : 获取该匹配对象中指定组所匹配的字符串
        match.__getitem__(g) ： match.group(g)的简化写法。
        match.groups(default=None) : 返回match对象中所有组所匹配的字符串组成的元组
        match,groupdict(default=None) ：返回match对象中所有组所匹配的字符串组成的字典
        match.start([group]) ：获取该匹配对象中指定组所匹配的字符串的开始位置
        match.end([group]) ：获取结束位置
        match,span([group]) ：获取开始和结束位置，相当于同时返回 start 和 end方法的返回值
        match.pos : 该属性返回传给正则表达式对象的search , match等方法的pos参数
        match.lastindex : 返回最后一个匹配的捕获组的整数索引，如没有，则返回None
        match.lastgroup : 返回最后一个匹配的捕获组的名字，如没有，则返回None
        match.re : 返回执行正则表达式匹配时所用的正则表达式
        match.string : 返回执行正则表达式时所用的字符串</code></pre><h2 id="set-和-frozenset-集合操作"><a href="#set-和-frozenset-集合操作" class="headerlink" title="set 和 frozenset 集合操作"></a>set 和 frozenset 集合操作</h2><h3 id="set-集合是可变容器，可改变容器中的元素，-frozenset集合，是set的不可变版本，他的元素不可变"><a href="#set-集合是可变容器，可改变容器中的元素，-frozenset集合，是set的不可变版本，他的元素不可变" class="headerlink" title="set 集合是可变容器，可改变容器中的元素， frozenset集合，是set的不可变版本，他的元素不可变"></a>set 集合是可变容器，可改变容器中的元素， frozenset集合，是set的不可变版本，他的元素不可变</h3><pre><code>set集合：
    两个特征：
        1. set 不记录元素的添加顺序
        2. 元素不允许重复
        [e for e in dir(set) if not e.startswith(&apos;__&apos;)]
    add添加 、 remove 删除元素、discard 删除元素、clear 清空 
    remove 和 discard 区别： remove 报KeyError异常。discard 不报
set 支持的运算符：
    &lt;= : 相当于调用 issubset() 方法，判断前面的set集合是否为后面set集合的子集合
    &gt;= ：调用issuperset 方法，判断是否为后面set集合的父集合
    - ： 调用difference ，前面的set集合减去后面的set集合的元素
    &amp; ： 调用intersection，获取两个set集合的交集
    ^ ： 计算两个集合异或的结果，即两个集合的并集减去交集的元素</code></pre><h3 id="frozenset-集合"><a href="#frozenset-集合" class="headerlink" title="frozenset 集合"></a>frozenset 集合</h3><pre><code>是set的不可变版本，set集合中不改变集合本身的方法，fronzenset 都支持
作用：
    1. 当集合元素不需要改变时，使用frozenset 代替 set更安全
    2. 当某些api需要不可变对象时，必须用frozenset代替set</code></pre><h3 id="queue-双端队列-模块"><a href="#queue-双端队列-模块" class="headerlink" title="queue (双端队列) 模块"></a>queue (双端队列) 模块</h3><pre><code>栈：一种特殊的线性表，允许一端进行插入、删除操作。这个端为栈定(top),另一端为栈底(botton)
从栈顶插入一个元素称为： 进栈， 压入栈。 push 
从栈顶删除一个元素称为： 出栈， 弹出栈。 pop
栈，陷入栈的元素位于栈底，上面元素出栈后，栈底的元素才能出栈。 栈 是一种 后进先出(LIFO)的线性表 
队列是一种特殊的线性表，只允许在表的前段(font) 删除，在后端(rear) 插入。 插入的操作的端为 队尾， 删除操作的端为 队头
    队列：元素是从队列的rear 端进。 队列是一种 先进先出FIFO 的线性表。 
双端队列deque 代表特殊的队列， 在两端同时进行插入、删除操作，deque 即可为队列使用，也可为 栈 使用
deque 位于 collections 包下，[e for e in dir(collections.deque)if not e.startswith(&apos;__&apos;)]
    from collections import deque
    双端队列的特征， deque 的左边 left 相当于 它的队头front， 右边right 相当于它的队列尾rear
        append 和 appendleft ：在deque的右边或左边添加元素， 即在默认队列尾添加元素
        pop 和 popleft ：在deque的右边或左边弹出元素，默认在队列尾弹出元素
        extend 和 extendleft ： 在deque的右边或左边添加多个元素，默认在队列尾添加多个元素
    deque 中clear 方法用于清空队列，insert 方法是线性表的方法，指定位置插入元素
    deque 中 rotate 方法。将队列的队尾元素移动到队头，使之首位相连</code></pre><h3 id="heapq-堆操作"><a href="#heapq-堆操作" class="headerlink" title="heapq 堆操作"></a>heapq 堆操作</h3><pre><code>    小顶堆的任意子树是小顶堆，大顶堆的任意子树是大顶堆
    import heapq    -&gt; heapq.__all__
    函数功能：
        heappush(heap,item) ： 将item元素加入堆
        heappop(heap) : 将堆中最小元素弹出
        heapify(heap) : 将堆属性应用到列表上
        headpreplace(heap,x) : 将堆中最小元素弹出，并将元素x入堆
        merge(*iterables, key=None, reverse=False) ： 将多个有序的堆合并为一个大的有序堆，然后输出
        headppushpop(heap,item) ： 将item入堆，然后弹出并返回堆中最小的元素
        nlargest(n,iterable,key=None) ： 返回队中最大的n个元素
        nsmallest(n,iterable,key=None) : 返回堆中最小的n个元素

ChainMap
    使用链的方式将多个 dict 链在一起，允许程序可直接获取任意一个dict所包含的key对应的value
    ChainMap 相当于把多个dict合并为一个大的dict，</code></pre><h3 id="Counter-类"><a href="#Counter-类" class="headerlink" title="Counter 类"></a>Counter 类</h3><pre><code>    可自动统计容器中个元素出现的次数
    本质是一个特殊的dict，key是所包含的元素，value记录key出现的次数 
    Counter 继承了dict， 提供三个常用的方法：
        1. elements ： 返回该counter 所包含的全部元素组成的迭代器
        2. most_common([n]) ：返回Counter 中出现最多的n个元素
        3. subtract([iterable-or-mapping]) ： 计算counter 的减法，计算减去之后各元素出现的次数
    可把Counter对象转换为 set集合、list列表、dict字典等，可对Counter执行 加、减、交、并运：
        加： 将两个Counter对象中各Key 出现的次数相加，保留为正的元素
        减： 相减，保留出现次数为正的元素
        并： 出现key且各key对应的次数的最小数
        求正： 只保留出现次数为0 或正数的key-value对
        求负： 保留次数为负的 key-value 对，将次数改为正数

defaultdict ：
    是dict 的子类，与dict 的区别： 根据不存在的key访问dict中对应的value，会引发KeyError异常，defaultdict则提供default_factory属性， 指定的函数为不存在的key来生成value</code></pre><h3 id="namedtuple-工厂函数功能"><a href="#namedtuple-工厂函数功能" class="headerlink" title="namedtuple 工厂函数功能"></a>namedtuple 工厂函数功能</h3><pre><code>    可创建一个tuple类的子类，为tuple的每个元素指定字段名，可根据字段名访问namedtuple的各元素，根据索引来访问namedtuple的各元素
        namedtuple(typename,field_names, * , verbose=False, rename=False,module=None)
            typename : 指定所创建的tuple子类的类名，等于用户定义一个新类
            field_names ： 字符串序列，使用单个字符串代表所有字段名，用空格、逗号隔开
            rename ： 如参数为True， 无效字段名会被自动替换为位置名
            verbose ： 参数为True， 当子类被创建后，该类定义会被立即打印出来
            module ： 自定义类的__module__属性将被设为该参数值
        Python 为命名元组提供的方法和属性：
            _make(iterable) ：类方法，根据序列或可迭代对象创建命名元组对象
            _asdict() : 将当前命名元组对象转换为OrderdDict 字典
            _replace(**kwargs) ： 替换命名元组中一个或多个字段的值
            _source ： 返回定义该命名元组的源代码
            _fileds ： 返回该命名元组中所有字段组成的元组

OrderdDict用法：
    是dict的子类，可 维护 添加 key-value 对的顺序， 先添加key-value对排的前面，后添加的key-value对排的后面
    两个方法：
        1. popitem(last=True) ： 弹出并返回最左边的最后加入的key-value对，将last参数设为False，则弹出并返回最左边最先加入的key-value对
        2. move_to_end(key,last=True) : 将指定的key-value对移动到最右边最后加入，将last改为False，则将指定的key-value对移动到最左右最先加入</code></pre><h3 id="itertools模块：生成迭代器"><a href="#itertools模块：生成迭代器" class="headerlink" title="itertools模块：生成迭代器"></a>itertools模块：生成迭代器</h3><pre><code>先导入 import itertools 模块， [e for e dir(itertools) if not e.startswith(&apos;__&apos;)]
三个生成无限迭代器的函数：
    1. count(start,[step]) ：生成start、start+step、start+2*step,...的迭代器，step默认为1。 count(10) 生成的迭代器包含： 10，11，12，13，14.。。
    2. cycle(p) : 对序列p生成无限循环p0，p1.。。的迭代器。cycle(&apos;ABCD&apos;) 包含：A,B,C,D,A,B,C,D,...
    3. repeat(elem [,n]) ： 生成无限个 elem元素重复的迭代器. repeat(10,3) ：10，10，10，
在itertools 模块中常用的迭代器函数：
        accumulate(p,[func]) ： 生成根据序列p元素累加的迭代器
        chain(p,q,...) : 将多个序列里的元素 链 在一起生成新的序列
        compress(data,selectros) ： 根据selectors序列的值对data序列的元素进行过滤
        dropwhile(pred,seq) : 使用pred函数对seq序列进行过滤，如计算为False，保留该元素到序列结束的全部元素
        takewhile(pred,seq) ：使用pred函数对seq进行过滤，去掉从该元素序列结束的全部元素
        filterfalse(pred,seq)：使用pred函数对seq序列进行过滤，保留seq中使用pred计算为True的元素
        islice(seq,[start,]stop[,step]) ：类似于slice，返回seq[start:stop:step]的结果
        starmap(func,seq)：使用func对seq每个元素进行计算，结果为新的序列元素
        zip_longest(p,q,...) ：将p、q序列中元素按索引合并成元组，元组作为新序列的元素
在itertools 模块中生成序列排列的工具函数：
        product(p,q,...[repeat = 1])：用序列p、q，。。。进行排序组合，相当于嵌套循环组合
        permutations(p[,r]) ：从序列p中取出r个元素组成排序，将排序得到的元组作为新迭代器的元素
        combinations(p,r) ：从序列p中取出r个元素组成全组合，元素不重复，将组合得到的元组作为新迭代器的元素
        combinations with_replacement(p,r)：从序列p中取出r个元素组成全组合，元素可重复，将组合得到的元组作为新迭代器的元素</code></pre><h3 id="functools-模块："><a href="#functools-模块：" class="headerlink" title="functools 模块："></a>functools 模块：</h3><pre><code>包含函数装饰器和便捷的功能函数， import functools 
    常用函数装饰器和功能函数：
        functools.cmp_to_key(func) ：将老式的比较函数(func)转换为关键字函数(key function) py3不支持
        @function.lru

        [更多](http://c.biancheng.net/view/2443.html)</code></pre><h2 id="Tkinter-GUI图形洁面开发"><a href="#Tkinter-GUI图形洁面开发" class="headerlink" title="Tkinter (GUI图形洁面开发)"></a>Tkinter (GUI图形洁面开发)</h2><h3 id="GUI-：Graphics-User-Interface-图形用户界面。三要素：输入数据、处理数据、输出数据"><a href="#GUI-：Graphics-User-Interface-图形用户界面。三要素：输入数据、处理数据、输出数据" class="headerlink" title="GUI ：Graphics User Interface 图形用户界面。三要素：输入数据、处理数据、输出数据"></a>GUI ：Graphics User Interface 图形用户界面。三要素：输入数据、处理数据、输出数据</h3><pre><code>常用库：
    wxPython ： 跨平台GUI工具集
    PyQt ： 是Py和Qt库的融合
    PyGTK ： 基于老版本GTK+2的库提供绑定，借助于底层GTK+2提供的可视化元素和组件
    Pywin32 ： 允许像VC使用Py开发win32应用
    Kivy ： 开源库，使用同源代码创建的程序跨平台
    Flexx ： 纯Py工具包，创建图形化界面程序，支持使用web技术进行界面渲染</code></pre><h3 id="Tkinet-GUI-编程组件及用法"><a href="#Tkinet-GUI-编程组件及用法" class="headerlink" title="Tkinet GUI 编程组件及用法"></a>Tkinet GUI 编程组件及用法</h3><pre><code>    学习GUI步骤为三步：
        1. 包含的组件
        2. 容器及容器对组件布局的方法
        3. 掌握各组件的用法
        [Tkinter GUI 关系](http://c.biancheng.net/view/2451.html)
    Tkinter的GUI组件有两个根父类，直接继承object类
        1. Misc ： 所有组件的根父类
        2. Wm ： 提供窗口管理器通行的功能函数
    BaseWidget ： 所有组件的基类，派生类：Widget ，通用GUI组件，Tkinter 是所有GUI组件都是Widget的子类
    各GUI组件的功能
        Toplevel：        顶层            容器类
        Button ：        按钮            按钮组件
        Canvas ：        画布            绘图功能
        Checkbutton：    复选框            可勾选的复选框
        Entry  ：        单行输入框        用户可输入容内
        Frame ：        容器            装载其他GUI组件
        Label ：        标签            显示不可编辑的文本或图标
        LabelFrame ：    容器            容器组件，支持添加标题
        Listbox ：        列表框            列出多个选项，供用户选择
        Menu    ：        菜单            菜单组件
        Menubutton ：    菜单按钮        包含菜单的按钮 包括下拉式、层叠式
        OptionMenu ：    菜单按钮        Menubutton的子类
        Message ：        消息框            类标签，显示多行文本，Lable代替，废弃
        PanedWindow：    分区窗口        该容器可划分为多个区域
        Radiobutton    ：    单选钮            单选按钮
        Scale ：        滑动条            可设置起始值和结束值，显示当前精准值
        Spinbox ：        微调选择器        可通过组件向上、向下选择不同的值
        Scrollbar ：    滚动条            用于为组件(文本域、画布、列表框、文本框)提供滚动
        Text ：            多行文本框        显示多行文本
    initWidgets 方法实现的代码：
        1.创建 GUI 组件
        2.添加 GUI 组件
        3.配置 GUI 组件
    配置GUI组件的2种方法：
        1. 以关键字参数的方式配置
        2. 以字典语法进行配置
    [GUI通用选项](http://c.biancheng.net/view/2451.html)

TKinter Pack 布局管理器
    [常用选项及功能]()
    anchor : 空间大于组件所需求的大小，决定被放置在容器的位置
    expand : 指定当容器增大时是否拉伸组件
    fill :    组件是否沿水平或垂直方向填充
    ipadx :    指定组件在 x 方向上的内部留白
    ipady : 在 y 方向上内部留白
    padx :  在x方向上与其他组件的间距
    pady :    在y方向上的间距
    side :  设置组件的添加位置

Tkinter Grid 布局管理器
    Grid 把组件空间分解为一个网格进行维护
    Tkinter Grid 常用选项
        column ： 指定将组件放哪列
        columnspan : 指定组件横跨多少列
        row ：指定放入哪行
        sticky ：类 pack方法的anchor选项</code></pre><h3 id="Tkinter-Place-布局管理器"><a href="#Tkinter-Place-布局管理器" class="headerlink" title="Tkinter Place 布局管理器"></a>Tkinter Place 布局管理器</h3><pre><code>    绝对布局 ： 要求程序显式指定每个组件的绝对位置或相对其他组件的位置
    常用选项：
        x            指定组件的X坐标， x 为 0 代表最左边
        y            Y 坐标                        最右边
        relx        组件的X坐标
        rely        组件的Y坐标
        width        组件的宽度
        height        组件的高度
        relwidth    组件的宽度
        relheight    组件的高度
        bordermode    设置组件的宽度、高度

Tkinter Command 和 Bind 事件处理
    command 绑定事件处理方法：
        可通过command 来绑定，可绑函数或方法，单击时，触发绑定的函数或方法
    bind 绑定事件处理方法：
        无法为具体事件绑定事件处理方法
        无法获取事件相关信息
    bind()方法： 可为 任意 事件绑定事件处理方法
        Tkinter 支持的鼠标、键盘事件

Tkinter ttk组件及用法
    是Tinkter 包下的模块，界面美化、包装

Tkinter Variable类用法
    支持GUI组件与变量进行双向绑定，
        1. 如改变变量的值，GUI组件的显示内容或值也改变
        2. 当GUI组件的内容改变时，值也改变
    Tinkter 不能讲组件和普通变量进行绑定，只能和tkinter 包下的Variable类的子类进行绑定
    1. StringVar() :    包装str值的变量
    2. IntVar() :        整形值的变量
    3. DoubleVar() ：    浮点值的变量
    4. BooleanVar() :  包装bool值的变量</code></pre><h3 id="Tkinter-compound-选项使用方法"><a href="#Tkinter-compound-选项使用方法" class="headerlink" title="Tkinter compound 选项使用方法"></a>Tkinter compound 选项使用方法</h3><pre><code>如使组件同时显示文本和图片，可通过 compound 选型进行控制
    属性值：
        1. None ： 图片覆盖文字
        2. LEFT 常量： 图片在左，文本在右
        3. RIGHT 变量： 图片在右，文本在左
        4. TOP 常量： 图片在上， 文本在下
        5. BOTTON 常量： 图片在底，文本在上
        6. CENTER 常量： 文本在图片上方</code></pre><h3 id="Tkinter-Entry-和-Text-控件用法"><a href="#Tkinter-Entry-和-Text-控件用法" class="headerlink" title="Tkinter Entry 和 Text 控件用法"></a>Tkinter Entry 和 Text 控件用法</h3><pre><code>    可接收用户输入的输入框组件，区别： Entry ： 单行。 Text： 多行

Tkinter Radiobutton 和 Checkbutton 用法
    单选按钮，可绑定一个方法或函数。 将多个Radiobutton 编为一组，将多个Radiobutton绑定到同一个变量，当其中一个单选按钮被选中时，该变量随之改变。

Tkinter Listbox 和 Combobox 控件用法
    列表框，通过列表框选择一个列表项。
        创建 Listbox 的步骤：
            1. 创建Listbox 对象，设置listbox的选择模式
            2. 调用listbox的insert(self,index,*elements)添加选项

Tkinter Spinbox 控件
    通过两个小箭头调整该组件内的值

Tkinter Scale 和 LabeledScale用法
    代表一个滑动条，为滑动设置最大最小值
    Scale 组件选项：
        from ： 最大值
        to ： 最小值
        resolution ： 滑动时的步长
        lable ： 设置标签内容
        length ： 设置轨道的长度
        width ： 轨道的宽度
        troughcolor ： 背景色
        sliderlength ： 长度
        sliderrelief ： 立体样式
        showvalue ： 是否显示当前值
        orient ： 设置方向
        digits ： 设置有效数字位数
        variable ： 与变量进行绑定
        command ： 为该Scale 组件绑定事件处理，函数或方法

Tinkter LabelFrame 用法
    是Frame容器改进版，为容器添加标签，可为普通文字标签，也可为GUI组件为标签
    对标签进行定制：
        1. labelwidget ： 将任意GUI组件作为标签
        2. labelanchor ： 设置标签位置</code></pre><h3 id="Tkinter-Panedwindow-控件"><a href="#Tkinter-Panedwindow-控件" class="headerlink" title="Tkinter Panedwindow 控件"></a>Tkinter Panedwindow 控件</h3><pre><code>    管理窗口布局的容器，允许添加多个子组件，并为每个子组件划分一个区域，可用鼠标移动分隔线改变各子组件的大小
    操作Panedwindow 容器中子组件的方法：
        1. add(self,child,**kw) : 添加一个子组件
        2. insert(self,pos,child,**kw) : 在pos 位置插入一个子组件
        3. remove(self,child) ： 删除一个子组件，所在区域也删除 

Tkinter OptionMenu控件
    构建带菜单的按钮，可在按钮的四个方向上展开，通过direction选项控制
        __init__(self,master,variable ,value,*values, **kwargs)
            1. variable ； 指定该按钮上的菜单与哪个变量绑定
            2. Value ： 默认选择菜单中的哪一项
            3. values ： 将收集为此参数传入的多个值，为每个值创建一个菜单项
            4. kwargs ： 为 OptinoMenu配置选项

Tkinter 对话框创建及使用
    1. 对话框依赖类似于顶级窗口，创建时需指定master属性
    2. 对话框有非模式noo-modal和模式modal，某个模块对话框被打开，位于它依赖的窗口之上。
    Tkinter 在 simpledialog 和dialog 模式下分别提供了 SimpleDialog 类和 Dialog 类，可作为普通对话框使用
        使用simpledialog 和dialog 创建对话框可指定：
            1. title： 标题
            2. text ：内容
            3. button： 按钮
            4. default：默认第几个按钮得到焦点
            5. cancel： 指定对话框上角的X按钮关闭对话框

Tkinter 自定义对话框
    自定义通过继承Toplevel 实现：
        1. 继承Toplevel 实现自定义对话框需要为对话框指定 master
        2. 调用Toplevel 的grab_set 方法 把对话框变为模式对话框，否则为非模式对话框</code></pre><h4 id="Tkinter-输入对话框"><a href="#Tkinter-输入对话框" class="headerlink" title="Tkinter 输入对话框"></a>Tkinter 输入对话框</h4><pre><code>工具函数：
    1. askinteger ； 生成一个让用户输入正数的对话框
    2. askfloat ： 输入浮点数的对话框
    3. askstring ： 输入字符串的对话框</code></pre><h4 id="Tkinter-文件对话框创建和使用"><a href="#Tkinter-文件对话框创建和使用" class="headerlink" title="Tkinter 文件对话框创建和使用"></a>Tkinter 文件对话框创建和使用</h4><pre><code>    直接返回用户选择文件的输入/输出流：
        1. askiopenfile ： 打开单个文件的对话框
        2. askopenfiles ： 打开多个文件的对话框
        3. askopenfilename ： 打开单个文件的对话框，返回选择文件的文件路径
        4. askopenfilenames ： 多个文件的对话框
        5. asksavesfile ： 生成保存文件的对话框
        6. asksaveasfilename ： 保存文件的对话框，返回所选择文件的文件路径
        7. askdirectory ： 生成打开目录的对话框
    生成打开文件的对话框工具函数：
        1. defaulttextension ： 指定默认扩展名
        2. filetypes ： 查看的文件类型
        3. initaldir ： 初始化打开的目录
        4. parent ： 指定该对话框的属主窗口
        5. title ： 对话框的标题
        6. multiple ： 允许多选

Tkinter askcolor 颜色选择对话框
    函数选项：    
        1. parent ： 属主窗口
        2. title ： 标题
        3. color ： 颜色</code></pre><h4 id="Tkinter-消息框"><a href="#Tkinter-消息框" class="headerlink" title="Tkinter 消息框"></a>Tkinter 消息框</h4><pre><code>    选项按钮
        1. icon  ： 定制图标
        2. type ： 定制按钮的选项
    showinfo 函数： 默认生成的消息框的图标是感叹号

Tkinter Menu 菜单 窗口菜单和右键菜单
    添加菜单项的方法：
        1. add_command() : 添加菜单项
        2. add_checbutton(): 复选框
        3. add_radiobutton(): 单选按钮
        4. add_separator() : 菜单分隔条
    添加菜单的三个方法选项：    
        1. label ： 指定菜单项的文本
        2. command ： 指定绑定的事件处理方法
        3. image ： 指定菜单项的图标
        4. compound ： 图标位于文字的哪个方位
    Menu窗口菜单：
        创建菜单后，将菜单设为窗口的menu选项即可
            add_command 为file_menu 添加多个菜单项
            add_cascade 再次为file_menu添加子菜单
            add_radiobutton 添加多个单选菜单项
    Menu 右键菜单：
        先创建菜单，为目标组件的右键菜单绑定处理函数, 点击右键，调用菜单post 方法即可</code></pre><h3 id="Tkinter-Canvas-画布完全攻略"><a href="#Tkinter-Canvas-画布完全攻略" class="headerlink" title="Tkinter Canvas 画布完全攻略"></a>Tkinter Canvas 画布完全攻略</h3><pre><code>    绘制直线、矩形、椭圆等图形，提供create_rectangle 方法绘制和 create_oval 绘制椭圆，绘制方法：
        create_arc ： 绘制弧
        create_bitmap ： 位图
        create_image ： 图片
        create_polygon ： 多边形
        create_line ： 直线
        create_text ： 文本
        creat_window ： 绘制组件
            绘制指定的选项：    
                fill ： 填充颜色
                outline ： 边框颜色
                width ： 边框宽度
                dash ： 边框虚线
                stipple ： 位图平铺填充
                start ： 开始角度
                extend ： 绘制弧的角度
                style ： 绘制弧样式
                arrow ： 是否有箭头
                arrowshape ： 箭头样式
                joinstyle ： 连接点的风格
                anchor ： 绘制文字
                justify ： 文本对齐方式

Tkinter Canvas tag_bind ：指定图形项绑定事件处理函数或方法
    tag_bind 方法： 用于为指定图形项绑定事件处理函数或方法，可用于响应用户动作

Tkinter Canvas 绘制动画
    小球转动； 循环显示多张转动的小球图片
    小球移动： 改变小球的坐标程序</code></pre><h2 id="文件操作I-O"><a href="#文件操作I-O" class="headerlink" title="文件操作I/O"></a>文件操作I/O</h2><h3 id="文件基本操作"><a href="#文件基本操作" class="headerlink" title="文件基本操作"></a>文件基本操作</h3><pre><code>常见操作： 创建、删除、修改权限、读取、写入等
    1. 删除、修改权限：作用于文件本身，属于系统级操作
    2. 写入、读取： 文件常用操作，作用于文本的内容，属于应用级操作
文件操作实现函数：
    1. 打开文件： open 函数，返回文本对象
    2. 对已打开的文件做读/写操作，读写，使用 read 、readline readlines 函数，写入：write 函数
    3. 关闭文件： close </code></pre><h3 id="open-函数：打开指定文件"><a href="#open-函数：打开指定文件" class="headerlink" title="open 函数：打开指定文件"></a>open 函数：打开指定文件</h3><pre><code>如要操作文件，需创建或者打开指定的文件，并创建一个文件对象，内置的 open 函数
    file = open(file_name [, mode [, buffering]]) 
        file: 表示要创建的文件对象
        file_mode ： 要创建或打开文件的文件名称，需用引号扩起来，注意路径
        mode ： 可选参数；指定文件的打开模式，如不写，默认只读r
        buffing ： 指定对文件做读写操作，是否使用缓存区</code></pre><h3 id="open-函数文件打开模式："><a href="#open-函数文件打开模式：" class="headerlink" title="open 函数文件打开模式："></a>open 函数文件打开模式：</h3><pre><code>            r ： 只读，指针在开头
            rb ： 二进制格式，只读模式，指针位于开头，用于打开非文本文件，如图片
            r+ ： 从头读取文件内容，从开头写入新的内容，新内容覆盖原有内容
            rb+ ： 二进制格式读写模式打开，针对非文本文件，如音频文件
            w ： 只读，清空文件原有内容
            wb ：二进制格式、只读模式，音频文件
            w+ ： 读写， 清空原有内容
            wb+ ： 二进制格式、读写模式，非文本
            a ：追加模式，只写权限，如文件不存在，则创建新文件
            a+ ： 读写，指针位于末尾，如不存在，则新建
            ab+ ： 二进制模式，追加模式，读写权限
[读写操作](http://c.biancheng.net/uploads/allimg/190228/2-1Z22QI61c59.gif)
    open 打开文件时，默认GBK编码，指定打开文件的编码格式； 
        file = open(&apos;xx.txt&apos;,encoding=&quot;utf-8&quot;)</code></pre><h3 id="open-是否需要缓冲区"><a href="#open-是否需要缓冲区" class="headerlink" title="open()是否需要缓冲区"></a>open()是否需要缓冲区</h3><pre><code>    一般建议打开缓冲，open函数，第三个参数是0或False，是不带缓冲的，若是1或True，则带缓冲
open 文件对象常用属性：
    file.closed ： 判断是否关闭
    file.mode ： 返回访问模式
    file.name ： 返回文件名

以文件格式和二进制格式打开文件的区别：
    相同点： 都是以二进制格式打开文件
    不同点： 对文件中换行符的处理不同
        Win： \r\n  转换为 \n 
        Unix/Linux ： 默认换行符是 \n
        推荐使用 b 打开二进制文件</code></pre><h3 id="read-函数：-按字节、字符读取文件"><a href="#read-函数：-按字节、字符读取文件" class="headerlink" title="read 函数： 按字节、字符读取文件"></a>read 函数： 按字节、字符读取文件</h3><pre><code>        read 读取文件是字节、字符的区别： 取决于open函数打开文件时，是否使用 b 模式，如使用 b ，读取的是 字节， 如不是 b ，则是 字符
        file.read([size])
    read 抛出UnicodeDecodeErorr 异常的解决方案：
        文本的额字符集和操作系统的字符集不匹配，解决方案：
            1. 使用二进制模式读取， 然后用bytes 的decode 方法恢复为字符串
            2. 采用 codecs 模块的open函数打开文件时指定字符集
readline 和 readlines ： 按行读取文件
    readline ： 读取一行内容 。 readlines ： 读取文件内的所有行 
        readline ： 
            file.readline([size])
                file 为打开的文件对象， size 可选参数，指定读取每一行，一次最多读取的字符数，模式使用 r 或 r+ 读写
        readlines ：
            file.readlines() : file 为文件打开对象， 模式使用r 或 r+

    write 和 writelines ： 向文件中写入数据
        file.write(string) :向文件中写入指定内容。 file。write(string)
        writefiles() 函数： 
            将字符串列表写入文件中。 向文件中写入多行数据时，不自动给各行添加换行符</code></pre><h3 id="close-：-关闭文件"><a href="#close-：-关闭文件" class="headerlink" title="close ： 关闭文件"></a>close ： 关闭文件</h3><pre><code>        flie.close()
            关闭使用open函数打开的文件
                如不在关闭文件的前提下将数据写入到文件中，使用文件对象提供的flush 函数

seek 和 tell 函数
    tell ：判断文件指针当前所处的位置
    seek ：用于移动文件指针到文件的指定位置
        file.tell()
        file.seek(offset[, whence])
            file : 文件对象
            whence ： 指定文件指针要放置的位置，0 开头，1当前位置，2文件尾
            offset ： 相对于whence位置文件指针的偏移量</code></pre><h3 id="with-as-用法"><a href="#with-as-用法" class="headerlink" title="with  as 用法"></a>with  as 用法</h3><pre><code>使用with as 语句操作上下文管理器 context manager，自动分配并且释放资源
    with 表达式 [as target]:
        代码块
即使没有关闭文件，修改文件内容的操作也能成功</code></pre><h3 id="上下文管理器，-python-with-as-底层原理"><a href="#上下文管理器，-python-with-as-底层原理" class="headerlink" title="上下文管理器， python with as 底层原理"></a>上下文管理器， python with as 底层原理</h3><pre><code>    包含 __enter__() 和  __exit__() 方法的对象是上下文管理器，上下文管理器必须实现一下两个方法：
        1. __enter__(self): 进入上下文管理器自动调用的方法，会在with as 执行前执行，返回值被赋值给 as 子句后的变量，可返回多个值，在as子句后可指定多个变量，必须用 () 括起来
        2. __exit__(self,exc_typ`e,exc_value,exc_traceback ) ： 退出上下文管理器自动调用的方法，在with as 代码执行后执行，如with as 因异常终止，程序自动调用该方法，使用 sys.exc_info 得到的异常信息将作为调用该方法的参数
    构建上下文管理器，实现的2种方式：
        1. 基于类的上下文管理器
            只要类实现 __enter__()  __exit__ 这两个方法，就可使用with as来管理， 通过 __exit__ 方法的参数，可判断with 代码块执行是否遇到了异常，
        2. 基于生成器的上下文管理器
            使用基于生成器的上下文管理器时，不需要定义 __enter__() 和 __exit__()方法，但必须添加 装饰器 @contextmanager 
        基于类的上下文管理器灵活，适用于大型的系统开发
        基于生成器的上下文管理器更方便、简洁、适用于小型程序
            切记： 用__exit__() 或是 finally 块中释放资源








fileinput模块：逐行读取多个文件
    把多个输入流合并在一起
        fileinput.input (files = &quot;filename1,filenamex,...&quot;,inplace=False,backup=&quot;,bufsize=0,mode=&apos;r&apos;,openhook=None&quot;)
            files ：多个文件的路径列表
            inplace ： 指定是否将标准输出的结果写回到文件，默认值为 False
            backup ： 指定备份文件的扩展名
            bufsize ： 指定缓存区的大小，默认0
            mode ： 打开文件的格式，默认 r
            openhook ： 控制文件的打开方式，如编码格式
    fileinput 模块常用函数
        fileinput.filename() ：返回读取文件的文件名
        fileinput.fileno() ：返回文件描述
        fileinput.lineno() ：返回读取的行号
        fileinput.filelineno() ：返回读取的行在文件中的行号
        fileinput.isfirstline() ： 读取的行在文件中是否为第一行
        fileinput.isstdin() ： 是否从sys.stdin 读取
        fileinput.nextfile() ： 关闭当前文件，开始读取下一个文件
        fileinput.close() ： 关闭fileinput对象

linecache模块：随机读取文件指定行
    从源文件随机读取指定行，并在内部使用缓存优化存储，会使用utf-8字符集
        常用函数：
            linecache.getline(filename,lineno,module_globals=None)：读取指定模块中指定文件的指定行，filename指定文件名，lineno指定行号
            linecache,clearcache() ：清空缓存
            linecache.checkcache(filename=None) ：检查缓存是否有效，如没有指定文件名filename参数，默认检查所有缓存的数据

pathlib模块
    提供了一组面向对象的类，代表各种操作系统上的路径
    PuraPath 的两个子类： PurePosixPath:Unix风格的路径  PureWindowsPath：Windows风格的路径
PurePath ：使用此函数或他的子类来创建PurePath对象，创建时，可闯入单个路径字符串，也可传入多个路径字符串
PurePath类的属性和方法：
    操作路径字符串，[](http://c.biancheng.net/view/2541.html)    
Path类功能和用法：
    Path 是PurePath的子类，可访问底层的文件系统，判断Path对应的路径是否存在，可对文件进行读写

os.path 模块函数
    操作目录的方法，可操作系统的目录本身，如 exists():判断目录是否存在, getctime()：创建时间 getmtime()：修改时间  getatime()：访问时间  getsize()：文件大小

fnmatch模块：文件名的匹配
    匹配支持的通配符：
        * ： 匹配任意个任意字符
        ? ： 匹配一个任意字符
        [字符序列] ：匹配中括号里字符序列中的任意字符，
        [!字符序列] ： 匹配不在中括号里字符序列中的任意字符
    fnmatch.fnmatch(filename,pattern)：判断指定文件名是否匹配指定pattern
    fnmatch.fnmatchcase(filename,pattern)：匹配时不区分大小写
    fnmatch.filter(names,pattern) ：对names列表进行过滤，返回names列表中匹配pattern的文件名组成的子集合。 
    fnmatch.translate(patteran)：将Unix shell风格的pattern转换为正则表达式pattern

os模块：
    os模块与目录相关的函数：
        os.getcwd()：获取当前目录
        os.chdir(path) ： 改变当前目录
        os.fchdir(fd) ：通过文件描述改变当前目录
        os.chroot(path)：改变当前进程的根目录
        os.listdir(path)：返回paht对应目录下的所有文件和子目录
        os.mkdir(path[,mode])：创建path对应的目录，mode指定目录的权限
        os.makedirs(path[,mode])：类似mkdir ，可递归创建目录，
        os.rmdir(path)：删除path对应的空目录，如非空抛出 OSError异常，可先用os.remove()删除文件
        os.removedirs(path) ：递归删除目录，类似rmdir
        os.rename(src,dst)：重命名文件或目录，将src命名为dst
        os.renames(old,new) ：对文件或目录进行递归重命名，类rename，

os模块与权限相关的函数
    os.access(path,mode)：检查path对应的文件或目录是否具有指定权限，第二参数的四个状态
        os.F_OK ： 判断是否存在
        os.R_OK ： 是否可读
        os.W_OK ： 是否可写
        os.X_OK ： 是否可执行
    os.chrnod(path,mode) :更改权限，
        stat.S_IXOTH ：其他用户有执行权限
        [更多](http://c.biancheng.net/view/2558.html)            
    os.chown(path,uid,gid) ：更改文件的所有值，uid代表用户id，gid代表组id
    os.fchmod(fd,mode) ：改变一个文件的访问权限，fd代表文件
    os.fchown(fd,uid,gid) ：改变文件的所有者&apos;&apos;

os模块与文件访问函数
    os.open(file,flags[,mode]) ：打开一个文件，设置打开选项，flags表示打开文件的旗标
，支持多个选项
        os.O_RDONLY ： 只读方式打开
        os.O_WRONLY ： 只写方式
        os.O_RDWR ： 读写方式
        os.O_NONBLOCK ： 打开时不阻塞
        os.O_APPEND ： 追加方式打开
        os.O_CREAT ；创建并打开一个新文件
        [更多](http://c.biancheng.net/view/2558.html)
    os.read(fd,n) ：从文件描述符fd中读取最多n个字符，返回读到的字符串
    os.wirte(fd,str) ：将字符串写入文件描述符fd，返回写入的字符串长度
    os.close(fd) : 关闭文件描述符fd
    os.lseek(fd,pos,how) ： 用于移动文件指针，how指定从哪里开始移动，
    os.fdopen(fd[,mode[,bufsize]]) ：通过fd打开，返回文件对象
    os.closerange(fd_low,fd_high) : 关闭从fd_low 包含 到 fd_high 不包含范围的所有文件描述符
    os.dup(fd) ： 复制文件描述符
    os.dup2(fd,fd2) ： 讲一个fd 复制到另一个文件描述符 fd2中
    os.ftruncate(fd,length) ： 将fd对应的文件截断到length长度，length参数不超文件大小
    os.remove(path) ：删除path对应的文件
    os.link(src,dst) ： 创建从src 到dst的硬连接
    os.symlink(src,dst) ：创建从src到dst的符号链接

tempfile模块：生成临时文件和临时目录
    常用函数：
        tempfile.TemporaryFile(mode=&apos;w+b&apos;,buffering=None,encoding=None,newline=None,suffix=None,prefix=None,dir=None) ：创建临时文件，返回类文件对象，支持I/O
    [More](http://c.biancheng.net/view/2560.html)
        tempfile.gettempdir() : 获取系统临时目录
    创建临时文件的两种方式：
        1. 手动创建临时文件，读写临时文件后需主动关闭，程序关闭时文件自动删除
        2. 使用with语句创建临时文件，with语句自动关闭临时文件</code></pre><h2 id="数据库编程"><a href="#数据库编程" class="headerlink" title="数据库编程"></a>数据库编程</h2><h3 id="数据库API-DB-API"><a href="#数据库API-DB-API" class="headerlink" title="数据库API(DB API)"></a>数据库API(DB API)</h3><pre><code>全局变量
    3个全局变量：
        1. apilevel ： 显示数据库模块的API版本号
        2. threadsafety ： 指定数据库模块的线程安全等级，等级值为 0～3，3代表模块完全是线程安全的，1:部分安全 ，0：  完全不能共享该模块
        3. paramstyle ： 指定SQL语句需要参数时，使用风格的参数，返回如下变量值：
            format ： 格式化字符串代表参数，使用 %s
            pyformat ： 使用扩展的格式代码代表参数
            qmark ： 使用 ？ 问号代表参数
            numeric ： 使用数字占位符 :N 代表参数，1 代表一个参数，2 也代表参数
            named ： 使用命名占位符 :name 代表参数

数据库API的核心类
    连接对象的方法和属性
        cursor() ：            打开游标
        commit() ：            提交事物
        rollback()：        回滚事物
        close() ：            关闭数据库连接
        isolation_level:    返回或指定数据库连接中事物的隔离级别
        in_transaction:        判断当前是否处于事物中
cursor ： 返回游标对象，游标对象是 Python DB API的核心对象，用于执行各种SQL语句，包括DDL、DML、select 查询语句等，使用游标执行不同的SQL语句返回不同的数据。
    游标对象的属性和方法：
        execute(sql[,parameters]) ： 执行SQL语句，parameters 参数用于为SQL语句中的参数指定值
        executemany(sql,seq_of_parameters) ：重复执行SQL语句，通过第二个参数指定值，序列有多少个元素，SQL语句被执行多少次
        executescript(sql_script) ：直接执行包含多条SQL语句的SQL脚本
        fetchone() : 获取查询结果集的下一行，如没有，则返回None
        fetchmany(size=cursor.arraysize) ：返回查询结果集的下N行组成的列表，如没有，返回空
        fetchall() : 返回查询结果集的全部行组成的列表
        close() : 关闭游标
        rowcount ： 只读属性返回受SQL语句影响的行数，修改的记录条数也可通过该属性获取
        lastrowid ：获取最后修改行的rowid
        arraysize ： 设置或获取fetchmany 默认获取的记录条数，默认为 1
        desciption ： 获取最后一次查询返回所有列的信息，只读
        connection ： 返回创建游标的数据库连接对象，属性只读

    操作数据库的基本流程
        1. 调用 connect 方法打开数据库连接，返回数据库连接对象
        2. 通过数据库连接对象打开游标
        3. 使用游标执行SQL语句 包括 DDL、DML、select查询语句，如执行的是查询语句，则处理查询数据
        4. 关闭游标
        5. 关闭数据库连接
        [图示](http://c.biancheng.net/uploads/allimg/190301/2-1Z301153400E3.gif)

SQLite 创建数据库表
    是一种嵌入式数据库，数据库是一个文件，SQLite将整个数据库包括定义表、索引以及数据本身，作为一个单独的、可跨平台使用的文件存储在主机中。不需要安装。直接导入
    连接数据库：
        connect() 函数
            conn = sqlite3.connect(&apos;xx.db&apos;)        // xx.db 是一个数据库,如不存在，在当前目录下创建对应的文件
    创建数据库：
        import sqlite3
        conn = sqlite3.connect(&apos;xx.db &apos;)
        c = conn.cursor()
        c.execute(&apos;&apos;&apos; create table user_tb(
            id interger primary key autoincrement,
            name text,
            pass text,
        gender text)&apos;&apos;&apos;
                )
        c.execute(&apos;&apos;&apos; create table post_tb
                id integer primary key autoincrement,
                post_name text,
                post_author text,
                post_number real,
                user_id integer,
                foreign key(user_id) references user_tb(id)&apos;&apos;&apos;)
        c.close()
        conn.close()
    SQLite 支持 NULL、INTEGER、REAL浮点数、TEXT文本、BLOD大二进制对象

SQLite execute 和 executemany 
    游标的execute 方法可执行DML 操纵语言 的 insert 、update、delete 语句，对数据库执行插入、修改和删除数据操作
    调用execute 方法执行insert 可向数据库插入数据
    向数据库插入一条数据：
        // 导入访问SQLite的模块
        import sqlite3
        // 打开或创建数据库， 可用 :memory: 代表创建内存中的数据库
        conn = sqlite3.connect(&apos;xx.db&apos;)            // xx.db 指创建时指定的数据库文件
        // 获取游标
        c = conn.cursor()
        //    调用执行 insert 语句插入数据
        c.execute(&apos;insert into user_tb values (null,?,?,?)&apos;, (&apos;xxx&apos;,&apos;xxx&apos;,&apos;xxx&apos;))
        c.execute(&apos;insert into xxx_tb values (null,?,?,?)&apos; (&apos;xx&apos;,&apos;xx&apos;,&apos;xx&apos;))
        //    提交事物
        conn.commit()
        // 关闭游标
        c.close()
        // 关闭连接
        conn.close()
 executemany ： 多次执行同一条SQl语句
        import sqlite3
        conn = sqlite3.connect(&apos;xx.db&apos;)
        c = conn.cursor()
        c.executemany(&apos;inert into xxx_tb values (null,?,?,?)&apos;,
            (    (&apos;xx&apos;,&apos;xxx&apos;,&apos;xxxx&apos;),
                (&apos;aa&apos;,&apos;aaa&apos;,&apos;aaaa&apos;),
                (&apos;bb&apos;,&apos;bbb&apos;,&apos;bbbb&apos;),
                (&apos;zz&apos;,&apos;zzz&apos;,&apos;zzzz&apos;)
            ))
        conn.commit()
        c.close()
        conn.close()
update | delete
    import sqlite3
    conn = sqlite3.connect(&apos;xx.db&apos;)
    c = conn.cursor()
    c.execute(&apos; update user_tb set xxx=? where xx=? &apos;,
                ((&apos;aa&apos;,1),
                (&apos;bb&apos;,2)
            ))
    print(&apos;change numbers : &apos;, c.rowcount)
    conn.commit()
    c.close()
    conn.close()

SQLite : fetchone() , fetchmany() and fetchall:
    select 语句执行查询结果， 通过游标的 fetchone 、fetchmany、fecthall获取查询结果，fetchone 获取一条，fetchmany 获取多条， fetchall 获取全部
    import sqlite3
    conn = sqlite3.connect(&apos;xx.db&apos;)
    c = conn.cursor()
    c.execute(&apos;select * from user_tb where xx &gt; ?&apos;,(2,))
    print(&apos;result : &apos;, c.rowcount)
    for col in (c.description):
        print([col[0],end&apos;\t&apos;])
    print(&apos;\n------&apos;)
    where True:
        row = c.fetchone()
        if not row:
            break
        print(row)
        print(row[1] + &apos; -&gt; &apos; + row[2])
    c.close()
    conn.close()
可修改部分代码：
    while True:
        // 指定抓起的条数记录，返回由条数组成的列表
        rows = c.fetchmany(3)
        //    判断rows是否为None
        if not row:
            break
        // 再次使用循环遍历获取的列表
        for r in rows:
            print(r)
    避免使用fetchall获取查询的全部记录，如数据量过大，会导致内存开销过大，导致系统崩溃！

SQLite： executescript 
    可执行一段SQL脚本
        import sqlite3
        conn = sqlite3.connect(&apos;xx.db&apos;)
        c = conn.cursor()
        c.executescript(&apos;&apos;&apos;
            insert into user_tb values (null,&apos;aaa&apos;,&apos;aaa&apos;,&apos;aaaa&apos;),
            insert into user_tb values (null,&apos;bbb&apos;,&apos;bbb&apos;,&apos;bbbb&apos;),
            create table item_tb (id integer primary key autoincrement, name, price)
        &apos;&apos;&apos;)
        conn.commit()
        c.close()
        conn.close()
    简化： SQLite 提供了3个方法为数据库连接对象
        1.  execute(sql[,parameters]) : 执行一条SQL语句
        2. executemany(sql[, parameters]) : 根据序列重复执行SQL语句
        3. executescipt(sql_script) ： 执行SQL脚本
        只是游标对象的3个方法的快捷方式                                 
SQLite： create_function 方法： 注册自定义函数
    create_function 方法包含的三个参数：
        1. name ： 指定注册的自定义函数的名字
        2. num_params ： 指定自定义函数所需参数的个数
        3. func ： 指定自定义函数对应的函数
        为SQL语句注册一个自定义函数，可在SQL语句中使用该自定义函数
            import sqlite3
            def reverse_ext(st):
                return &apos;[&apos; + st[::-1] + &apos;]&apos;
            conn = sqlite3.connect(&apos;xx.db&apos;)            // xx.db 代表数据库文件
            conn.create_function(&apos;enc&apos;,reverse_ext)
            c = conn.cursor()
            c.execute(&apos;insert into user_tb values(null,?,enc(&gt;),?)&apos; ,
                        (&apos;xx&apos;,&apos;xx&apos;,&apos;xxx&apos;))
            conn.commit()
            c.close()
            conn.close()

SQLite create_aggregate() : 自定以聚集函数
    SQL提供的5个聚集函数：
        1. sum() : 统计总和
        2. avg()  ：统计平均值
        3. count() ： 统计记录条数
        4. max() ： 统计最大数
        5. min() ： 统计最小数
可使用数据库连接对象提供的 create_aggregate(name,num_params,aggregate_class)方法，用于注册一个自定义的聚集函数
        create_aggregate 方法包含3个方法：
                1. name ： 指定自定义聚集函数的名字
                2. num_params ： 指定聚集函数所需的参数
                3. aggregate_class ： 指定聚集函数的实现类，该类必须实现 step(self,pargams,..) 和 finalize(self) 方法，step方法返回每条记录各执行一次，finalize 方法只在最后执行一次，返回值作为聚集函数最后的返回值

SQLite： create_collation ： 创建自定义比较函数
    create_collation(name, callable) 注册一个自定义的比较函数
        2个参数：
            1. name ： 指定自定义比较函数的名字
            2. callable ： 指定自定义比较函数对应的函数，包含两参数，对两个参数进行比较，如返回正整数，第一个参数更大，如是负整数，第二个参数更大，如返回0，则相等
            import sqlite3
            def my_collate(str1,str2):
                if st1[1:-1] == str2[1:-1]:
                    return 0;
                elif ...
            conn = sqlite3.connect(&apos;xx.db&apos;)
            conn.creat_collation(&apos;sub_cmp&apos;,my_callate)
            c = conn.cursor()
            c.execute(&apos;seleft * from xxx_tb where field = ?&apos;, (1))
            for row in c:
                print(row)
            conn.commit()
            c.close
            conn.close()

MySQL 数据库
    查看已安装的模块： pip list
                       pip show packagename
                       pip show mysql-connector-python
    卸载已安装的模块： pip uninstall packagename
    安装模块： pip install packagename
                pip install mysql-connector-python
                pip install packagename == 1.0    // 可指定版本

    MySQL 数据库执行DDL 语句
        import mysql.connector
        conn = mysql.connector.connect(user=&apos;root&apos;,password=&apos;root&apos;, host=&apos;127.0.0.1|localhost&apos;,post=&apos;3306&apos;, database=&apos;python&apos;,use_unicode=True)
        c = conn.cursor()
        c.execute(&apos;&apos;&apos;    create table user_tb (
                user_id int primary key auto_increment,
                name varchar(100),
                pass varchar(200),
                gender varchar(100)
            )&apos;&apos;&apos;)
        c.execute(&apos;&apos;&apos; create table order_tb (
            order_id int primary key auto_increment,
            item_name varchar(100),
            item_price double,
            item_number double,
            user_id  int,
            foreign key(user_id) reference user_tb(user_id)
        )&apos;&apos;&apos;)
        c.close()
        conn.close()

MySQL 数据库执行DML 语句
    可使用游标的execute 方法执行DML的 insert 、upadte、delete
        import mysql-connector
        conn = mysql-connector.connect(user=&apos;root&apos;,password=&apos;hale&apos;,host=&apos;localhost&apos;,port=&apos;3306&apos;,database=&apos;python&apos;,use_unicode=True)
        c = conn.cursor()
        c.execute(&apos;insert into user_tb values(null, %s,%s,$s)&apos;,(&apos;aa&apos;,&apos;aaa&apos;,&apos;aaaa&apos;))
        c.executemany(&apos;insert into order_tb values (null,%s ,%s,%s,%s)&apos;, 
                ((&apos;a&apos;,&apos;aa&apos;,&apos;aaa&apos;),(&apos;b&apos;,&apos;bb&apos;,&apos;bbb&apos;),(&apos;c&apos;,&apos;cc&apos;,&apos;ccc&apos;)))
        conn.commit()
        c.close()
        conn.close()
    使用 %s 作为占位符
    update 
        c.executemany(&apos;update user_tb set name=%s where user_id = %s &apos;, ((&apos;e&apos;,&apos;ee&apos;,&apos;eee&apos;),(&apos;w&apos;,&apos;ww&apos;,&apos;www&apos;)))
        print(&apos;change : &apos;, c.rowcount)
        conn.comm
    mysql数据库模块连接对象有一个 autocommit ，如属性设置为True ，则关闭连接的事物支持，每次执行DML语句后会自动提交，无需调用 commit 方法提交事物
        import mysql.connector 
        conn = mysql.connector.connect(user=&apos;root&apos;,password=&apos;hale&apos;,host=&apos;localhost&apos;,port=&apos;3306&apos;,database=&apos;python&apos;,use_unicode=True)
        conn.autocommit = True

MySQL 数据库执行查询语句
    import mysql.connector
    conn = mysql.connector.connect(user=&apos;root&apos;,password=&apos;hale&apos;,host=&apos;localhost&apos;,port=&apos;3306&apos;,database=&apos;python&apos;,use_unicode=True)
    c = conn.cursor()
    c.execute(&apos;selecet * from user_tb where user_id &gt; %s&apos;, (1,))    
    for col in (c.description):
        print(col[0],end=&apos;\t&apos;)
    print(&apos;\n -------&apos;)
    for row in c:
        print(row)
        print(row[1] + &apos; -&gt; &apos; + row[2])
    c.close()
    conn.close()

    游标对象支持 fetchone() fetchmany() fetchall() 
    c.execute(&apos;select * from ueer_tb where user_id &gt; %s&apos;,(1,))
    where True:
        rows = c.fetchmany(3)
        if not rows:
            break
        for r in rows:
            print(r)

MySQl callproc : 调用数据库存储过程
    callproc(self,procname,args=0)
        procname : 代表存储过程的名字， args 参数用于存储过程传入参数
        result_args = c.callproc(&apos;add_pro&apos;,2,1,0)

PyMySQl模块下载和安装
    类Connector/Python、PyMySQL ，称为接口程序，通过此对象，可对另外一个对象操作
    安装PyMySQL模块：
        pip install PyMySQL
            import pymysql

    import pymysql
    conn = pymysql.connect(host=&apos;localhost&apos;,root=&apos;root&apos;,password=&apos;pass&apos;,db=&apos;python&apos;,charset=&apos;utf8mb4&apos;)
    c = conn.cursor()
    c.execute(&apos;select  Version()&apos;)
    while True:
        rows = c.fetchmany(3):
            if not rows:
                break

            for i in rows:
                print(i)
    c.close()
    conn.close()
创建数据库：    
    import pymysql
    conn = pymysql.connect(&apos;localhost&apos;,&apos;root&apos;,&apos;root&apos;,&apos;python&apos;)
    cursor = conn.cursor()
    cursor.execute(&apos;Drop table if exists tb_name&apos;)
    sql = &apos;&apos;&apos; create table user_tb (
        user_id int primary key auto_increment,
        name varchar(100),
        email varchar(10),
        pass varchar(100)
    )&apos;&apos;&apos;
    cursor.execute(sql)
    cursor.close()
    conn.close()

数据库插入操作
    import pymysql
    conn = pymysql.connect(&apos;localhost&apos;,&apos;root&apos;,&apos;root&apos;,&apos;py_db&apos;)
    cursor  = conn.cursor()
    sql = &apos;&apos;&apos; insert into user_tb (name,pass) values (&apos;%s&apos;,&apos;%s&apos;) % (&apos;aa&apos;,&apos;aa&apos;)&apos;&apos;&apos;
    try: 
        cursor.execute(sql)
        conn.commit()
    except:
        conn.rollback()
    conn.close()</code></pre><h2 id="并发编程-多进程、多线程"><a href="#并发编程-多进程、多线程" class="headerlink" title="并发编程(多进程、多线程)"></a>并发编程(多进程、多线程)</h2><h3 id="进程和线程-区别"><a href="#进程和线程-区别" class="headerlink" title="进程和线程 区别"></a>进程和线程 区别</h3><pre><code>进程： 操作系统资源分配的基本单位，通常是一个程序
线程： 任务调度和执行的基本单位，是进程的组成部分
    可运行多个进程(程序)，同一进程可多个线程同时执行(通过CPU调度，每个时间片中只有一个线程执行
内存方面：进程分配不同的内存控件，线程不分配
开销方面： 进程有独立的代码和数据空间程序上下文，进程切换开销大，线程是轻量级的进程，同一类线程共享代码和数据空间，有独立的运行栈和计数器，线程切换开销小

单线程： 当一个进程中只有一个线程时
多线程： 当一个进程中有多个线程时 </code></pre><h3 id="创建线程的两种方式："><a href="#创建线程的两种方式：" class="headerlink" title="创建线程的两种方式："></a>创建线程的两种方式：</h3><pre><code>相关模块：
    1. _thread ： 提供低级别的原始的线程支持，及简单的锁，功能有限，不建议使用
    2. threading ： 提供丰富的多线程支持，推荐使用
创建方式：
    1. 使用 threading 中的 Thread 类的构造器创建线程，直接对类 threding.Thread 进程实例化，并调用对象的 start 方法创建线程
    2. 继承 threading 模块中的 Thread 类创建线程类，用 threading.Theread 派生出一个新的子类， 将新建类实例化，并调用 start 方法创建线程

 调用Thread 类的构造器创建线程：
    直接调用 threading.Thread 类构造器创建线程：
        __init__(self,gourp=None,target=None,name=None,args=(),kwargs=None,*,daemon=None)
            group: 指定该线程所属的线程组，
            target： 指定该线程要调度的目标方法
            args ： 指定一个元组，以位置参数形式为target 指定的函数传入参数，元组的第一个参数传给target函数的第一个参数，第二个传给target第二个参数，以此类推
            kwargs ：指定一个字典，以关键字参数的形式为target指定的函数传参
            daemon ： 指定所构建的线程是否为后代线程
    通过Thread 类的构造器创建并启动多线程的步骤：
        1. 调用Thread类的构造器创建线程对象，创建时，target参数指定的函数将作为线程执行体
        2. 调用线程对象的start() 方法启动该线程
            import threading
            // 定义普通的action函数，作为线程执行体
            def action(max):
                for i in range(max):
                    print(threading.current_thred().getName() + &quot; &quot; + str(i))
            // 主程序、祝线程的执行体
            for i range(100):
                print(threading.current_thread().getName() + &quot; &quot; + str(i))
                if i == 20:
                    t1 = threading.Thread(target=action,args=(100,))
                    t1.start()
                    t2 = threading.Thread(target=action,args=(100,))
                    t2.start()
            print(&apos;master thread is run over !&apos;)
            1. 创建一个Thread对象，线程的target 为 action， 将action函数作为线程主体执行，接下来的程序调用start 来启动t1线程
            2. 再次创建线程，创建和启动与第一个线程完全相同
            显式创建并启动了两个线程，但实际上有三个，当程序运行后，至少创建一个主线程，主线程的线程执行代码就是程序中的主程序，没放在任何函数中的代码
                用到的函数和方法：
                    threading.current_thread(): 是threading 模块的函数，总是返回当前正在执行的线程对象
                    getName ：Thread类的实例方法，返回调用他的线程名字
                在Threading模块中，经常用到的函数：
                    threading.enumerate() : 正运行线程的list
                    threading.activeCount ： 返回正在运行的线程数量，与 len(threading.enumerate())

继承Thread类创建线程类
    步骤：
        1. 定义Thread 类的子类，并重写run方法，run方法方法体代表线程需要完成的任务，因此 run方法称为 线程执行体
        2. 创建Thread 子类的实例，即创建线程对象
        3. 调用线程对象的start 方法来启动线程
            import threading
            class FKThread(threading.Thread):
                def __init__(self):
                    threading.Thread.__init__(self)
                    self.i = 0 
                def run(self):
                    while self.i &lt; 100:
                        print(threading.current_thread().getName() + &quot; &quot; + str(self.i))
                    self.i += 1
            for i in range(100):
                print(threading.current_thread().getName() + &quot; &quot; + str(i) )
                if i == 20:
                    ft1 = FKThread()
                    ft1.start()
                    ft2 = FKThread()
                    ft2.start()

            print(&apos;threading is ok !&apos;)</code></pre><h3 id="Python-线程的生命周日-新建、就绪、运行、阻塞、死亡"><a href="#Python-线程的生命周日-新建、就绪、运行、阻塞、死亡" class="headerlink" title="Python 线程的生命周日(新建、就绪、运行、阻塞、死亡)"></a>Python 线程的生命周日(新建、就绪、运行、阻塞、死亡)</h3><h4 id="线程的新建和就绪状态"><a href="#线程的新建和就绪状态" class="headerlink" title="线程的新建和就绪状态"></a>线程的新建和就绪状态</h4><pre><code>        [具体](http://c.biancheng.net/view/2606.html)
            程序新建Thread对象或Thread子类的对象后，线程处于新建状态。 线程对象调用start 方法，会处于就绪状态，解释器会为其创建方法调用栈和程序计数器。启动线程用start 方法，不是run方法。 start 方法启动线程，系统把该run方法当成线程执行体处理。
        import threading
        def action(max):
            for i in range(max):
                print(threading.current_thread().name + &quot; &quot; + str(i))

        for i in range(100):
            print(threading.current_thread().name + &quot; &quot; + str(i))
            if i == 20:
                threading.Thread(target=action,args=(100,)).run()
                threading.Thread(target=action,args=(100,)).run()
        如果程序对同一线程重复调用start方法，会引发 RuntimeError警告

    线程运行和阻塞状态
        如处于就绪状态的线程获得了CPU，执行run方法的线程执行体，该线程处于运行状态
        在一个具有多处理器的机器上，会有多个线程并行执行 Parallel。当线程数大于处理器时，依然存在多个线程在同一CPU上轮换
    进入阻塞状态的情况：
        1. 线程调用 sleep 方法主动放弃其所占用的处理器资源
        2. 线程调用了一个阻塞式I/O方法，返回之前，线程被阻塞
        3. 线程试图获取一个锁对象，但锁对象被其他线程持有
        4. 线程在等待某个通知 Notify
    解除阻塞，重新进入就绪状态的情况：
        1. 调用sleep方法的线程经过了指定的时间
        2. 线程调用的阻塞模式I/O方法已经返回
        3. 线程成功获得了试图获取的锁对象
        4. 线程等待某个通知时，其他线程发出通知Notify，

线程死亡
    线程死亡的方式：
        1. run方法或代表线程执行体的target 函数执行完成，线程正常结束
        2. 线程抛出一个未捕获的Exception 或 Error
        测试某个线程是否四万过的方法：调用线程对象的is_alive()方法，当线程处于就绪、运行、阻塞三种状态，方法返回True，当线程处于新建、死亡状态时，方法返回False
            import threading
            def action(max):
                for i in range(100):
                    print(threading.current_thread().name + &quot; &quot; + str(i))
            // 创建线程对象
            sd = threading.Thread(target=action,args=(100,))
            for i in range(300):
                print(threading.current_thread().name + &quot; &quot; + str(i))
                if i == 20:
                    sd.start()
                    print(sd.is_alive())
            //    试图启动死亡线程
                if i &gt; 20 and not(sd.is_alive()):
                    sd.start()

Thread join() 用法
    让一个线程等待另一个线程完成的join方法，当在某个程序执行流中调用其他线程的join方法，调用线程将被阻塞，直接被join方法加入额join线程执行完成
    import threading
    def action(max):
        for i in range(max):
            print(threading.current_thread().name + &quot; &quot; + str(i))

    threading.Thread(target=action,args=(100,),name=&quot;new threading&quot;).start()
    for i in range(100):
        if i == 20:
            jt = threading.Thread(target=action, args=(100,), name=&quot;join threading&quot;)
            jt.start()
            jt.join()
        print(threading.current_thread().name + &quot; &quot; + str(i))

Python守护线程及作用
    后台线程Daemon Thread： 后台运行，任务时为其他线程提供服务。又称 &quot;精灵线程&quot;。 特征：所有前台死亡，后台会自动死亡
    调用Thread对象的daemon属性可将指定线程设置为后台线程，
        import threading
        def action(max):
            for i in range(max):
                print(threading.current_thread().naem + &quot; &quot; + str(i))
    t = threading.Thread(target=action, args=(100.), name=&quot;daemon threading&quot;)
    // 将此线程设置为后台线程
    t.daemon = True
    t.start()
    for i in range(100):
        print(threading.currenct_thread().name + &quot; &quot; + str(i))
    创建线程的两种方法：
        1. 主动将线程的daemon 属性设置为True
        2. 后台线程启动的线程默认时后台线程
    将daemon 属性设为True，必须在start方法调用之前进行，否则引发 RuntimeError异常

sleep 函数用法： 线程睡眠
    如需让当前线程暂停一段时间，并进入阻塞状态，可调用 time 模块的 sleep(secs)函数实现，secs参数为指定线程阻塞多少秒
    import time
    for i in range(10):
        print(&quot;now time : %s&quot; % time.ctime())
        time.sleep(1)

互斥锁Lock: 解决多线程安全问题
    多线程优势在于并发性，可同时运行多个任务， 互斥锁解决数据不同步问题
        类银行取钱：
            1. 用户输入账号、密码，系统判断用户输入信息是否匹配
            2. 输入金额
            3. 系统判断余额是否大于取款金额
            4. 若大于，则成功，如小于，则失败
        并发取款：
            class Account:
                def __init__(self,account_no,balance):
                    self.account_no = account_no
                    self.balanace = balance

        取钱：
            import threading
            import time 
            import Account
            def draw(account,draw_amount):
                if account.blance &gt;= draw_amount:
                    print(threading.current_thread().name + &quot; get RMB successful &quot; + str(draw_amount)) 
                    account.balance -= draw_amount
                    print(&apos;yu e &apos; + str(accnout.balance))
                else:
                    print(threading.current_thread().name + &apos;get RMB error &apos;)
            user = Account.Account(&apos;12345&apos;,1000)
            threading.Thread(name=&apos;A&apos;,target=draw, args=(user,100)).start()
            threading.Thread(name=&apos;B&apos;,target=draw, args=(user,200)).start()
            [LOCK](http://c.biancheng.net/view/5107.html)

互斥锁同步线程
    python的threading模块引入互斥锁，解决run方法体不具有线程安全性，threading模块提供了lock和Rlock两个类，提供了两个方法来加互斥锁和释放互斥锁：
        1. acquire(blocking=True, timeout=-1):请求对lock或Rlock加锁，timeout参数指定加锁的秒数
        2. release() : 释放锁
    lock 和 Rlock 的区别：
        threading.lock: 一个基本的锁对象，每次只能锁一次，其余的锁请求，徐等待锁释放后才能获取
        threading.Rlock: 代表可重入锁，同一线程可多次锁定，也可多次释放，如使用Rlock，acquire和release 方法必须成对出现
    class X:
        def m():
            self.lock.acquire()
            try:
                paxx
            finally:
                self.lock.release()
    线程安全的类具有的特征：
        1. 该类的对象可被多个线程安全地访问
        2. 每个线程在调用该对象的任意方法后，可得到正确的结果
        3. 每个线程在调用该对象的任意方法后，该对象依然保持合理的状态

    减少线程安全带来的负面影响的策略：
        1. 不对线程安全类的所有方法进行同步，只对改变竞争资源方法进行同步
        2. 在单线程环境中使用线程不安全版本保证性能，在多线程环境中使用线程安全版本

死锁： 如何避免死锁
    当两个线程相互等待对方释放同步监视器时会发生死锁，在进行多线程编程时采取措施避免死锁
    [死锁](http://c.biancheng.net/view/2620.html)
避免死锁的方式：
    1. 避免多次锁定，避免同一个线程对多个Lock进行锁定
    2. 具有相同的加锁顺序
    3. 使用定时锁
    4. 死锁检测

Python condition实现线程通信
    线程调度具有一定的透明性，程序无法准确控制线程的轮换执行。如有需要，可通过线程通信保证线程协调运行，
    Condition对象保持协调。Condition可让那些已经得到lock对象却无法继续执行的线程释放Lock对象，Condition可唤醒其他处于等待状态的线程
    Condition类提供的方法：
        1. acquire([timeout])/release(): 调用Condition 关联的lock的acquire或release 方法
        2. wait([timeout]) : 导致当前进程进入Condition的等待池等待通知并释放锁，知道其他调用该Condition的Notify或notify_all() 方法来唤醒该线程
        3. notify() : 唤醒在该Condition 等待池中的单个线程并通知它，收到通知自动调用acquire 方法尝试加锁。
        4. notify_all() : 唤醒在该Condition 等待吃中等待的所有线程并通知他们
        [More](http://c.biancheng.net/view/2622.html)    

Queure 队列实现线程通信
    queue模块提供阻塞队列，用于实现线程通信。主要提供三个类： 主要区别在于进队列、出队列的不同
        1. queue.Queue(maxsize=0): 代表FIFO 先进先出的常规队列，maxsize 可限制队列的大小。 如maxsize为0 或负数，表示该队列的大小无限制
        2. queue.LifoQueue(maxsize=0): 代表LIFO 后进先出，与Queue区别是出队列的顺序不同
        3. PriorityQueue(maxsize=0): 代表优先级队列， 优先级最小的元素先出队列
    三个队列类的属性和方法提供的属性和方法：
        Queue.qsize(): 返回队列的实际大小，即该队列中包含的元素个数
        Queue.empty(): 判断是否为空
        Queue.full() : 判断队列是否已满
        Queue.put(item,block=True,timeout=None): 向队列中放入元素，如已满，且block参数为True阻塞，timeout指定阻塞时间，如timeout为None，则代表一直阻塞，
        Queue.put_nowait(item): 向队列中放入元素，不阻塞。
        Queue.get(item,block=True,timeout=None):从队列中取出元素，如队列已满，则block参数为True阻塞。
        Queue.get_nowait(item): 从队列中取出元素，不阻塞
    普通的Queue的功能和用法：
        import queue
        bq = queue.Queue(3)
        bq.put(&apos;Python&apos;)
        bq.put(&apos;PHP&apos;)
        print(&apos;123213&apos;)
        bq.put(&apos;Queue&apos;)
        print(&apos;2222&apos;)

    利用Queue实现线程通信
        import threading
        import time 
        import queue
        def product(qu):
            str_tuple = (&apos;python&apos;,&apos;golang&apos;,&apos;php &apos;)
            for i in range(9999):
                print(threading.current_thread().name + &quot; Product Env&quot;)
                time.sleep(0.2)
                qu.put(str_tuple[i % 3])
                print(threading.current_thread().name + &apos;product ok&apos;)
        def consume(qu):
            while True:
                print(threading.current_thread().name + &apos;take money&apos; )
                time.sleep(0.2)
                t = qu.get()
                print(threading.current_thread().name + &apos;take ok %s &apos;% t)
        qu = queue.Queue(maxsize = 1)
        threading.Thread(target=product,args=(qu,)).start()
        threading.Thread(target=product,args=(qu,)).start()
        threading.Thread(target=product,args=(qu,)).start()
        threading.Thread(target=consume,args=(qu,)).start()

Event 实现线程通信
    间的线程通信机制，一个线程发出一个Evnet，另一个线程可通信该Evnet 被触发
    Event 是一个内部旗标，可通过Event 的set方法将旗标设置为True，可调用clear方法将旗标设置为False，可调用wait 方法来阻塞当前进程。
    Event方法：
        1. is_set(): 返回Event 的内部旗标是否为True
        2. set() : 把Event的内部旗标设置为True，并唤醒所有处于等待状态的进程
        3. clear() : 将Event的内部旗标设置为False，调用wait方法阻塞当前进程
        4. wait(timeout=None): 阻塞当前进程
            import threading
            import time
            event = threading.Event()
            def cal(name):
                print(&apos;%s start &apos; % threading.currentThread().getName())
                print(&apos;%s status&apos; % name)
                event.wait()
                print(&apos;%s get message&apos; % threading.currentThread().getName())
                print(&apos;%s is status&apos; % name)
            threading.Thread(target=cal,args=(&apos;Ai&apos;,)).start()
            threading.Thread(target=cal,args=(&apos;Bi&apos;,)).start()
            time.sleep(3)
            print(&apos;=====&apos;)
            print(&apos;master thread event&apos;)
            event.set()
            [More](http://c.biancheng.net/view/2626.html)








线程池及其原理和使用
    当启动新线程的时，使用线程池可提升性能 。线程池在系统启动时即创建大量空闲的线程。
    线程池的使用：
        基类是concurrent.futures模块中的Executor。提供两个子类，即 ThreadPoolExecutor 和 ProcessPoolExecutor。 ThreadPollExecutor 用于创建线程池，ProcessPoolExecutor创建进程池
        Executor提供的常用方法：
            submit(fn,args,**kwargs): 将fn函数提交给线程池， *args 代表传给fn函数的参数，*kwargs 代表以关键字参数的形式给fn函数传入参数
            map(func,*iterables,timeout=None,chunksize=1):类全局函数
            map(func,*iterables)，该函数加你个启动多个线程，以异步方式立即对iterables执行map处理
            shotdown(wait=True): 关闭线程池
        submit方法返回Future对象，Future 提供的方法
            cancel()：取消该Future代表的线程任务，如任务正在执行，不可取消，返回False
            cancelled ：返回线程任务是否被成功取消
            running ： 如正在执行，不可取消，返回False
            done ；如任务被成功取消，返回True
            result(timeout=None) : 获取线程返回的结果，如任务还未完成，该方法会阻塞当前线程，timeout指定组赛的秒数
            exception(timeout=None):任务引发的异常，如任务成功完成，没异常，则返回None
            add_done_callback(fn):为该Future 的线程注册一个 回调函数，任务完成，自动出发fn函数。
    使用线程池执行线程任务的步骤：
            1. 调用ThreadPoolExecutor 类的构造器创建一个线程池
            2. 定义一个普通函数作为线程任务
            3. 调用ThreadPoolExecutor对象的submi方法来提交线程任务
            4. 调用ThreadPoolExecutor对象的shutdown方法来关闭线程池
                from concurrent.futures import ThreadPoolExecutor
                import threading
                import time

                def action(max):
                    sum = 0
                    for i in range(max):
                        print(threading.current_therad().name() + &apos; &apos; + str(i))
                        sum += i
                    return sum
                pool = ThreadPoolExecutor(max_workers=2)
                future1 = pool.submit(action,50)
                future2 = pool.submit(action,100)
                print(future1.done())
                time.sleep(3)
                print(future2.done())
                print(future1.result())
                pool.shutdown()
    获取执行结果
        1.调用result方法获取线程任务的返回值。
        2.通过Future的add_done_callback()方法添加回调函数
          线程池实现了上下文管理协议Context Manage Protocol，程序可用with语句来管理线程池，避免手动关闭线程池
          map方法会为iterables的每个元素启动一个线程，以并发方式执行func函数，相当于启动len(iterables)个线程，并收集每个线程的执行结果。
    threading local函数：返回线程局部变量
            threding 提供local函数，可返回一个线程局部变量，使用线程局部变量可很简捷隔离多线程访问的竞争资源。
            线程局部变量Thread local Variable，为每个使用该变量的线程提供一个变量的副本，
    线程局部变量的作用：
        import threading
        from concurrent.futures import ThreadPoolExecutor
        data = threading.local()
        def action(max):
            for i in range(max):
                try:
                    data.x += i
                except:
                    data.x = i
                print(&quot; data %d&quot; % (threading.current_thread().name,data.x)) 
        with ThreadPoolExecutor(max_workers=2) as pool:
            pool.submit(action,10)
            pool.submit(action,10)

Timer 定时器：控制函数在特定时间执行
    Thread类的子类Timer，可用于控制指定函数在特定时间内执行一次，
        from threading import Timer
        def hi():
            print(&apos;hi&apos;)
        t = Timer(10.0, hi)
        t.start()
    取消Timer的调度 cancel 函数

schedule 任务调度及用法
    如需执行更复杂的任务调度，使用sched模块，提供了 sched.scheduler类，该类代表一个任务调度器
    sched.scheduler(timefunc=time.monotonic,delayfunc=time.sleep) 构造器支持两个参数：
        1. timefunc : 指定生成时间戳的时间函数，默认使用time.monotonic 生成时间戳
        2. delayfunc; 指定阻塞程序的函数，默认使用 time.sleep 函数阻塞程序
        [More](http://c.biancheng.net/view/2630.html)
    sched.scheduler 调度器常用属性和方法：
        scheduler.enterabs(time,priority,action,argument=(),kwargs={}): 指定time时间点执行action函数，argument 和 kwargs 用于向 action函数传入参数，arg...使用位置的形式传入参数。 kwargs 使用关键字传入参数
    scheduler.enter(delay,priority,action, argument=(),kwargs={}): delay 指定多少秒后执行action任务。作用同上
    scheduler.cancel(event): 取消任务
    scheduler.empty(): 判断调度器队列是否为空
    scheduler.run(blocking=True): 运行所有需要调度的任务
    scheduler.queue： 只读属性返回该调度器的调度队列
        import sched,time
        improt threading
        s = sched.scheduler()
        def print_time(name=&apos;default&apos;):
            print(&apos; %$ de time %s&apos; % (name,time.ctime()))
        print(&apos;master threading time&apos;, time.ctime())
        s.enter(10,1,print_time)
        s.enter(3,2,print_time,argument=(&apos;wei zhi hanshu &apos;))
        s.enter(5,2,print_time,kwargs=[&apos;name&apos;:&apos;guanjianzi hanshu &apos;])
        s.run()
        print(&apos;master &apos;, time.ctime())

os.fork方法：创建新进程
    多进程实现并发编程
    fork 方法作用： 程序会启动两个进程(一个主进程，一个fork出来的子进程)来执行从os.fork() 开始的所有代码
        fork方法不需要函数,有返回值表明哪个进程在执行:
            1. 如果fork返回0， 表明fork出来的子进程在执行
            2. 如fork返回非0， 表明父进程在执行，返回fork出来的子进程的进程ID
                import os
                print(&apos;master %s &apos; % os.getpid())
                pid = os.fork()
                print(&apos;worker in %s &apos; % os.getpid())
                if pid == 0:
                    print(&apos;origin id  %s  master  id %s&apos; % (os.getpid(),os.getppid()))
                else:
                    print(&apos;me %s makr son id %s&apos; % (os.getpid(),pid))
                print(&apos;thread over %s &apos; % os.getpid())

Process 创建进程的2种方法
    1. 指定函数作为target ，创建Process对象即可创建新进程
    2. 继承Process 类，重写run方法来创建进程类，创建process子类的实例作为进程
    Process 类的属性和方法：
        1. run() : 实现进程的执行体
        2. start ： 启动进程
        3. join([timeout]) ： 类线程的join方法
        4. name ： 设置和访问进程的名字
        5. is_alive ：判断进程是否活着
        6. daemon ： 判断是否设置进程的后台状态
        7. pid ： 返回进程的ID
        8. authkey ：返回进程的授权key
        9. terminate ： 中断该进程
    以指定函数作为target 创建新进程
            import multiprocessing
            import os
            def action(max):
                for i in range(max):
                    print(&apos;%s subprocess paterprocess %s  id %d &apos; % (os.getpid(),os.getppid(), i))
            if __name__ == &apos;__main__&apos;:
                for i in range(100):
                    print(&apos;parent %s id %d&apos; % (os.getpid(), i))
                    if i == 20:
                        mp1 = multiprocessing.Process(target=action,args=(100,))
                        mp1.start()
                        mp2 = multiprocessing.Process(target=action,args=(100,))
                        mp2.start()
                        mp2.join()
                print(&apos;master process is ok&apos;)

    继承Process 类 创建子进程
        步骤：
            1. 定义继承Process 的子类，重写run方法准备作为进程执行提
            2. 创建Process 子类的实例
            3. 调用 Process 子类的实例的start方法来启动进程
                import multiprocessing
                import os
                class MyProcess(multiprocessing.Process):
                    def __init__(self,max):
                        self.max = max
                        super().__init__()
                    def run(self):
                        for i in range(self.max):
                            print(&apos;%s subprocess %s parent process %d &apos; % (os.getpid(),os.getppid(),i))
                if __name__ == &apos;__main__&apos;:
                   for i in range(100):
                        print(&apos;%s master process %d &apos; % (os.getpid(),i))
                        if i == 20:
                            mp1 = MyProcess(100)
                            mp1.start()
                            mp2 = MyProcess(100)
                            mp2.start()
                            mp2.join()
                    print(&apos;master process is ok!&apos;)

设置进程启动的3种方式
    1. spawn ：父进程启动解释器进程，子进程继承run方法所需的资源。不必要的文件描述和handler都不被继承，效率比fork或forkserver方式要低得多。 Windows 只支持spawn方式
    2. fork： 通过os.fork 启动解释器， 子进程继承父进程所有资源，子进程等效于父进程
    3. forkserver ： 启动一个服务器进程，当再次启动新进程，父进程会连接到该服务器进程。请求由服务器进程来fork新进程
    multiprocessing 模块提供set_start_method 函数，用于设置启动进程的方式，必须将这行设置代码放在所有与多进程相关代码之前。 
    if __name__ == &apos;__main__&apos;:
        multiprocessing.set_start_method(&apos;spawn&apos;)
        q = multiprocessing.Queue()
        mp = multiprocessing.Process(target=foo,args=(q,))
        mp.start()
        print(q.get())
        mp.join()

多进程和多线程优缺点
    都使用并行机制提升系统运行效率，区别在于运行时所占内存分布不同，多线程共用一套内存的代码块区间，而多进程是各用一套独立的内存区间
    多进程有点在于 稳定性好，一个子进程奔溃，不影响主进程和其余进程，此特性多用多进程来实现守护服务器的功能
    多进程创建进程的代价非常大，操作系统会给每个进程分配固定的资源，会对进程的总数有一点的限制。
    多线程效率高 ，用于批处理任务等功能。 不足：一个线程奔溃整个进程奔溃。
    场景： 计算密集型的任务，多线程效率更高。 IO密集型的任务，如文件操作，网络爬虫，采用多线程
    IO密集型操作，消耗时间是等待时间，Python会释放GIL供新的线程使用，实现线程间的切换。    将多进程程序分布运行在不同的计算机上协同工作，每一进程内部，由多个线程并行工作
    最佳线程数量 = ()(线程等待时间+线程CPU时间) / 线程CPU时间) * CPU数量

使用进程池管理进程
    如需启动多个进程，可使用进程池管理进程，程序可通过multiprocess模块的pool函数创建进程池： multiprocessing.pool.Pool类
    进程池常用方法：
        1. apply(func[,args[,kwds]]) : 将func函数提交给进程池处理，args 传给func的位置参数， kwds代表传给func的关键字参数，会被阻塞直到func函数执行完成
        2. apply_async(func[,args[,kwds[,callback[,error_callback]]]]): 异步，不被阻塞。callback指定func函数完成后的回调函数，error_callback 指定fun指定回调函数
        3. map(func,iterable[,chunksize]) : 类python的map全局函数，使用新进程对iterable的每个元素执行func函数
        4. imap(func,iterable[,chunksize]): map方法的延迟版本
        5. imap_unordered(func,iterable[,chunksize]):类imap，不保证元素顺序一致
        6. starmap(func,iterable[,chunksize]): 类map方法，要求iterable的元素是iterable对象，
        7. close ： 关闭进程池，不再接收新任务，把进程池中的所有任务执行完后再关闭自己
        8. terminate ： 立即中止进程池
        9. join ： 等待所有进程完成
        import multiprocessing
        import time
        import os
        def action(name=&apos;default&apos;):
            print(&apos;%s process param %s &apos; % (os.getpid(),name))
            time.sleep(3)
        if __name__ == &apos;__main__&apos;:
            pool = multiprocessing.Pool(processes=4)
            pool.apply_async(action)
            pool.apply_async(actino,args=(&apos;location parame:&apos;,))
            pool.apply_async(action,kwds={&apos;name&apos;:&apos;kwords params&apos;})
            pool.join()
        线程池同样实现上下文管理协议，可使用with子句来管理进程池，避免程序主动关闭进程池
            import multiprocessing
            import time
            import os
            def action(max):
                sum = 0
                for i in range(max):
                    print(&apos;%s %d &apos; % (os.getpid(),i))
                    sum += i
                return sum
            if __name__ == &apos;__main__&apos;:
                with multiprocessing.Pool(processes=4) as pool:
                    results = pool.map(action,(50,100,200))
                    print(&apos;---&apos;)
                    for r in results:
                        print(r)

进程间通信的2种实现方法 Queue Pipe
    进程通信提供的2种机制：
        1. Queue ： 一个进程向Queue中放入数据，另一个进程从Queue中读取数据
        2. Pipe ： Pipe代表连接两个进程的管道，程序可调用Pipe函数时会产生两个连接段，分别交给两个进程，进程可从连接端读取数据，也可向该连接端写入数据
    使用Queeu实现进程间通信
        multiprocessing 模块下的Queue和queue 模块下的Queue类似，都提供qsize 、empyt、full、put、put_nowwait、get、get_nowait 等方法，区别： multiprecessing 模块下的Queue为进程提供服务， 而queue模块下的Queue为线程提供服务
        import multiprecessing
        def f(q):
            print(&apos;%s &apos; % multiprocessing.current_process().pid)
            q.quit(&apos;Python&apos;)
        if __name__ == &apos;__main__&apos;:
            q = multiprocessing.Queue()
            p = multiprocessing.Process(target=f,args=(q,))
            p.start()
            print(&apos;%s &apos; % multiprocessing.current_process().pid)
            print(q.get())
            p.join

使用Pipe实现进程间通信
    程序调用 multiprocessing.Pipe() 创建一个管道，返回两个PipeConnection对象，代表管道的两个连接端，一个管道有两个连接端，分别用于连接通信的两个进程
    PipeConnection对象包含的常用方法：
        1. send(obj) : 发送一个obj给管道的另一端，另一端使用 recv方法接收， 该obj需是可picklable的python序列化机制，如该对象序列化超过32MB，可引发ValueError异常
        2. recv ：接收另一端通过send方法发送过来的数据
        3. fileno：关于连接所使用的问价描述器
        4. close ： 关闭连接
        5. poll([timeout]):返回连接中是否有数据可读取
        6. send_types(buffer[,offset[,size]]: 发送字节数据，使用recv_bytes 或 recv_bytes_into 方法接收
        7. recv_bytes([maxlength])):通过send_bytes方法发送的数据，maxlength指定最多接收的字节数，返回接收到的字节数据
        8. recv_bytes_into(buffer[,offset]): 类recv_bytes方法，将接收到的数据放在buffer中
            import multiprocessing
            def f(conn):
                print(&apos;%s &apos; % multiprocessing.current_process().pid)
                conn.send(&apos;Python&apos;)
            if __name__ == &apos;__main__&apos;:
                parent_conn,child_conn = multiprocessing.Pipe()
                p = multiprocessing.Process(target=f, args=(child_conn,))
                p.start()
                print(&apos;%s get data&apos; % multiprocessing.current_process().pid)
                print(parent_conn.recv())
                p.join()</code></pre><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><pre><code>计算机网路的功能：
    1. 资源共享
    2. 信息传输与集中处理
    3. 均衡负荷与分布处理
    4. 总和信息服务
常见的类型有： 局域网LAN、城域网MAN、广域网WAN。
通信协议：负责对传输速率、传输代码、代码结构、传输控制步骤、出错控制等指定处理标准。
    通信协议由三部分组成：
        1. 语义： 决定双方对话的类型
        2. 语法： 决定双方对话的格式
        3. 交换： 决定通信双方的应答关系
        OSI ： Open System Interconnection ：将网络简化，以模块化的方式来设计网络
        OSI七层： 物理层、链路层、网络层、传输层、会话层、表示层、应用层。
    通信协议：是网络通信的基础，IP：Internet Protocol 称为 网际协议，支持网间互联的数据报协议，提供来网间连接的完善功能。TCP：Transmission Control Protocol，传输控制协议，规定一种可靠的数据信息传送服务，可单独使用，功能是互补的，两个协议统称为 TCP/IP 协议
IP地址和端口号
    IP地址用于唯一标识网络中的一个通信实体。 IP地址是数字型，是一额32位整数
    NIC：Internet Network Information Center ： 统一负责全球IP地址的规划和管理，分为 InterNIC、APNIC、RIPE 三个网络信息中心负责IP地址分配。亚太地区通过APNIC，总部设在日本东京大学
    IP地址分为 A、B、C、D、E五类。每个类别的网络标识和主机标识各有规则：
        1. A 类： 10.0.0.0 ～ 10.255.255.255
        2. B 类： 172.16.0.0 ～ 172.31.255.255
        3. C 类： 192.168.0.0 ～ 192.168.255.255
        IP地址是一个通信实体，每个通信实体可有多个通信程序同时提供网络服务，还需提供使用端口
        端口：是一个16位整数，用于将数据交给哪个通信程序处理。端口是应用程序与外界交流的出入口，是一种抽象的软件结构，包括数据结构和 I/O 缓冲区
        端口分为三类：
            1. 公认端口(Well Known Port): 端口号为 0～1023，绑定特定的服务
            2. 注册端口(Registered Port): 端口号为 1024～49151
            3. 动态和/或私有端口(Dynamic and / or Private Port): 端口号为 49152～65535，是应用程序使用的动态端口

网络编程模块
    网络模型大致分为四层，各有对应的网络协议提供支持
        1. 网络接口层： LAN、MAN、WAN
        2. 网络层： ICMP、IGMP、IP、ARP、RARP
        3. 传输层： TCP、UDP
        4. 应用层： SMTP、FTP、DNS、SNMP、NFS、HTTP、TELNET
    网络层协议主要是IP，是互联网协议的基础，ICMP、IGMP、ARP、RARP等协议是IP协议族的子协议，很少直接基于网络层进行应用程序编程
    Python标准库中的网络相关模块
        socket ： 基于传输层TCP、UDP协议进行网络编程的模块
        asyncore ： socket 模块的异步版，支持基于传输层协议的异步通信
        asynchat ： asyncore 的增强版
        cgi ： 基于CGI：Common Gateway Interface，早期动态网站的技术支持
        email ： E-mail 和MIME消息处理模块
        ftplib ： 支持FTP协议的客户端模块
        httplib、http.client ： 支持HTTP协议以及HTTP客户端的模块
        imaplib ： 支持IMAP4协议的客户端模块
        mailbox ： 操作不同格式邮箱的模块
        mailcap ： 支持Mailcap文件
        nntplib ： NTTP协议
        smtplib ： SMTP 协议，发送邮件的客户端模块
        poplib ： 支持POP3协议
        telnetlib ： 支持TELNET 协议
        urllib及其子模块： 支持URL处理的模块
        xmlrpc、xmlrpc.server、xmlrpc.client ：支持XML-RPC协议的服务和客户端模块

urllib.parset 模块：
    URL：Uniform Resource Locator 对象代表统一资源定位器，指向互联网资源的指针。资源可以是文件、目录、或复杂对象的引用。 URL可由协议名、主机、端口和资源路径组成
        protocol://host:port/path
        1. urllib.request:最核心的子模块，包含打开和读取URL的各种函数
        2. urllib.error ： 包含urllib.request 子模块所引发的各种异常
        3. urllib.parset ： 解析URL
        4. urllib.robotparset ： 解析robots.txt 文件
        通过使用urllib模块可打开任意URl所指向的资源，可完整下载远程页面，与re模块结合使用，可提取页面中的各种信息，即网络爬虫的初步原理
            urllib.parse 子模块中用于解析URL地址和查询字符串的函数：
                1. urllib.parse.urlparset(urlstring,scheme=&quot;,allow_fragments=True&quot;):解析URL字符串，返回ParseResult 对象，获取解析出的数据
                2. urllib.parse.urlunparse(parts): 是上一函数的反向操作，解析结果反向拼接URL地址
                3. urllib,parse.parse_qs(qs,keep_blank_values=False,strict_parsing=False,encoding=&apos;utf-8&apos;,errors=&apos;replace&apos;):解析查询字符串(application/x-www-forn--=urlencoded 类型的数据)，以dict形式返回解析结果
                                                                                                        4. urllib.parse.urlencode(query,deseq=False,safe=&apos;&apos;,encoding=None,errors=None,quote_via=quote_plus): 将字典形式或列表形式的请求参数恢复成请求字符串。相当与parse_qs、parse_qsl 的逆函数
                                                                                                                                                                                                5. urllin.parse.urljoin(base,url,allow_fragments=True): 将一个base_url和另一个资源URL连接成代表绝对地址的URl
                from urllib.parse import *
                result = urlparse(&apos;https://www.baidu.com&apos;)
                print(result)
                print(&apos;scheme:&apos;, result.scheme,result[0])
                print(&apos;hostname and port:&apos;, result.netloc,result[1])
                ...
                print(result.geturl())
        ParseResult 各属性与元组索引的对应关系
                scheme        0        返回URL的scheme                scheme参数
                netloc        1        网络位置部分主机名和端口    空字符串
                path        2        资源路径                    空字符串
                params        3        资源路径的附加参数    
                query        4        查询字符串
                fragment    5        Fragment标识符
                username            用户名                        None
                password            密码
                hostname            主机名
                port                端口                        None
        urlunparse ： 把一个 ParseResult 对象或元组恢复成URL字符串
        result = urlunparse((&apos;http&apos;,&apos;www.baidu.com:80&apos;,&apos;index.php&apos;,&apos;text&apos;,&apos;name=hale&apos;,frag))
        print(result)
            parse_qs() parse_qsl() ： l代表list，用于解析查询字符串，返回值不同，
        urljoin 负责将两个URL拼接在一起，返回代表绝对值的URL，可出现三种情况：
            1. URL只是一个相对路径path
            2. 被拼接的URl是一个根路径path
            3. URL是一个绝对的path

urllib.requset 模块读取资源用法
    urllib.request.urlopen(url,data=None)：用于打开url指定的资源，并从中读取数据，根据url的不同，返回值发生变化，如url是一个HTTP地址，该方法返回一个http.client.HTTPResponse对象
    from urllib.request import *
    // 打开URL对应的资源
    result = urlopen(&apos;http://www.baidu.com/index.php&apos;)
    // 按字节读取数据
    data = result.read(333)
    // 将字节数据恢复成字符串
    print(data.decode(&apos;utf-8&apos;))
    // 用context manager 管理打开的URL资源
    with urlopen(&apos;http://www.baidu.com/index.php&apos;) as f:
        // 按字节读取数据
        data = f.read(333)
        // 将字节数据恢复成字符串
        print(data.decode(&apos;utf-8&apos;))

    使用urlopen函数时，可通过data属性向被请求的URL发送数据：
        from urllib.request import * 
        with urlopen(url=&apos;https://www.baidu.com/index.php&apos;,data=&apos;test&apos;.encode(&apos;utf-8&apos;)) as f:
            print(f.read().decode(&apos;utf-8&apos;))
    通过urlopen 函数发送POST请求参数，可通过data 属性来实现：
        import urllib.parse
        params = urllib.parse.urlencode({&apos;name&apos;:&apos;hale&apos;,&apos;password&apos;:&apos;password&apos;})
        params = params.encode(&apos;utf-8&apos;)
        with urlopen(&apos;https://www.baidu.com/index.php&apos;,data=params) as f:
            print(f.read().decode(&apos;utf-8&apos;))
    urllib.request.Request对象的构造函器：
        urllib.request.Request(url,data=None,headers={},origin_req_host=None,unverifiable=False,method=None)
            Request 可通过method指定请求方法，也可通过data指定请求方法，可通过 headers 指定请求头
            from urllib.request import *
            params = &apos;put request&apos;.encode(&apos;utf-8&apos;)
            req = Request(url=&apos;https://www.baidu.com/index.php&apos;,data=params,method=&apos;PUT&apos;) 
            with urlopen(req) as f:
                print(f.status)
                print(f.read().decode(&apos;utf-8&apos;))
    使用Request对象添加请求头
        // 创建Request对象
        req = Request(&apos;https://www.baidu.com/index.php&apos;)
        // 添加请求头
        req.add_header(&apos;Referer&apos;,&apos;https://www.baidu.com&apos;)
        with urlopen(req) as f:
            print(f.status)
            print(f.read().decode(&apos;utf-8&apos;))
        通过Request 的add_header 方法添加一个Referer 请求头，
    实现多线程下载的步骤：
        from urllib.request import * 
        import threading
        class DownUtil:
                def __init__(self,path,target_file,thread_num):
                    self.path = path
                    self.thread_num = thread_rum 
                    self.threads = []
                def download(self):
                    req = Request(url=self.path,method=&apos;GET&apos;)
                    ...


        1. 使用 urlopen 方法打开远程资源
        2. 获取指定的URL对象所指向资源的大小，通过Content-Length响应头获取
        3. 计算每个线程应该下载网络资源的哪个部分，从哪个节点开始，到哪个字节结束
        4. 依次创建并启动多个线程
            from DownUtil import * 
            du = DownUtil(&apos;https://www.baidu.com/&apos; + &apos;from/logo.png&apos;,&apos;a.png&apos;,3)
            du.download()
            def show_process():
                print(&apos;ok : %.2f&apos; % du.get_complete_rate())
                global t
                if du.get_complete_rate() &lt; 1:
                    t = threading.Timer(0.1,show_process)
            t = threading.Timer(0.1,show_process)
            t.start()

http.cookiejar模块：管理cookie
    如使用urllib.request 模块来访问被保护页面，维修与服务器之间的sesion，借助于 cookie 管理器
    使用OpenerDirector 对象来发送请求，步骤：
        1. 创建 http.cookiejar.CookieJar 对象或其子类的对象
        2. 以CookieJar对象为参数，创建urllib.rquest.HTTPCookieProcessor对象，该对象负责调用CookieJar来管理cookie
        3. 以HTTPCookieProcessor对象为参数，调用urllib.reques.build_opener()函数创建OpenerDirector对象
        4. 使用OpenerDirector对象来发送请求，通过HTTPCookieProcessor调用CookieJar管理cookie
            from urllib.request import *
            import http.cookiejar, urllib.parse
            cookie_jar = http.cookiejar.MozillaCookieJar(&apos;a.txt&apos;)
            cookie_processor = HTTPCookieProcessor(cookie_jar)
            opener = build_opener(cookie_processor)
            user_agent = r&apos;Mozialla ...&apos;
            header = {&apos;User-Agent&apos;:user_agent,&apos;Connection&apos;:&apos;keep-alive&apos;}


        [More](http://c.biancheng.net/view/2646.html)

TCP协议、IP协议的关系
    TCP/IP通信协议是可靠的网络协议，在通信的两端各建立一个socket，形成虚拟的网络链路，建立虚拟的网络链路，两端的程序可通过该链路进行通信。 使用socket对象来代表两端的通信端口并通过socket进行网络通信
    IP是Internet 的关键协议，全称：Internet Protocol，即Internet协议，简称：IP协议。IP协议负责将消息从一个主机传送到另一个主机，信息被分割成一个个小包
    TCP：端对端协议，TCP协议让他们之间建立一个虚拟链路，用于发送和接收数据
    TCP协议负责收集数据包，并按照顺序传送，接收端接收到数据包后再将其正确地还原。TCP协议保证数据包传送无误，采用重发机制，即当一个通信实体发送一个消息给另一个通信实体后，需要接收到的另一个通信实体的确认信息，如没有收到确认信息，则会重发信息
    只有把TCP和IP两个协议结合，才能保证Internet在复杂的环境下正常运行。</code></pre><h3 id="socket-建立TCP连接"><a href="#socket-建立TCP连接" class="headerlink" title="socket 建立TCP连接"></a>socket 建立TCP连接</h3><pre><code>在使用socket之前，须建立socket对象，通过该类的构造器来创建socket实例：
    socket.socket(family=AF_INET,type=SOCK_STREAM, proto=0,fileno=None)
        1.family 参数用于指定网络类型，socket.AF_UNIX：UNIX网络、socket.AF_INET 基于IPv4协议的网络 和socket.AF_INET6 基于IPv6协议的网络 这三个变量
        2. type参数用于指定网络的Sock类型，支持SOCK_STREAM默认值，创建基于TCP协议的socket、SOCK_DGRAM 创建基于UDP协议的socket 和SOCK_RAW 创建原始socket。常用 SOCK_STREAM和SOCK_DGRAM
        3. proto参数用于指定协议号， 默认0，可忽略
        socket 对象提供的常用方法：
            1. socket.accept： 作为服务端使用的socket调用该方法接收来自客户端的连接
            2. socket.bind(address)：将该socket绑定到指定address，address可是一个元组，包含IP地址和端口
            3. socket.close ： 关闭连接，回收资源
            4. socket.connect(address): 连接远程服务器
            5. socket.connect_ex(address): 当程序出错时，不抛出异常，返回错误标识符
            6. socket.listen([backlog]): 服务器使用socket调用该方法进行监听
            7. socket.makefile(mode=&apos;r&apos;,buffering=None,*,encoding=None,errors=None,newline=None): 创建和该socket关联的文件对象

            8. socket.recv(bufsize[,flags]): 返回值是(bytes,address)元组
            9. socket.recvmsg(bufsize[,ancbufsize[,flags]]): 不仅接收来自socket的数据，还接收来自socket的辅助数据，返回值是一个长度为4的元组(data.ancdata,msg_flags,address).
            10. socket.recvmg_into(butters[,nbytes[,flags]]):类socket.recvmsg ，将接收的数据放入buffers中
            11. socket.recvfrom_into(buffer[,nbytes[,flags]]):将接收到的数据放入buffer中
            12. socket.recv_into([buffer[,nbytes[,flags]]]): 类recv方法，将接收到的数据放入buffer中
            13. socket.send(bytes[,flags]): 向socket发送数据，该socket必须与远程socket建立连接，基于TCP协议的网络中发送数据
            14. socket.sendto(bytes,addresss)：向socket发送数据，没有与远程socket连接，基于UDP协议发送数据
            15. socket.sendfile(file,offset=0,count=None):将整个文件内容发送出去，直到遇到EOF
            16. socket.shutdown(how):关闭连接，how用于设置关闭方法
    TCP通信的服务器端编程的基本步骤：
        1. 服务器端先创建一个socket对象
        2. 服务器端socket将自己绑定到指定IP地址和端口
        3. 服务器端socket调用listen 方法监听网络
        4. 程序采用循环不断调用socket 的accept方法接收来自客户端的连接
            // 创建socket对象
            s = socket.socket()
            // 将socket 绑定到本机IP地址和端口
            s.bind(&apos;192.168.0.123&apos;,8888)
            // 服务器开始监听客户端的连接
            s.listen()
            while True:
                c,addr = s.accept()
    客户端先创建一个socket对象，将该socket绑定到指定的ip地址和端口号，然后调用connect方法建立与服务器的连接，就可建立一个基于TCP协议的网络连接
        TCP通信的客户端的基本步骤如下：
            1. 客户端先创建一个socket对象
            2. 客户端socket调用connect方法连接到远程服务器
    socket提供大量方法发送和接收数据：
        1. 发送数据：使用send方法，注意：sendto方法用于UDP协议的通信
        2. 接收数据：使用recv_xxx方法
            import socket
            s = socket.socket()
            s.bind((&apos;192.168.1.88&apos;,999))
            s.listen()
            while True:
                c, addr = s.accept()
                print(c)
                print(&apos;connect addrss&apos;, addr)
                c.send(&apos;himessge &apos;.encode(&apos;utf-8&apos;))
                c.close()
    从socket中获取服务器发送的数据
        import socket
        s = socket.socket()
        s.connect((&apos;192.168.1.88&apos;,999))
        print(&apos;--%s--&apos;s.recv(1024).decode(&apos;utf-8&apos;))
        s.close()

多线程实现socket通信
    由于socket的recv方法在成功读取到数据之前。线程会被阻塞，因此，服务器为每个socket单独启动一个线程，每个线程负责与一个客户端进行通信
    服务器端使用list来保存所有的socket
    import socket
    import threading
    socket_list = []
    ss = scoket.socket()
    ss.bind((&apos;192.168.1.14&apos;,999))
    ss.listen()
    def read_from_client(s):
        try:
            return s.recv(2048).decode(&apos;utf-8&apos;)
        except:
            socket_list.remove(s):
    def server_target(s):
        try:
            while True:
                content = read_from_client(s)
                print(content)
                if content is None:
                        break
                for client_s in socket_list:
                    client_s.send(content.encode(&apos;utf-8&apos;))
        except e:
            print(e.strerror)
    while True:
        s,addr = ss.accept()
        socket_list.append(s)
        threading.Thread(target=server_target,args=(s,)).start()

socket shutdown 方法
    以bytes对象作为通信的最小数据单位，服务器端在处理信息时是针对每个bytes进行的，一些协议中，通信数据单位可需多个bytes对象
    shutdown(how)方法，可只关闭socket的输入或输出部分，用以表示数据已经发送完成
    shutdown方法的how参数的参数值：
        SHUT_RD： 关闭socket的输入部分，可通过socket输出数据
        SHUT_WR： 关闭socket的输出部分，通过该socket读取数据
        SHUT_RDWR： 全关闭，该socket既不能读取数据，也不能写入数据
        服务器端先向客户端发送数据发送多条数据，当数据发送完成后，该socket对象调用shutdown方法来关闭输出部分
        import socket
        s = socket.socket()
        s.bind((&apos;192.168.1.88&apos;,999))
        s.listen()
        skt,addr = s.accept()
        skt.send(&apos;server first data&apos;.encode(&apos;utf-8&apos;))
        skt.send(&apos;server second data&apos;.encode(&apos;utf-8&apos;))
        skt.shutdown(socket.SHUT_WR)
        while True:
            line = skt.recv(2048).decode(&apos;utf-8&apos;)
            if line is None or line == &apos;&apos;:
                break
            print(line)
        skt.close()
        s.close()

selectors 模块：实现非阻塞式编程
    selectors 允许以非阻塞方式进行通信，selector相当于一个事件注册中心，只要将socket的所有事件注册给selectors管理，当检测到socket中的特定事件后，程序调用相应的监听方法进行处理
    selectors主要支持两种事件：
        1. selectros.EVENT_READ: 当socket有数据可读时触发该事件，有客户端连接时也触发
        2. selectors.EVENT_WRITE： 当socket将要写数据时触发该事件
    selectors实现非阻塞式编程的步骤如下：
        1. 创建selectors对象
        2. 通过selectors对象为socket的selectors.EVENT_READ或selectors.EVENT_WRITE事件注册监听器函数，当socket有数据读写时，系统负责触发所注册的监听器函数
        3. 在监听器函数中处理socket通信
    使用seletros实现非阻塞通信的服务器端：
        import seletors, socket
        sel = seletors.DefaultSelector()
        def read(skt,mask):
            try:
                data = skt.recv(1024)
                if data:
                    for s in socket_list:
                        s.send(data)
                else:
                    print(&apos;close &apos;,skt)
                    sel.unregisters(skt)
                    skt.close()
                    socket_list.remove(skt)
            except:
                print(&apos;close&apos;)
                sel.unregister(skt)
                skt.close()
                socket_list.remove(skt)
        socket_list = []
        def accept(sock, mask):
            conn,addr = sock.accept()
            socket_list.append(conn)
            conn.setblocking(False)
            sel.register(conn,selectors.EVENT_READ,read)
        sock = socket.socket()
        sock.bind((&apos;192.168.1.1&apos;,999))
        sock.listen()
        sock.setblocking(Flase)

UDP协议及优缺点
    UDP：User Datagram Protocol：用户数据报协议
    UDP 面向非连接的协议，是在正式通信前不必与对象先建立连接，不管对方状态，直接发送数据， UDP协议无法控制，是一种不可靠的协议
    UDP协议适用于一次只传送少量数据、对可靠性要求不高的应用环境
    作用：完成网络数据流和数据报之间的转换在信息的发送端，UDP协议将网络数据流封装为数据报，然后将数据发送出去，在信息的接收端，UDP协议将数据报转换为实际数据内容
    UDP协议和TCP协议的简单对比：
        1. TCP协议：可靠，传输大小无限制，需要建立连接，差错控制开销大
        2. UDP协议：不可靠，差错控制开销小，传输大小限制在64Kb以下，不需要建立连接。

socket发送和接收数据：基于UDP协议
    创建socket，通过type参数指定socket的类型，将参数指定为 SOCK_DGRAM，即创建基于UDP协议的socket
    通过两个方法发送和接收数据
        1. socket.sendto(bytes,address): 将bytes数据发送到address地址
        2. socket.recvfrom(bufsize[,flags]):接收数据，返回socket中的数据和数来源地址
            import socket
            PORT = 999
            DATA_LEN = 4096
            books = (&apos;one&apos;,&apos;tow&apos;,&apos;three&apos;)
            s = socket.socket(type=socket.SOCK_DGRAM)
            s.bind((&apos;192.168.1.1&apos;,PORT))
            for i in range(1000):
                data ,addr = s.recvfrom(DATA_LEN)
                print(data,decode(&apos;utf-8&apos;))
                send_data = books[i % 4].encode(&apos;utf-8&apos;)
                s.sendto(send_data,addr)
            s.close()
    来自服务器端的数据，客户端程序代码：
            import socket
            PORT = 3000
            DATA_LEN = 4096
            DEST_IP = &apos;192.168.1.1&apos;
            s = socket.socket(type=socker.SOCK_DGRAM)
            while True:
                line = input(&apos;&apos;)
                if line is None or line == &apos;exit&apos;:
                    break
                data = line.encode(&apos;utf-8&apos;)
                s.sendto(data,(DEST_IP,PORT))
                data = s.recv(DATA_LEN)
                print(data.decode(&apos;utf-8&apos;))
            s.close()

UDP 多点广播原理及实现
    多点广播，将数据以广播方式发送到多个客户端
    创建socket对象后，将该socket加入指定的多点广播地址中，socket使用setsockopt 方法加入指定组
    创建仅发送数据报的socket对象， 使用默认地址、随机端口即可。 如创建接收数据报的socket对象，将对象绑定到指定端口
多点广播可设置广播信息的TTL(Time-To-Live)，TTL参数用于设置数据报最多可跨过的网络个数：
    1. TTL的值为0：指定数据报应停留在本地主机中
    2. 1: 指定将数据报发送到本地局域网中，此值为默认值
    3. TTL的值为 32 时： 只能将数据报发送到本站点的网络上
    4. 。。64 ： 数据报应被保留在本地区
    5. 128 ： 被保留在本大洲
    6. 255 ： 数据可被发送到所有地方
    socket实现一个基于广播的多人聊天室，只需要一个socket、两个线程，socket用于发送数据、接收数据。主线程负责读取用户的键盘输入内容，并向socekt发送数据，子线程负责从socket中读取数据
        import time,socket,threading, os
        senderIP  = &apos;192.168.1.99&apos;
        senderPORT = 999
        myGroup = &apos;230.0.0.1&apos;
        s = socket.socekt(type=socket.SOCK_DGRAM)
        s.bind ((&apos;0.0.0.0&apos;,senderPORT))
        s.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICASE_TTL,64)
        s.setsockopt(socket.SOL_SOCKET. socket.SO_REUSEADDR, 1)
        status = s.setsockopt(socket.IPPROTO_IP,
                socket.IP_ADD_MEMBERSHIP,
                socket.inet_aton(mygroup))
        ...
        [More](http://c.biancheng.net/view/2663.html)

smtplib 模块： 发送邮件
    底层的处理由smtplib封装，3步发送邮件：
        1. 连接STMP服务器，使用用户名、密码登录服务器
        2. 创建EmailMessage 对象，该对象代表邮件本身
        3. 调用代表与SMTP服务器连接的对象的sendmail方法发送邮件
            import smtplib
            from email.message import EmailMessage
            smtp_server = &apos;smtp.qq.com&apos;
            from_addr = &apos;mr_hale@qq.com&apos;
            password = &apos;password&apos;
            to_addr = &apos;mr_hale@163.com&apos;
            conn = smtplib.SMTP_SSL(smtp_server,465)
            conn.set_debuglevel(1)
            conn.login(from_addr,password)
            msg = EmailMessage()
            msg.set_content(&apos;hi&apos;,&apos;plain&apos;,&apos;utf-8&apos;)
            conn.sendmail(from_addr,[to_add],msg.as_string())
            conn.quit()
        基于SSL的SMTP服务器的默认端口是465
        常见参数：
            1. maintype ：指定附件的主类型，如image代表附件图片
            2. subtype ： 附件的子类型，如指定为png，代表附件是png图片，子类型受主类型的限制
            3. filename ： 指定附件的文件名
            4. cid = img ： 指定附件的资源ID，可通过资源ID引用该资源
                import smtplib, email.utils
                from emial.message import EmailMessage
                smtp_server = &apos;smtp.qq.com&apos;
                from_arrd = &apos;mr_hale@qq.com&apos;
                password = &apos;pass&apos;
                to_addr = &apos;mr_hale@163.com&apos;
                conn = smtplib.SMTP_SSL(smtp_server,465)
                conn.set_debuglevel(1)
                conn.login(from_addr,password)
                msg = EmailMessage()
                first_id ,second_id  = email.util.make_msgid(), email.utils.make_msgid()
                msg.set_connect(&apos;&lt;h1&gt;hi&lt;/hi&gt;&apos;)
                msg[&apos;subject&apos;] = &apos;subject&apos;
                msg[&apos;from&apos;] = &apos;mr_hale@qq.com&apos;
                msg[&apos;to&apos;] = &apos;mr_hale@163.com&apos;
                with open(&apos;file_Path:/xx.png&apos;,&apos;rb&apos;) as f:
                    msg.add_attchment(f.read(),maintype=&apos;image&apos;,
                        subtype=&apos;jpeg&apos;,filename=&apos;xxx.png&apos;,cid=first_id)
                with open(&apos;path_dir/xx.gif&apos;,&apos;rb&apos;) as f:
                    msg.add_attachment(f.read(),maintype=&apos;image&apos;,subtype=&apos;gif&apos;,filename=&apos;xxx.gif&apos;,cid=second_id)
                with open(&apos;xxx.pdf&apos;,&apos;rb&apos;) as f:
                    msg.add_attachment(f.read(),maintype=&apos;application&apos;,subtype=&apos;pdf&apos;,filename=&apos;xxx.pdf&apos;)
                conn.sendmail(from_arrd,[to_addr],msg.as_string())
                conn.quit()

poplib 模块： 收取邮件
    提供poplib.POP3 和poplib.POP3_SSL 两个类，用于连接POP服务器和基于SSL的POP服务器
        POP3 协议属于请求，响应式交互协议，当客户端连接服务器后，客户端向POP服务器发送请求，而POP服务器对客户端生成响应数据，客户端可通过响应数据下载得到邮件内容
    POP3的命令和数据都基于ASCII文本，以 CR 和 LF(/r/n)作为行结束符，响应数据包括一个表示返回状态的符号(+/)和描述信息
    请求和响应的标准格式：
        请求标准格式： 命令[参数] CRLF
        响应标准格式： +OK /[-ERR] description CRLF
    POP3协议客户端的命令和服务器端对象的响应数据：
        1. user name ： 向POP服务器发送登录的用户名
        2. pass string ： 向POP服务器发送登录的密码
        3. quit： 退出POP服务器
        4. stat ：统计邮件服务器状态，包括邮件数和总大小
        5. list[msg_no] : 列出全部邮件或指定邮件，返回邮件编号和大小
        6. retr msg_no : 获取指定邮件的内容，编号从1开始
        7. del msg_no ： 删除指定邮件
        8. noop ： 空操作，仅用于于服务器保持连接
        9. rset ： 用于撤销dele命令
    接收邮件的步骤：
        1. 使用poplib.POP3 或 poplib.POP3_SSL 按 POP3 协议从服务器下载邮件
        2. 使用 email.parser.Parset 或 email.parser.BytesParser解析邮件内容，得到EmailMessage对象，从EmailMessage 对象中读取邮件内容
            import poplib,  os.path , mimetypes
            from email.parser import BytesParser, Parser
            from email.policy import default
            emial = &apos;mr_hale@163.com&apos;
            password = &apos;password&apos;
            pop3_server = &apos;pop.qq.com&apos;
            conn = poplib.POP3_SSL(pop3_server, 995)
            conn.set_debuglevel(1)
            print(conn.getwelcome().decode(&apos;utf-8&apos;))
            conn.user(email)
            conn.pass_(password)
            message_num, total_size = conn.stat()
            print(&apos;email num %s total %s&apos; % (message_num,total_size))
            resp, mails, octets = conn.list()
            print(resp, mails)
            resp, data, octets = conn.retr(len(mails))
            msg_data = b&apos;\r\n&apos;.join(data)
            mg = BytesParser(policy=default).parsebytes(msg_data)
            [More](http://c.biancheng.net/view/2667.html)

            程序在创建BytesParser 解析字节串格式的邮件数据 或 Parser 解析字符串格式的邮件数据时，必须指定 policy=default， 否则 BytesParser或Parser 解析邮件数据得到的就是过时的Message对象</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Author : Hale Lv</span><br><span class="line">@Created Time : 2019-08-27 20:41:18</span><br><span class="line">@Description :</span><br></pre></td></tr></table></figure>

<h2 id="pydoc-模块：查看、生成帮助文档"><a href="#pydoc-模块：查看、生成帮助文档" class="headerlink" title="pydoc 模块：查看、生成帮助文档"></a>pydoc 模块：查看、生成帮助文档</h2><pre><code>在控制器中使用help 函数和 __doc__ 属性查看函数、类、方法的文档
借助自带的pydoc模块，方便查看、生成帮助文档，是HTML格式
创建名为 HI_doc.py 的文件
    MY_NAME = &apos;Python DOC&apos;
    def say_hi(name):
        &apos;&apos;&apos;
            定义一个say hi的函数
            返回对指定用户打招呼的字符串
        &apos;&apos;&apos;
        print(&apos;run hi func&apos;)
        return name + &apos;welcome !&apos;
    def run(load):
        &apos;&apos;&apos;
            走路ing
        &apos;&apos;&apos;
        print(&apos;run run func&apos;)
        return &apos;run &apos; + load
    class User:
        NAME = &apos;Hale&apos;
        &apos;&apos;&apos;
            定义一个用户的类
            命名名字为Hale
        &apos;&apos;&apos;
        def __init__(self,name,age):
            &apos;&apos;&apos;
                name 为初始化的name值
                age 初始化该用户的age
            &apos;&apos;&apos;
            self.name = name
            self.age = age
        def eat(food):
            &apos;&apos;&apos;
                定义用户在吃东西的方法
                food 代表正在吃的东西
            &apos;&apos;&apos;
            print(&apos;%s eat %s&apos; % (self.user, food))
        定义了一个HI_doc.py 源文件，即定义了一个HI_doc 模块， 该模块为函数、类、方法都提供文档

    pydoc在控制台中查看文档
        使用pydoc模块在控制台查看HTML文档
            python -m pydoc 模块名
                -m ： 选项，表示运行指定模块，运行pydoc模块，模块名参数代表程序要查看的模块
                python -m pydoc HI_doc 
            pydoc 模块中的全部内容：
                CLASSES 部分： 列出该模块所包含的全部类
                FUINCTIONS ： 列出包含的全部函数
                DATA ： 全部成员变量
                FILE： 源文件

    pydoc 生成HTML文档
        python -m pydoc -w 模块名
            -m ：代表模块0
            -w 选项： 代表 write，表明输出HTML文档
    pydoc 为指定目录生成HTML文档，为指定目录下的所有模块生成HTML文档：
        python -m pydoc -w 目录名

启动本地服务器查看文档信息
    启动本地服务器产看文档信息的两个命令
        1. python -m pydoc -p 端口号
    指定端口启动HTTP服务器，通过浏览器查看Python的所有模块的文档信息：
        2. python -m pydoc -b

    第一部分：显示python内置的核心模块
    第二部分：显示当前目录下的所有模块
    第三部分：显示当前目录下的所有模块，

pydoc 查找模块
    python -m pydoc -k 被搜索的模块的部分内容</code></pre><h3 id="doctest模块：-文档测试"><a href="#doctest模块：-文档测试" class="headerlink" title="doctest模块： 文档测试"></a>doctest模块： 文档测试</h3><pre><code>文档测试工具可以提取说明文档中的测试用例，其中 &quot;&gt;&gt;&gt;&quot; 之后的内容表示测试用例，下一行代表测试用例的输出结果
def squre(x):
    &apos;&apos;&apos;
    计算平方的函数
    eg :
    &gt;&gt;&gt; squre(2)
    4
    &gt;&gt;&gt; squre(4)
    16 
    &apos;&apos;&apos;
    return x * 2 # 故意写错的

class User:
    &apos;&apos;&apos;
    定义一个代表用户的类，包括属性：
    name - 代表名字
    age - 代表年龄
    例如：
    &gt;&gt;&gt; u = User(&apos;hale&apos;,23)
    &gt;&gt;&gt; u.name
    &apos;hale&apos;
    &gt;&gt;&gt; u.age
    23ß
    &apos;&apos;&apos;

if __name__ == &apos;__main__&apos;:
    import doctest
    doctest.testmdo()

测试结果包含的内容：
    1. 第一部分：显示在哪个源文件的哪一行
    2. 第二部分：Failed example，显示是哪个测试用例出错了
    3. 第三部分：Expected 显示程序期望的输出结果，即在&quot;&gt;&gt;&gt;命令&quot;的下一行给出的运行结果
    4. 第四部分：Got ，显示程序实际运行产生的输出结果，只有输出结果与期望结果一致，才表明测试用例通过
可见：为文档注释提供doctest模块，程序只要导入该模块，并调用模块的testmod 函数即可。 testmod 自动提取模块的说明文档的测试用例，并执行这些测试用例，最终生成测试报告。</code></pre><h3 id="unittest-PyUnit-单元测试框架"><a href="#unittest-PyUnit-单元测试框架" class="headerlink" title="unittest(PyUnit)单元测试框架"></a>unittest(PyUnit)单元测试框架</h3><pre><code>    PyUnit unittest 是单元测试框架，编写和运行可重复的测试。 PyUnit 是xUnit体系的一个成员，xUnix是众多测试框架的总称。主要用于进行白盒测试和回归测试
    好处： 
        可以使测试代码与产品代码分离
        针对某一个类的测试代码只需要进行较少的改动，便于另一个类的测试
        开源，方便对PyUnit的扩展

    特征：
        1. 使用断言方法判断期望值和实际值的差异，返回bool值
        2. 测试驱动设备可使用共同的初始化变量或实例
        3. 测试包结构便于组织和继承运行

    PyUnit(unittest)用法：
        通过给定参数执行函数，判断函数的实际输出结果和期望的输出结果是否一致，测试用例提供执行函数和方法， 获取他们的执行结果，然后使用断言方法来判断
        开发方式称为：测试驱动开发，强调先编写测试用例，然后在编写函数和方法，例：开发A功能的fun_a函数，采用测试驱动开发的步骤：
        1. 为fun_a 函数编写测试用例，使用大量不同的参数组合来执行fun_a函数，并断言该函数的执行结果与业务期望的执行结果匹配
        2. 编写、修改fun_a 函数
        3. 运行fun_a函数的测试用例，如不能完全通过，则重复第2步和第3步，直到fun_a的所有测试用例全部通过
            开发一个简单的 fk_math.py 程序，包含两个函数，分别用于计算一元一次方程的解和二元一次方程的解
                def one_equation(a,b):
                    &apos;&apos;&apos;
                    一元一次方程的解
                    返回方程解
                    &apos;&apos;&apos;
                    if a == 0:
                        raise ValueError(&apos;参数错误&apos;)
                    else:
                        return b / a
                def two_equation(a,b,c):
                    &apos;&apos;&apos;
                    一元二次方程 

                    &apos;&apos;&apos;
                    if a == 0:
                        raise ValueError(&quot;参数错误&quot;)
                    elif b * b - 4 * a * c &lt; 0:
                        raise ValueError(&apos;方程在有理数范围内无解&apos;)
                    elif b * b - 4 * a * c == 0:
                        return -b / (2 * a)
                    else:
                        r1 = (-b + (b * b - 4 * a * c) ** 0.5 ) / 2 /a 
                        r2 = (-b + (b * b - 4 * a * c) ** 0.5 ) / 2 /a 
                        return r1, r2

                unittest要求单元测试类必须继承 unittest.TestCase，该类中的测试方法需要满足：
                    1. 测试方法应该没有返回值
                    2. 测试方法不应该有任何参数
                    3. 测试方法应以test开头
                        import unittest
                        from fk_math import * 

                        class TestFkMath(unittest.TestCase):
                            def test_one_equation(self):
                                self.assertEqual(one_equation(5,9), -1.8)

                                with self.assertRaises(ValueError):
                                    one_euqation(0,9)
                            def test_two_equation(self):
                                r1,r2 = two_equation(1,-3,2)
                                self.assertCountEqual((r1,r2),(1.0,2.0),&apos;求解出错&apos;)
                                ...
                                with self.assertRaises(ValueError):
                                    two_equation(0,9,3)
                                    ...






            unittest.TestCase内置大量assertXxx方法执行断言：
                assertEqual(a,b)            a == b
                assertNotEqual(a,b)            a != b
                assertTrue(x)                bool(x) is True
                assertFalse(x)                bool(x) is False
                assertIsNot(a,b)            a is not b
                assertIs(a,b)                a is b
                assertIsNone(x)                x is None
                assertIsNotNone(x)            x is not None
                [More](http://c.biancheng.net/view/2679.html)
            TestCase 包含断言方法
                assertAlmostEqual(a,b)        round(a-b,7) == 0
                assertNotAlmostEqual(a,b)    round(a-b,7) != 0
                assertGreater(a,b)            a &gt; b 
            TestCase 包含针对特定类型的断言方法
                assertMultiLineEqual(a,b)    字符串string
                assertSequenceEqual(a,b)    序列sequence
                assertListEqual(a,b)        列表list
                assertTupleEqual(a,b)        元组tuple
                assertSetEqual(a,b)            集合set 或 frozenset
                assertDictEqual(a,b)        字典dict

    运行测试
        两种方式：
            1. 通过代码调用测试用例，通过调用unittest.main() 运行当前源文件中所有测试用例        
                if __name__ == &apos;__main__&apos;:
                    unittest.main()
            2. 使用unittest 模块运行测试用例，语法：
                python -m unittest 测试文件
        测试结果：
            1. . ：代表测试通过
            2. F ： 代表失败，F ： failure
            3. E ： 出错    E ： error
            4. s ： 跳过该测试    s ： skip

TestSuite 测试包及用法
    可组织多个测试用例， 还可嵌套测试包，使用测试运行器 TestRunner 来运行该测试包所包含的所有测试用例
    // 开发一个程序 hello.py
    def say_hello():
        return &apos;hi&apos;
    def add(a,b):
        return a + b
    // 为上面程序提供测试类 test_hello.py
        import unittest
        from hello improt *
        class TestHello(unittest.TestCase):
            def test_say_hell(self):
                self.assertEqual(say_hello(),&apos;Hello world.&apos;)
            def test_add(self):
                self.assertEqual(add(2,1),5)
                self.assertEqual(add(3,6),7)
    将 test_fk_math 和 test_hello.py 放在同一目录，可通过TestSuite将他们组织在一起，然后使用TestRunner来运行该测试包
        import unittest
        from test_fk_math import TestFkMath
        test_cases = (TestHello, TestFkMath)
        def whole_suite():
            // 创建测试加载器
            loader = unittest.TestLoader()
            // 创建测试包
            suite = unittest.TestSuit()
            // 遍历所有测试类
            for test_class in test_cases:
            // 从测试类中加载测试用例
                tests = loaders.loadTestsFromTestCase(test_class)
            // 将测试用例添加到测试包
                suite.addTests(tests)
            return suite
        if __name__ == &apos;__main__&apos;:
            // 创建测试运行器
            runner = unittest.TexTestRunner(verbosity=2)
            runner.run(whole_suite())
    把测试报告输出到该类文件对象中
        修改__main__ 部分代码：
            if __name__ == &apos;__main__&apos;:
                with open(&apos;fk_test_report.txt&apos;,&apos;a&apos;) as f:
                    runner = unittest.TextTextRunner(verbosity=2,stream=f)
                    runner.run(whole_suite())

单元测试setUp 和 tearDown 用法
    测试用例类：TestCase的子类、测试包TestSuit、测试运行器TestRunner、测试固件TestFixture的概念：
        1. 测试用例类：是单个的测试单元，负责检查特定输入和对应的输出是否匹配，
        2. 测试包： 组合多个测试用例， 可嵌套测试包
        3. 测试运行器：负责组织、运行测试用例，向用户呈现测试结果
        4. 测试固件： 代表执行一个或多个测试用例所需的准备工作，及相关联的准备操作，包括：创建临时数据库、创建目录、开启服务器进程等。
        unittest.TestCase包含setUp 和 tearDown 两个方法，其实setUp方法用于初始化测试固件， tearDown 方法用于销毁测试固件。运行每个测试用例以 test_ 开头的方法之前自动执行setUp方法来初始化测试固件，并在每个测试用例结束后自动执行tearDown方法销毁测试固件
        import unittest
        from hello import * 
        class TestHello(unittest.TestCase):
            def test_say_hello(unittest.TestCase):
                self.assertEqual(say_hello(),&apos;Hello world&apos;)
            def test_add(self):
                self.assertEqual(add(3,5),7)
            def setUp(self):
                print(&apos;---- setUp model--- &apos;)
            def tearDown(self):
                print(&apos;----tearDown-----&apos;)
        python -m unittest -v fixture_test.py

unittest跳过测试用例
    unittest 自动测试每一个测试用例 以test开头的方法，如跳过某个测试用例，通过两种方式：
        1. 使用 skipXxx 装饰器 跳过测试用例，unittest 提供3个装饰器，分别是 @unittest.skip(reason) , @unittest.skipif(condition,reason), @unittest.skipUnless(condition,reason),其中 skip 代表无条件跳过，skiplf 代表当condition为True时跳过，skipUnless 代表当condition为False时跳过
        2. 使用TestCase 的skipTest 方法来跳过测试用例
            import unittest
            from hello import * 
            class TestHello(uniitest.TestCase):
                def test_say_hello(self):
                    self.assertEqual(say_hello(),&apos;hi hello&apos;)
                @unittest.skip(say_hello(),&apos;hello world&apos;)
                def test_add(self):
                    self.assertEqual(add(3,4),7)
                    ...
            @unittest.skip装饰器跳过了test_add 测试方法
            python -m unittest skip_test.py
            测试结果中，s 代表跳过第一个测试用例，. 代表第二个测试用例通过
        可使用TestCase 的skipTest 方法跳过测试用例：
            import unittest
            from hello import * 
            class TestHello(unittest.TestCase):
                def test_say_hello(self):
                    self.assertEqual(say_hello(),&apos;hi&apos;)
                def test_add(self):
                    self.skipTest(add(3,4),5)
                    ...
            python -m unittest -v skip_test.py
                -v : 生成更详细的测试报告</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Author : Hale Lv</span><br><span class="line">@Created Time : 2019-08-28 12:01:48</span><br><span class="line">@Description :</span><br></pre></td></tr></table></figure>

<h2 id="打包和发布-zipapp-和-PyInstaller"><a href="#打包和发布-zipapp-和-PyInstaller" class="headerlink" title="打包和发布 zipapp 和 PyInstaller"></a>打包和发布 zipapp 和 PyInstaller</h2><pre><code>用于将Python 应用打包为一个 .pyz 文件，无论多少个源文件和依赖包，使用zipapp可将他们大包为一个 .pyz 文件。
zipapp 模块： 将一个 python模块或多个模块打包为一个Python应用，可发布为Windows 的可执行程序

生成可执行的Python档案包
    zipapp 是一个可直接运行的模块，将单个python文件或整个目录下的所有文件打包为可执行的档案包
        python -m zipapp source [options]
            source ：代表要打包的Python源程序或目录，参数可是单个的pyhton文件，也可是文件夹。        
            option 选项：
                -o &lt;output&gt;, --output=&lt;output&gt;: 指定输出档案包的文件名，如不指定该选项，生成的档案包的文件名默认是source 参数值，并加上 .pyz后缀
                -p &lt;interpreter&gt;, --python=&lt;interpreter&gt; : 指定Python解释器，
                -m &lt;mainfn&gt;, --main=&lt;mainfn&gt; : 指定Python程序的入口函数，该选项应为： pkg.mod:fn 形式，pkg.mod 是一个档案包中的包或模块，fn是指定模块中的函数，如不指定，默认从模块中的 __main__.py 文件开始执行
                -c ， --compress ： 指定是否对档案包进行压缩来减少文件的大小，默认不压缩
                --info ： 用于诊断时显示档案包中的解释器
                -h ， --help ： 该选项用于显示 zipapp 模块中的帮助信息

    建立一个app 子目录， 包办多个python程序，如：say.py
            def say(name):
                return &apos;hi&apos; + name
        在该目录下开发一个app.py 程序来使用 say 模块：
            from say import *
            def main():
                    print(&apos;start run&apos;)
                    print(say(&apos;hale&apos;))
        在命令行中进入该目录(app目录的父目录)：
            python -m zipapp app -o first.pyz -m &quot;app:main&quot;
                指定将当前目录下的app子目下的所有Py源文件打包为一个档案包，-o 选项指定生成档案包的文件名为 first.pyz； -m ： 指定使用app.py 模块中的main函数作为程序入口
            python -m zipapp app -m &quot;app:main&quot;
                没有-o， 使用默认的输出文件名，生成一个 app.pyz文件</code></pre><h3 id="zipapp-创建独立应用"><a href="#zipapp-创建独立应用" class="headerlink" title="zipapp 创建独立应用"></a>zipapp 创建独立应用</h3><pre><code>如需使用第三方模块和包
创建独立启动的应用 自带依赖模块和包，执行2个步骤：
    1. 将应用依赖的模块和包下载到应用目录中
    2. 使用zipapp将应用和依赖模块一起打包为档案包
    在app目录中创建一个dbapp子目录，在dbapp中创建一个__main__.py 文件作为程序入口，打包档案包时不需指定入口
        from exec_select import *
        query_db()
    exec_select.py 文件：
        import mysql.connector
        def query_db():
            conn = conn.connector.connect(user=&apos;user&apos;,&apos;passwor&apos;=&apos;pass&apos;,host=&apos;localhost&apos;,port=&apos;3306&apos;,database=&apos;dbname&apos;,use_unicode=True)
        c = conn.cursor()
        c.execute(&apos;select * from user_tb where user_id &gt; %s&apos;,(2,))
        for col in (c.description):
            print(col[0],end=&apos;\t&apos;)
        print(&apos;\n-----&apos;)
        for row in c:
            print(row)
            print(row[1] + &apos;--&gt;&apos; + row[2])
        c.close()
        conn.close()
    1.    将dbapp子目录下的应用打包为独立应用：
        python -m pip install -r requirements.txt --target dbapp
            使用 pip 安装模块，python -m pip install 表示安装模块， -target 指定要安装到指定目录下， 此处安装到dbapp子目录下。-r 指定安装哪些模块，使用requirements.txt 列出要安装的模块和包 -r 选项支持两个值：
                1. 直接指定要安装的模块或包
                2. 使用清单文件指定要安装的模块和包
        如：pip 模块提示找不到 requirements.txt 文件，需在当前目录下添加一个requirements.txt 文件，在该文件中增加：  mysql-connector-python
            如模块需要依赖多个模块，则在requirements.txt 文件中定义多行，每行定义一个模块。
    2.    如pip在dbapp子目录生成 .dist-info 目录，删除即可
    3.  使用zipap 模块执行打包操作，如dbapp子目录下包含了 __main__.py 文件，则不需指定 -m 选项 
        python -m zipapp dbapp
    卸载在python目录下安装的mysql-connector-python 模块：
        pip uninstall mysql-connector-python</code></pre><h3 id="PyInstaller-安装和使用"><a href="#PyInstaller-安装和使用" class="headerlink" title="PyInstaller 安装和使用"></a>PyInstaller 安装和使用</h3><pre><code>    默认不包含PyInstaller 模块， 需自行安装
        pip install pyinstaller

PyInstaller生成可执行程序
    pyinstaller 选项 Python 源文件
        单文件、多文件，使用pyinstaller 编译作为程序入口的python 程序即可
        先创建一个app目录，在该目录下创建一个 app.py 文件
            from say_hello import *
            def main():
                print(&apos;start run&apos;)
                print(say_hello(&apos;hale&apos;))
            if __name__ == &apos;__main__&apos;:
                main()
            进入此app目录，执行：
                pyinstaller -F app.py 
                    执行完毕，会生成 dist目录、app.exe 文件
                    -F 选项： 指定生成单独的EXE 文件， —D ：指定生成一个目录作为程序
                pyinstaller -D app.py
                    执行完毕，生成dist目录， 包含大量.dll 文件和 .pyz 文件
        PyInstaller 支持的常用选项
            -F， -onefile ：                产生单个的可执行文件
            -D， --onedir ：                产生一个目录(包含多个文件)作为可执行程序
            -a， --ascii  ：                不包含Unicode 字符集支持
            -d， --debug  ：                产生debug 版本的可执行文件
            -w， --windowed，--noconsolc ： 指定程序运行时不显示命令行窗口(仅对windwos有效)
            -c， --nowindowed，-console ：    指定命令行窗口运行程序
            -o DIR， --out=DIR ：            指定spec文件的生成目录，如没指定，默认使用当前目录来生成spec文件
            -p DIR，--path=NAME    ：            设置python导入模块的路径，可用路径分隔符(win:&apos;,&apos;,unix:&apos;:&apos;来分割多个路径)
            -n NAME，--name=NAME ：            指定项目的名字 如省略，第一个脚本的主文件名将作为spec的名字
            -h ：        查看选项的详细信息

    创建带图形的用户界面，可访问数据库的应用
        在app所在目录创建一个dbapp目录，并在该目录下创建python程序，exec_select.py 负责查询数据， main.py 负责创建图形用户界面来显示查询结果
            exec_select.py 代码：
                import mysql.connector
                def query_db():
                    conn = mysql.connector.connect(user=&apos;root&apos;,password=&apos;pass&apos;,host=&apos;localhost&apos;,port=&apos;3306&apos;,database=&apos;dbname&apos;,use_unicode=True)
                    c = conn.cursor()
                    c.execute(&apos;select * from user_tb where user_id &gt; %s&apos;,(2,))
                    description = c.description
                    rows = c.fetchall()
                    c.close()
                    conn.close()
                    return description, rows
            main.py 文件代码：
                from exec_select import *
                from tkinkter import * 
                def main():
                    description,rows = query_db()
                    win = Tk()
                    win.title(&apos;query db&apos;)
                    for i, col in enumerate(description):
                        lb = Button(win,text=col[0],padx=50,pady=0)
                        lb.grid(row=0,colunm=i)
                    for i, row  in enumerate(rows):
                        for j in range(len(row)):
                            en = Label(win, text=row[j])
                            en.grid(row=i+1,column=j)
                    win.mainloop()
                if __name__ == &apos;__main__&apos;:
                   main()
            Pyinstaller -F -w main.py</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Author : Hale Lv</span><br><span class="line">@Created Time : 2019-08-28 15:32:33</span><br><span class="line">@Description :</span><br></pre></td></tr></table></figure>

<h2 id="数据可视化-Matplotlib-Pygal"><a href="#数据可视化-Matplotlib-Pygal" class="headerlink" title="数据可视化 Matplotlib, Pygal"></a>数据可视化 Matplotlib, Pygal</h2><h3 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h3><pre><code>是Python 2D 绘图库，符号格式的数据，通过Matplotlib 方便制作折线图、柱状图、散点图等各种高质量的数据图
安装：
    1. pip install matplotlib
    2. python -m pip install matplotlib
python -m pydoc -p 8899        //    文档

Matplotlib plot 函数： 生成折线图
    给出对应的 x轴、y轴数据， 调用pyplot子模块下的plot函数即可生成简单的折线图
    如：生成2013年～2019年的销售数据
        import matplotlib.pyplot as plt
        x_data = [&apos;2013&apos;,&apos;2014&apos;,&apos;2015&apos;,&apos;2016&apos;,&apos;2017&apos;,&apos;2018&apos;,&apos;2019&apos;]
        y_data = [123000,1232131,2131421,23532,453,645363,54654645]
        plt.plot(x_data,y_data)
        plt.show()
    plot函数支持创建具有单条折线的折线图，也支持多条折线复式折线图，调用plot函数传入多个分别x轴和y轴数据的list列表即可。
        import matplotlib.pyplot as plt 
        x_data = [&apos;2018&apos;,&apos;2019&apos;]
        y_data = [5555555,666666]
        y_data1 = [777777,8888888]
        plt.plot(x_data,y_data,y_data1)
        plt.show()
    plot函数可传参数指定折线的样子，如 线宽、颜色、样式等，例：
        import matplotlib.pyplot as plt
        x_data = [&apos;2016&apos;,&apos;2017&apos;,&apos;2018&apos;,&apos;2019&apos;]
        y_data = [100000,200000,300000,400000,500000]
        y_data1 = [900000,800000,70000,40000,32222]
        plt.plot(x_data,y_data,color=&apos;red&apos;,linewidth=2.0, linestyle=&apos;--&apos;)
        plt.plot(x_data,y_data1,color=&apos;blue&apos;,linewidth=3.0,linestyle=&apos;-.&apos;)
        plt.show()
            color: 颜色，  linewidth ： 线宽 、 linestyle ： 折线样式
            linestyle 折线样式，字符串参数值：
                -  ： 代表实线，默认值
                -- ： 代表虚线
                .  ： 代表点线
                -. :  代表短线、点相同的虚线    

Matplotlib legend  : 为每条折线添加图例
    对于复式折线图，应为每条折线添加图例，通过legend 函数实现，可传入两个list参数，第一个list参数 handles参数，用于引用折线图赏的每条折线，第二个list参数labels 代表为每条折线所添加的图形
    为两条折线添加图例：
        import matplotlib.plot as plt 
        x_data = [&apos;2018&apos;,&apos;2019&apos;]
        y_data = [200000,3000000]
        y_data1 = [30000,500000]
        ln1 = plt.plot(x_data,y_data,color=&apos;red&apos;,linewidth=2.0, linestyle=&apos;--&apos;)
        ln2 = plt.plot(x_data,y_data1,color=&apos;gary&apos;,linewidth=3.0,linestyle=&apos;-.&apos;)
        plt.legend(handler=[ln2,ln1],labels=[&apos;Python&apos;,&apos;PHP&apos;],loc=&apos;lower right&apos;)
        plt.show()
loc参数指定图例的添加位置，参数支持的参数值：
    &apos;base&apos;:     自动选择最佳位置
    &apos;upper right&apos;: 将图例放在右上角
    &apos;upper left&apos;:    左上角
    &apos;lower left&apos;:    左下角
    &apos;lower right&apos;:    右下角
    &apos;right&apos;:    右边
    &apos;center left&apos;:    左边剧中    
    &apos;center right&apos;:    右边剧中
    &apos;lower center&apos;:    底部剧中
    &apos;upper center&apos;: 顶部剧中
    &apos;center&apos;:    将图例放在中心
    在程序中修改 Matplotlib 的默认字体，步骤：
        1. 使用 matplotlib.fnot_manager 子模块下的FontProperties 类加载中文字体
        2. 在调用legend 函数时通过 prop 属性指定中文字体
        improt matplotlin.font_manager as fm
        my_font = fm.FontProperties(fname=&apos;/usr/font/powerline.ttf&apos;)
        plt.legend(handles=[ln2,ln1], labels=[&apos;你好&apos;,&apos;Python基础&apos;],loc=&apos;lower right&apos;,prop=my_font)
        使用 legend 函数时可不指定handles参数，只传入labels参数
            plt.legend(labels=[&apos;Python 中文&apos;,&apos;PHP基础&apos;],loc=&apos;center&apos;,proc=my_font)
        Matplotlib 可在调用 plot 函数时为每条折线分别传入label参数，
        import matplotlib.pyplot as plt
        x = [&apos;2018&apos;,&apos;2019&apos;]
        y1 = [1233,312321]
        y2 = [123213214,32131]
        plt.plot(x,y1,color=&apos;red&apos;,linewidth=2.0,linestyle=&apos;-.&apos;,label=&apos;Python你好&apos;)
        plt.plot(x,y2,color=&apos;blue&apos;,linewidth=3.0,linestyle=&apos;--&apos;,lebale=&apos;PHP再见&apos;)
        import matplotlib.font_manager as fm
        my_font = fm.FontProperties(fname=&apos;font dir&apos;)
        plt.legend(loc=&apos;best&apos;)
        plt.show()</code></pre><h3 id="Matplotlib-time-xlabel-ylabel-xticks-yticks-设置坐标轴"><a href="#Matplotlib-time-xlabel-ylabel-xticks-yticks-设置坐标轴" class="headerlink" title="Matplotlib time, xlabel, ylabel , xticks, yticks : 设置坐标轴"></a>Matplotlib time, xlabel, ylabel , xticks, yticks : 设置坐标轴</h3><pre><code>调用 xlabel 、 ylabel 函数设置x轴、y轴，通过title 函数设置整个数据图的标题，调用xticks 、yticks 改变x轴、y轴的刻度值
    为数据图添加名称、标题、坐标轴刻度值
    import matplotlib.pyplot as plt
    x = [&apos;2018&apos;,&apos;2019&apos;]
    y1 = [111111,2222]
    y2 = [1233213,3213213213]
    plt.plot(x,y1,color=&apos;red&apos;,linewidth=2.0,linestyle=&apos;--&apos;,label=&apos;Hi PYthon你好&apos;)
    plt.plot(x,y2,color=&apos;blue&apos;,linewidth=3.0,linestyle=&apos;-.&apos;,label=&apos;PHP 再见&apos;)
    import matplotlib.font_manager as fm
    font = fm.FontProperties(fname=&apos;font dir .ttf&apos;)
    plt.legend(loc=&apos;best&apos;)
    plt.xlabel(&apos;年份&apos;)
    plt.ylabel(&apos;教程销量&apos;)
    plt.title(&apos;Python 开发指南&apos;)
    plt.yticks([1000,100000,1000000],[r&apos;挺好&apos;,r&apos;优秀&apos;,r&apos;火爆&apos;)
    plt.show()
    如要对x轴、y轴进行更细致的控制，可调用 gca 函数来获取坐标轴信息对象，对坐标轴进行控制
        对坐标轴的详细控制：
            import matplotlib.pyplot as plt
            x = ...
            plt.yticks([1000,100000,10000],[r&apos;justsoso&apos;,r&apos;good&apos;,r&apos;great&apos;])
            ax = plt.gca()
            ax,xaxis.set_ticks_position(&apos;bottom&apos;)
            ax.yaxis.set_ticks_position(&apos;left&apos;)
            ax.spines[&apos;right&apos;].set_color(&apos;none&apos;)
            ax.spines[&apos;top&apos;].set_color(&apos;none&apos;)
            ax.spines[&apos;buttom&apos;].set_position((&apos;data&apos;,8000))
            plt.show()

    Matplotlin subplot : 创建子图
        subplot(nrows,ncols,index,**kwargs) : nrows: 指定将数据区域分为多少行，ncols ：将数据图区域分为多少列，index 指定获取第几个区域。
        subplot 支持直接传入一个三位数的参数， 第一位数为 nrows 参数，第二位数为 ncols，第三位数为 index 参数
            import matplotlib.pyplot as plt
            import numpy as np
            plt.figure()
            [More](http://c.biancheng.net/view/2711.html)    

    Matplotlib pie : 绘制饼图
        [More](http://c.biancheng.net/view/2713.html)

    Matplotlib 绘制柱状图 bar 、barh 函数
        [More](http://c.biancheng.net/view/2716.html)

    Matplotlib scatter : 绘制散点图
        [More](http://c.biancheng.net/view/2718.html)    

    Matplotlib contour 、 contourf ： 绘制等高线
        [More](http://c.biancheng.net/view/2718.html)





    plot_surface(Axes3D): 绘制3D图形
            X、Y数据决定坐标点， Z轴数据决定X、Y坐标点对应的高度
            [More](http://c.biancheng.net/view/2720.html)

Pygal 模块安装和使用
    数据图库，以面向对象的方式创建各种数据图
    Pygal 模块安装：
        1. pip install pygal
        2. python -m pip install pygal
    查看文档：
        python -m pydoc -p 9990

    Pygal 数据图入门
        生成数据图的步骤：
            1. 创建Pygal 数据图对象，不同的数据图提供不同的类，如：柱状图使用pygal.Bar 类， 饼状图：pygal.Pie 类， 折线图：pygal.Line类，等等
            2. 调用数据图对象的add 方法添加数据
            3. 调用Config 对象的属性配置数据图
            4. 调用数据图对象的render_to_xxx 方法将数据图渲染到指定的输出节点

            import matplotlib.pyplot as plt
            import numpy as np
            from mpl_toolkits.mplot3d import Axes3D
            fig = plt.figure(figsize=(12, 8))
            ax = Axes3D(fig)
            delta = 0.125
            // 生成代表X轴数据的列表
            x = np.arange(-3.0, 3.0, delta)
            生成代表Y轴数据的列表
            y = np.arange(-2.0, 2.0, delta)
            对x、y数据执行网格化
            X, Y = np.meshgrid(x, y)
            Z1 = np.exp(-X**2 - Y**2)
            Z2 = np.exp(-(X - 1)**2 - (Y - 1)**2)
            计算Z轴数据（高度数据）
            Z = (Z1 - Z2) * 2
            绘制3D图形
            ax.plot_surface(X, Y, Z,
                        rstride=1,  # rstride（row）指定行的跨度
                            cstride=1,  # cstride(column)指定列的跨度
                                cmap=plt.get_cmap(&apos;rainbow&apos;))  # 设置颜色映射
            设置Z轴范围
            ax.set_zlim(-2, 2)
            设置标题
            plt.title(&quot;3D图&quot;)
            plt.show()&quot;&quot;)&apos;&apos;))

Pygal 模块安装和使用
        以面向对象的方式创建各种数据图
    Pygal 模块安装
        1. pip install pygal
        2. python -m pip install pygal
        python -m pydoc -p 9999
    Pygal 数据图
        使用面向对象的方式生成数据图的步骤：
            1. 创建pygal数据图对象，pygal 为不同的图像提供不同的类， 柱状图：pygal.Bar 。 饼状图：pygal.Pie类， 折线图: pygal.Line类
            2. 调用数据图对象的add 方法添加数据
            3. 调用 Config 对象的属性配置数据图
            4. 调用数据对象的render_to_xxx 方法将数据渲染到指定的输出节点
                import pygal
                x_data = [&apos;2011&apos;, &apos;2012&apos;, &apos;2013&apos;, &apos;2014&apos;, &apos;2015&apos;, &apos;2016&apos;, &apos;2017&apos;]
                y_data = [58000, 60200, 63000, 71000, 84000, 90500, 107000]
                y_data2 = [52000, 54200, 51500,58300, 56800, 59500, 62700]
                bar = pygal.Bar()
                bar.add(&apos;C语言基础&apos;, y_data)
                bar.add(&apos;Python语言基础&apos;, y_data2)
                bar.x_labels = x_data
                bar.title = &apos;编程教程的历年销量&apos;
                bar.x_title = &apos;年份&apos;
                bar.y_title = &apos;销量&apos;
                bar.render_to_file(&apos;fk_books.svg&apos;)&apos;&apos;)&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;)&apos;&apos;)&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;]
                虽然没有X、Y轴没有名称，都可通过pygal.Bar 对象来配置，为pygal.Bar对象的title、x_labels、x_title、y_title属性赋值
                [More](http://c.biancheng.net/view/2721.html)

    Pygal 常见数据图：折线图、柱状图、饼图、点图、仪表图、雷达图等
        折线图：pygal.Line 类
            [More](http://c.biancheng.net/view/2731.html)

Python读取csv文件
    csv: 以文本存储的表格数据,每行代表一行数据,每行数据中每个单元格内的数据以逗号隔开
        使用csv模块读取csv文件:
            1. 创建csv模块的读取器
            2. 循环调用csv读取器的next方法逐行读取csv文件内容,next返回list列表代表一行数据,list列表的每个元素代表一个单元格数据
            import csv
            filename = &apos;xxx.csv&apos;
            with open(filename) as f:
                reader = csv.reader(f)
                header_row = next(reader)
                print(hreader_row)
                first_row next(reader)
                print(first_row)
            [More](http://c.biancheng.net/view/2734.html)

Python 读取 JSON 文件
    JSON格式的数据会被转换为Python的list列表或dict字典
        import json
        filename = &apos;xxx.json&apos;
        with open(filename) as f:
            xx_list = json.load(f)
        for xx_dict in xx_list:
            if xx_dict[&apos;Year&apos;] == 2016 and xx_dict[&apos;Country Code&apos;] == &apos;CHN&apos;:
                print(xx_dict[&apos;Country Name&apos;],xx_dict[&apos;Value&apos;])
        调用json的load函数加载JSON数据，返回一个list列表，遍历该list列表即可访问到制定年份、国家的值

Python 读取网络数据 request库和re模块
    网络支持库:urllib.通过该库下的request模块向远程发送HTTP请求,获取服务器响应,思路:使用urllib.request 向 网站发送请求,获取该网站的响应,然后使用python的re模块来解析服务器响应,从中获得数据
        import re 
        from datatime import datetime
        from datatime import timedelta
        from matplotlib import pyplot as plt
        from urllib.request import * 
        def get_html(city,year,month):
            url = &apos;http://lishi.tianqi.com/&apos; + &apos;city&apos; + &apos;/&apos; + str(year) + str(month) + &apos;.html&apos;
            request = Request(url)
            request.add_header(&apos;User-Agent&apos;,&apos;xx&apos;)
            response = urlopen(request)
            return response.read().decode(&apos;gbk&apos;)

        dates,highs,lows = [], [], []
        city = &apos;guangzhou&apos;
        year = &apos;2019&apos;
        months = [&apos;01&apos;,&apos;02&apos;,...,&apos;12&apos;]
        prev_day = datetime(2019,2,14)
        for month in months:
            html = get_html(city,year,month)
            text = &apos;&apos;.join(html.split())
            pattern = re,compile(&apos;&lt;divclass=&quot;tqtong&quot;&apos;)
            ...</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Author : Hale Lv</span><br><span class="line">@Created Time : 2019-08-29 13:27:28</span><br><span class="line">@Description :</span><br></pre></td></tr></table></figure>

<h2 id="Python-Scrapy-爬虫框架"><a href="#Python-Scrapy-爬虫框架" class="headerlink" title="Python Scrapy 爬虫框架"></a>Python Scrapy 爬虫框架</h2><pre><code>网络爬虫：自动获取多个页面中的所有天气信息，使用正则表达式、XPath 来提取页面中所有的链接 &lt;a.../&gt;元素，顺着这些链接递归打来对应的页面，然后提取页面中的信息
    网路爬虫具体的核心工作：
        1. 通过网络向指定的URL发送请求，获取服务器响应内容
        2. 使用如正则表达式、XPath等提取页面中需要的信息
        3. 高效地识别响应页面中的链接信息，顺着这些链接递归执行第1、2、3步
        4. 使用多线程有效地管理网络通信交互
    网络爬虫的核心工作:
        1. 向URL发送请求,获取服务器响应内容,此核心工作是所有网络爬虫都需要做的通用工作,通用工作由爬虫框架来实现,可提供更稳定的性能.提高开发效率
        2. 提取页面中感兴趣的信息.使用XPath提取信息的效率更高,正则表达式效率比较低
        3. 识别响应页面中的链接信心,使用XPath效率高,正则表达式则底
        4. 多线程管理: 核心工作是通用,由框架完成

    Scrapy 是一个专业,高效的爬虫框架.试用专业的Twisted包,基于事件驱动的网络引擎包,使用lxml专业的XML处理包,cssselect高效地提取HTML页面的有效信息,同时也提供了有效的线程管理

Scrapy 安装
    pip install scrapy
    python -m pip install scrapy 
    Scrapy需要依赖的第三方包：
        1. pyOpenSSL: 用于支持SSL：Security Socket Layer 
        2. cryptography: 用于加密的包
        3. CFFI ：调用C的接口库
        4. zope.interface : 为Python缺少接口而提供扩展的库
        5. lxml ：一个处理XML、HTML文档的库，比python内置的xml模块更好用
        6. cssselect ： 处理css选择器的扩展包
        7. Twisted ： 为python提供的基于事件驱动的网络引擎包
        pip install Twisted-xxx-xxx-xxx.whl

Scrapy 项目创建
    创建一个名为 xxxSplider的项目：
        scrapy startproject xxxSplider
        scrapy 是Scrapy框架提供的命令； startproject 是scrapy 的子命令，用于创建项目； xxxSplider是要创建的项目名
            scrapy 提供的子命令： 
                startproject: 创建项目
                fetch ：从指定URL获取响应
                gensplider ：生成蜘蛛
                shell ：启动交互式控制台
                version : 查看Scrapy版本
        项目目录和文件:
            scrapy.cfg: 项目的总配置文件，无需修改
            xxxSplider :项目的Python模块，程序将从此处导入Python代码
            xxxSplider/items.py ：用于定义项目用到的Item类，Item是一个DTO数据传输对象，定义N个属性，该类需由开发者来定义
            xxxSplider/pipelines.py ：项目的管道文件，负责处理爬取到的信息
            xxxSplider/settings.py : 项目的配置文件
            xxxSplider/spiders : 存放项目所需的蜘蛛，负责抓取项目感兴趣的信息
    Scrapy包含的核心组件：
        调度器： 由Scrapy框架实现，负责调度下载中间件从网络上下载资源
        下载器： 由Scrapy框架实现，负责从网络上下载数据，下载得到的数据会由Scrapy引擎自动交给蜘蛛
        蜘蛛：由开发者实现，负责从下载数据中提取有效信息，提取到的信息会由Scrapy引擎以Item对象的形式转交给Pipeline
        Pipeline：该组件由开发者实现，该组件接收到Item对象，包含蜘蛛提取的信息后，可将这些信息写入文件或数据库中

    Scrapy Shell 调式工具及用法
        使用shell调式工具抓取页面中的信息：
            scrapy shell https://wwww.zhihu.com/xxx/xxx/
        让Scrapy伪装为浏览器，需在发送请求时设置 User-Agent头
            scrapy shell -s USER_AGENT=&apos;Mozilla/5.0/xxx/xxx&apos; 
            https://www.zhipin.com/xxx/xxx
        使用XPath 或 CSS 选择器提取感兴趣的信息
        XPath简化写法：
            nodename            匹配此节点的所有内容
            /                    匹配根字节
            //                    匹配任意位置的节点
            .                    匹配当前节点
            ..                    匹配父节点
            @                    匹配属性
        使用//div匹配页面中任意位置处的&lt;div.../&gt;元素，也可使用//div/span匹配页面中任意位置处的 &lt;div...&gt;元素内的&lt;span.../&gt;子元素
        XPath支持谓词，在节点后增加一个方括号，在方括号内放一个限制表达式对该节点进行限制
        使用//div[@class]来匹配页面中任意位置处、由class属性的 &lt;div.../&gt;元素，也可使用 //div/span[1]匹配页面中任意位置处的 &lt;div.../&gt;元素内的最后一个 &lt;span.../&gt;子元素
        使用 //div/span/[last()]来匹配页面中任意位置处的 &lt;div.../&gt;元素内的最后一个 &lt;span.../&gt;子元素
        使用 //div/span[last()-1] 匹配页面中任意位置处的 &lt;div.../&gt;元素内的倒数第二个 &lt;span.../&gt;子元素 
        XPath :
            //div[@class=&quot;job-primary&quot;]
        extract() 提取节点的内容
        [More](http://c.biancheng.net/view/2750.html)

Scrapy 爬虫项目开发过程详解
    步骤：
        1. 定义 Item 类，该类仅用于定义项目需要爬虫的N个属性，如：名称、工资、公司等信息，可在items.py 中增加如下类定义：
            import scrapy
            class xxSpliderItem(scrapy.Item):
                title = scrapy.Field()
                salary = scrapy.Field()
                company = scrapy.Field()
                url = scrapy.Field()
                addr = scrapy.Field()
                industry = scrapy.Field()
                publish = scrapy.Field()
        2. 编写Spider类，将该Spider 类文件放在spiders目录下， 需要使用XPath或CSS选择器来提取HTML中感兴趣的信息
            创建Splider：
                scrapy genspider [options] &lt;name&gt; &lt;domain&gt;
            在命令行中进入xxxSpider 目录下，执行如下命令行创建一个Spider：
                scrapy genspider job_position &quot;xxx.com&quot;
            可在xxSpider项目的xxxSpider/spider 目录下找到一个job_position.py，包含的内容如下：
                import scrapy 
                class JobPositionSpider(scrapy.Spider):
                    name = &apos;job_position&apos;
                    allowd_domains = [&apos;zhipin.com&apos;]
                    start_urls = [&apos;https://zhipin.com/xxx/xx/&apos;]
                def parse(self,response):
                    pass
                是Spider类的模板，该类的name属性用于指定该Spider的名字，allow_domains用于限制该Spider所爬取的域名，start_urls 指定该Spider会自动爬取的页面URl
                Spider 需继承scrapy,Spider，并重写parse(slef,response)方法， 注意字符集问题
                开发者要做的两件事情：
                    1. 将要爬取的各页面URL定义在start_urls列表中
                    2. 在parse(self,response)方法中通过XPath或CSS选择器提取项目感兴趣的信息
                    import scrapy

        3. 编写pipelines.py 文件，该文件负责将所爬取的数据写入文件或数据库中
            [More](http://c.biancheng.net/view/2753.html)

scrapy 爬虫数据保存到MySQL数据库
    将爬虫的信息写入到文件中之外，也可通过修改Pipeline文件将数据库存到数据库中
    创建数据库：
    CREATE TABLE job_inf (
        id int(11) not null primary key auto_increment,
        title varchar(100),
        salary varchar(100)
        url varchar(100),
        ...
    )
    修改Pipeline文件，将爬取到的信息保存到MySQL数据库中：
        improt mysql.connector
        class xxxPipeline(object):
            def __init__(self):
                self.conn = mysql.connector.connect(user=&apos;root&apos;,password=&apos;pass&apos;,host=&apos;localhost&apos;,port=&apos;3306&apos;,database=&apos;dbname&apos;,use_unicode=True)
                self.cur = self.conn.cursor()
            def close_spider(self,spider):
                print(&apos;---------close mysql----&apos;)
                self.cur.close()
                slef.conn.close()
            def process_item(self,item,spider):
                self.cur.execute(&apos;insert into job_inf values(null,%s,%s,%s,%s,...%s)&apos;,(item[&apos;title&apos;],item[&apos;salary&apos;],item[&apos;company&apos;],...item[&apos;xxx&apos;]))
                self.conn.commit()
        程序为该Pipeline类定义了构造器，用于初始化数据库链接、游标，还为该Pipeline类重写了close_spider方法， 负责关闭构造器中初始化的数据库资源

Scrapy 突破反爬虫机制</code></pre>
      
    </div>
    
    
    

      <div>
	
		
<div class="my_post_copyright">
  <script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>
  
  <!-- JS库 sweetalert 可修改路径 -->
  <script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"></script>
  <script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script>
  <p><span>本文标题:</span><a href="/2019/08/09/Python-Note/">Python</a></p>
  <p><span>文章作者:</span><a href="/" title="访问 <center> Hale Lv </center> 的个人博客"><center> Hale Lv </center></a></p>
  <p><span>发布时间:</span>2019年08月09日 - 18:08</p>
  <p><span>最后更新:</span>2019年08月29日 - 21:08</p>
  <p><span>原始链接:</span><a href="/2019/08/09/Python-Note/" title="Python">http://yoursite.com/2019/08/09/Python-Note/</a>
    <span class="copy-path" title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="http://yoursite.com/2019/08/09/Python-Note/" aria-label="复制成功！"></i></span>
  </p>
  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> 转载请保留原文链接及作者。</p>  
</div>
<script> 
    var clipboard = new Clipboard('.fa-clipboard');
    $(".fa-clipboard").click(function(){
      clipboard.on('success', function(){
        swal({   
          title: "",   
          text: '复制成功',
          icon: "success", 
          showConfirmButton: true
          });
    });
    });  
</script>


	
      </div>

    
      <div>
        <div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center">
    <img id="wechat_subscriber_qcode" src="http://39.106.208.58/pic/wechat.jpg" alt="<center> Hale Lv </center> wechat" style="width: 200px; max-width: 100%;">
    <div>扫一扫，公众号！</div>
</div>

      </div>
    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>文能提笔安天下，武能上马定乾坤！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="http://39.106.208.58/pic/wxpay.jpg" alt="<center> Hale Lv </center> 微信支付">
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="http://39.106.208.58/pic/alipay.jpg" alt="<center> Hale Lv </center> 支付宝">
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
	
   <div>
	
		<div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

	
   </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Python/" rel="tag"><i class="fa fa-tag"></i> Python</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/08/09/Linux-Note/" rel="next" title="Linux">
                <i class="fa fa-chevron-left"></i> Linux
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/08/09/Golang-Note/" rel="prev" title="Golang">
                Golang <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>



  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/uploads/avatar.jpg" alt="<center> Hale Lv </center>">
            
              <p class="site-author-name" itemprop="name"><center> Hale Lv </center></p>
              <p class="site-description motion-element" itemprop="description"><center> 上九天揽月，下五洋捉鳖。</center></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/hello.html">
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/i-china" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:mr_hale@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.facebook.com/mr_hale" target="_blank" title="FB Page">
                      
                        <i class="fa fa-fw fa-facebook"></i>FB Page</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://youtube.com/mr_hale" target="_blank" title="YouTube">
                      
                        <i class="fa fa-fw fa-youtube"></i>YouTube</a>
                  </span>
                
            </div>
          


          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://gitee.com/aspire_8" title="码云" target="_blank">码云</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://weibo.com/iaspirant" title="微博" target="_blank">微博</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.ruanyifeng.com" title="阮一峰" target="_blank">阮一峰</a>
                  </li>
                
              </ul>
            </div>
          


          

        </div>
      </section>


      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Python-编程基础"><span class="nav-number">1.</span> <span class="nav-text">Python 编程基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#第一个python"><span class="nav-number">1.1.</span> <span class="nav-text">第一个python</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#变量类型和运算符"><span class="nav-number">2.</span> <span class="nav-text">变量类型和运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#列表、元组、字典、集合"><span class="nav-number">3.</span> <span class="nav-text">列表、元组、字典、集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#list列表"><span class="nav-number">3.1.</span> <span class="nav-text">list列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tuple元组"><span class="nav-number">3.2.</span> <span class="nav-text">tuple元组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字典"><span class="nav-number">3.3.</span> <span class="nav-text">字典</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串常用方法详解"><span class="nav-number">4.</span> <span class="nav-text">字符串常用方法详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串拼接-拼接数字"><span class="nav-number">4.1.</span> <span class="nav-text">字符串拼接(+拼接数字)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串大小写转换的三种函数"><span class="nav-number">4.2.</span> <span class="nav-text">字符串大小写转换的三种函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#流程控制"><span class="nav-number">5.</span> <span class="nav-text">流程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#if条件语句可分3中形式："><span class="nav-number">5.1.</span> <span class="nav-text">if条件语句可分3中形式：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#while-循环语句"><span class="nav-number">5.2.</span> <span class="nav-text">while 循环语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for循环用法"><span class="nav-number">5.3.</span> <span class="nav-text">for循环用法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数和lambda表达式"><span class="nav-number">6.</span> <span class="nav-text">函数和lambda表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数是执行特定任务的一段代码，通过一段代码定义成函数，并为该函数指定一个函数名，可多次调用。可代码复用"><span class="nav-number">6.1.</span> <span class="nav-text">函数是执行特定任务的一段代码，通过一段代码定义成函数，并为该函数指定一个函数名，可多次调用。可代码复用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数的定义"><span class="nav-number">6.2.</span> <span class="nav-text">函数的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数值传递和引用传递-包括形式参数和实际参数的区别"><span class="nav-number">6.3.</span> <span class="nav-text">函数值传递和引用传递(包括形式参数和实际参数的区别)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数参数传递机制"><span class="nav-number">6.4.</span> <span class="nav-text">函数参数传递机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数默认参数设置"><span class="nav-number">6.5.</span> <span class="nav-text">函数默认参数设置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变量作用域-全局和局部"><span class="nav-number">6.6.</span> <span class="nav-text">变量作用域(全局和局部)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数高级用法"><span class="nav-number">6.7.</span> <span class="nav-text">函数高级用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lambda-表达式及用法"><span class="nav-number">6.8.</span> <span class="nav-text">lambda 表达式及用法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类和对象"><span class="nav-number">7.</span> <span class="nav-text">类和对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#面向对象：-一切皆对象"><span class="nav-number">7.1.</span> <span class="nav-text">面向对象： 一切皆对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类对象的创建和使用"><span class="nav-number">7.2.</span> <span class="nav-text">类对象的创建和使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#封装机制及实现方法"><span class="nav-number">7.3.</span> <span class="nav-text">封装机制及实现方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#继承机制及作用"><span class="nav-number">7.4.</span> <span class="nav-text">继承机制及作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多态"><span class="nav-number">7.5.</span> <span class="nav-text">多态</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异常处理机制"><span class="nav-number">8.</span> <span class="nav-text">异常处理机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#异常机制主要依赖try、except、else、finally、raise-五个关键字"><span class="nav-number">8.1.</span> <span class="nav-text">异常机制主要依赖try、except、else、finally、raise 五个关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异常处理机制-1"><span class="nav-number">8.2.</span> <span class="nav-text">异常处理机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#raise-用法"><span class="nav-number">8.3.</span> <span class="nav-text">raise 用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sys-exc-info-获取异常信息"><span class="nav-number">8.4.</span> <span class="nav-text">sys.exc_info(): 获取异常信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#traceback模块：-获取异常信息"><span class="nav-number">8.5.</span> <span class="nav-text">traceback模块： 获取异常信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义异常类及用法"><span class="nav-number">8.6.</span> <span class="nav-text">自定义异常类及用法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类特殊成员-属性和方法"><span class="nav-number">9.</span> <span class="nav-text">类特殊成员(属性和方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#特殊：-方法名、属性名前后添加双下划线。-可重写或调用方法来实现特殊的功能"><span class="nav-number">9.1.</span> <span class="nav-text">特殊： 方法名、属性名前后添加双下划线。 可重写或调用方法来实现特殊的功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#setattr-getattr-hasattr-函数用法"><span class="nav-number">9.2.</span> <span class="nav-text">setattr(), getattr(), hasattr() 函数用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#issubclass-和-isinstance-函数-：-检查类型"><span class="nav-number">9.3.</span> <span class="nav-text">issubclass 和 isinstance 函数 ： 检查类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#iter-和-reversed-：实现迭代器"><span class="nav-number">9.4.</span> <span class="nav-text">iter 和 reversed ：实现迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生成器"><span class="nav-number">9.5.</span> <span class="nav-text">生成器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#两种方式创建生成器："><span class="nav-number">9.6.</span> <span class="nav-text">两种方式创建生成器：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模块和包"><span class="nav-number">10.</span> <span class="nav-text">模块和包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#常用-sys、OS-、-traceback-三个模块"><span class="nav-number">10.1.</span> <span class="nav-text">常用 sys、OS 、 traceback 三个模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#导入模块：-import"><span class="nav-number">10.2.</span> <span class="nav-text">导入模块： import</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义模块"><span class="nav-number">10.3.</span> <span class="nav-text">自定义模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#导入模块的三种方式"><span class="nav-number">10.4.</span> <span class="nav-text">导入模块的三种方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#导入模块的本质"><span class="nav-number">10.5.</span> <span class="nav-text">导入模块的本质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建包，导入包"><span class="nav-number">10.6.</span> <span class="nav-text">创建包，导入包</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常见模块"><span class="nav-number">11.</span> <span class="nav-text">常见模块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#sys模块包含全部成员-包括变量、函数等"><span class="nav-number">11.1.</span> <span class="nav-text">sys模块包含全部成员 包括变量、函数等</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#os-模块及用法"><span class="nav-number">11.2.</span> <span class="nav-text">os 模块及用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#time-模块"><span class="nav-number">11.3.</span> <span class="nav-text">time 模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#json-模块"><span class="nav-number">11.4.</span> <span class="nav-text">json 模块</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#正则表达式"><span class="nav-number">12.</span> <span class="nav-text">正则表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Regular-Expression-描述一种字符串匹配的模式，检查一个字符串是否含有某个子串，也可从字符串中提取匹配的子串，或对字符串中匹配的子串执行替换操作，可用来开发数据抓取、网络爬虫等"><span class="nav-number">12.1.</span> <span class="nav-text">Regular Expression 描述一种字符串匹配的模式，检查一个字符串是否含有某个子串，也可从字符串中提取匹配的子串，或对字符串中匹配的子串执行替换操作，可用来开发数据抓取、网络爬虫等</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#set-和-frozenset-集合操作"><span class="nav-number">13.</span> <span class="nav-text">set 和 frozenset 集合操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#set-集合是可变容器，可改变容器中的元素，-frozenset集合，是set的不可变版本，他的元素不可变"><span class="nav-number">13.1.</span> <span class="nav-text">set 集合是可变容器，可改变容器中的元素， frozenset集合，是set的不可变版本，他的元素不可变</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#frozenset-集合"><span class="nav-number">13.2.</span> <span class="nav-text">frozenset 集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#queue-双端队列-模块"><span class="nav-number">13.3.</span> <span class="nav-text">queue (双端队列) 模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#heapq-堆操作"><span class="nav-number">13.4.</span> <span class="nav-text">heapq 堆操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Counter-类"><span class="nav-number">13.5.</span> <span class="nav-text">Counter 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#namedtuple-工厂函数功能"><span class="nav-number">13.6.</span> <span class="nav-text">namedtuple 工厂函数功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#itertools模块：生成迭代器"><span class="nav-number">13.7.</span> <span class="nav-text">itertools模块：生成迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#functools-模块："><span class="nav-number">13.8.</span> <span class="nav-text">functools 模块：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Tkinter-GUI图形洁面开发"><span class="nav-number">14.</span> <span class="nav-text">Tkinter (GUI图形洁面开发)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#GUI-：Graphics-User-Interface-图形用户界面。三要素：输入数据、处理数据、输出数据"><span class="nav-number">14.1.</span> <span class="nav-text">GUI ：Graphics User Interface 图形用户界面。三要素：输入数据、处理数据、输出数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tkinet-GUI-编程组件及用法"><span class="nav-number">14.2.</span> <span class="nav-text">Tkinet GUI 编程组件及用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tkinter-Place-布局管理器"><span class="nav-number">14.3.</span> <span class="nav-text">Tkinter Place 布局管理器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tkinter-compound-选项使用方法"><span class="nav-number">14.4.</span> <span class="nav-text">Tkinter compound 选项使用方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tkinter-Entry-和-Text-控件用法"><span class="nav-number">14.5.</span> <span class="nav-text">Tkinter Entry 和 Text 控件用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tkinter-Panedwindow-控件"><span class="nav-number">14.6.</span> <span class="nav-text">Tkinter Panedwindow 控件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Tkinter-输入对话框"><span class="nav-number">14.6.1.</span> <span class="nav-text">Tkinter 输入对话框</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Tkinter-文件对话框创建和使用"><span class="nav-number">14.6.2.</span> <span class="nav-text">Tkinter 文件对话框创建和使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Tkinter-消息框"><span class="nav-number">14.6.3.</span> <span class="nav-text">Tkinter 消息框</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tkinter-Canvas-画布完全攻略"><span class="nav-number">14.7.</span> <span class="nav-text">Tkinter Canvas 画布完全攻略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件操作I-O"><span class="nav-number">15.</span> <span class="nav-text">文件操作I/O</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文件基本操作"><span class="nav-number">15.1.</span> <span class="nav-text">文件基本操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#open-函数：打开指定文件"><span class="nav-number">15.2.</span> <span class="nav-text">open 函数：打开指定文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#open-函数文件打开模式："><span class="nav-number">15.3.</span> <span class="nav-text">open 函数文件打开模式：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#open-是否需要缓冲区"><span class="nav-number">15.4.</span> <span class="nav-text">open()是否需要缓冲区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#read-函数：-按字节、字符读取文件"><span class="nav-number">15.5.</span> <span class="nav-text">read 函数： 按字节、字符读取文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#close-：-关闭文件"><span class="nav-number">15.6.</span> <span class="nav-text">close ： 关闭文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#with-as-用法"><span class="nav-number">15.7.</span> <span class="nav-text">with  as 用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#上下文管理器，-python-with-as-底层原理"><span class="nav-number">15.8.</span> <span class="nav-text">上下文管理器， python with as 底层原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库编程"><span class="nav-number">16.</span> <span class="nav-text">数据库编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据库API-DB-API"><span class="nav-number">16.1.</span> <span class="nav-text">数据库API(DB API)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#并发编程-多进程、多线程"><span class="nav-number">17.</span> <span class="nav-text">并发编程(多进程、多线程)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程和线程-区别"><span class="nav-number">17.1.</span> <span class="nav-text">进程和线程 区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建线程的两种方式："><span class="nav-number">17.2.</span> <span class="nav-text">创建线程的两种方式：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Python-线程的生命周日-新建、就绪、运行、阻塞、死亡"><span class="nav-number">17.3.</span> <span class="nav-text">Python 线程的生命周日(新建、就绪、运行、阻塞、死亡)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#线程的新建和就绪状态"><span class="nav-number">17.3.1.</span> <span class="nav-text">线程的新建和就绪状态</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网络编程"><span class="nav-number">18.</span> <span class="nav-text">网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#socket-建立TCP连接"><span class="nav-number">18.1.</span> <span class="nav-text">socket 建立TCP连接</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pydoc-模块：查看、生成帮助文档"><span class="nav-number">19.</span> <span class="nav-text">pydoc 模块：查看、生成帮助文档</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#doctest模块：-文档测试"><span class="nav-number">19.1.</span> <span class="nav-text">doctest模块： 文档测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unittest-PyUnit-单元测试框架"><span class="nav-number">19.2.</span> <span class="nav-text">unittest(PyUnit)单元测试框架</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#打包和发布-zipapp-和-PyInstaller"><span class="nav-number">20.</span> <span class="nav-text">打包和发布 zipapp 和 PyInstaller</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#zipapp-创建独立应用"><span class="nav-number">20.1.</span> <span class="nav-text">zipapp 创建独立应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PyInstaller-安装和使用"><span class="nav-number">20.2.</span> <span class="nav-text">PyInstaller 安装和使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据可视化-Matplotlib-Pygal"><span class="nav-number">21.</span> <span class="nav-text">数据可视化 Matplotlib, Pygal</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Matplotlib"><span class="nav-number">21.1.</span> <span class="nav-text">Matplotlib</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Matplotlib-time-xlabel-ylabel-xticks-yticks-设置坐标轴"><span class="nav-number">21.2.</span> <span class="nav-text">Matplotlib time, xlabel, ylabel , xticks, yticks : 设置坐标轴</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Python-Scrapy-爬虫框架"><span class="nav-number">22.</span> <span class="nav-text">Python Scrapy 爬虫框架</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      


<script type="text/javascript" charset="utf-8" src="/js/tagcloud.js"></script>
<script type="text/javascript" charset="utf-8" src="/js/tagcanvas.js"></script>
<div class="widget-wrap">
    <h3 class="widget-title"> Hale's 标签云 </h3>
    <div id="myCanvasContainer" class="widget tagcloud">
        <canvas width="250" height="250" id="resCanvas" style="width=100%">
            <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Design/">Design</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/">Docker</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Error/">Error</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang/">Golang</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/">Hexo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Laravel/">Laravel</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Life/">Life</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mac/">Mac</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MarkDown/">MarkDown</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/">MySQL</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nginx/">Nginx</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NoSQL/">NoSQL</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PHP/">PHP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Socket/">Socket</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vim/">Vim</a><span class="tag-list-count">1</span></li></ul>
        </canvas>
    </div>
</div>



    </div>

  </aside>



        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"> </i>
  </span>
  <span class="author" itemprop="copyrightHolder"><center> Hale Lv </center></span>

  
</div>


<!--  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>
-->



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共87.8k字</span>
</div>







   <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>

<span id="busuanzi_container_site_uv">
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
