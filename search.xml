<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Docker]]></title>
    <url>%2F2019%2F08%2F16%2FDocker-Note%2F</url>
    <content type="text"><![CDATA[iFaithFreedom Docker 基础1234567891011121314151617181920212223install windwos: Control Panel -&gt; open: Hyper-V 和 容器[Docker.exe](https://www.docker.com/products/docker-desktop)Mac os : [Docker.dmg](https://www.docker.com/products/docker-desktop)Linux : wget -qO- https://get.docker.com/ | sh usermod -aG docker your-userWindows Server : Install-Module DockerProvider -Force Install-Package Docker -ProviderName DockerProvider -ForceUpdate Docker apt update apt remove docker docker-engine docker-ce docker.io -y wget -qO- https://get.docker.com/ | sh systemctl enable docker // 设置开机启动 systemctl is-enabled docker // 检测是否开机启动Docker Storage Driver: 存储驱动 /etc/docker/daemon.json : &#123;&quot;storage-driver&quot;:&quot;overlay2&quot;&#125; docker system info // 检查docker当前的存储驱动类型 运维角度看Docker1234567891011docker version镜像：docker image ls 容器：docker container run -it ubuntu:latest /bin/bash // -it 交互模式 ps -ef // 查看全部进程 docker container ls // 系统内全部处于运行状态的容器 docker container exec // 将shell连接到一个运行中的容器终端 docker container exec -it &lt;options&gt; &lt;container-name or container-id&gt; &lt;command/app&gt; Ctrl + PQ // 退出容器 docker container stop &lt;container-name or container-id&gt; // 停止容器 docker container rm &lt;container-name or container-id&gt; // 删除容器 docker container ls -a // 列出所有容器 包括已删除的 开发角度看Docker123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131 clone web应用代码 cd xxx -&gt; ls -l -&gt; cat Dockfile -&gt; docker image build // 根据Dockerfile中的指令来创建新的镜像 -&gt; docker image build -t xxx:latet .Docker 引擎 engine [总体逻辑](http://c.biancheng.net/uploads/allimg/190416/4-1Z416140U0537.gif) 组成： Docker Client、 Docker daemon、 Contained 、runc [引擎架构](http://c.biancheng.net/uploads/allimg/190416/4-1Z41614102M63.gif)启动一个新的容器 docker container run --name ctr1 -it alpine:latest sh [启动过程](http://c.biancheng.net/uploads/allimg/190416/4-1Z4161413112O.gif)daemon 作用 镜像管理、镜像构建、REST API、身份验证、安全、核心网络以及编排Docker镜像 docker container run docker service create // 从某个镜像启动一个或多个容器拉取镜像 docker image pull xxx:latest // xxx 为镜像名 latest 为版本 docker image ls // 检查docker主机本地仓库是否包含镜像 镜像仓库服务 Image Registry 镜像命名和标签 拉取镜像：docker image pull &lt;repository&gt;:&lt;tag&gt; docker image pull ubuntu:latest // 从官方ubuntu库拉取标签为latest的镜像 拉取某组织的镜像: docker image pull microsoft/powershell:nanoserver 为镜像打多个标签 docker image pull -a nigelpoulton/tu-demo 返回镜像列表内容 docker image ls --filter dangling=true // 返回没有标签的镜像(悬虚镜像)，显示为 &lt;none&gt;:&lt;none&gt; 移除全部的悬虚镜像: docker image prune 过滤器： dangding: 返回悬虚镜像(true), 非悬虚镜像(false) before : 需要镜像名称或者id，返回在之前被创建的全部镜像 since : 类似before，返回指定镜像之后创建的全部镜像 label : 根据标注(label)的名称或者值，进行过滤 docker image ls --filter=reference=&quot;*.latest&quot; docker image ls --format &quot;&#123;&#123;.Size&#125;&#125;&quot; // 通过Go模板对输出内容格式化 docker image ls --format &quot;&#123;&#123;.Repository&#125;&#125;:&#123;&#123;.Tag&#125;&#125;:&#123;&#123;.Size&#125;&#125;&quot;搜索Docker Hub docker search xxx // xxx 为 仓库名称 docker search xxx --filter &quot;is-official=true&quot; // 返回官方镜像 docker search xxx --filter &quot;is-automated=true&quot; // 显示自动创建的仓库镜像和分层 Docker 镜像由一些 松耦合 的只读镜像层组成 查看镜像分层： docker image inspect xxx:latest 查看镜像的构建历史记录： docker history [镜像层](http://c.biancheng.net/uploads/allimg/190416/4-1Z416164115364.gif) 共享镜像层 docker image pull -a xxx/xxx 本地产看镜像摘要： docker image ls --digests xxx 在docker主机删除镜像： docker image rm xxx:latest 多层架构的镜像 [Multi-architecture Image](http://c.biancheng.net/uploads/allimg/190416/4-1Z416164446156.gif) 删除本地镜像： docker image rm container-id 获取本地全部镜像: docker image ls -q 删除本地全部镜像: docker image rm $(docker image ls -q) -f Docker 镜像常用命令 docker image pull // 下载镜像 docker image pull xxx:xxx // 下载指定镜像 docker image ls // 列出全部镜像 docker image inspect // 列出镜像层数数据和元数据 docker image rm // 删除镜像 docker image rm xxx:xxx // 删除指定镜像Docker 容器 docker container run // 启动容器 docker container run &lt;image&gt; &lt;app&gt; // 指定启动所需的镜像及要运行的应用 docker container run xxx:xxx sleep 10 // shell连接到容器 10s 的时间 docker container stop // 手动停止容器运行 docker container start // 再次启动该容器 docker container rm // 删除容器容器和虚拟机 [](http://c.biancheng.net/uploads/allimg/190417/4-1Z41G01336346.gif)检擦Docker daemon docker version 如果server 部分有错，需要 usermod -aG docker &lt;user&gt; 添加到本地docker 组 检查docker daemon状态 service docker status systemctl is-active docker 启动一个简单容器 docker container run docker container run &lt;options&gt; &lt;im- age&gt;:&lt;tag&gt; &lt;app&gt; docekr 默认非TLS网络端口为 2375 ， TLS端口为 2376容器进程： ps -ef 查看正在运行的容器列表 docker container ls 启动容器后，重新连接到Docker docker container exec -it &lt;container-name or container-id&gt; bash 停止容器 docker container stop &lt;container-id or container-name&gt;删除容器 docker container rm &lt;container-id&gt;容器生命周期 docker container run --name percy -it xxx:xxx /bin/bash Ctrl - PQ 组合键退出当前容器优雅地停止容器 docker container stop // 向容器内的PID 1进程发送 SIGTERM 信号，优雅结束10s时间 没有预警停止容器 docker container stop &lt;container&gt; -f docker container rm &lt;container&gt; -f // -f 不会发送 SIGTERM，直接发出 SIGKILL 利用重启策略进行容器的自我修复 容器支持的重启策略： always unless-stopped on-failed docker container run --name xxx -it --restart always xx sh exit docker container ls 1. 创建两容器 docker container run -d --name always --restart always alpine sleep 1d docker container run -d --name unless-stopped --restart unless-stopped alpine sleep 1d docker container ls 2. 停止两容器 docker container stop always unless-stopped docker container ls 3. 重启 Docker systemctl restart docker 4. 检查两状态 docker container ls -a 结论：always 重启了，unless-stopped 没有重启 Web服务器示例12345678910111213141516171819202122232425262728293031323334353637383940414243 docker container run -d --name webserver -p 80:8080 nigelpoulton/pluralsight -docker -ci // -d 后台模式 -p 80:8080 端口映射 将Docker主机的80端口映射到容器内的8080端口 docker container stop docker container pause docker container start docker container rm 查看容器详情 docker container inspect 快速清理 $() rm $(docker image ls -q) | ($docker container ls -aq) docker container rmDocker容器常用命令 docker container run // 启动新容器 docker container ls // 列出在运行(UP)， -a: 列出停止的(Exited) docker container exec // 连接该容器 -it &lt;container-name or container-id&gt; bash docker container stop // 停止运行中的容器 docker container start // 重启停止(Exited)状态的容器 &lt;container-id or contaienr -name&gt; docker container rm // 删除停止运行的容器 docker container inspect // 显示容器配置细节和运行时信息 &lt;container-id or container-name&gt;Docker应用容器化(将应用程序部署到容器中) 容器化：将应用整合到容器中并且运行起来的过程，能够简化应用的构建、部署和运行过程 完整的应用容器化过程分为以下步骤 1. 编写应用代码 2. 创建一个Dockfile，包括应用的描述、依赖、及如何运行应用 3. 对该Dockerfile 执行 docker image build 命令 4. 等待Docker将应用程序构建到Docker镜像中 [步骤](http://c.biancheng.net/uploads/allimg/190417/4-1Z41G51T3502.gif)单体应用容器化 步骤： 1， 获取应用代码 2. 分析 Dockfile 3. 构建应用镜像 4. 运行该应用 5. 测试应用 6. 容器应用化细节 7. 生产环境中的多阶段构建 8. 最佳实践登录到Docker Hub docker login // 登录到docker docker image push // 推送到docker docker image tag web:latest xxx/web:latest // 为镜像打标签 Dockerfile1234567891011121314151617181920212223242526272829303132333435docker image build // 读取Dockerfile，并将应用程序容器化Dockerfile 示例代码： # Linux x64 FROM xxx LABEL maintainer=&quot;mr_hale@163.com&quot; # install Node and NPM RUN apk and --update nodejs nodejs-npm # Copy app to /src COPY ./src WORKDIR /src # Install dependencies RUN npm install EXPOSE 8080 ENTRYPOINT [&quot;node&quot;,&quot;./app.js&quot;]解释： -t ： 为镜像打标签 -f ： 指定Dockerfile 的路径和名称，指定位于任意路径下的任意名称的Dockerfile FROM ：用于指定要构建的镜像的基础镜像，通常是Dockerfile 中的第一条指令 RUN ： 用于在镜像中执行命令，会创建新的镜像层，每个指令创建一个新的镜像层 COPY ： 用于将文件作为一个新的层添加到镜像中，使用COPY指令将应用代码赋值到镜像中 EXPOSE ： 记录应用所使用的网络端口 ENTRYPOINT ： 指定镜像以容器方式启动后默认运行的程序 LABEL ： ENV ： ONBUILD ： HEALTHCHECK ： CMD ： Dockers Compose1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798 与Docker Stack类似，在Docker节点上，以单引擎模式(Single-Engine Mode)进行多容器应用的部署和管理 如：一个间的示例应用可能有4个服务组成 1. Web前端 2. 订单管理 3. 品类管理 4. 后台数据库 Compose 用来部署和管理繁多的服务使用：首先编写定义多容器(多服务)应用的YAML文件，然后由 docker-compose 命令处理，基于Docker引擎API完成应用的部署安装： 使用curl下载二进制文件，然后 chmod 修改权限 检验： docker-compose --version 用 pip 安装 Docker Compose 的 python 包Docker Compose YML 配置文件及常用指令 YAML 定义多服务的应用，是JSON的子集，可使用JSON定义 默认使用文件名 docker-compose.yml, 也可使用-f参数指定具体文件 示例：包含 web-fe 、 redis 的小型Flask应用 能够对其访问者进行计数并将其保存到Redis的简单Web服务 version: &quot;1.0&quot; services: web-fe: build:. command: python app.py ports: - taget: 5000 published: 5000 networks: - counter-net volumes: - type: volume source: counter-vol target: /code redis: image: &quot;redis:alpine&quot; networks: counter-net: networks: counter-net: volumes: counter-vol: 包含4个一级key： version、services、networks、volumes version: 指定版本 services: 定义不同的应用服务，compose 会将每个服务部署到各自的容器中 networks：指引docker创建新的网络，默认 创建 bridge 网络，也可以使用driver属性指定网络类型,允许独立的容器连接到该网络上 networks: over-net: driver: overlay attachable: true volumes: 指定docker创建新的卷 定义了两个Key：web-fe 、redis，因此Docker Compose部署两容器，一个包含web-fe，一个redis web-fe服务定义中，包含以下指令： 1. build： 指定docker基于当前目录 (.) 下dockerfile来构建新景象，用于启动该服务的容器 2. command： 指定docker在容器中执行名为 app.py 的Python脚本作主程序 3. ports： 将容器内(-target)的5000端口映射到主机(published)的5000端口 4. networks：是的docker将服务连接到指定的网络上 5. volumes：将counter-vol卷(source:)挂载到容器内的 /code (target:) 6. image： redis:alpine 是的docker基于redis:alpine 镜像启动一个独立的名为redis的人弄国企，镜像会从docker hub上拉取下来 7. networks：配置redis容器连接到counter-net网络Docker-Compose 部署应用 在项目目录中，检查文件是否存在 app.py: 应用程序代码 Flask应用 docker-compose.yml: compose文件，定义了Docker如何部署应用 Dockerfile: 定义了如何构建web-fe服务所使用的镜像 requirements.txt: 列出了应用所依赖的python包启动应用： docker-compose up &amp; docker-compose -f prod-equus-bass.yml up // 基于名为 prod... 的compose文件部署应用 docker-compose up -d // 没有-d 用 &amp; 将终端窗口返回 FROM python:3.4-alpine &lt;&lt; 基础镜像 ADD ./code &lt;&lt; 将app复制到镜像中 WORKDIR /code &lt;&lt; 设置工作目录 RUN pip install -r requirements.txt &lt;&lt; 安装依赖 CMD [&quot;python&quot;,&quot;app.py&quot;] &lt;&lt; 设置默认启动命令若 .Services.redis 中指定了image: &quot;redis:alpine&quot;，会从docker hub拉取redis:alpine 镜像 docker container ls docker network ls docker volume ls使用Docker-Compose 子命令 docker-compose up -d // 拉取和构建的镜像保存在系统中 docker-compose ps // 列出容器名称、command、状态、网络端口 docker-compose top // 列出各个服务(容器)内运行的进程 docker-compose stop // 停止应用，但不删除 docker-compose rm // 删除应用相关的容器和网络，但不删除卷和镜像 docker-compose restart // 重启应用 docker-compose down // 停止和关闭应用 ./code [Dockerfile and Compose file](http://c.biancheng.net/uploads/allimg/190417/4-1Z41GJ242b5.gif) Docker Swarm1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192 集群管理工具，作用：把若干台Docker主句抽象为一个整体，通过一个入口统一管理各种Docker资源。 类似 Kubernetes，包含：企业级的Docker安全集群，微服务应用编排引擎 默认内置： 分布式集群存储、加密网络、公用TLS、安全集群接入令牌、简化数字证书管理的PKI 基于Docker引擎之上的独立产品 一个Swarm由一个或多个Docker节点组成，通过可靠的网络相连。 节点被配置为管理节点(Manager)和工作节点(Worker)， 管理节点负责集群控制面，进行诸如监控集群状态、分发任务至工作节点等操作。 工作节点接受来自管理节点的任务并执行 [Swarm](http://c.biancheng.net/uploads/allimg/190418/4-1Z41Q045505Y.gif) 集群搭建： [Swarm](http://c.biancheng.net/uploads/allimg/190418/4-1Z41Q24Z2332.gif) 每个节点装 Docker，并能够与Swarm的其他节点通信 防火墙开放以下端口： 2377/tcp: 用于客户端与Swarm进行安全通信 7946/tcp 与 7946/udp: 用于控制面gossip分发 4789/udp: 用于基于VXLAN的覆盖网络大体流程：初始化第一个管理节点 -&gt; 加入额外的管理节点 -&gt; 加入工作节点 -&gt; 完成初始化一个全新的Swarm： [Swarm](http://c.biancheng.net/uploads/allimg/190418/4-1Z41Q25041I0.gif) 在单引擎模式下的Docker 主机执行 docker swarm init 切换到swarm模式 接入额外的管理节点，并切换为Swarm模式 docker swarm init --advertise-addr 10.0.0.1:2377 --listen-addr 10.0.0.1:2377 docker swarm init // 初始化并设置为第一个管理节点，开始swarm模式 --advertise-addr // 指定其他节点用来连接到当前管理节点的IP和端口，可选 --listen-addr // 用于承载Swarm流量的IP和端口 docker node ls // 列出Swarm 节点 docker swarm join-token // 获取添加新的工作节点和管理节点到Swarm的命令和Token docker swarm join-token worker docker swarm join-token manager docker swarm join --token SWMTKN-1-0uahebax...ca... 10.0.0.1:2377 --advertise-addr 10.0.0.4:2377 --listen-addr 10.0.0.4:2377Swarm 管理器高可用性(HA) [Swarm HA](http://c.biancheng.net/uploads/allimg/190418/4-1Z41Q25541296.gif) [详细文章：](http://c.biancheng.net/view/3178.html) 内置的Swarm 安全机制锁定Swarm 启用锁： docker swarm init --autolock 解锁 ： docker swarm init --unlock Docker Swarm 服务的部署及操作 docker service create // 创建一个新的服务 docker service create --name web-fe -p 8080:8080 --replicas 5 xxx/xxx 与 docker container run 相似，--name：将其命名为 web-fa -p：映射端口 查看服务： docker service ls 查看服务副本列表及个副本的状态： docker service ps &lt;service-name or serviceid&gt; 查看服务详细信息： docker service inspect --pretty xxx // --pretty 易于阅读的格式 副本服务 VS 全局服务： 副本模式：服务的默认复制模式(Replication Mode) 是副本模式(replicated) 全局模式：global docker service create --mode global 服务的扩缩容： 大流量情况下： docker service scale web-fa=10 // 对web-fa服务扩容，将服务副本由5个增加到10个 检查操作是否成功： docker service ls 显示服务副本在各个节点上是均衡分布： dockers service ps 减少副本树： docker service scale web-fa=5 // 从10个降为5个 删除服务： docker service rm web-fa docker service ls 滚动升级： docker network create -d overlay uber-net // 创建网络并将服务接入网络 [](http://c.biancheng.net/uploads/allimg/190418/4-1Z41Q4221H59.gif) docker network ls // 查看网络是否创建成功 docker service create --name uber-svc --network uber-net -p 80:80 --replicas 12 xxxx/xxx docker service create --name uber-svc --network uber-net -publish published=80,target=80,mode=host --replicas 12 xxx/xxx docker service update // 更新运行中的服务 docker service ps docker inspect --prettyDocker Swarm 服务日志及相关配置 docker service log // 查看服务的日志 节点默认配置服务是 json-file 日志驱动，还有 journald(仅限systemctl的linux主机)、syslog、splunk、gelf json-file和journald 可用logs命令 docker service logs &lt;service-name&gt; 第三方日志驱动： &#123; &quot;log-driver&quot;:&quot;syslog&quot; &#125; docker service create --logdrive --log-opts // 强制某服务使用一个不同的日志驱动，会覆盖 daemon.json的配置 --follow ：进行跟踪 --tail : 显示最近的日志 --details ： 获取额外细节 Docker Swarm 汇总12345678910111213docker swarm init: 创建新的Swarm，成为第一管理节点docker swarm join-token: 加入管理节点和工作节点到现有Swarm docker swarm join-token manager: 获取新增管理节点 docker swarm join-token worker: 获取新增工作节点docker node ls: 列出Swarm中的所有节点及相关信息docker service create: 创建一个新服务docker service ls: 列出Swarm中运行的服务，如服务状态、副本等基本信息docker service ps &lt;service&gt;: 列出某个服务副本的信息docker service inspect: 获取关于服务的详细信息，--pretty 仅显示重要信息docker service scale: 对服务副本个数进行增减docker service update: 对运行中的服务属性进行变更docker service logs: 查看服务的日志docker serivce rm: 从Swarm中删除某服务，不做确认会删除服务的所有副本 Dockerfile1234567891011121314151617181920212223242526272829303132333435docker image build // 读取Dockerfile，并将应用程序容器化Dockerfile 示例代码： # Linux x64 FROM xxx LABEL maintainer=&quot;mr_hale@163.com&quot; # install Node and NPM RUN apk and --update nodejs nodejs-npm # Copy app to /src COPY ./src WORKDIR /src # Install dependencies RUN npm install EXPOSE 8080 ENTRYPOINT [&quot;node&quot;,&quot;./app.js&quot;]解释： -t ： 为镜像打标签 -f ： 指定Dockerfile 的路径和名称，指定位于任意路径下的任意名称的Dockerfile FROM ：用于指定要构建的镜像的基础镜像，通常是Dockerfile 中的第一条指令 RUN ： 用于在镜像中执行命令，会创建新的镜像层，每个指令创建一个新的镜像层 COPY ： 用于将文件作为一个新的层添加到镜像中，使用COPY指令将应用代码赋值到镜像中 EXPOSE ： 记录应用所使用的网络端口 ENTRYPOINT ： 指定镜像以容器方式启动后默认运行的程序 LABEL ： ENV ： ONBUILD ： HEALTHCHECK ： CMD ：]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel]]></title>
    <url>%2F2019%2F08%2F16%2FLaravel-Note%2F</url>
    <content type="text"><![CDATA[iFaithFreedom composer的安装和使用1234567891011121314151617181920&gt;&gt; php -r &quot;copy(&apos;https://getcomposer.org/installer&apos;, &apos;composer-setup.php&apos;);&quot;&gt;&gt; php composer-setup.php&gt;&gt; mv composer.phar /usr/local/bin/composer&gt;&gt; composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/&gt;&gt; 取消配置： composer config -g --unset repos.packagist&gt;&gt; composer install&gt;&gt; composer search xxx&gt;&gt; composer selfupdate&gt;&gt; composer show | composer show xxx &gt;&gt; curl -sS https://getcomposer.org/installer | php &gt;&gt; mv composer.phar /usr/local/bin/composer&gt;&gt; composer require xxx/xxx&gt;&gt; composer remove xxx/xxx | xxx &gt;&gt; composer.json &#123; &quot;require&quot;: &#123; &quot;xxx/xxx&quot;:&quot;1.0.*@beta&quot;, &quot;xxx/xxx&quot;:&quot;@dev&quot; &#125; &#125; Laravel 安装1234567891011121314151617181920212223242526Laravel install Tool: composer global require &quot;laravel/install&quot;添加laravel 到系统环境变量： export PATH=“root/.config/composer/vendor/bin:$PATH $HOME/.composer/vendor/bin 主要让系统找到laravel的可执行文件 laravel new xxxcomposer install laravel: composer create-project --prefer-dist laravel/laravel xxx &quot;5.5.*&quot;Web 服务器配置：Nginx: location / &#123; try_files $uri $uri/ /index.php?$query_string; &#125;具体看微信图片收藏中的配置信息php artisan servephp artisan --version | php artisan -Vphp artisan down | up// 设置时区在 app.php 中&apos;timezone&apos; =&gt; &apos;Asia/Shanghai&apos;;&apos;timezone&apos; =&gt; &apos;PRC&apos;;初始化完成后，修改.env配置文件，配置数据库等exec: php artisan migrate:install // 检测数据是否迁移成功 文章模块路由: 路由 模板表设计: 表设计 模型 页面逻辑： 文章列表 添加文章 编辑文章 删除文章 文章详情路由123456789101112131415161718192021- HTTP 方法：Route::get($uri,$callback);get | post | put | patch | delete | options | any | macth - 路由参数Route::get(&apos;uri1&apos;/&#123;param1&#125;/uri2/&#123;param2&#125;&apos;,function($param1,$param2)&#123; ...&#125;)-&gt;where(&apos;param&apos;,&apos;[a-zA-z0-9]+&apos;);- 路由分组Route::group([&apos;prefix&apos; =&gt; &apos;xxx&apos;],function()&#123; Route:;get(&apos;xxx&apos;,function()&#123; xxx &#125;);&#125;);Route::middleware([&apos;xxx&apos;,&apos;xxxx&apos;]) -&gt; group(function()&#123; Route::get(&apos;x&apos;,function()&#123; ... &#125;);&#125;); 模型绑定123Route::get(&apos;api/users/&#123;user&#125;&apos;,function(\App\User $user)&#123; return $user -&gt; email;&#125;); 创建控制器，路由123456789101112131415161718192021php artisan make:controller PostController Route: 文章列表Route:;get(&apos;/posts&apos;,&apos;\App\Http\Controllers\PostController@index&apos;);创建文章Route:;get(&apos;/posts/create&apos;,&apos;\App\Http\Controllers\PostController@create&apos;);Route:;post(&apos;/posts&apos;,&apos;\App\Http\Controllers\PostController@store&apos;);文章详情页Route:;post(&apos;/posts/&#123;post&#125;&apos;,&apos;\App\Http\Controllers\PostController@show&apos;);编辑文章Route:;get(&apos;/posts/&#123;post&#125;/edit&apos;,&apos;\App\Http\Controllers\PostController@edit&apos;);Route:;put(&apos;/posts/&#123;post&#125;&apos;,&apos;\App\Http\Controllers\PostController@update&apos;);删除文章Route:;get(&apos;/posts/&#123;post&#125;/delete&apos;,&apos;\App\Http\Controllers\PostController@delete&apos;);-- 控制器Controller:namespace \App\Http\Controllers;use Illuminate\Http\Request;class PostController exntends Controller &#123; public function xxx()&#123; ... &#125;&#125; 页面渲染创建文章 编辑文章 文章列表 文章详情 在控制器进行页面渲染：1234567891011Extends Controller:public function index()&#123; $arrs = [ [&apos;title&apos; =&gt; &apos;totle ...&apos;], [&apos;title&apos; =&gt; &apos;titles ...&apos;], [&apos;ok&apos; =&gt; &apos;okoko&apos;], ]; return view(&apos;post/index&apos;,[&apos;arrs&apos; =&gt; $arr]); // 指 post文件夹下的index.blade.php 页面&#125;-- 传递参数$tit = &apos;a tit&apos;;view(&apos;post/index&apos;,[&apos;title&apos; =&gt; &apos;text&apos;,&apos;isTrue&apos; =&gt; false,&apos;arrs&apos; =&gt; $arrs] );view(&apos;post/index&apos;,compact(&apos;tit&apos;,&apos;arrs&apos;)); view(&apos;post/index&apos;,compact(&apos;arrs&apos;)); – Blade模板 1234567891011121314151617181920212223242526272829303132333435363738模板语法：&#123;&#123; &#125;&#125; @if @foreach 参数传递： 继承模板：extends/ section/ yield/ content引入视图：include -- index.blade.php &#123;&#123;$title&#125;&#125; // 解析控制器中传递的变量值@if($isTrue == true) Message @endif@foreach($arrs as $arr) &#123;&#123;$arr&#125;&#125;@endforeach- 文章模块页面模板调整提取 layout提取 footer提取 navlayout/main.blade.php公用头部@yield(&apos;content&apos;)公用尾部单独拆解layout/footer.blade.phpfooter 的页面内容layout/nav.blade.phpnav 的页面内容模板集成与包含post/index.blade.php@extends(&apos;layout.main&apos;)@section(&apos;content&apos;)@include(&apos;layout.nav&apos;)index 中的页面内容@include(layout.footer)@endsection 文章模块数据表12345678910111213141516171819202122232425使用 migrate 创建数据表外键 user_id时间 created_at/updated_atmigration： 数据库同步迁移php artisan make:migration create_posts_table // 格式：create_ 数据表名_table 在创建好的create_posts_table.php中pubic function up()&#123; // 创建表用crate 更新表用 table Scheme::create(&apos;posts&apos;,function(Blueprint $table)&#123; // 创建表 $table -&gt; increment(&apos;id&apos;); $table -&gt; string(&apos;title&apos;,100) -&gt; default(&apos;&apos;); $table -&gt; text(&apos;content&apos;); $table -&gt; integer(&apos;user_id&apos;) -&gt; default(0); $table -&gt; timestamps(); &#125;);&#125;public function down()&#123; Scheme::dropIfExists(&apos;posts&apos;); // 删除表&#125;// 如果报错 SQL max key length 767 bytes，就需要在 app\Providers 文件的boot() 方法中添加 一下代码public function boot()&#123; Schema::defaultStringLength(191); // 191 = 797 / 4 &#125;php artisan migrate // 完成数据表的迁移数据库的回滚php artisan migrate:rollback 表名 posts123456789101112131415161718192021ORM: 创建posts 的模型: php artisan make:model Posttinker 的使用:php artisan think基本的增删改查增加: $post = new \App\Post(); $post -&gt; title = &apos;title text&apos;; $post -&gt; content = &apos;content text&apos;; $post -&gt; save();查找：\App\Post::find(3);\App\Post::where(&apos;title&apos;,&apos;titel text&apos;) -&gt; get() | -&gt; first();更新：$post = \App\Post::find(3);$post -&gt; title = &apos;new title text&apos;;删除:$post = \App\Post::find(3);$post -&gt; delete(); 文章列表逻辑模型查找 页面渲染 时间格式 数据填充 字符截断 分页在列表控制器中实现 12345678910111213141516171819202122232425262728293031323334353637383940PostController.phpuse \App\Post;public function index()&#123; $posts = Post::orderBy(&apos;created_at&apos;,&apos;desc&apos;) -&gt; get(); // 模型查找 return view(&apos;posts/index&apos;,compact(&apos;posts&apos;)); // 页面渲染&#125;接着在模板中修改页面渲染：如果传递过来的是数组：@foreach($arrs as $arr)&#123;&#123;$arr[&apos;title&apos;]&#125;&#125;@endforeach如果传递过来的是对象@foreach($posts as $post)&#123;&#123;$post -&gt; title&#125;&#125; // post 的 title 属性 和其他属性&#123;&#123;$post -&gt; created_at&#125;&#125; | &#123;&#123;$pos -&gt; id&#125;&#125; | &#123;&#123;$post -&gt; content&#125;&#125; | &#123;&#123;$post -&gt; updated_at&#125;&#125;@endforeach时间格式渲染：&#123;&#123;$post -&gt; created_at -&gt; toFormattedDateString()&#125;&#125; // 格式化时间数据填充：在 database\factories\ModelFactory.php 文件中设置以下代码$factory -&gt; define(App\Post::class,function(Faker\Generator $faker)&#123; return [ &apos;title&apos; =&gt; $faker -&gt; sentence(6); // 6个单词 &apos;content&apos; =&gt; $faker -&gt; paragraph(10); // 10个句子 ];&#125;);php artisan tinker: factory(App\Post::class,20) -&gt; create(); //生成 make-&gt; (); //演示分页：控制器PostController index() $posts = Post::orderBy(&apos;created_at&apos;,&apos;desc&apos;) -&gt; paginate(n); // n 一个页面显示的数量模板 view/post/index.blade.php&#123;&#123;$posts -&gt; links()&#125;&#125; 字符截取：&#123;&#123;str__limit($post -&gt; content,&apos;100&apos;,&apos;...&apos;)&#125;&#125; // str__limit() 100：显示的数量 ... 显示文本 文章添加逻辑1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950控制器模板 form 中传递的参数名和数据库字段名保持一致文章列表 详情页面 创建页面 创建逻辑 编辑页面 编辑逻辑控制器对应的方法中在接收传递数据的内容调试时使用 dd(\Request::all()); == dd(request()); // dd(request(&apos;title&apos;)); dd = dump and die CSRF在模板页面需要设置 csrf_token() 字段&lt;input type=&apos;hidden&apos; name=&apos;_token&apos; value=&quot;&#123;&#123;csrf_token()&#125;&#125;&quot;&gt; == &#123;&#123;csrf_field()&#125;&#125;保存model1. 第一种方式$post = new Post();$post -&gt; title = request(&apos;title&apos;); // 通过request 获取title数据$post -&gt; content = request(&apos;content&apos;); // 通过request 获取content数据$post -&gt; save(); // 通过 save() 进行保存2. 第二种方式$params = [&apos;title&apos; =&gt; request(&apos;title&apos;), &apos;content&apos; =&gt; request(&apos;content&apos;)];Post::create($params);3. 第三种方式是第二种方式的简写Post::create(request([&apos;title&apos;,&apos;content&apos;]))；如果报错，create方法需要在模型中设置相对应的规则app/Post.php class Post extends Model&#123; protected $guarded = []; // 不可以注入数据的字段 为空的话，所有数据都可以注入 protected $fillable = [&apos;title&apos;,&apos;content&apos;]; // 可以注入数据的字段&#125;此处可以把$guarded $fillable 提取到新的model 类文件中, post.php 集成新的model类就可以简写很多代码验证和错误提示控制器做数据的验证：public function store()&#123; // 验证 $this -&gt; validate(request()[ &apos;title&apos; =&gt; &apos;required|string|max:100|min:5&apos;, &apos;content&apos; =&gt; &apos;required|string|min:10&apos; ]);&#125; // 逻辑 $post = Post::create(request([&apos;title&apos;,&apos;content&apos;])); // 渲染 return redirect(&apos;/posts&apos;);视图层做错误的提示：@if(count($errors) &gt; 0)@foreach($errors as $error) &#123;&#123;$error&#125;&#125;@endforeach @endif错误提示本地化resources/lang/zh/ 复制 en中的文件到zh中，中文汉化放到validation.php中， 在config/app.php 中修改 locale en 为 zh 富文本编辑器的使用12345678下载wangEdit2 js 和其他的模板中对标签的格式化&#123;!! str_limit($post -&gt; content),&apos;100&apos;,&apos;...&apos; !!&#125;图片上传设置 路由Route::post(&apos;/posts/image/upload&apos;,&apos;\App\Http\PostController@imageUpload&apos;);控制器这一部分不是最重要的，暂时不细研究 文章编辑逻辑12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849路由：Route::get(&apos;/posts/&#123;post&#125;/edit&apos;,&apos;\App\Http\PostController@edit&apos;); // 传递 post 模型绑定控制器:如果路由中有传递 模型绑定，那么控制器也需要在相对应的方法中注入模型参数 public function edit(Post $post)&#123; return view(&apos;/posts/edit&apos;,compact(&apos;posts&apos;));&#125;CSRF 视图层：&#123;&#123; method_field(&apos;PUT&apos;) &#125;&#125; // 视图层&#123;&#123; csrf_field() &#125;&#125;&#123;&#123; $posts -&gt; title &#125;&#125; //&#123;&#123; $posts -&gt; content &#125;&#125; 更新 Model:路由:Route::put(&apos;/posts/&#123;post&#125;/&apos;,&apos;\App\Http\PostController@update&apos;);控制器 PostController:public function update(Post $post)&#123; // 验证 $this -&gt; validate(requset()[ &apos;title&apos; =&gt; &apos;required|string|max:100|min:5&apos;, &apos;content&apos; =&gt; &apos;required|string|min:10&apos; ]); // 逻辑 $post -&gt; title = request(&apos;title&apos;); $post -&gt; content = request(&apos;content&apos;); $post -&gt; save(); // 渲染 return redirect(&apos;/posts/&#123;$post -&gt; id&#125;&apos;);&#125;视图层：错误提示代码提取到 layout/error.blade.phpedit.blade.php@extends(&apos;layout.main&apos;)@section(&apos;content&apos;)some html code ... @include(&apos;layout.error&apos;)@endsection删除文章：路由: Route::get(&apos;/posts/&#123;post&#125;&apos;,&apos;\App\Http\PostController@delete&apos;);控制器:public function delete(Post $post)&#123; // TODO: 用户的权限认证 $post -&gt; delete(); return redirect(&apos;/posts&apos;);&#125;]]></content>
      <categories>
        <category>PHP</category>
        <category>Laravel</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Error]]></title>
    <url>%2F2019%2F08%2F14%2FError-Note%2F</url>
    <content type="text"><![CDATA[积累工作中常见错误 TODO List 积累错误]]></content>
      <categories>
        <category>Error</category>
      </categories>
      <tags>
        <tag>Error</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Design]]></title>
    <url>%2F2019%2F08%2F14%2FDesign-Note%2F</url>
    <content type="text"><![CDATA[设计模式 TODO: 设计模式创造型设计模式 简单工厂 工厂方法 抽象工厂 构建器 原型 单例 结构型设计模式 适配器 桥梁 组合 装饰 门面 享元 代理 行为型设计模式 责任链 命令行 迭代器 中介者 备忘录 观察者 访问者 策略 状态 模版方法 设计模式创造型 结构型 行为型 创造型设计模式 简单工厂： 只是为客户端生成一个实例，而不会向客户端公开任何实例化逻辑 工厂时用户创建其他对象的对象，正式工厂是一种函数或方法，它从一些方法调用返回变化的原型或类的对象，这被假定为&quot;新&quot; 程序化示例： 首先，定义一个门界面和实现 12345678910111213141516171819202122interface Door &#123; public function getWidth(): float; public function getHeight(): float;&#125;clas WoodenDoor implements Door &#123; protected $width; protected $height; public function __construct(float $width, float $height) &#123; $this -&gt; width = $width; $this -&gt; height = $height; &#125; public function getWidth(): float &#123; return $this -&gt; width; &#125; public function getHeight(): float &#123; return $this -&gt; height; &#125;&#125; 我们有我们的门工厂、门，并返回它 12345class DoorFactory &#123; public static function makeDoor($width, $height): Door &#123; return new WoodenDoor($width, $height); &#125;&#125; 然后它可以用作 12345678// Make me a door of 300 x 300$door = DoorFactory::makeDoor(300,300);echo &apos;Width: &apos; . $door -&gt; getWidth();echo &apos;Height: &apos;. $door -&gt; getHeight();// Make me a door of 100 x 100$door2 = DoorFactory::makeDoor(100,100); 用处：当创建一个对象不仅仅是一些分配而且涉及一些逻辑时，将它放在专用工厂中，而不是在任何地方重复相同的代码时有意义的 工厂方法 提供了一种将实例化逻辑委托给子类的方法 处理创建对象的问题，无需指定将要创建的对象的确切类。在接口中指定并由子类实现，或者在基类中实现并可选地由派生类覆盖，而不是通过调用构造函数 程序化示例： 123456789101112131415interface Interviewer &#123; public function askQuestions();&#125;class Developer implements Interviewer &#123; public function askQuestions() &#123; echo &apos;Factory Design Patterns &apos;; &#125;&#125;class CommunityExecutive implements Interviewer &#123; public function askQuestions() &#123; echo &apos;Asking about community building &apos;; &#125;&#125; 创造 HiringManager 123456789abstract class HiringManager &#123; // Factory method abstract protected function makeInterviewer(): Interviewer; public function takeInterview() &#123; $interviewer = $this -&gt; makeInterviewer(); $interviewer -&gt; askQuestions(); &#125;&#125; 任何子类可以延长并提供所需的 1234567891011class DevelopmentManager extends HiringManager &#123; protected function makeInterviewer(): Interviewer &#123; return new Developer(); &#125;&#125;class MarketingManager extends HiringManager &#123; protected function makeInterviewer(): Interviewer &#123; return new CommunityExecutive(); &#125;&#125; 12345$devManager = new DevelopmentManager();$devManager -&gt; takeInterview(); // Output: Asking about design patterns $marketingManager = new MarketingManager();$marketingManager -&gt; takeInterview(); // Output : Asking about community building 用处： 在类中有一些通用处理但在运行时动态决定所需的子类时用，当客户端不知道他需要什么样子的子类时 抽象工厂 将个人 相关\依赖工厂组在一起而不指定其具体类别的工厂 提供了一种封装一组具有共同主题但没有指定具体类的单个工厂的方法 程序化示例123456789101112131415interface Door &#123; public function getDescription();&#125;class WooderDoor implements Door &#123; public function getDescription() &#123; echo &apos;I am a wooden door&apos;; &#125;&#125;class IronDoor implements Door &#123; public function getDescription() &#123; echo &apos;I am an iron door&apos;; &#125;&#125; 为每种门类型都配备一些装配专家 123456789101112131415interface DoorFittingExpert &#123; public function getDescription();&#125;class Weler implements DoorFittingExpert &#123; public function getDescription() &#123; echo &apos;i can only fit iron doors &apos;; &#125;&#125;class Carpenter implements DoorFittingExpert &#123; public function getDescription() &#123; echo &apos;I can only fit wooden doors &apos;; &#125;&#125; 有抽象工厂，制作相关对象的家庭，即木门工厂将创建一个木门和木门配件，门专家 12345678910111213141516171819202122232425262728interface DoorFactory &#123; public function makeDoor(): Door; public function makeFittingExpert(): DoorFittingExpert;&#125;// Wooden factory to return carpenter and wooden door class WoodenDoorFactory implements DoorFactory &#123; public function makeDoor(): Door &#123; return new WoodenDoor(); &#125; public function makeFittingExpert(): DoorFittingExpert &#123; return new Carpenter(); &#125;&#125;// Iron Door factory to get iron door and the relevant fitting expert class IronDoorFactory implements DoorFactory &#123; public function makeDoor(): Door &#123; return new IronDoor(); &#125; public function makeFittingExpert(): DoorFittingExpert &#123; return new Welder(); &#125;&#125;// Iron d 可用作： 12345678910111213141516$woodenFactory = new WoodenDoorFactory();$door = $woodenFactory -&gt; makeDoor();$expert = $woodenFactory -&gt; makeFittingExpert();$door -&gt; getDescription(); // Output: i am a wooden door$expert -&gt; getDescription();// Same for Iron Factory $ironFactory = new IronDoorFactory();$door = $ironFactory -&gt; makeDoor();$expert = $ironFactory -&gt; makeFittingExpert();$door -&gt; getDescription();$expert -&gt; getDescription(); 木门工厂疯转 各种函数用法： 当存在互相关联的依赖关系时，涉及非简单的创建逻辑 构建器 允许创建不同风格的对象，同时避免构造函数污染，当有几种风格的物体时很有用，或在创建对象时设计很多步骤 目的：找到伸缩构造器反模式的解决方案 程序化示例：12345678910111213141516class Burger &#123; protected $size; protected $cheese = false; protected $pepperoni = false; protected $lettuce = false; protected $tomato = false; public function __construct(BurgerBuilder $builder) &#123; $this -&gt; size = $builder -&gt; size; $this -&gt; cheese = $builder -&gt; cheese; $this -&gt; pepperoni = $builder -&gt; pepperoni; $this -&gt; lettuce = $builder -&gt; lettuce; $this -&gt; tomato = $builder -&gt; tomato; &#125;&#125; 然后有建设者 123456789101112131415161718192021222324252627282930313233343536class BurgerBuilder &#123; public $size; public $cheese = false; public $pepperoni = false; public $lettuce = false; public $tomato = false; public function __construct(int $size) &#123; $this -&gt; size = $size; &#125; public function addPepperoni() &#123; $this -&gt; pepperoni = true; return $this; &#125; public function addLettuce() &#123; $this -&gt; lettuce = true; return $this; &#125; public function addCheese() &#123; $this -&gt; cheese = true; return $this; &#125; public function addTomato() &#123; $this -&gt; tomato = true; return $this; &#125; public function build(): Burger &#123; return new Burger($this); &#125;&#125; 用法： 12345$burger = (new BurgerBuilder(14)) -&gt; addPepperoni() -&gt; addLettuce() -&gt; addTomato() -&gt; build(); 用处： 当可能存在几种类型的对象并避免构造函数伸缩时，与工厂模式区别在于：当创建时一步过程时，将使用工厂模式，而当创建是多步骤过程时，将使用构造器模式 原型 通过克隆基于现有对象创建对象, 允许创建现有对象的副本并进行修改，而不是从头开始创建对象并进行设置 程序化示例12345678910111213141516171819202122232425class Sheep &#123; protected $name; protected $category; public function __construct(string $name, string $category = &apos;Mountain Sheep&apos;) &#123; $this -&gt; name = $name; $this -&gt; category = $category; &#125; public function setName(string $name) &#123; $this -&gt; name = $name; &#125; public function getName() &#123; return $this -&gt; name; &#125; public function setCategory(string $category) &#123; $this -&gt; category = $category; &#125; public function getCategory() &#123; return $this -&gt; category; &#125;&#125; 用法： 123456789$original = new Sheep(&apos;Hale&apos;);echo $original -&gt; getName(); // Haleecho $original -&gt; getCategory() // Mountain Sheep// Clone and Modify what is required$cloned = clone $original;$cloned -&gt; setName(&apos;Lv&apos;);echo $cloned -&gt; getName(); // Lvecho $cloned -&gt; getCategory(); // Mountain Sheep 可用魔术方法 __clone() 来修改克隆方法用处： 当需要一个与现有对象类似的对象时，或者与克隆相比，创建的成本会很高 单例 确保只创建特定类的一个对象 程序化示例12345678910111213141516171819202122final Class President &#123; private static $instance; private function __construct() &#123; // Hide the constructor &#125; public static function getInstance(): President &#123; if(!self::$instance) &#123; self::$instance = new self(); &#125; return self::$instance; &#125; private function __clone() &#123; // Disable cloning &#125; private function __wakeup() &#123; // Disable unserialize &#125;&#125; 用法： 1234$president1 = President::getInstance();$president2 = President::getInstance();var_dump($president1 === $president2); // true 结构型设计模式适配器 桥梁 组合 装饰 门面 享元 代理 适配器： 在适配器中包装其他不兼容的对象，以使其与另一个类兼容。 允许将现有类的接口用作另一个接口，通常用于使现有类与其他类一起工作而无需修改其源代码 程序化示例 123456789101112131415interface Lion &#123; public function roar();&#125;class AfricanLion implements Lion &#123; public function roar()&#123; &#125;&#125;class AsianLion implements Lion &#123; public function roar()&#123; &#125;&#125; 实现任何Lion接口可以进行搜索 12345class Hunter &#123; public function hunt(Lion $lion) &#123; $lion -&gt; roar(); &#125;&#125; 12345678910111213class Wilddog &#123; public function bark() &#123; &#125;&#125;// Adapter around wild dog to make it compatible with our game class WildDogAdapter implements Lion &#123; protected $dog; public function __construct(WildDog $dog) &#123; $this -&gt; dog = $dog; &#125;&#125; 12345$wildDog = new WildDog();$wildDogAdapter = new WildDogAdapter($wildDog);$hunter = new Hunter();$hunter -&gt; hunt($wildDogAdapter); 桥梁模式 优先于集成的组合,实现细节从层次结构推送到具有单独层次结构的另一个对象 程序化示例 12345678910111213141516171819202122232425262728interface WebPage &#123; public function __construct(Theme $theme); public function getContent();&#125;class About implements WebPage &#123; protected $theme; public function __construct(Theme $theme) &#123; $this -&gt; theme = $theme; &#125; public function getContent() &#123; return &apos;About page in&apos; . $this -&gt; theme -&gt; getColor(); &#125;&#125;class Careers implements WebPage &#123; protected $theme; public function __construct(Theme $theme) &#123; $this -&gt; theme = $theme; &#125; public function getContent() &#123; return &apos;Careers page in &apos; . $this -&gt; theme -&gt; getColor(); &#125;&#125; 123456789101112131415161718192021interface Theme &#123; public function getColor();&#125;class DarkTheme implements Theme &#123; public function getColor() &#123; return &apos;Dark Black&apos;; &#125;&#125;class LightTheme implements Theme &#123; public function getColor() &#123; return &apos;Off white&apos;; &#125;&#125;class AquaTheme implements Theme &#123; public function getColor() &#123; return &apos;Light theme&apos;; &#125;&#125; 1234567$darkTheme = new DarkTheme();$about = new About($darkTheme);$careers = new Careers($darkTheme);echo $about -&gt; getContent(); // about page in dark blackecho $careers -&gt; getContent(); // Careers page in Dark Black 组合模式 复合模式允许客户以统一的方式处理单个对象 程序化示例 12345678910111213141516171819202122232425262728293031323334interface Employee &#123; public function __construct(string $name , float $salary); public function getName(): string; public function setSalary(float $salary); public function getSalary(): flaot; public function getRoles(): array;&#125;class Developer implements Employee &#123; protected $salary; protected $name; protected $roles; public function __construct(string $name, float $salary) &#123; $this -&gt; name = $name; $this -&gt; salary = $salary; &#125; public function getName(): string &#123; return $this -&gt; name; &#125; public function setSalary(float $salary) &#123; $this -&gt; salary = $salary; &#125; public function getSalary(): float &#123; return $this -&gt; salary; &#125; public function getRoles(): array &#123; return $this -&gt; roles; &#125;&#125; 12345678910111213141516class Organization &#123; protected $employees; public function addEmployee(Employee $employee) &#123; $this -&gt; employees[] = $employee; &#125; public function getNetSalaries(): float &#123; $netSalary = 0; foreach($this -&gt; employees as $emploess) &#123; $netSalary += $employee -&gt; getSalary(); &#125; return $netSalary; &#125;&#125; 123456789$john = new Developer(&apos;John Doe&apos;, 12000);$hale = new Designer(&apos;Hale Lv&apos;, 15000);// Add them to organization()$organization = new Organization();$organization -&gt; addEmployee($john);$organization -&gt; addEmployee($hale);echo &apos;Net Salaries: &apos; . $organization -&gt; getNetSalaries(); // Net Salaries : 27000 装饰模式 通过将对象包装在装饰器类的对象中来动态更改对象在运动时的行为 程序化示例 1234567891011121314interface Coffee &#123; public function getCost(); public function getDescription();&#125;class SimpleCoffee implements Coffee &#123; public function getCost() &#123; return 10; &#125; public function getDescription() &#123; return &apos;Simple Coffee&apos;; &#125;&#125; 添加组件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class MilkCoffee implements Coffee &#123; protected $coffee; public function __constrcut(Coffee $coffee) &#123; $this -&gt; coffee = $coffee; &#125; public function getCost() &#123; return $this -&gt; coffee -&gt; getCost + 2; &#125; public function getDescription() &#123; return $this -&gt; coffee -&gt; getDescription() . &apos; Milk &apos;; &#125;&#125;class WhipCoffee implements Coffee &#123; protected $coffee; public function __construct(Coffee $coffee) &#123; $this -&gt; coffee = $coffee; &#125; public function getCost() &#123; return $this -&gt; coffee -&gt; getCost() + 5; &#125; public function getDescription() &#123; return $this -&gt; coffee -&gt; getDescription() . &apos;whip&apos;; &#125;&#125;class VanlillaCoffee implements Coffee &#123; protected $coffee; public function __constrcut(Coffee $coffee) &#123; $this -&gt; coffee = $coffee; &#125; public function getCost() &#123; return $this -&gt; coffee = getCost() + 3; &#125; public function getDescription() &#123; return $this -. coffee -&gt; getDescription(). &apos; Valilla&apos;; &#125;&#125; 123456789101112131415$someCoffee = new SimpleCoffee();echo $someCoffee -&gt; getCost(); echo $someCoffee -&gt; getDescription();$someCoffee = new MilkCoffee($someCoffee);echo $someCoffee -&gt; getCost();echo $someCoffee -&gt; getDescription();$someCoffee = new WhipCoffee($someCoffee);echo $someCoffee -&gt; getCost();echo $someCoffee -&gt; getDescription();$someCoffee = new VanillaCoffee($someCoffee);echo $someCoffee -&gt; getCost();echo $someCoffee -&gt; getDescription(); 门面模式Facade 模式为复杂的子系统提供了简化的界面 外观是一个对象，它为更大的代码提供了简化的接口，如类库 程序化示例1234567891011121314151617181920212223242526272829class Computer &#123; public function getElectricShock() &#123; echo &apos;CDB&apos;; &#125; public function makeSound() &#123; echo &apos;Liunx&apos;; &#125; public function showLoadingScreen() &#123; echo &apos;Loding ... &apos;; &#125; public function bam() &#123; echo &apos;Ready to be used !&apos;; &#125; public function closeEverything() &#123; echo &apos;Biu biu biu ... !&apos;; &#125; public function sooth() &#123; echo &apos;zzzzz&apos;; &#125; public function pullCurrent() &#123; echo &apos;Hahaha!&apos;; &#125;&#125; 1234567891011121314151617181920class ComputerFacade &#123; protected $computer; pulic function __construct(Computer $computer) &#123; $this -&gt; computer = $computer; &#125; public function turnOn() &#123; $this -&gt; computer -&gt; getElectricShock(); $this -&gt; computer -&gt; makeSound(); $this -&gt; computer -&gt; showLoadingScreen(); $this -&gt; computer -&gt; bam(); &#125; public function turnOff() &#123; $this -&gt; computer -&gt; closeEverything(); $this -&gt; computer -&gt; pullCurrent(); $this -&gt; computer -&gt; sooth(); &#125;&#125; 123$computer = new ComputerFacade(new Computer());$computer -&gt; turnOn();$computer -&gt; turnOff(); 享元模式 通过尽可能多地与类似对象共享来最小化内存使用或计算开销 程序示例 123456789101112class KarakTea &#123;&#125;class TeaMaker &#123; protected $availableTea = []; public function make($preference) &#123; if(empty($this -&gt; availableTea[$preference])) &#123; $this -&gt; availableTea[$preference] = new KarakTea(); &#125; return $this -&gt; availableTea[$preference]; &#125;&#125; 123456789101112131415161718class TeaShop &#123; protected $orders; protected $teaMaker; public function __construct(TeaMaker $teaMaker) &#123; $this -&gt; teaMaker = $teaMaker; &#125; public function takeOrder(string $teaType, int $table) &#123; $this -&gt; orders[$table] = $this -&gt; teaMaker -&gt; make(teaType); &#125; public function serve() &#123; foreach($this -&gt; orders as $table =&gt; $tea) &#123; echo &apos;Serving tea to table &apos; . $table; &#125; &#125;&#125; 12345678$teaMaker = new TeaMaker();$shop = new TeaShop($teaMaker);$shop -&gt; takeOrder(&apos;Less Sugar&apos;);$shop -&gt; takeOrder(&apos;More Milk&apos;);$shop -&gt; takeOrder(&apos;Without Sugar&apos;, 5);$shop -&gt; serve(); 代理模式 类表示另一个类的功能 程序化示例 1234567891011121314interface Door &#123; public function open(); public function close();&#125;class LabDoor implements Door &#123; public function open() &#123; echo &apos;Opening lab door&apos;; &#125; public function close() &#123; echo &apos;Closing the lab door&apos;; &#125;&#125; 1234567891011121314151617181920212223class SecuredDoor &#123; protected $door; public function __constrcut(Door $door) &#123; $this -&gt; door = $door; &#125; public function open($password) &#123; if($this -&gt; authenticate($password)) &#123; $this -&gt; door -&gt; open(); &#125;else &#123; echo &apos;Big no! &apos;; &#125; &#125; public function authenticate($password) &#123; return $password === &apos;$ecr@t&apos;; &#125; public function close() &#123; $this -&gt; door -&gt; close(); &#125;&#125; 用法： 12345$door = new SecureDoor(new LabDoor());$door -&gt; open(&apos;invalid&apos;);$door -&gt; open(&apos;$ecr@t&apos;);$door -&gt; close(); 行为型设计模式责任链 命令行 迭代器 中介者 备忘录 观察者 访问者 策略 状态 模板 责任链 构建一系列对象,请求从一端进入并继续从一个对象到另一个对象，直到找到合适的处理程序 程序示例 123456789101112131415161718192021222324252627282930313233343536373839abstract class Account &#123; protected $successor; protected $balance; public function setNext(Account $account) &#123; $this -&gt; succcessor = $account; &#125; public function par(float $amountToPay) &#123; if($this -&gt; canPay($amountToPay)) &#123; echo sprintf(&apos;Paid %s using %s &apos; . PHP_EOL, $amountToPay, get_called_class()); &#125;else if($this -&gt; successor) &#123; echo sprintf(&apos;Cannot pay using %s. Proceeding..&apos; .PHP_EOL, get_called_class()); $this -&gt; successor -&gt; pay($amountToPay); &#125;else &#123; throw new Exception(&apos;None of the accounts have enough balance&apos;); &#125; &#125; public function canPay($amount): bool &#123; return $this -&gt; balance &gt;= $amount; // 原文是 &gt;= ,感觉应该是 = &#125;&#125;class Bank extends Account &#123; protected $balance; public function __construct(float $balance) &#123; $this -&gt; balance = $balance; &#125;&#125;class Bitcoin extends Account &#123; protected $balance; public function __constrcut(flaot $balance) &#123; $this -&gt; balance = $balance; &#125;&#125; 12345678$bank = new Bank(100);$paypal = new Paypal(200);$bitcoin = new Bitcoin(300);$bank -&gt; setNext($paypal);$paypal -&gt; setNext($bitcoin);$bank -&gt; pay(259); 命令行 将操作封装在对象中，提供将客户与接收器分离的方法. 对象用于封装执行动作或稍后触发事件所需的所有信息，此信息包括方法名称，拥有该方法的对象以及方法参数的值。 程序化示例 123456789class Bulb &#123; public function trunOn() &#123; echo &apos;Buld has been lit&apos;; &#125; public function turnOff() &#123; echo &apos;Darkness !&apos;; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445interface Command &#123; public function execute(); public function undo(); public function redo();&#125;class TurnOn implements Command &#123; protected $bulb; public function __construct(Bulb $bulb) &#123; $this -&gt; bulb = $bulb; &#125; public function execute() &#123; $this -&gt; bulb -&gt; turnOn(); &#125; public function undo() &#123; $this -&gt; bulb -&gt; turnOff(); &#125; public function redo() &#123; $this -&gt; execute(); &#125;&#125;class TurnOff implements Command &#123; protected $bulb; public function __constrcut(Bulb $bulb) &#123; $this -&gt; bulb = $bulb; &#125; public function execute() &#123; $this -&gt; bulb -&gt; turnOff(); &#125; public function undo() &#123; $this -&gt; bulb -&gt; turnOn(); &#125; public function redo() &#123; $this -&gt; execute(); &#125;&#125; 12345class RemoteControl &#123; public function submit(Command $command) &#123; $command -&gt; execute(); &#125;&#125; 12345678$bulb = new Bulb();$turnOn = new TurnOn($bulb);$turnOff = new TurnOff($bulb);$remote = new RemoteControl();$remote -&gt; submit($turnOn);$remote -&gt; submit($turnOff); 迭代器 提供了一种访问对象元素而不是暴露底层表示的方法 用于遍历容器并访问容器的元素,将算法与容器分离，因算法是特定于容器，so 不能解耦 程序化示例 1234567891011class RadioStation &#123; protected $frequency; public function __construct(float $frequency) &#123; $this -&gt; frequency = $frequency; &#125; public function getFrequency(): float &#123; return $this -&gt; frequency; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142use Countable;use Iterator;class StationList implements Countable, Iterator &#123; protected $stations = []; protected $counter = []; public function addStation(RadioStation $station) &#123; $this -&gt; stations[] = $station; &#125; public function removeStation(RadioStation $toRemove) &#123; $toRemoveFrequency = $toRemove -&gt; getFrequency(); $this -&gt; stations = array_filter($this -&gt; stations, function(RadioStation $station) use ($toRemoveFrequency) &#123; return $station -&gt; getFrequency() !== $toRemoveFrequency; &#125;); &#125; public function count(): int &#123; return count($this -&gt; stations); &#125; public function current(): RadioStation &#123; return $this -&gt; stations[$this -&gt; counter]; &#125; public function key() &#123; return $this -&gt; counter; &#125; public function next()&#123; $this -&gt; counter++; &#125; public function rewind() &#123; $this -&gt; counter = 0; &#125; public function valid(): bool &#123; return isset($this -&gt; stations[$this -&gt; counter]); &#125;&#125; 123456789101112$stationList = new StationList();$stationList -&gt; addStation(new RadioStation(89));$stationList -&gt; addStation(new RadioStation(90));$stationList -&gt; addStation(new RadioStation(100));$stationList -&gt; addStation(new RadioStation(120.3));foreach($stationList as $station) &#123; echo $station -&gt; getFrequency() . PHP_EOL;&#125;$stationList -&gt; removeStation(new RadioStation(89)); 中介者 添加第三方对象控制两个对象之间的交互,减少彼此通信的类之间的耦合，不需要了解彼此的实施。 中介模式定义了一个对象，该对象封装了一组对象的交互方式，可以改变程序的运行行为。 程序化示例 123456789101112interface ChatRoomMediator &#123; public function showMessage(User $user, string $message);&#125;class CharRoom implements CharRoomMediator &#123; public function showMessage(User $user, string $message) &#123; $time = date(&apos;M d, y H:i&apos;); $sender = $user -&gt; getName(); echo $time . &apos;[&apos; . $sender .&apos;]:&apos; . $message; &#125;&#125; 1234567891011121314151617class User &#123; protected $name; protected $charMediator; public function __constrcut(string $name, ChatRoomMediator $chatMediator) &#123; $this -&gt; name = $name; $this -&gt; chatMediator = $chatMediator; &#125; public function getName() &#123; return $this -&gt; name; &#125; public function send($message) &#123; $this -&gt; chatMediator -&gt; showMessage($this, $message); &#125;&#125; 1234567$mediator = new ChatRoom();$hale = new User(&apos;Hale Lv &apos;, $mediator);$judy = new User(&apos;Judy &apos;, $mediator);$hale -&gt; send(&apos;Hi there!&apos;);$judy -&gt; send(&apos;Hey!!!&apos;);]]></content>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NoSQL]]></title>
    <url>%2F2019%2F08%2F11%2FNoSQL-Note%2F</url>
    <content type="text"><![CDATA[NoSQL TODO ListRedis Memcached]]></content>
      <categories>
        <category>NoSQL</category>
        <category>Redis</category>
        <category>Memcached</category>
      </categories>
      <tags>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL]]></title>
    <url>%2F2019%2F08%2F11%2FMySQL-Note%2F</url>
    <content type="text"><![CDATA[MySQL TODO LIST基本语法常见用法集群缓存主从复制双主热备分库分表分布式架构 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667创建表： create table tb [if not exists] _name( `id` int(10) auto_incrementl, `name` varchar(20) not null default &apos;&apos;, `user_id` int(10) default 1, `salary` float unique, `create_at` time, primary key(id,user_id), contraint fk_name foreign key (field) references other_tb(id) ); 主键约束： primary key 外键约束： foreign key 非空约束： not null 唯一性约束：unique 默认约束：default value 自动增加： auto__increment查看表： describe describe tb_name / desc tb_name;查看表结构： show create table tb_name \G查看警告信息： show warnings;修改数据表: 修改表名： alter table tb_oldName rename tb_newName;修改自增ID值 alter table tb_name auto_increment = 1修改字段的数据类型： alter table tb_name modify id int(11);修改字段名： alter table tb_name change tb_old_field tb_new_field int(10);添加字段： alter table tb_7 add name varchar(100) [first|after id];删除字段： alter table tb_7 drop fieldName;修改字段的排列位置： alter table tb_7 modify name varchar(30) [first|after] id; 修改表的存储引擎： alter table tb_7 engine = myisam;删除表的外键约束： alter table tb_7 drop foreign key FK_Name;删除数据表: drop table [if exists] tb_name;删除没有被关联的表: drop table tb_name;删除被其他表关联的表的主表： 全部删除：删除会破坏表的参照完整性，先删除与之关联的子表，再删除父表，这样会删除两个表中的数据。 单独删除：如果保存子表，只需将关联表的外键约束条件取消，然后删除父表 alter table tb_name drop foreign key FK_Name; 123456789101112131415161718192021222324252627282930数据类型:整数类型: tinyint smallint mediumint int(integer) bigint浮点类型: 浮点类型：float double 定点类型：decimal字符串类型： char varchar binary varbinary blob text enum set二进制类型： bit binary varbinary tinyblob blob mediumblob longblob运算符： 算数运算： + - * / 比较运算:结果为 0，1 或者 null = &lt;=&gt; &lt;&gt; (!=) &lt;= &gt;= &gt; is null it not null least greatest between and isnull in not in like regexp 逻辑运算： false null not null and &amp;&amp; or || xor 位操作运算： | &amp; 异或：^ &lt;&lt; &gt;&gt; 取反：~ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879函数：数学函数： 绝对值函数： abc() 平方根函数|求余函数： mod(x,y) 获取整数函数： ceil(x), ceiling(x) , floor(x) 随机整数函数： rand() rand(x) 四舍五入函数： round(x), round(x,y), truncate(x,y) 符号函数： sign(x) 幂运算函数： pow(x,y), power(x,y), exp(x) 对数运算函数： log(x) , log10(x) 角度与弧度相互转换的函数： radians(x), degrees(x) 正弦函数： sin(x)， 反弦函数: asin(x) 余弦函数： cos(x), 反余弦函数： acos(x) 正切函数、反正切函数、余切函数字符串函数： 计算长度的函数： length(), char_length() 合并字符串的函数： concat(str,str1...), concat_ws(str,str1...) 替换字符串的函数： insert(str1, x ,len,str2) 大小写转换函数： lower(), upper() 获取指定长度的字符串的函数： left(s,n), right(s,n) 填充字符串的函数： lpad(str1,len,str2), rpad(str1,len,str2) 删除空格的函数： ltrim(s), rtrim(s), trim(s) 删除指定字符串的函数： trim(str1 from s) 重复生成字符串的函数： repeat(s,n) 比较字符串大小的函数： strcmp(str,str1) 获取字串的函数： substring(s,n,len), mid(s,n,len) 匹配字串开始位置的函数： locate(&apos;s&apos;,&apos;str&apos;); position(&apos;s&apos; in &apos;str&apos;); instr(&apos;str&apos;,&apos;s&apos;); 字符串逆序的函数： reverse(s) 返回指定位置的字符串的函数： 返回指定字符串位置的函数： field(s,s1,s2) 返回字串位置的函数： find_in_set(s1,s2) 选取字符串的函数： make_set(x,s1,s2...)日期和时间函数： 当前日期和时间的函数：curdate(), current_date(), curdate() 时间函数获取系统当前时间：curtime(), current_time(), curtime() 获取当前系统日期和时间： current_timestamp(), localtime(), now(), sysdate() Unix时间戳函数：unix_timestamp() 将UNIX时间戳转为普通格式时间： from_unixtime(&apos;1232131&apos;) 返回UTC日期的函数和返回UTC时间的函数：utc_date(), utc_time(), 返回月份的函数： month(date), monthname(date) 获取日期的函数： dayname(d)， dayofweek(d), weekday(d) 获取天数的函数： dayofyear(d), dayofmonth(d) 获取年份、季度、小时、分钟、秒钟的函数：year(), quarter(), minute(), second() 获取日期的指定值的函数： extract(type from d) 时间和秒钟转换的函数：time_to_sec(), sec_to_time(), 计算日期和时间的函数：date_add(), adddate(), date_sub(), subdate(), addtime(), datediff(),subtime(), 将日期和时间格式化的函数：date_format(), time_format(), get_format(), 条件判断函数： if(expr,v,v1) ifnull(v1,v2) case, case value when, case when系统信息函数: 获取版本号、连接数、数据库名的函数：select version(), connect_id(), show processlist() select database(), select schema() 获取用户名的函数：select user() | current_user() | system_user() 获取字符串的字符集和排序方式的函数：charset(&apos;abc&apos;), charset(convert(&apos;abc&apos; using latin1), charset(version)) 获取最后一个自动生成的ID值的函数：select last_insert_id() 加密函数： password(str) md5(str) 加密函数：encode(str,pswd_str) 解密函数：decode(crypt_str,pswd_str)其他函数： 格式化函数：format() 不同进制的数字进行转换的函数：conv() IP地址与数字相互转换的函数：inet_aton(), inet_ntoa() 加锁函数和解锁函数：select get_lock(), is_used_lock(), is_free_lock(), release_lock() 重复执行指定操作的函数：denchmark() 改变字符集的函数：convert() 改变数据类型的函数：cast(), convert() 123456789101112131415161718192021222324252627282930313233343536查询语句： 基本查询： select &#123; * | &#125; [from table_name [ where &lt;&gt;] [group by &lt;&gt;] [ having &lt;&gt; ] [ order by &lt;&gt; ] [ limit [&lt;&gt;,] &lt;row count&gt;] ] select filed,field1...fieldN from [table | view] where [&lt;condition&gt;] 单表查询： 查询所有字段：select * from table; 查询指定字段：select filed,field1... from table; 查询指定记录：select filed,filed1... from table where condition; 带 IN 关键字的查询：select filed,filed1... from table where filed in (a,z) order by field; 带 Between and 的范围查询：select filed from table where filed between a and z; 带 Like 的字符匹配查询：select filed from table where filed like &apos;%&apos; % 匹配任意长度的字符， _ 下划线只能匹配任意一个字符 查询空值：select filed from table where filed is null | is not null 带 And 的多条件查询：select field, field1 from table where filed &gt; condition and filed &gt; condition; 带 Or 的多条件查询：select field, filed1 from table where field = condition or filed1 = condition; 查询结果不重复：select distinct field from table; 对查询结果排序：select field,filed1 from table order by field | desc | asc 分组查询： gourp by field having condition 创建分组，使用having过滤分组， 在group by 字句中使用with rollup， 多字段分组 group by 和order by 一起使用 select filed,filed1 from table gourp by filed having count(filed1) &gt; condition;&lt;F8&gt;&lt;F9&gt; select filed,field1 from table gourp by filed with rollup; 用Limit 限制查询结果的数量：select * from table limit n | n,m; 集合函数查询： count(), sum() avg() max() min() 连接查询： 内连接：inner join select tb_1.field from table where tb_2.filed = tb_1.id; 外连接：left join, right join 复合条件连接查询： 子查询： 子查询： 合并查询： 为表和字段取别名： 正则表达式查询：]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo]]></title>
    <url>%2F2019%2F08%2F11%2FHexo-Note%2F</url>
    <content type="text"><![CDATA[Hexo 基础和语法 npm install -g hexo-clihexo init &lt;Folder&gt;npm installvim package.jsonhexo new [layout] &lt;title&gt;hexo generate = hexo ghexo publish [layout] &lt;filename&gt;hexo server -p xxxx -s --static -l --loghexo deploy = hexo dhexo render &lt;file1&gt; [file2] ... -o --outputhexo migratehexo clean = hexo chexo list &lt;type&gt;hexo versionhexo --safehexo --debughexo --silenthexo --config custom.ymlhexo --drafthexo --cwd /path/to/cwd npm install hexo-migrator-rss --savehexo migrate rss &lt;source&gt;npm install hexo-migrator-wordpress --savehexo migrate wordpress &lt;source&gt; Writehexo new [layout] &lt;title&gt;layout: post &gt; source/_posts page &gt; source draft &gt; source/_draftshexo new photo &quot;TEXT&quot; Front-Matter1234567891011121314151617181920212223242526272829title: TEXTdate: DATEupdated: UPDATE_TIMEcomments: truetags: TEXTcategories: TEXTpermalink: urlkeywords: TEXTcopyright: true Tag Plugins引用块&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125; content &#123;% endblockquote %&#125; 代码块&#123;% codeblock [title] [lang:language] [url] [link text] %&#125;code snippet&#123;% endcodeblock %&#125; 反引号代码块&#123;% pullquote [class] %&#125;content&#123;% endpullquote %&#125; SERVERnpm install hexo-server --savehexo server -p 5000hexo server -shexo server -i 192.168.1.1 MADE FILEShexo generatehexo generate --watchhexo generate --deployhexo deploy --generatehexo g -dhexo d -g DEPLOYnpm install hexo-deploy-git --savehexo deploydeploy: type: git repo: &lt;repository url&gt; branch: [branch_name] message: [message] SFTPnpm install hexo-deployed0-sftp --savevim _config.yml deploy: type: sftp host: &lt;host&gt; user: &lt;user&gt; pass: &lt;password&gt; remotePath: [remote path] port: [port] privateKey: [path/to/privateKey] passphrase: [passphrase] agent: [path/to/agent/socket] PERMALINKSvim _config.yml permalink_defaults: lang: en|zh-Hans THEMEgit clone git@github.com/&lt;username&gt;/xxx.git theme/xxx cd xxx npm install TEMPLATEindex 首页 post 文章 page 分页 archive 归档 category 分类 tag 标签 具体看官方APIHEXO-DOC]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript]]></title>
    <url>%2F2019%2F08%2F11%2FJavaScript-Note%2F</url>
    <content type="text"><![CDATA[JavaScript]]></content>
      <categories>
        <category>JavaScript</category>
        <category>JQuery</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx]]></title>
    <url>%2F2019%2F08%2F11%2FNginx-Note%2F</url>
    <content type="text"><![CDATA[iFaithFreedom TODO LIST基本语法常见用法虚拟主机反向代理缓存负载均衡 配置文件由指令与指令块构成Nginx_DOC每条指令以 ； 分号结尾，指令与参数间以空格符号分隔指令块以 {} 大括号将多条指令组织在一起include 语句允许组合多个配置文件以提升可维护性使用# 符号添加注释，提高可读性使用 $ 符号使用变量部分指令的参数支持正则表达式配置参数： 时间的单位s: seconds m: minutes h:hours d:days w:weeks M:months,30 days y:years,365 days 空间的单位bytes k/K: kilobytes m/M: megabytes g/G: gigabyteseg: &#123;12345678910111213141516 include mime.types; upstream xxx &#123; server 127.0.0.1:8000; &#125;&#125;server &#123; listen 443 http2; # Nginx Config syntax limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s; location ~* \.(gif|jpg|jpeg)$ &#123; proxy_cache my_cache; expires 3m;proxy_cache_key $host$uri$is_args$args; proxy_cache_valid 200 304 302 1d; proxy_pass http://xxx.xxx; &#125;&#125; 重载，热部署，日志切割Nginx 命令行：格式： nginx -s reload帮助： -？ -h使用指定的配置文件： -c指定配置指令： -g指定运行目录： -p发送信号： -s ： 立刻停止服务： stop 优雅的停止：quit 重载配置文件： reload 重新开始记录日志文件 reopen测试配置文件是否有语法错误： -t -T打印nginx的版本信息、编译信息等： -v -V 重载： nginx -s reload热部署：nginx 版本升级， 编译安装， kill -USR2 nginxID(ps -ef | grep nginx), kill -WINCH ID(进程号)日志切割：xxx.lg(日志文件) nginx -s reopen Nginx 配置静态资源Web服务器http { include mime.types; #default_type application/octet-stream; log_format main ‘$remote_addr - $remote_user [$time_local] “$request” ‘ ‘$status $body_bytes_sent “$http_referer” ‘ ‘“$http_user_agent” “$http_x_forwarded_for”‘; client_max_body_size 60M; proxy_cache_path /tmp/nginxcache levels=1:2 keys_zone=my_cache:10m max_size=10g inactive=60m use_temp_path=off; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; gzip on; gzip_min_lengt 1; gzip_comp_level 2; gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png; } server { listen 8080; server_name hale.dev; access_log logs/hale.dev.log main; location / { alias dirpath/; #autoindex on; # 开启目录浏览功能 #set $limit_rate 1k; # 限制访问速度 每秒传输1kb #index index.html index.htm; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; } nginx -s reloadNginx 搭建缓存功能的反向代理服务openresty实现反向代理 include vhost/****.conf;upstream local { server 127.0.0.1:8080;} server { server_name hale.dev; listen 80; location / { proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; #proxy_cache my_cache; #proxy_cache_key $host$uri$is_args$args; #proxy_cache_valid 200 304 302 1d; proxy_pass http://local; }} 此处的配置详情可以在Nginx官网 ngx__http__proxy_module 中获取GoAccess实现可视化并实时监控access日志]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown]]></title>
    <url>%2F2019%2F08%2F11%2FMarkDown-Note%2F</url>
    <content type="text"><![CDATA[MarkDown 基础、语法 斜体、粗体 *斜体* _斜体 _ **粗体** *** 加粗斜体 *** ~~ 删除线 ~~ 分级标题 # ## ## ### #### ##### ###### 超链接 TEXT[Your Message](https://i-china.github.io/) TExt[Your Text][https://i-china.win/ &quot;message&quot;] 锚点 Goto[Redirect](#TEXT) 列表 无序列表 * + - 有序列表 1. Text 2. Text 3. Text ... 代码缩进 * TEXT // * 后三空格 列表引用 &gt; TEXT &gt; TEXT 引用 列表嵌套 &gt;&gt;&gt; TEXT &gt;&gt; TEXT &gt; TEXT 其他要素 &gt; T1 &gt; T2 &gt; T3 &gt; T4 ... 插入图片 TEXT:![TEXT](URL &quot;TEXT&quot;) 内容目录 [TOC] 注脚 TEXT[^1] TEXT[^2] TEXT[^flag] [^1]: TEXT Comment [^2]: TEXT Comment [^flag]: TEXT FOR flag 公式$ 表示行内公式 $E=mc^2$$$ 整行公式 $$\sum_{i=1}^n a_i=0$$ 流程图st=&gt; start: START:&gt;url e=&gt;end: TEXT:&gt;url op1=&gt;operation: text|past // 有些复杂，不经常用，先不写了 表格居左：:---- 居中：:----:或者 ----- 居右：:----:TEXT|TEXT|TEXT-|-|-|TEXT|TEXT|TEXTTEXT|TEXT|TEXT-----------TEXT|TEXT-|-:TEXT TEXT | TEXT/TEXT 分割线* * *********- - ---------- 代码CODE()``` #include&lt;stdio.h&gt; ``` 换行行后 加两空格 文本&lt;center&gt; TEXT &lt;/center&gt;&lt;left&gt; TEXT &lt;/left&gt;&lt;right&gt; TEXT &lt;/right&gt;&lt;u&gt; TEXT &lt;/u&gt; 备注： 有些不清楚，需要随用随查！]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang]]></title>
    <url>%2F2019%2F08%2F09%2FGolang-Note%2F</url>
    <content type="text"><![CDATA[iFaithFreedom TODO List]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python]]></title>
    <url>%2F2019%2F08%2F09%2FPython-Note%2F</url>
    <content type="text"><![CDATA[Python Note]]></content>
      <categories>
        <category>Python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux]]></title>
    <url>%2F2019%2F08%2F09%2FLinux-Note%2F</url>
    <content type="text"><![CDATA[Linux TODO ListCentos Ubuntu Linux 文件和目录管理cd: 切换目录 cd 选项~ ： 当前用户的主目录 ~用户名：指定用户的主目录 - ： 上次所在的目录 . : 当前目录 ..: 上级目录 pwd：显示当前路径 whoami：当前登陆的用户 ls： 查看目录下文件 ls 选项 文件 -a: 全部文件 -A: 全部不包括. .. -d: 目录本身 -f: 以文件名排序 -F: 再文件或目录后加上类型的指示符号 -h: 以易读方式显示 -i:显示inode节点信息 -n: 以UID和GID代替用户名和群组 -r: 将排序结果反向输出 -R: 列出目录下所有文件 -S: 以文件容量大小排序 -t: 以时间排序 -l: 使用长格式列出文件和目录信息 ls:第一列： 权限 第二列：计数(硬连接数) 第三列：所有者 第四列：所属组 第五列：大小 第六列：文件修改时间 第七列: 文件名和目录名 mkdir：创建目录文件夹 mkdir 选项 文件目录名 -p: 递归创立目录 -m: 自定义目录权限 rmdir: 删除空目录 rmdir 选项 文件目录名 -p：递归删除空目录 rmdir touch：创建文件及修改文件时间戳 touch 选项 文件名 选项： -a：访问时间 -c：时间参数 -d：修订日期 -m：修改时间 -t：修订时间 ln：在文件之间建立链接(硬链接和软链接) ln 选项 源文件 目标文件 -s：建立软链接文件，不加-s 则建立硬链接 -f：强制 如果目标文件存在，则删除后再建立链接文件 cp：复制文件和目录 cp 选项 源文件 目标文件 -a：相当于 -d -p -r 的集合 -d：如源文件为软链接，则复制出的目标文件也为软链接 -i：询问 是否覆盖 -l：把目标文件建立为源文件的硬链接，而不是复制源文件 -s：把目标文件建立为源文件的软连接，而不是复制。。。 -p：复制后目标文件保留源文件的属性 所有者、所属组、权限和时间 -r：递归复制，用于复制父母 -u：若目标文件比源文件有差异，则使用该选项更新目标文件，用于对文件的升级和备用 rm：删除文件或目录 rm 选项 文件或目录 -f： 强制删除 -i: 删除前给出提示 -r： 递归删除，用于目录 mv：移动文件或改名 mv 选项 文件或目录 -f：强制覆盖，不询问，直接覆盖 -i：交互移动，询问是否覆盖 -n：如果目标文件已存在，不会覆盖移动，也不询问 -v: 显示文件或目录移动过程 -u: 若目标文件存在，两者相比，源文件更新，对目标文件进行升级 打包(归档)和压缩tar：打包 tar 选项 源文件或目录 -c：将多个文件或目录打包 -A：追加tar文件到归档文件 -f：指定包的文件名 -v：显示打包过程 -x：对tar包做 解压 -C：指定解压包位置 -z：压缩和解压缩”.tar.gz” -j：压缩和解压缩”.tar.bz2” tar.gz: -zxvf -zcvftar.bz2: -jxvf -jcvf zip: 压缩文件和目录 zip 选项 压缩包名 源文件或源目录列表 -r： 递归压缩目录，所有文件以及目录全部压缩 -m： 压缩后，删除源文件 -v： 显示详细的压缩过程 -q： 不显示命令执行过程 -压缩级别： 1~9 -1 代表压缩速度最快 -9 代表压缩效果更好 -u： 更新压缩文件，往压缩文件添加新文件 unzip：解压zip文件 unzip 选项 压缩包名 -d 目录： 将压缩文件解压到指定目录下 -n： 解压时不覆盖存在的文件 -o： 解压时覆盖已经存在的文件，无需确认 -v： 查看压缩文件的详细信息 -t： 测试有无损坏，并不解压 -x 文件列表: 解压文件，但不包含文件列表中指定的文件 gzip：压缩文件或目录 gzip 选项 源文件 -c：将压缩数据输出到标准输出中，保留源文件 -d：对压缩文件解压 -r：递归压缩指定目录下以及目录下的所有文件 -l：对每一个压缩文件 显示字段 压缩文件大小 未压缩大小 压缩比 未压缩名称 -数字 ：指定压缩等级， -1 等级最低，压缩比最差 gunzip：解压缩文件或目录 gunzip 选项 文件 -r：递归处理，解压缩指定目录下所有文件 -c：把解压缩后的文件输出到标准设备 -f：强制解压缩文件，不理会是否已存在 -l：列出压缩文件内容 -v：显示命令执行过程 -t：测试压缩文件是否正常，不做任何操作 bzip2：压缩文件 bz2格式 bzip2 选项 源文件 -d: 执行解压缩 -k: 解压缩完成后，删除源文件，要保留源文件，需使用此选项 -f：再解压或解压缩时，若同名，默认不覆盖，此选项会强制覆盖现有文件 -t：测试压缩或解压缩的完整性 -v：显示详细信息 -数字： -1 等级最低，压缩比最差 -9 压缩比最高 bunzip2 bz2 格式的及压缩命令 bunzip2 选项 -k: 解压缩后，默认删除压缩文件，若要保留，使用此参数 -f： 解压缩时，若同名，默认不覆盖，若要覆盖，使用此参数 -v： 显示命令执行过程 -L: 列出压缩文件内容 三剑客 grep sed awkcat： 连接文件并打印输出到标准输出设备 cat 选项 文件名 -A：列出所有隐藏符号 -E: 列出每行结尾的回车符$ -n：对输出的所有行进行编号 -b：只对非空行进行编号 -T：把Tab键 ^| 显示 -V：列出特殊字符 -s：连续2行以上的空白行，替换为1行的空白行 &gt;: 合并 &gt;&gt;：追加 more：分屏显示文件内容 more 选项 文件名 -f：计算行数 实际的行数， -p：清屏后显示内容 -c：先显示内容再清楚旧的资料 -s：连续两行以上的空白行，就替换为一行的空白行 -u：不显示下引号 +n：从第n行开始显示文件内容，n代表数字 -n：一次显示的行数，n表示数字 交互指令及功能 h或？： 帮助信息 q或Q ： 退出 v： 在当前行启动一个编辑器 ：f 显示当前文件的文件名和行号 !&lt;命令&gt;：在子shell中执行指定命令 回车：向下移动一行 空格：向上移动一行 Ctrl+l：刷新屏幕 =： 显示当前行的行号 ‘： 转到上一次搜索开始的地方 Ctrl+f： 向下滚动一页 .：重复上次输入的命令 /字符串：搜索指定的字符串 d：向下移动半页 b：向上移动半页 head：显示文件开头的内容 head 选项 文件名 -nK： K表示行数，除了文件最后K行外，显示剩余的全部内容 -cK： K表示字节，除了文件最后K字节，显示剩余全部的内容 -v： 显示文件名 less： 查看文件内容 less 选项 文件名 -N： 显示每行的行号 -S： 行过长时舍弃超出部分 -e： 文件显示结束后，自动离开 -g： 只标志最后搜索到的关键词 -Q： 不使用警告音 -i： 忽略搜索时的大小写 -m： 显示类似more的百分比 -f: 强迫打开特殊文件 -s: 显示连续行为一行 -b： 设置缓冲区的大小 -o： 将less输出的内容保存到指定文件中 -x： 将tab键显示为规定的数字空格 交互指令及功能 / ? n N b d h|H q|Q y 空格键 回车键 PgDn PgUp Ctrl + f Ctrl + b Ctrl + d Ctrl + u j k G g ZZ v [ ] p u tail： 显示文件结尾的内容 tail 选项 文件名 -nK： K指行数，从文件的第K行开始输出 -cK： K指字节数，从文件第K个字节开始输出 -f： 输出文件变化后新增加的数据 grep： 查找文件内容 正则表达式正则表达式的通配符 c* ： 匹配0个空白或多个字符c(c为任一字符) . ： 匹配任何一个字符，只能是一个字符 [xyz]：匹配方括号中的任意一个字符 [^xyz]：匹配除方括号中字符外的所有字符 ^ ： 锁定行的开头 $ ： 锁定行的结尾 需结合反斜杠 \， grep 命令基本格式： grep 选项 模式 文件名 -c ：列出文件中包含模式的行数 -i ：忽略模式中的字母大小写 -l ：列出带有匹配行的文件名 -n ：在每一行的最前面列出行号 -v ：列出没有匹配模式的行 -w ：把表达式当作一个完整的单字符来搜寻，忽略部分匹配的行sed 根据脚本命令处理文本文件中的数据，命令从命令行输入，或存储在一个文本文件中，此命令执行数据顺序： 1.每次仅读取一行内容 2. 根据规格命令匹配并修改数据 3.将执行结果输出sed 选项 脚本命令 文件名 -e 脚本命令： 将其后跟的脚本命令添加到已有的命令中 -f 脚本命令文件： 将其后文件中的脚本命令添加到已有的命令中 -n ： 所有脚本指定执行完毕后，自动输出处理后的内容，需使用print来输出 -i ： 直接修改源文件，慎用！ sed 脚本命令 sed s 替换脚本命令： [address]s/pattern/reloacement/flags address : 指定要操作的具体行 pattern ：需要替换的内容 replacement：要替换的新内容 sed s 命令 flags 标记及功能 n ： 1-512 之间数字，表示指定要替换的字符串出现第n次时才进行替换 g ： 匹配到的所有内容进行替换 p ： 打印与替换命令中指定的模式匹配的行 与-n选项使用 w file ：将缓冲区中的内容写道指定的file文件中 &amp; ： 用正则表达式匹配到的内容进行替换 \n ： 匹配第n个字串，该字串之前在pattern中用 \(\) 指定 \ ： 转义 sed d 替换脚本命令 需要删除文本中的特定行，用d脚本命令，删除指定行中的所有内容，如忘记指定具体行，删删除所有内容 [address]d sed a | sed i 脚本命令 a 表示在指定行的后面附加一行，i表示在指定行的前面插入一行 [address]a(i或) \新文本内容 sed c 替换脚本命令 c 表示将指定行中的所有内容，替换成该选项后面的字符串 [address]c\用于替换的新文本 sed y 转换脚本命令 y 转换命令唯一可以处理单个字符 [address]y/inchars/outchars/ sed p 打印脚本命令 p 搜索符号条件的行，输出该行的内容 [address]p sed w 脚本命令 w 将文本中指定行的内容写入文件 [address]w filename sed r 脚本命令 r 将一个独立文件的数据插入到当前数据流的指定位置 [address]r filename sed q 退出脚本命令 q 使sed命令在第一次匹配任务结束后，退出sed程序sed 脚本命令的寻址方式 两种： 1.[address]脚本命令 2.address{ 多个脚本命令 }awk 文本数据处理工具基本格式： awk 选项 &apos;脚本命令&apos; 文件名 -F fs ：指定以fs作为输入行的分隔符，默认以分隔符为空格或制表符 -f file ：从脚本文件中读取awk脚本指令，取代直接在命令行中输入指令 -v var=val：在执行前，设置一个变量var，初始值为 val awk 使用数据字段变量 $0 ：代表整个文本行 $1 ： 代表文本行的第1个数据字段 $2 : 。。。第2个数据字符按 $n : 代表第n个数据字段 awk 脚本命令使用多个命令 awk &apos;{ $a = &quot;some text&quot; print $0 }&apos; awk 从文件中读取程序 awk -F: -f awk.sh /etc/passwd awk BEGIN 关键字 awk &apos;BEGIN&apos; {print &quot;text&quot;} awk END 关键字 awk &apos;ENG&apos; {print &quot;text&quot;}软件安装相关RPM 包安装、卸载、升级 /etc/ ：配置文件安装目录 /usr/bin/ ：可执行的命令安装目录 /usr/lib/ ：程序所使用的函数库保存位置 /usr/share/doc/ ：基本的软件使用手册保存位置 /usr/share/man/ ：帮助文件保存位置RPM 包的安装 rpm -ivh 包名 -i ：安装(install) -v ：显示详细信息(verbose) -h ：打印 # 显示安装进度(hash) rpm -ivh x.rpm xx.rpm xxx.rpm rpm 选项 包名 -nodeps ： 不检测依赖性安装 -replacefiles ：替换文件安装 -replacepkgs ：替换软件包安装 -force ：强制安装 -test ：测试安装 -prefix ：指定安装路径 软件的启动和管理service 服务名 start | stop | restart | status stat: 启动服务 stop: 停止服务 restart: 重启服务 status: 查看服务状态 检测端口： netstat -tlun | grep 80RPM 包的升级 rpm -Uvh 包名 ： 如没安装过则直接安装 rpm -Fvh 包名 ： 如没有安装，则不安装 RPM 包的卸载 (e 时 erase) rpm -e 包名 RPM 命令查询软件包 (-q, -qa, -i ,-p, -l, -f ,-R ) rpm 选项 查询对象 -q ：表示查询， query -qa ：查询系统中所有安装的软件包 -qi ：查询软件包的详细信息 i = information -ql ：查询软件包的文件列表 -qf ：查询系统文件属于哪个RPM包 -qR ：查询软件包的依赖关系 RPM 包验证和数字证书(数字签名) rpm 包校验 -Va ：校验系统中已安装的软件包 -V ：校验已安装的包名 -Vf ：校验某个系统文件是否被修改 提取RPM包文件(cpio命令) cpio 用于从归档包中存入和读取文件 cpio 选项 -o ： 指 copy-out 模式，把数据备份到文件库中 -v ： 显示备份过程 -c ： 使用较新的protable format 存储方式 -B ： 设定输入/输出块为5120Bytes，而不是模式的512Bytes -i ： 指 copy-in ，把数据从文件库中恢复 -d ： 还原时自动新建目录 -u ： 自动使用较新的文件覆盖较旧的文件 -p ： 指复制模式 YUM 源配置 Yum 源配置文件： /etc/yum.repos.d/ ， 文件扩展名为：”*.repo” 参数： [base]: 容器名称 name：容器说明 mirrorlist：镜像站点 baseurl：源服务器的地址 enable：此容器是否生效， 不写或写enable表示生效，0为不生效 gpgcheck：为1表示RPM的数字证书生效，0为不生效 gpgkey：数字证书的公钥文件保存位置 Yum 查询、安装、升级、卸载 yum list : 列出已安装的和可安装的软件名 yum list 包名 : 查询安装情况 yum search 关键字 : 查找与关键字相关的所有软件包 yum info 包名 : 查询执行软件包的详细信息 Yum 安装命令 yum -y install 包名 install ： 安装 -y ： 自动回答yes Yum 升级命令 yum -y update ： 升级所有软件包 yum -y update 包名 ： 升级特定的软件包 Yum 卸载命令 yum remote 包名 ：卸载指定的软件包 Yum 查询软件组包含的软件 yum groupinfo 软件组名 ： 查询软件组包含的软件 Yum 安装软件组 yum groupinstall 软件组名 ： 安装指定软件组，组名由grouplist查询出来 Yum 卸载软件组 yum groupremove 软件组名 ： 卸载指定软件组 Linux 源码包安装和卸载 首先安装 gcc 和 make rpm -q gcc | yum -y install gcc rpm -q make | yum -y install make 下载源码包，如: xxx.tar.gz 解压： tar -zxvf xxx.tar.gz 进入解压目录 检测系统环境是否符合安装要求： ./configure 定义需要的功能选项： ./configure –prefix=安装路径 执行 ./configure–help 查询支持的功能 编译： make 正式安装软件： make install 重装：在make前，要执行 make clean ，他会清空 Makefile 文件或编译产生的 .o 头文件 Linux 源码包卸载 rm -rf /usr/local/xxx ： 删除软件的安装目录，删除前需停止服务 Linux 源码包快速升级 使用补丁更新源码包： 省去./configure 生成新的 Makefile文件，还省去了编译 Linux 补丁文件的生成和使用 diff 选项 old new -a ： 将任何文档当作文本文档处理 -b ： 忽略空格造成的不同 -B ： 忽略空白行造成的不同 -l ： 忽略大小写造成的不同 -N ： 比较两个目录时，如某个文件只在一个目录，则另一个目录视为空 -r ： 比较目录时，递归比较子目录 -u ： 使用同一输出格式 1. 创建两个文件 mkdir test | cd test | vi old.txt | vim new.txt 2. 利用diff命令，比较两个文件(old.txt 和 new.txt)的不同，并生成补丁文件 (txt.patch)，执行一下代码： diff -Naur /roor/test/old.txt /root/text/new.txt &lt; txt.patch给软件打入补丁 1. 下载补丁文件 2. 复制补丁文件到源码包解压目录中 cp xxx.diff 软件包名 3. 给旧软件打入补丁 cd 软件目录 | vi xxx.diff 4. 重新编译 软件包源码 make 3. 安装 软件 make install Linux 用户和用户组管理UID 和 GID (用户ID 和 组ID) /etc/passwd 系统用户配置文件，存储系统所有用户的基本信息，所有用户有读操作 表达的含义： 用户名： 密码：UID(用户ID) ：GID(组ID) ：描述性信息 ： 主目录 ： 默认Shell 用户名： 代表用户身份的字符串 密 码 ：x 表示此用户设有密码， 真正的密码保存在 /etc/shadow 文件中 UID ： 用户ID，识别不同的用户 0~65535 0 ： 超级用户 1 ~ 499 ： 系统用户 500 ~ 65535 ： 普通用户 GID ： Group ID ，组ID 初始组： 如：建立用户lamp的同时，建立 lamp组作为lamp用户的初始组 附加组： 指用户可以加入多个其他的用户组，并拥有这些组的权限 描述性信息： 主目录： 用户登陆后有操作权限的访问目录，用户的主目录 默认的Shell：Linux的解释器，用户和Linux内核沟通的桥梁，默认 bash /bin/bash/etc/shadow (影子文件) 用户名：加密密码：最后一次修改时间：最小修改时间间隔：密码有效期：密码需要变更前的警告天数：密码过期后的款期时间：账号失效时间：保留字段 忘记密码： 1.重启进入单用户模式， 系统会提供root权限的bash 接口，用 passwd命令修改账号密码； 2.通过挂载根目录，修改 /etc/shadow，将账户的root密码清空/etc/group 用户组配置文件，用户组的所有信息存放在此文件中 组名：密码：GID：该用户组中的用户列表 /etc/gshadow 组名：加密密码：组管理员：组附加用户列表 初始组和附加组 添加新用户： useradd user 添加新群组： groupadd group 将用户xxx加入到xxx群组： usermod -G group user 查找： grep ‘user’ /etc/passwd /etc/group /etc/gshadow 一个用户可以所属多个附加组，但只能有一个初始组 查看用户所属全部群组: gourps/etc/login.defs :创建用户的默认设置文件 useradd ： 添加新的系统用户 useradd 选项 用户名 -u UID : 手工指定用户的UID，UID 不要小于500 -d 主目录 ： 手工指定用户的主目录，必须是绝对路径，注意权限 -c 用户说明 ： 手工指定 /etc/passwd 文件中各用户信息中第5哥字段的描述性内容，可随意配置 -g 组名 ： 手工指定用户的初始组 -G 组名 ： 指定用户的附加组 -s shell ：手工指定用户的登录 Shell ，默认是 /bin/bash -e 日期 ： 指定用户的失效日期 格式为 “YYYY-MM-DD” /etc/shadow 文件的第八个字段 -o ： 允许创建的用户的UID 相同，例如：useradd -u 0 -o usertest -m ： 建立用户时强制建立用户的家目录 -r ： 创建系统用户 UID 在 1 ~ 499 /etc/default/useradd 文件 passwd ：修改用户密码 passwd 选项 用户名 -S ：查询用户密码的状态 = /etc/shadow -l ：暂时锁定用户 -u ：解锁用户 –stdin ：通过管道符输出的数据作为用户的密码，主要用于批量添加用户 -n ： 天数 不能修改密码期限 /etc/shadow 第4个字段 -x ： 天数，设置密码有效期 第5个字段 -w ： 天数 用户密码过期的警告天数 第6个字段 -i ： 日期，用户密码失效日期 第7个字段 usermod ： 修改用户信息 usermod 选项 用户名 -c ： 用户说明：修改用户的说明信息 修改 /etc/paswd 文件目标用户信息的第5个字段 -d ： 主目录： 修改用户的主目录 6 -e ： 日期：修改用户的失效日期 8 -g ： 组名：修改用户的初始组 4 -u ： UID： 修改用户的UID 3 -G ： 组名：修改用户的附加组，把用户加入其他用户组 -l ： 修改用户名称 -L ： 临时锁定用户 -U ： 解锁用户 -s ： shell： 修改用户的登录Shell chage ： 修改用户密码状态 chage 选项 用户名 -l ： 列出用户的详细密码状态 -d ： 日期 /etc/shadow 第3个字段 -m ： 天数 修改密码最短保留天数 第4个字段 -M ： 天数 修改密码的有效期 第5个字段 -W ： 天数 修改密码过期前的警告天数 第6个字段 -i ： 天数 修改密码过期后的宽限天数 第7个字段 -E ： 日期 修改账号失效日期 第8个字段 userdel : 删除用户 userdel -r 用户名 -r : 在删除用户的同时删除用户的家目录 id ： 查看用户的UID 和GID id 用户名 su ： 用户间切换 su 选项 用户名 - ： 当前用户不仅切换为指定用户的身份，刚工作环境也切换为此用户的环境包括 PATH变量、MAIL变量等，可省略用户名，默认为root -l ： 同-，但后面需要添加欲切换的使用者账号 -p ： 切换为指定用户的身份，但不改变当前的工作环境 -m ： 同 -p -c ： 仅切换用户执行一次命令，执行后自动切换回来 su 和 su - 的区别 工作环境 groupadd ： 添加用户组 groupadd 选项 用户 -g GID ： 指定组ID -r ： 创建系统群组 groupmod ： 修改用户组 groupmod 选项 用户名 -g GID ： 修改组ID -n 新组名 ： 修改组名 groupdel ： 删除用户组 groupdel 组名 gpasswd ： 把用户添加进组或从组中删除 gpasswd 选项 组名 ： 选项为空时，给群组设置密码，仅root用户可用 - A user1,… ： 将群组控制权交给 user1，… 等用户管理， 是将 user1，等用户为群组的管理员，仅root用户可用 -M user1，… ：将user1等加入到群组中，仅root可用 -r ： 移除群组的密码，仅root可用 -R ： 让群组的密码失效，仅root可用 -a user ： 将user 用户加入到群组中 -d user ： 将user 用户从群组中移除 newgrp ： 切换用户的有效组 newgrp 组名 权限管理针对不同的用户，设置不同的文件访问权限，包括读、写、删除等 ls -al // 查看文件或目录的权限信息chgrp：修改文件和目录的所属组 chgrp [-R] 所属组 文件名(目录名) -R: 递归 修改 所属组chown：修改文件和目录的所有者和所属组 chown [-R] 所有者 文件后目录 -R: 递归 修改 所有者 chown [-R] 所有者:所属组 文件或目录 权限位 文件权限 3 种， 文件 读(r), 写(w), 执行(x) 每行的第一列表示权限，共11位，第一位表示具体类型，最后以为收SELinux安全规则管理 读、写、执行 共 9 位字符 rw- r– r– // 所有者、所属群组、其他用户 r ： 4 w ： 2 x ： 1 chmod： 修改文件或目录的权限 chmod [-R] 权限值 文件名 -R ：递归 设定 权限 chmod [字母 u、g、o、a ] +|-|= r|w|x 文件或目录 u：用户 g：群组 o：其他 a：所有 +：加入 -：删除 =：设定 umask： 令新建文件和目录拥有默认权限 umask // 默认值：root用户 0022， 普通用户：0002 默认权限由4个八进制数组成，第一个数代表所有者的特殊权限 (SetUID, SetGID, Sticky BIT) 最后3位022 才是真正用到的umask权限 可转换为 — -w- -w- 文件或目录初始权限 = 文件或目录最大默认权限 - umask权限 文件最大默认权限是666：-rw-rw-rw- 666 - 033 = 633 目录最大权限默认是777 drwxrwxrwx 777 - 022 = 755 默认权限修改方法： umask 022 umask 033 ACL 访问控制权限 三种身份： 文件所有者、所属群组、其他用户 三种权限： 读 r 、 写 w 、 访问 x 权限前的字符，表示文件的具体类型，d：目录，-：普通文件，|：表示连接文件，b：设备文件 ACL：Access Control List (访问控制列表)，ACL可实现单一用户设定访问文件的权限，除了传统方式，还可以用ACL进行设定 mount ：查看系统挂载的分区 dumpe2fs -h /dev/sda1 // dumpe2fs 查询指定分区文件系统详细信息 -h：仅显示超级块中的信息，不显示磁盘块组的信息 mount -o remount,acl / // 重新挂载根分区，并加入ACL权限，针对分区 ACL权限设置(setfacl 和 getfacl) getfacl 文件名 // 查看文件或目录设定的ACl权限信息 setfacl 选项 文件名 // 设定用户或群组对指定文件的访问权限 -m ： 设定ACl权限 // setfacl -m u:user:rx /dir -x : 删除指定用户 // setfacl -x u:user /dir -b : 删除所有的ACL权限 // setfacl -b /dir -d ： 设定默认ACL权限 // setfacl -m d:u:user:rwx 文件名 群组: d:g:group:rwx -R : 递归设定ACL权限 // setfacl -m u:user:rwx -R /dir -k ： 删除默认ACL权限 mask： 有效权限 指用户或群组能拥有的最大ACL权限，给用户或群组设定的ACl权限不能超过mask规定的权限范围，超出部分无效 SetUID(SUID)文件特殊权限 仅适用于可执行文件，对设有SUID的文件有执行权限，执行此文件时，会以文件所有者的身份去执行，执行结束，身份的切换也消失 chmod u-s /usr/bin/passwd ： 取消SetUID SUID 特点： 只有可执行文件才能设定SetUID权限，对目录无效 对文件拥有执行(x)权限 执行文件时，以文件所有者的身份执行 SetUID 权限只在文件执行过程有效，执行完毕，也消失 不要轻易设置SetUID权限，有重大安全隐患 Stick BIT (SBIT)文件特殊权限 仅对目录有效，设定SBIT权限，目录下创建的文件和目录，只有自己和root有修改和删除权限 Chattr：修改文件系统的权限属性 chattr [+-=] [属性] 文件或目录 +：添加属性 -：移除拥有的属性 =：设定一些属性 i：对文件设定i属性，不允许删除、改名、添加、修改。 对目录设置i属性，只能修改，不能建立、删除文件 a：文件：只增加数据，不能修改、删除。 目录：在目录中只建立和修改文件，不能删除文件 u：文件或目录：删除时，内容保存，能恢复。防止意外删除文件或目录 s：与u相反，删除文件或目录，会彻底删除，不可恢复 lsattr：查看文件系统属性 lsattr 选项 文件或目录名 -a：不带文件或目录，显示所有文件和目录，包括隐藏 -d: 目录：列出本身的隐藏属性，布列出包含文件或子目录的隐藏属性 -R： 与-d相反， 目录：连同子目录隐藏信息数据一并显示 sudo：系统权限管理 sudo [-b] [-u 新使用者账号] 要执行的命令 -b:将后续的命令放到背景中让系统自行运行，对当前shell无影响 -u： 后面+切换的用户名，无用户名则为root -l： sudo -l，用于显示当前用户可用sudo执行命令 文件系统管理Centos6.3 默认为Ext4 兼容Ext3 最大1EB文件系统和16TB文件 无限数量子目录 Extents 连续数据块概念 多块分配、延迟分配、持久项分配 快速FSCK、日志校验、无日志模式、在线碎片整理、inode增强、默认穷barrier等 支持的文件系统 Ext：最早的文件系统 Ext2：1993年发布，最大支持16TB分区，2TB文件 Ext3：带日志功能 Ext4：上面以写 swap：交换分区，类似虚拟内存，当内存不够时，交换分区代替，必须分区 NFS： 网络文件系统Network File System，本地通过挂载使用远程共享的资源 iso9660：关盘的标准文件下体哦那个 fat： 类windows fatl6文件系统 vfat：类windows fat32文件系统 最大支持32G文曲和4G文件啊你 NTFS： windows 所有，2TB分区 64G文件 ufs：Sun公司系统Solaris SunOS采用的文件系统 proc：内存的虚拟文件系统，/proc sysfs： =proc tmpfs： 基于内存的虚拟文件系统，可使用swap交换分区df：查看文件系统硬盘使用情况 df 选项 目录或文件名 -a：显示所有系统信息 -m: 以MB显示容量 -k：以KB显示 -h: 以KB、MB、GB等自行显示 -T：显示分区的文件系统名称 -i: 不用硬盘容量显示，以含有inode的数量显示du: 统计目录或文件所占磁盘空间大小 du 选项 目录或文件名 -a： 显示每个子文件的磁盘占用量，默认统计子目录的磁盘占用量 -h: 人性化显示磁盘占用量 -s： 统计总磁盘占用量，不列出子目录和子文件的磁盘占用量 mount： 挂载Linux系统外的文件 mount -l：mount显示系统已挂载的设备信息， -l 额外显示卷标名称 -a： 自动检查 /etc/fstab 文件中有无疏漏被挂载的设备文件，有，则自动挂载。开机主动读取/etc/fstab 文件中的内容 mount -t系统类型 -L卷标名 -o特殊选项 -n设备文件名挂载点 -t：系统类型，指欲挂载的文件系统类型：Ext2、Ext3、Ext4等 -L: 卷标名 利用文件系统的卷标名称进行挂载 -n：系统将实际挂载的情况写入 /etc/mtab 文件中。若不写入，使用此选项 -o：特殊选项：可指定挂载的额外选项，如读写权限、同步异步 umount：卸载文件系统 umount 设备文件名或挂载点 fsck：检测和修复文件系统 fsck 选项 分区设备文件名 -a: 自动修复，不提示 -r: 互助的修复模式，会询问 -A： 按照/etc/fstab 配置文件的内容，检查文件内罗列的全部文件系统 -t 文件系统类型： 指定要检查的文件系统类型 -C： 显示检查分区的进度条 -f： 强制检测 -y： 自动修复=-a，但有些文件系统只支持-y dumpe2fs：查看文件系统信息 dumpe2fs -h 文件名 -h： 仅列出superblock(超级块)的数据信息 fdisk： 给硬盘分区 fdisk -l ：列出系统分区 最高支持2TB的硬盘分区 fdisk 设备文件名 创建分区 parted：创建分区 parted 硬盘设备文件名 具体操作见 交互命令 mkfs： 格式化分区(为分区写入文件系统) mkfs -t 文件系统格式 分区设备文件名 mke2fs：格式化硬盘(给硬盘写入文件系统) mke2fs 选项 分区设备文件名 -t 文件系统： 指定格式化为如： ext2、ext3、ext4 -b 字节：指定block大小 -i 字节：指定字节 inode 的比例 -j： 建立带有ext3 日志功能的文件系统 -L 卷标名： 给文件系统设置卷标名 swap： 分区及作用 交换分区 建立swap分区的步骤 1. 分区 fdisk或parted 2. 格式化 mkswap 格式化为 swap分区 3. 使用swap分区 分区：fdisk /dev/sdb 格式化： mkswap /dev/sdb1 使用： 加入swap分区 swapon 分区设备文件名 高级文件系统管理磁盘配额、 LVM(逻辑卷管理)、 RAID(磁盘阵列) 磁盘配额：限制普通用户在分区中使用的容量和文件个数 LVM： 在不停机和不损失数据的情况下修改分区带线啊哦 RAID：有多块硬盘或分区组成，拥有数据冗余功能，在某块硬盘或分区损坏时，硬盘或分区保存的数据不丢失磁盘配额 Linux系统中限制特定的普通用户或用户组在指定的分区上占用的磁盘空间或文件个数 满足磁盘配额的条件： 1. 内核支持 grep CONFIG_QUOTA /boot/conrrfig-2…el6.i686 2. 安装Quota工具 rpm -qa | grep quota 3. 支持磁盘配额的分区必须开启磁盘配额功能 常见概念 用户配额和组配额 磁盘容量限制和文件个数限制 软限制和硬限制 宽限时间 磁盘配额启动的前期准备(设置挂载参数usrquota和grpquota) 添加方式： 1. 手动添加挂载参数： mount -o remout,usrquota,grpquota /home mount | grep home 2. 修改/etc/fstab文件。将挂载参数写入配置中 vi /etc/fstab LABEL = /home /home ext3 defaults.usrquota,grpquota 1 2 umount /home mount -a mount | grep home quotacheck：扫描文件系统并建立Quota记录文件 quotacheck [-avugfM] 文件系统 -a：扫描所有在/etc/mtab 中含有quota支持的filesystem，此参数后边的文件系统可不写 -u：针对使用者扫描文件与目录的使用情况，会创建 aquota.user -g：针对群组扫描文件与目录的使用情况，会创建aquota.group -v：显示扫描的详细过程 -f：强制扫描文件系统，并写入新的quota记录文件 -M：强制以读写的方式扫描文件系统，特殊情况下使用 quotaon：开始磁盘配额限制 quotaon [-avug] quotaon [-vug] 文件系统名称 -a：根据/etc/mtab 文件中对文件系统的配置，启动相关的Quota服务 -u：针对用户启动Quota -g：针对群组启动Quota -v：显示启动服务过程的详细信息 quotaoff：关闭磁盘配额限制 quotaoff [-avug] quotaoff [-vug] 文件系统名称 -a：根据/etc/mtab 文件，关闭已启动的Quota服务，如不使用-a选项，则后面需要明确协商特定的文件系统名称 -u：关闭针对用户启动的Quota服务 -g：关系针对群组启动的Quota服务 -v：显示服务过程的详细信息 edquota：修改用户(群组)的磁盘配额 edquota [-u用户名] [-g群组名] edquota -t edquota -p 源用户名 -u 新用户名 -u 用户名：进入配额的Vi编辑界面，修改针对用户的配置值 -g 群组名：修改针对群组的配置值 -t： 修改配额参数中的宽限时间 -p： 将源用户(或群组)的磁盘配额设置，复制给其他用户(或群组) edquota 命令配额限制信息 文件系统 filesystem：针对哪个文件系统或分区 磁盘容量 blocks： quota自己算的，单位为Kbytes，不要手动修改 磁盘容量的软限制 soft： 超过此限制值，登陆时会收到警告信息 磁盘容量的硬显示 hard： 要求用户使用的磁盘空间不超此限制值，单位为KB 文件数量 inodes： 当文件数量超过此值，会发出警告 文件数量的硬限制 hard： 用户拥有的文件数量不超此值 setquota：非交互式设置磁盘配额 setquota -u 用户名 容量软限制 容量硬限制 个数软限制 个数硬限制 分区名 quota和repquota查询磁盘配额方法 quota 查询用户或用户组的配额 quota 选项 用户名或组名 -u 用户名： 查询用户配额 -g 组名 ： 查询组配额 -v： 显示详细信息 -s： 以习惯单位显示容量大小 如 M、G repquota 查询整个分区的配额情况 repquota 选项 分区名 -a： 依据/etc/mtab 文件查询配额，如不加-a，就得加分区名 -u： 查询用户配额 -g： 查询组配额 -v： 显示详细信息 -s： 以易读单位显示容量大小 LVM逻辑卷管理机制(硬盘分区管理机制)LVM：Logical Volume Manager，逻辑卷管理，Linux下对硬盘分区的一种管理机制 物理卷(Physical Volume, PV)：真正的物理硬盘或分区 卷组(Volume Group, VG)：将多个物理卷组成了卷组，把卷组想象为一块逻辑硬盘 逻辑卷(Logical Volume, LV)：逻辑卷可被格式化和写入数据，可想象为分区 物理扩展(Physical Extend,PE)：PE保存数据的最小单元，默认是4MB 建立LVM的步骤： 1. 把物理硬盘分成分区 2. 把物理分区建立为物理卷PV 3. 把物理卷整合为卷组VG 4. 把卷组划分为逻辑卷LVPV物理卷：创建、查看、删除 1. 建立所需的物理分区，方式使用fdisk交互命令 建立物理卷； pvcreate 设备文件名 查看物理卷： pvscan pvdisplay 删除物理卷： pvremove /dev/sdb7 VG卷组：创建、激活、查看、扩容、减小、删除 建立卷组： vgcreate [-s PE 大小] 卷组名 物理卷名 激活卷组： 激活：vgchange -a y 卷组名 停用：vgchange -a n 卷组名 查看卷组： vgscan ： 查看系统中是否有卷组 vgdisplay： 查看卷组的详细状态 增加卷组容量： vgextend scvg /dev/sdb7 减少卷组容量： vgreduce scvg /dev/sdb7 删除卷组： vgremove scvg LV逻辑卷：创建、查看、调整大小、删除 建立逻辑卷： lvcreate 选项 -n 逻辑卷名 卷组名 -L：容量，逻辑大小，单位为MB、GB、TB -l：个数，按照PE个数指定逻辑大小 -n：逻辑卷名 查看逻辑卷： lvscan ： 查看系统中是否拥有逻辑卷 lvdisplay ： 查看逻辑卷的详细信息 调整逻辑卷大小： lvresie 选项 逻辑卷的设备文件名 -L: 容量 -l: 个数 删除逻辑卷： lvremove 逻辑卷的设备文件名LVM(逻辑卷管理) 删除 RAID(磁盘列阵) 图形界面配置RAID mdadm配置RAID 启动管理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186启动流程： Upstart 启动服务 取代了 System V init 1. 服务器加点，加载BIOS信息，BIOS进行系统检测，依照BIOS设定，找到第一个可以启动的设备(硬盘) 2. 读取第一个启动设备的MBR(主引导记录)，加载MBR中的Boot Loader(启动引导程序，最常见为GRUB) 3. 依照Boot Loader的设置加载内核，内核再进行一遍系统检测，系统一般会采用内核检测硬件的信息，而不一定采用BIOS的自检信息。内核再检测硬件的同时，还会通过加载动态模板的形式加载硬件的驱动 4. 内核启动系统的第一进程，也就是 /sbin/init 5. 由 /sbin/init 进程调用 /etc/init/rcS.conf 配置文件，通过这个配置调用/etc/rc.d/rc.sysint 配置文件。 而/etc/rc.d/rc.sysinit 配置文件是用来进行系统初始化的，主要用于配置计算机的初始化环境 6. 通过/etc/init/rcS.conf 配置文件调用 /etc/inittab 配置文件。 通过 /etc/inittab 配置文件来确定系统的默认运行级别 7. 确定默认运行级别后，调用/etc/init/rc.conf 配置文件 8. 通过/etc/init/rc.conf 配置文件调用并执行 /etc/rc.d/rc 脚本，并传入运行级别参数 9. /etc/rc.d/rc 确定传入的运行级别，然后运行相应的运行级别目录 /etc/rc[0-6].d/ 中的脚本 10. /etc/rc[0-6].d/ 目录中的脚本依据设定好的优先级一次启动和关闭 11. 最后执行/etc/rc.d/rc.local 中的程序 12. 如果是字符界面启动，就可以看到登陆界面，如是图形界面启动，则调用相应的X Window 接口 归纳：BIOS自检 -&gt; 启动GRUB -&gt; 加载内核 -&gt; 执行第一个进程 -&gt; 配置系统初始环境 BIOS 开机自检 通电后，进入BIOS： Basic Input/Ouput System 基本输入/输出系统 BIOS初始化的工作： 1. 检查硬件和外围设备， CPU、内存、风扇灯。 自建过程称为 POST(Power On Self Test) 2. 对硬件进行初始化，规定当前启动设备的先后顺序，选择由哪个设备来开机 3. 选择好开机设备后，会从该设备的MBR(主引导目录)读取Boot Loader(启动引导程序)并执行，启动引导程序用于引导操作系统启动，Linux系统默认使用GRUB 当MBR被加载到RAM之后，BIOS将控制权交给RAM，进入系统第二阶段 [MBR](http://c.biancheng.net/uploads/allimg/181022/2-1Q0221G321149.jpg) 启动引导程序的作用： BIOS作用是自检，从MBR读取启动引导程序。 启动引导程序作用： 1. 加载操操作系统的内核 2. 可选择的系统菜单，如双系统 3. 调用其他的启动引导程序，多系统启动的关键 [启动引导程序](http://c.biancheng.net/uploads/allimg/181022/2-1Q0221G60U34.jpg) Linux内核(内核模块)的加载过程 内存存放位置： /boot 的启动目录中 GRUB加载内核后，内核进行二次系统自检，内核替代BIOS接管Linux启动。 内核完成后，采用动态方式加载每个硬件的模块，模块为硬件的驱动。 initramfe虚拟文件系统 通过initramfs虚拟文件系统再内存中模拟处一个根目录，然后加载SCSI等硬件驱动，可加载真正的跟目录，之后调用Linux的第一个进程/sbin/init 优点： initramfs随着数据的增减自动增减容量 再initramfas和页面缓存之间没有重复数据 initramfs重复利用Linux caching的代码，没有增加内核尺寸 不需要额外的文件系统驱动 [](http://c.biancheng.net/uploads/allimg/181023/2-1Q023093PD60.jpg) Linux /sbin/init 初始化系统环境 内核加载完，完成硬件检测与驱动程序加载后，内核主动呼叫第一个进程/sbin/init, 此配置主要功能准备软件执行的环境：主机名、网络设定、语言、文件系统格式及其他服务的启动 /etc/rc.d/rc.sysinit 配置文件的工作： 获得网络环境和主机类型 测试设备：侦测系统上是否有usb设备，如有主动加载usb驱动程序，并挂载usb文件系统 开机启动画面Plymouth 判断是否启用SELinux 显示开机过程的欢迎画面 初始化硬件 用户自定义模块的加载 配置内核的参数 设置主机名 同步存储器 设备映射器及相关的初始化 初始化软件磁盘阵列(RAID) 初始化LVM的文件系统功能 检验磁盘文件系统(fsck) 设置磁盘配置(quota) 重新以可读写模式挂载系统磁盘 更新quota(非必要) 启动系统虚拟随机数生成器 配置机器(非必要) 清除开机过程中的临时文件 创建ICE目录 启动交换分区(swap) 将开机信息写入 /var/log/dmesg 文件中Linux /etc/inittab：设置(修改)系统默认运行级别 Linux有7个级别： 0 ：关机 1 ：单用户模式，类Windows安全模式，系统修复 2 ：不完全的命令行模式，不含NFS服务 3 ：完全的命令行模式，标准字符界面 4 ：系统保留 5 ：图形模式 6 ：重新启动 runlevel：查看系统的运行级别 系统默认运行级别：/etc/inittab 配置文件功能：确定系统的默认运行级别，即开机进入哪个运行级别 Linux /etc/rc.d/rc.local 配置文件 在 /etc/rc[06].d/ 目录中的程序启动后，系统启动完成。 [启动流程](http://c.biancheng.net/uploads/allimg/181023/2-1Q02310563a22.jpg)Linux 启动引导程序(GRUB)加载内核 GRUB加载内核的过程 加载操作系统的内核 可选择的操作系统菜单 调用其他启动引导程序，实现多系统引导 1. 执行GRUB主引导 1.5 识别不同的文件系统 2. 加载GRUB的配置文件Linux /boot/grub/ 目录分 1. 第一阶段启动引导的主程序 2. 第二阶段为主程序加载配置文件，包括环境参数文件GRUB磁盘分区表示法 ha：硬盘 第一个0：系统查找到的第一块硬盘，第二块为1|2？ 第二个0：硬盘的第一个分区 硬盘 分区 设备文件名 GRUB设备文件名 第一块SCSI硬盘 [内容太多](http://c.biancheng.net/view/1030.html)/boot/grub/grub.conf(GRUB配置文件)内容 [内容太多](http://c.biancheng.net/view/1032.html)多系统并存的GRUB配置文件内容分析 [多系统](http://c.biancheng.net/view/1033.html)GRUB手动安装方法 手动安装GRUB的情况 1. 不使用GRUB作为引导程序，而想要GRUB作为引导程序 2. MBR中的引导程序被覆盖，如安装linux后安windows，引导被覆盖 步骤： 1. 使用grul-install 命令 在启动分区安装GRUB相关文件 2. 修改GRUB的配置文件 3. 安装GRUB到/dev/sdb1分区的启动扇区中Linux GRUB加密方法 启动选项按 e 进入编辑模式，通过命令grub-md5-crypt 模式： 1. 给每个启动菜单加密 2. 给GRUB菜单整体加密 字符界面调整分比率 [文章](http://c.biancheng.net/view/1037.html)Linux内核模块管理(查看、添加、删除) 模块：动态可加载内核模块，有独立功能的程序，可被单独编译，但不能独立运行 安装模块的方法： 1. 在编译内核时，手工调整内核模块功能，加入所需的模块 2. 下载厂商发布的新硬件的驱动模块，或下载驱动程序，在编译 内核模块保存位置与模块保存文件 内核模块保存： /lib/modules/内核版本/kernel/目录中 depmod 选项 -a：扫描所有模块 -A: 扫描新模块，有新模块，更新moudles.dep 文件 -n：扫描结果不写入modules.dep 文件，直接输出到屏幕 内核模块的查看： lsmod 命令指定结果： Module：模块名 Size：模块大小 Used by：模块是否被其他模块调用 内核模块的添加与删除： modprobe 选项 模块名 -l：列出所有模块的文件名，依赖modules.dep文件 -f：强制加载模块 -r：删除模块Linux NTFS文件系统安装 方法有三： 一. 重新编译内核 二. 下载编译内核 三. 第三方插件 NTFS-3G 二. 1.下载内核 2.解压内核 3.生成内核编译所需的.config文件 4.编译模块 5.模块安装 三： 1.下载NTFS-3G插件 2.安装NTFS-3G插件 Linux单用户模块(修改密码、运行级别)方法 如何进入单用户模式： 开机、e 进入GRUB kernel、e 进入编辑界面，然后输入 空格 single，代表启动单用户模式 单用户模式常见错误修复： root密码: 单用户模式、 passwd root 修改系统默认运行级别： 直接修改配置文件/etc/inittab. 系统的默认运行级别只能使用3或5光盘修复模式使用方法： [光盘修复](http://c.biancheng.net/view/1042.html)Linux系统安全性分析 [密码安全](http://c.biancheng.net/uploads/allimg/181024/2-1Q024111633X7.jpg) 系统服务管理服务是后台运行的应用程序，提供本地系统或网络的功能，Service，Daemon：守护神、守护进程 守护进程：为了实现服务、功能的进程，是服务在后台运行的真实进程 系统服务及分类 [服务分类](http://c.biancheng.net/uploads/allimg/181024/2-1Q02413195AP.jpg) 软件安装方式：1. RPM包 2. 源码包 服务分为两种： 独立的服务：可自动启动，不依赖管理服务，如 Nginx服务、FTP服务等 基于Xinetd的服务：依靠管理服务来调用，管理服务是xinetd服务，是系统的超级守护进程，作用：管理不能独立启动的服务，当有客户端请求时，先请求xinetd服务，由xinetd服务去唤醒相对应的服务。查询已安装的服务与区分服务 RPM包默认安装到系统默认位置，可被服务管理命令(service、chkconfig)识别 chkconfig –list 服务名 // 管理RPM包默认安装服务的自启动命令，列出所有服务的自启动状态 Linux端口及查询方法 协议： 面向连接的可靠的TCP协议(Transmission Control Protocol,传输控制协议) 面向无连接的不可靠的UDP协议(User Datagram Protocol, 用户数据报协议) 查询系统中已启动的服务： netstat 选项 -a： 列出系统中所有网络连接，包括：网络服务、监听的网络服务、Socket套接字 -t： 列出TCP 数据 -u： 列出UDP 数据 -l： 列出正在监听的网络服务(不包含已连接的网络服务) -n： 用端口号来显示而不用服务名 -p： 列出该服务的进程ID(PID) 执行结果字段解析： Proto： 数据包的协议 Revc-Q：收到的数据已在本地接受缓冲 Send-Q：对方没有收到的数据包数量 Local Address：本地IP：端口，通过端口知道本机开启的服务 Foreign Address：远程主机：端口， State： 连接状态，已建立连接(ESTABLISED)和监听(LISTEN) PID/Program name: 进程ID和进程命令 Socket套接字的解析： Proto：协议，一般是Unix RefCnt： 连接到此Socket的进程数量 Flags：连接标识 Type： Socket访问类型 State：状态 Listening：监听 Connected：已建立连接 l-Node：程序文件的i节点号 Path：Socket程序的路径、或者相关数据的输出路径 独立服务的启动管理(RPM包的启动与自启动) 两种方式： 1. 使用/etc/init.d/ 目录中的启动脚本来启动独立的服务 /etc/init.d/独立服务名 start|stop|status|restart|… start：启动服务 stop ：停止服务 status：服务状态 restart：重启服务 2. 使用service命令来启动独立的服务 service 只是一个脚本，调用/etc/init.d/ 中的启动脚本来启动独立服务 service 独立服务名 start|stop|restart|… –status-all :列出所有独立服务的启动状态独立服务的自启动管理 三种方式： 1. 使用chkconfig服务自启动管理命令 chkconfig –list // 查询自启动状态 chkconfig –list | grep nginx chkconfig [–level 运行级别][独立服务名][on|off] –level：设定在哪个运行级别中开机自启动(on)，关闭自启动(off) chkconfig –level 2345 nginx on // 修改2345这4个级别为启用 /etc/init.d/nginx status // 查看服务状态 2. 修改 /etc/rc.d/rc.local 文件，设置服务自启动 修改 rc.local 文件，添加服务的启动命令，注：/etc/rc.d/rc.local 和 /etc/rc.local 文件时软连接，修改哪个都可以，这个文件中的命令会在启动时调用 vi /etc/rc.d/rc.local /etc/rc.d/init.d/nginx start # 在文件中加入nginx的启动命令 好处： 1. 集中管理 2. 服务启动唯一性，不管哪种方式都通过 /etc/rc.d/rc.local 文件实现 3. 使用ntsysv 命令管理自启动 ntsysv：调用窗口模式管理服务的自启动 ntsysv [–level 运行级别] ntsysv –level 234 # 设定234级别的服务自启动 Linux基于xinetd服务的管理方法 基于xinetd服务的启动 xinetd 服务的配置文件保存在 /etc/xinetd.d/ 目录中 telnet： /etc/xinetd.d/telnet 如果要启动telnet服务，只需把 /etc/xinetd.d/telnet 文件中的disable=yes 改为 disable=no ，disable:代表取消 基于xinetd服务的自启动 1. 使用chkconfig 命令管理自启动 chkconfig 服务名 on|off 2. 使用ntsysv命令管理自启动 Linux源码包服务管理(启动与自启动) 源码包服务的启动管理： /usr/local/apache2/bin/apachectl start|stop|restart|status|… 源码包服务的自启动管理： vim /etc/rc.d/rc.local // 修改自启动文件 touch /var/lock/subsys/local /usr/local/apache2/bin/apachectl start # 加入源码包服务的标准启动命令 让源码包服务被服务管理命令识别： 1. 卸载RPM包默认安装的apache服务 yum -y remove httpd 2. 安装源码包的apache服务，并启动 /usr/local/apache2/bin/apachectl start netst -tlun | grep 80 3. 让源码包安装的apache服务能被service命令管理启动 ln -s /usr/local/apache2/bin/apachectl /etc/init.d/apache # 把源码包的启动脚本连接到 /etc/init.d/目录中，能被service命令管理 4. 让源码包安装的apache服务能被chkconfig命令管理自启动 vi /etc/init.d/apache # 修改源码包安装的apache服务的启动脚本，此文件是软连接，实际修改的是源码包的启动脚本 chkconfig: 运行级别 启动顺序 关闭顺序 chkconfig –add apache chkconfig –list | grep apache 5. 让ntsysv命令可以管理源码包安装的apache服务 把服务的启动脚本链接到/etc/init.d/目录中，在启动脚本中加入： #chkconfig:运行级别 启动顺序 关闭 #description:说明 然后使用： chkconfig –add 服务名 chkconfig 选项服务名 -add： 把服务加入chkconfig命令的管理中 -del： 把服务从chkconfig命令的管理中删除 chkconfig -del|httpd Linux常见服务类被及功能 acpid： 电源管理接口 anacron： 系统的定时任务，是cron的子系统 alsasound： alsa声卡驱动 apmd： 电源管理模块 atd：指定系统在特定时间执行某个任务，只能执行一次 auditd：审核子系统 autofs：让服务器可自动挂载网络中其服务器的共享数据，挂载NFS服务 avahi-daemon：avahi是zeroconf协议的实现 bluetooth：蓝牙设备支持 capi：仅对ISND设备用户有用 chargen-dgram：使用UDP协议的chargen server，类远程打字功能 chargen-stream： 同上 cpuspeed：调整CPU频率 crond：系统定时任务 cvs：版本控制系统 … More 常见服务]]></content>
      <categories>
        <category>Linux</category>
        <category>Ubuntu</category>
        <category>Centos</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP]]></title>
    <url>%2F2019%2F08%2F09%2FPHP-Note%2F</url>
    <content type="text"><![CDATA[iFaithFreedom TODO ListPHP基础PHP进阶PHP高阶More…]]></content>
      <categories>
        <category>PHP</category>
        <category>Laravel</category>
        <category>ThinkPHP</category>
        <category>Yii</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim]]></title>
    <url>%2F2019%2F08%2F09%2FVim-Note%2F</url>
    <content type="text"><![CDATA[iFaithFreedom 6 种模式普通模式 插入模式 可视模式 选择模式 命令行模式 Ex模式 12345678910111213141516171819202122232425262728293031323334- 普通模式dd ndd djdGdggdb dw- 插入模式i I aAxXsS- 可视模式与普通模式相似- 选择模式Ctrl + vShift + v- 命令行模式: ：执行命令/ ：搜索? ：搜索! ：过滤命令- Ex模式与命令行模式相似，在使用 :visual 命令离开Ex模式前，可一次执行多条命令 文件操作1234567filename = x.x-r x.x: -R x.x: + x.x: +n x.x:+ /pattern x.x:-c command x.x 编辑操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162i: 光标所在处插入I: 所在行的第一个非空格符处开始插入o: 光标所在行的下一行输入新的一行O: 光标所在行的上一行输入新的一行a: 光标所在的下一个字符处开始输入A: 光标所在行的最后一个字符处开始输入r: 取代光标所在的那个一字符一次R: 取代光标所在的文字，直到按下 ESC为止查找文本/abc: /^abc:/abc$:?abc:n:N:替换文本r:R::s/x/x1/g::x1,x2s/y1/y2/g::g/x1/x2/g删除文本x: 向后删除一个字符 X: 向前删除一个字符 nx：连续向后删除n个字符dd: 删除光标所在的一整行ndd: 删除光标所在的向下n行dG: 删除光标所在到最后一行的所有数据d$: 删除光标所在处到最后一个字符d0: 删除光标所在处到该行的最前面一个字符D: 删除光标末尾的字符:x1,x2dp: 粘贴被删除的文本内容复制文本p: 粘贴通过复制下的行数和字符P: 会增加行数yy: 复制光标所在的那一行nyy: 复制光标所在的向下n行y1G: 复制光标所在行的第一行的所有数据y0: 复制光标所在的那个字符到该行行首的所有数据y$: 复制光标所在的那个字符到该行行尾的所有数据yw: J: 将光标所在行与下一行的数据结合成同一行c: 重复删除多个数据u: 复原前一个动作Ctrl+r: 重做上一个动作保存退出:wq 保存并退出:wq! 强制保存并退出:q 离开vim:q! 强制退出不保存:w 将文本保存:w! 若文件为只读时，强制写入该档案。但取决于权限:w xxx.xx: 将编辑的数据保存成另一个档案，类似于另存:x! :n1,n2 w filename : 将n1到n2的内容存储成filename这个档案ZZ: 文件没有改动，则不保存离开，若改动，则保存后离开:! command: 暂时离开vim到指令模式下执行命令 方向键1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950h : 向左 H : 屏幕上方那一行的第一个字符j : 向下 M : 屏幕中央那一行的第一个字符k : 向上 L : 屏幕下方...l : 向右 G : 移到档案的最后一行Ctrl + f : 屏幕向下一页Ctrl + b : 屏幕向上一页Ctrl + d : 屏幕向下移动半页Ctrl + u : 屏幕向上移动半页+ : 光标移动到非空格符的下一行- ： 光标移动到非空格符的上一行n&lt;space&gt; : n 表示数字，按下数字再按空格键光标以单词位单位移动w|W : b|B :e|E :nw|nW :nb|nB :光标移动至行首或行尾0 | ^ : 光标移动到行首$ : 光标移动到行尾n$ : 光标移动到指定字符fx :Fx :光标移动到指定行gg : 移到档案第一行G : 移到档案最后一行nG : 移动到档案的第n行:n : 光标向下移动n行光标移动到匹配的括号处% : 将光标先定位到 &quot;&#123;&quot; ,然后再使用 &quot; % &quot; 命令，可定位到 &quot; &#125; &quot; 批量注释和自定义注释快捷键s/^/#/g :eg: :1,10s/^/#/g :取消连续行注释:1,10s/^#//g ::map 快捷键 执行命令 Vim map Vim]]></content>
      <categories>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git]]></title>
    <url>%2F2019%2F08%2F09%2FGit-Note%2F</url>
    <content type="text"><![CDATA[iFaithFreedom Git建Git仓库两种场景： 1. 把已有的项目代码纳入Git管理cd 项目代码所在的文件夹git init 2. 新建的项目直接用Git管理cd 某个文件夹git init your_project # 会在当前路径下创建和项目名称同名的文件夹cd your_project Git 分离头指针在没有绑定分支的情况下，git status 会显示 HEAD， 后面需要 git branch xxx head_id 如果没有保存，会被当作垃圾清理掉HEAD branchgit checkout -b xxx yyy // 基于yyy 创建 xxx 分支 HEAD 可脱离分支，独立存在git diff // 比较两个commit 的不同 git diff HEAD HEAD^ | HEAD～n 查看不同提交的指定文件的差异git diff 分支1 分支2 -- 文件 // 比较不同分支的差异 git diff 分支指针1 分支指针2 -- 文件 // 用分支比较文件的差异正确删除文件的方法git rm xxx // 删除xxx 文件开发中临时加塞了紧急任务的处理方法git stash // 把现在做的工作任务存放到不影响接下来要做的工作环境中去 git stash list // 查看所有的stash 任务的列表 git status git stash apply // 弹出最新的stash， 不保留stash 的任务 git stash pop // 弹出最新的stash 工作，存放起来的任务还在指定不需要Git管理的文件.gitignore // 文件中添加不需要被提交的文件类型将Git仓库备份到本地git clone --bare // 不在工作区的仓库 哑协议： git clone --bare 本地仓库.git 新建仓库name.git添加公钥到Github SSH and GPG keys在Github 创建个人仓库把本地仓库同步到Githubgit remote add xxx git@github.com:aspire_8/xxx.git // 新增远程Github仓库 git remote remove xxx // 删除远程Github仓库 git remote rename oldName newName // 更改远程Github仓库的名称 git push xxx -all // 提交本地所有分支到远端一般出错的情况在推送前，需要先 拉取 远程仓库到本地 git pull // 拉取远程到本地并且合并，等同于 git fetch + git merge git fetch // 仅仅把远端的拉到本地 git merge 远端分支/本地分支(master) // 合并分支把不相干的两个分支合并git merge --allow-unrelater-histories 远端仓库/本地仓库不同人修改了同文件的不同区域的处理方案git push不同人修改了同文件的同一区域的处理方案global: git pull vim xxx.xx git push local : git pull vim xxx.xx git push 会出错，local没办法提交，解决方案 vim xxx.xx // 把修改的同一地方，删除其中一个人的修改，删除git的提示信息 git status -&gt; git commit -am &apos;解决冲突&apos; -&gt; git push同时变更了文件名和文件内容的处理方案global 在更改同一文件名和内容之后 local 在本地修改文件内容， git pull 的时候，git会弹出界面提示修改的信息，同时也会在被更改文件中，添加local修改的内容 把同一文件改成不同文件名的处理方案global: 修改xxx.xx 为 xxxa.xx，local: 修改 xxx.xx 为 xxb.xx global: git push local: git pull , git rm xxx.xx, git rm xxa.xx, git add xxb.xx, git commit -m &apos;delete xxx.xx xxa.xx&apos; git push禁止向集成分支执行push -f 操作git push -f 示例: git log --oneline // 查看历史日志 git reset --hard commitID // 在本地使用reset 恢复到 任意一个commit的历史，如果使用 -f 提交的话，远程仓库所有被提交的commit之前的改动都会被删除掉，很危险！！！ 禁止向集成分支执行变更历史的操作]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生活日记]]></title>
    <url>%2F2019%2F08%2F08%2FLife-Note%2F</url>
    <content type="text"><![CDATA[记： 七夕节，回家做晚饭，吃完饭大概八点多，躺了一会，出去散了个步，回到家十点半，洗了个澡，十一点。然后闲着无聊，开始着手部署博客项目。到现在是8.8号凌晨 两点多。阿哈，真累！ 以后要养成记笔记的习惯，哈哈，不然学会的东西很快就会忘记的额～！]]></content>
      <categories>
        <category>Life</category>
        <category>Year</category>
        <category>Month</category>
        <category>Day</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
</search>
