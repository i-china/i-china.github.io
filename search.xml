<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Error]]></title>
    <url>%2F2019%2F08%2F14%2FError-Note%2F</url>
    <content type="text"><![CDATA[积累工作中常见错误 TODO List 积累错误]]></content>
      <categories>
        <category>Error</category>
      </categories>
      <tags>
        <tag>Error</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Design]]></title>
    <url>%2F2019%2F08%2F14%2FDesign-Note%2F</url>
    <content type="text"><![CDATA[设计模式 TODO: 设计模式创造型设计模式 简单工厂 工厂方法 抽象工厂 构建器 原型 单例 结构型设计模式 适配器 桥梁 组合 装饰 门面 享元 代理 行为型设计模式 责任链 命令行 迭代器 中介者 备忘录 观察者 访问者 策略 状态 模版方法]]></content>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019年]]></title>
    <url>%2F2019%2F08%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[At 2019 我的野心，以及和挚友的约定！]]></content>
      <categories>
        <category>Life</category>
        <category>Year</category>
        <category>Month</category>
        <category>Day</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NoSQL]]></title>
    <url>%2F2019%2F08%2F11%2FNoSQL-Note%2F</url>
    <content type="text"><![CDATA[NoSQL TODO ListRedis Memcached]]></content>
      <categories>
        <category>NoSQL</category>
        <category>Redis</category>
        <category>Memcached</category>
      </categories>
      <tags>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL]]></title>
    <url>%2F2019%2F08%2F11%2FMySQL-Note%2F</url>
    <content type="text"><![CDATA[MySQL TODO LIST基本语法常见用法集群缓存主从复制双主热备分库分表分布式架构]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo]]></title>
    <url>%2F2019%2F08%2F11%2FHexo-Note%2F</url>
    <content type="text"><![CDATA[Hexo 基础和语法 npm install -g hexo-clihexo init &lt;Folder&gt;npm installvim package.jsonhexo new [layout] &lt;title&gt;hexo generate = hexo ghexo publish [layout] &lt;filename&gt;hexo server -p xxxx -s --static -l --loghexo deploy = hexo dhexo render &lt;file1&gt; [file2] ... -o --outputhexo migratehexo clean = hexo chexo list &lt;type&gt;hexo versionhexo --safehexo --debughexo --silenthexo --config custom.ymlhexo --drafthexo --cwd /path/to/cwd npm install hexo-migrator-rss --savehexo migrate rss &lt;source&gt;npm install hexo-migrator-wordpress --savehexo migrate wordpress &lt;source&gt; Writehexo new [layout] &lt;title&gt;layout: post &gt; source/_posts page &gt; source draft &gt; source/_draftshexo new photo &quot;TEXT&quot; Front-Matter1234567891011121314151617181920212223242526272829title: TEXTdate: DATEupdated: UPDATE_TIMEcomments: truetags: TEXTcategories: TEXTpermalink: urlkeywords: TEXTcopyright: true Tag Plugins引用块&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125; content &#123;% endblockquote %&#125; 代码块&#123;% codeblock [title] [lang:language] [url] [link text] %&#125;code snippet&#123;% endcodeblock %&#125; 反引号代码块&#123;% pullquote [class] %&#125;content&#123;% endpullquote %&#125; SERVERnpm install hexo-server --savehexo server -p 5000hexo server -shexo server -i 192.168.1.1 MADE FILEShexo generatehexo generate --watchhexo generate --deployhexo deploy --generatehexo g -dhexo d -g DEPLOYnpm install hexo-deploy-git --savehexo deploydeploy: type: git repo: &lt;repository url&gt; branch: [branch_name] message: [message] SFTPnpm install hexo-deployed0-sftp --savevim _config.yml deploy: type: sftp host: &lt;host&gt; user: &lt;user&gt; pass: &lt;password&gt; remotePath: [remote path] port: [port] privateKey: [path/to/privateKey] passphrase: [passphrase] agent: [path/to/agent/socket] PERMALINKSvim _config.yml permalink_defaults: lang: en|zh-Hans THEMEgit clone git@github.com/&lt;username&gt;/xxx.git theme/xxx cd xxx npm install TEMPLATEindex 首页 post 文章 page 分页 archive 归档 category 分类 tag 标签 具体看官方APIHEXO-DOC]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript]]></title>
    <url>%2F2019%2F08%2F11%2FJavaScript-Note%2F</url>
    <content type="text"><![CDATA[JavaScript]]></content>
      <categories>
        <category>JavaScript</category>
        <category>JQuery</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx]]></title>
    <url>%2F2019%2F08%2F11%2FNginx-Note%2F</url>
    <content type="text"><![CDATA[iFaithFreedom TODO LIST基本语法常见用法虚拟主机反向代理缓存负载均衡 配置文件由指令与指令块构成Nginx_DOC每条指令以 ； 分号结尾，指令与参数间以空格符号分隔指令块以 {} 大括号将多条指令组织在一起include 语句允许组合多个配置文件以提升可维护性使用# 符号添加注释，提高可读性使用 $ 符号使用变量部分指令的参数支持正则表达式配置参数： 时间的单位s: seconds m: minutes h:hours d:days w:weeks M:months,30 days y:years,365 days 空间的单位bytes k/K: kilobytes m/M: megabytes g/G: gigabyteseg: &#123;12345678910111213141516 include mime.types; upstream xxx &#123; server 127.0.0.1:8000; &#125;&#125;server &#123; listen 443 http2; # Nginx Config syntax limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s; location ~* \.(gif|jpg|jpeg)$ &#123; proxy_cache my_cache; expires 3m;proxy_cache_key $host$uri$is_args$args; proxy_cache_valid 200 304 302 1d; proxy_pass http://xxx.xxx; &#125;&#125; 重载，热部署，日志切割Nginx 命令行：格式： nginx -s reload帮助： -？ -h使用指定的配置文件： -c指定配置指令： -g指定运行目录： -p发送信号： -s ： 立刻停止服务： stop 优雅的停止：quit 重载配置文件： reload 重新开始记录日志文件 reopen测试配置文件是否有语法错误： -t -T打印nginx的版本信息、编译信息等： -v -V 重载： nginx -s reload热部署：nginx 版本升级， 编译安装， kill -USR2 nginxID(ps -ef | grep nginx), kill -WINCH ID(进程号)日志切割：xxx.lg(日志文件) nginx -s reopen Nginx 配置静态资源Web服务器http { include mime.types; #default_type application/octet-stream; log_format main ‘$remote_addr - $remote_user [$time_local] “$request” ‘ ‘$status $body_bytes_sent “$http_referer” ‘ ‘“$http_user_agent” “$http_x_forwarded_for”‘; client_max_body_size 60M; proxy_cache_path /tmp/nginxcache levels=1:2 keys_zone=my_cache:10m max_size=10g inactive=60m use_temp_path=off; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; gzip on; gzip_min_lengt 1; gzip_comp_level 2; gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png; } server { listen 8080; server_name hale.dev; access_log logs/hale.dev.log main; location / { alias dirpath/; #autoindex on; # 开启目录浏览功能 #set $limit_rate 1k; # 限制访问速度 每秒传输1kb #index index.html index.htm; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; } nginx -s reloadNginx 搭建缓存功能的反向代理服务openresty实现反向代理 include vhost/****.conf;upstream local { server 127.0.0.1:8080;} server { server_name hale.dev; listen 80; location / { proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; #proxy_cache my_cache; #proxy_cache_key $host$uri$is_args$args; #proxy_cache_valid 200 304 302 1d; proxy_pass http://local; }} 此处的配置详情可以在Nginx官网 ngx__http__proxy_module 中获取GoAccess实现可视化并实时监控access日志]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown]]></title>
    <url>%2F2019%2F08%2F11%2FMarkDown-Note%2F</url>
    <content type="text"><![CDATA[MarkDown 基础、语法 斜体、粗体 *斜体* _斜体 _ **粗体** *** 加粗斜体 *** ~~ 删除线 ~~ 分级标题 # ## ## ### #### ##### ###### 超链接 TEXT[Your Message](https://i-china.github.io/) TExt[Your Text][https://i-china.win/ &quot;message&quot;] 锚点 Goto[Redirect](#TEXT) 列表 无序列表 * + - 有序列表 1. Text 2. Text 3. Text ... 代码缩进 * TEXT // * 后三空格 列表引用 &gt; TEXT &gt; TEXT 引用 列表嵌套 &gt;&gt;&gt; TEXT &gt;&gt; TEXT &gt; TEXT 其他要素 &gt; T1 &gt; T2 &gt; T3 &gt; T4 ... 插入图片 TEXT:![TEXT](URL &quot;TEXT&quot;) 内容目录 [TOC] 注脚 TEXT[^1] TEXT[^2] TEXT[^flag] [^1]: TEXT Comment [^2]: TEXT Comment [^flag]: TEXT FOR flag 公式$ 表示行内公式 $E=mc^2$$$ 整行公式 $$\sum_{i=1}^n a_i=0$$ 流程图st=&gt; start: START:&gt;url e=&gt;end: TEXT:&gt;url op1=&gt;operation: text|past // 有些复杂，不经常用，先不写了 表格居左：:---- 居中：:----:或者 ----- 居右：:----:TEXT|TEXT|TEXT-|-|-|TEXT|TEXT|TEXTTEXT|TEXT|TEXT-----------TEXT|TEXT-|-:TEXT TEXT | TEXT/TEXT 分割线* * *********- - ---------- 代码CODE()``` #include&lt;stdio.h&gt; ``` 换行行后 加两空格 文本&lt;center&gt; TEXT &lt;/center&gt;&lt;left&gt; TEXT &lt;/left&gt;&lt;right&gt; TEXT &lt;/right&gt;&lt;u&gt; TEXT &lt;/u&gt; 备注： 有些不清楚，需要随用随查！]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker]]></title>
    <url>%2F2019%2F08%2F11%2FDocker-Note%2F</url>
    <content type="text"><![CDATA[Docker Technology]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang]]></title>
    <url>%2F2019%2F08%2F09%2FGolang-Note%2F</url>
    <content type="text"><![CDATA[iFaithFreedom TODO List]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python]]></title>
    <url>%2F2019%2F08%2F09%2FPython-Note%2F</url>
    <content type="text"><![CDATA[Python Note]]></content>
      <categories>
        <category>Python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux]]></title>
    <url>%2F2019%2F08%2F09%2FLinux-Note%2F</url>
    <content type="text"><![CDATA[Linux TODO ListCentos Ubuntu Linux 文件和目录管理cd: 切换目录 cd 选项~ ： 当前用户的主目录 ~用户名：指定用户的主目录 - ： 上次所在的目录 . : 当前目录 ..: 上级目录 pwd：显示当前路径 whoami：当前登陆的用户 ls： 查看目录下文件 ls 选项 文件 -a: 全部文件 -A: 全部不包括. .. -d: 目录本身 -f: 以文件名排序 -F: 再文件或目录后加上类型的指示符号 -h: 以易读方式显示 -i:显示inode节点信息 -n: 以UID和GID代替用户名和群组 -r: 将排序结果反向输出 -R: 列出目录下所有文件 -S: 以文件容量大小排序 -t: 以时间排序 -l: 使用长格式列出文件和目录信息 ls:第一列： 权限 第二列：计数(硬连接数) 第三列：所有者 第四列：所属组 第五列：大小 第六列：文件修改时间 第七列: 文件名和目录名 mkdir：创建目录文件夹 mkdir 选项 文件目录名 -p: 递归创立目录 -m: 自定义目录权限 rmdir: 删除空目录 rmdir 选项 文件目录名 -p：递归删除空目录 rmdir touch：创建文件及修改文件时间戳 touch 选项 文件名 选项： -a：访问时间 -c：时间参数 -d：修订日期 -m：修改时间 -t：修订时间 ln：在文件之间建立链接(硬链接和软链接) ln 选项 源文件 目标文件 -s：建立软链接文件，不加-s 则建立硬链接 -f：强制 如果目标文件存在，则删除后再建立链接文件 cp：复制文件和目录 cp 选项 源文件 目标文件 -a：相当于 -d -p -r 的集合 -d：如源文件为软链接，则复制出的目标文件也为软链接 -i：询问 是否覆盖 -l：把目标文件建立为源文件的硬链接，而不是复制源文件 -s：把目标文件建立为源文件的软连接，而不是复制。。。 -p：复制后目标文件保留源文件的属性 所有者、所属组、权限和时间 -r：递归复制，用于复制父母 -u：若目标文件比源文件有差异，则使用该选项更新目标文件，用于对文件的升级和备用 rm：删除文件或目录 rm 选项 文件或目录 -f： 强制删除 -i: 删除前给出提示 -r： 递归删除，用于目录 mv：移动文件或改名 mv 选项 文件或目录 -f：强制覆盖，不询问，直接覆盖 -i：交互移动，询问是否覆盖 -n：如果目标文件已存在，不会覆盖移动，也不询问 -v: 显示文件或目录移动过程 -u: 若目标文件存在，两者相比，源文件更新，对目标文件进行升级 打包(归档)和压缩tar：打包 tar 选项 源文件或目录 -c：将多个文件或目录打包 -A：追加tar文件到归档文件 -f：指定包的文件名 -v：显示打包过程 -x：对tar包做 解压 -C：指定解压包位置 -z：压缩和解压缩”.tar.gz” -j：压缩和解压缩”.tar.bz2” tar.gz: -zxvf -zcvftar.bz2: -jxvf -jcvf zip: 压缩文件和目录 zip 选项 压缩包名 源文件或源目录列表 -r： 递归压缩目录，所有文件以及目录全部压缩 -m： 压缩后，删除源文件 -v： 显示详细的压缩过程 -q： 不显示命令执行过程 -压缩级别： 1~9 -1 代表压缩速度最快 -9 代表压缩效果更好 -u： 更新压缩文件，往压缩文件添加新文件 unzip：解压zip文件 unzip 选项 压缩包名 -d 目录： 将压缩文件解压到指定目录下 -n： 解压时不覆盖存在的文件 -o： 解压时覆盖已经存在的文件，无需确认 -v： 查看压缩文件的详细信息 -t： 测试有无损坏，并不解压 -x 文件列表: 解压文件，但不包含文件列表中指定的文件 gzip：压缩文件或目录 gzip 选项 源文件 -c：将压缩数据输出到标准输出中，保留源文件 -d：对压缩文件解压 -r：递归压缩指定目录下以及目录下的所有文件 -l：对每一个压缩文件 显示字段 压缩文件大小 未压缩大小 压缩比 未压缩名称 -数字 ：指定压缩等级， -1 等级最低，压缩比最差 gunzip：解压缩文件或目录 gunzip 选项 文件 -r：递归处理，解压缩指定目录下所有文件 -c：把解压缩后的文件输出到标准设备 -f：强制解压缩文件，不理会是否已存在 -l：列出压缩文件内容 -v：显示命令执行过程 -t：测试压缩文件是否正常，不做任何操作 bzip2：压缩文件 bz2格式 bzip2 选项 源文件 -d: 执行解压缩 -k: 解压缩完成后，删除源文件，要保留源文件，需使用此选项 -f：再解压或解压缩时，若同名，默认不覆盖，此选项会强制覆盖现有文件 -t：测试压缩或解压缩的完整性 -v：显示详细信息 -数字： -1 等级最低，压缩比最差 -9 压缩比最高 bunzip2 bz2 格式的及压缩命令 bunzip2 选项 -k: 解压缩后，默认删除压缩文件，若要保留，使用此参数 -f： 解压缩时，若同名，默认不覆盖，若要覆盖，使用此参数 -v： 显示命令执行过程 -L: 列出压缩文件内容 三剑客 grep sed awkcat： 连接文件并打印输出到标准输出设备 cat 选项 文件名 -A：列出所有隐藏符号 -E: 列出每行结尾的回车符$ -n：对输出的所有行进行编号 -b：只对非空行进行编号 -T：把Tab键 ^| 显示 -V：列出特殊字符 -s：连续2行以上的空白行，替换为1行的空白行 &gt;: 合并 &gt;&gt;：追加 more：分屏显示文件内容 more 选项 文件名 -f：计算行数 实际的行数， -p：清屏后显示内容 -c：先显示内容再清楚旧的资料 -s：连续两行以上的空白行，就替换为一行的空白行 -u：不显示下引号 +n：从第n行开始显示文件内容，n代表数字 -n：一次显示的行数，n表示数字 交互指令及功能 h或？： 帮助信息 q或Q ： 退出 v： 在当前行启动一个编辑器 ：f 显示当前文件的文件名和行号 !&lt;命令&gt;：在子shell中执行指定命令 回车：向下移动一行 空格：向上移动一行 Ctrl+l：刷新屏幕 =： 显示当前行的行号 ‘： 转到上一次搜索开始的地方 Ctrl+f： 向下滚动一页 .：重复上次输入的命令 /字符串：搜索指定的字符串 d：向下移动半页 b：向上移动半页 head：显示文件开头的内容 head 选项 文件名 -nK： K表示行数，除了文件最后K行外，显示剩余的全部内容 -cK： K表示字节，除了文件最后K字节，显示剩余全部的内容 -v： 显示文件名 less： 查看文件内容 less 选项 文件名 -N： 显示每行的行号 -S： 行过长时舍弃超出部分 -e： 文件显示结束后，自动离开 -g： 只标志最后搜索到的关键词 -Q： 不使用警告音 -i： 忽略搜索时的大小写 -m： 显示类似more的百分比 -f: 强迫打开特殊文件 -s: 显示连续行为一行 -b： 设置缓冲区的大小 -o： 将less输出的内容保存到指定文件中 -x： 将tab键显示为规定的数字空格 交互指令及功能 / ? n N b d h|H q|Q y 空格键 回车键 PgDn PgUp Ctrl + f Ctrl + b Ctrl + d Ctrl + u j k G g ZZ v [ ] p u tail： 显示文件结尾的内容 tail 选项 文件名 -nK： K指行数，从文件的第K行开始输出 -cK： K指字节数，从文件第K个字节开始输出 -f： 输出文件变化后新增加的数据 grep： 查找文件内容 正则表达式正则表达式的通配符 c* ： 匹配0个空白或多个字符c(c为任一字符) . ： 匹配任何一个字符，只能是一个字符 [xyz]：匹配方括号中的任意一个字符 [^xyz]：匹配除方括号中字符外的所有字符 ^ ： 锁定行的开头 $ ： 锁定行的结尾 需结合反斜杠 \， grep 命令基本格式： grep 选项 模式 文件名 -c ：列出文件中包含模式的行数 -i ：忽略模式中的字母大小写 -l ：列出带有匹配行的文件名 -n ：在每一行的最前面列出行号 -v ：列出没有匹配模式的行 -w ：把表达式当作一个完整的单字符来搜寻，忽略部分匹配的行sed 根据脚本命令处理文本文件中的数据，命令从命令行输入，或存储在一个文本文件中，此命令执行数据顺序： 1.每次仅读取一行内容 2. 根据规格命令匹配并修改数据 3.将执行结果输出sed 选项 脚本命令 文件名 -e 脚本命令： 将其后跟的脚本命令添加到已有的命令中 -f 脚本命令文件： 将其后文件中的脚本命令添加到已有的命令中 -n ： 所有脚本指定执行完毕后，自动输出处理后的内容，需使用print来输出 -i ： 直接修改源文件，慎用！ sed 脚本命令 sed s 替换脚本命令： [address]s/pattern/reloacement/flags address : 指定要操作的具体行 pattern ：需要替换的内容 replacement：要替换的新内容 sed s 命令 flags 标记及功能 n ： 1-512 之间数字，表示指定要替换的字符串出现第n次时才进行替换 g ： 匹配到的所有内容进行替换 p ： 打印与替换命令中指定的模式匹配的行 与-n选项使用 w file ：将缓冲区中的内容写道指定的file文件中 &amp; ： 用正则表达式匹配到的内容进行替换 \n ： 匹配第n个字串，该字串之前在pattern中用 \(\) 指定 \ ： 转义 sed d 替换脚本命令 需要删除文本中的特定行，用d脚本命令，删除指定行中的所有内容，如忘记指定具体行，删删除所有内容 [address]d sed a | sed i 脚本命令 a 表示在指定行的后面附加一行，i表示在指定行的前面插入一行 [address]a(i或) \新文本内容 sed c 替换脚本命令 c 表示将指定行中的所有内容，替换成该选项后面的字符串 [address]c\用于替换的新文本 sed y 转换脚本命令 y 转换命令唯一可以处理单个字符 [address]y/inchars/outchars/ sed p 打印脚本命令 p 搜索符号条件的行，输出该行的内容 [address]p sed w 脚本命令 w 将文本中指定行的内容写入文件 [address]w filename sed r 脚本命令 r 将一个独立文件的数据插入到当前数据流的指定位置 [address]r filename sed q 退出脚本命令 q 使sed命令在第一次匹配任务结束后，退出sed程序sed 脚本命令的寻址方式 两种： 1.[address]脚本命令 2.address{ 多个脚本命令 }awk 文本数据处理工具基本格式： awk 选项 &apos;脚本命令&apos; 文件名 -F fs ：指定以fs作为输入行的分隔符，默认以分隔符为空格或制表符 -f file ：从脚本文件中读取awk脚本指令，取代直接在命令行中输入指令 -v var=val：在执行前，设置一个变量var，初始值为 val awk 使用数据字段变量 $0 ：代表整个文本行 $1 ： 代表文本行的第1个数据字段 $2 : 。。。第2个数据字符按 $n : 代表第n个数据字段 awk 脚本命令使用多个命令 awk &apos;{ $a = &quot;some text&quot; print $0 }&apos; awk 从文件中读取程序 awk -F: -f awk.sh /etc/passwd awk BEGIN 关键字 awk &apos;BEGIN&apos; {print &quot;text&quot;} awk END 关键字 awk &apos;ENG&apos; {print &quot;text&quot;}软件安装相关RPM 包安装、卸载、升级 /etc/ ：配置文件安装目录 /usr/bin/ ：可执行的命令安装目录 /usr/lib/ ：程序所使用的函数库保存位置 /usr/share/doc/ ：基本的软件使用手册保存位置 /usr/share/man/ ：帮助文件保存位置RPM 包的安装 rpm -ivh 包名 -i ：安装(install) -v ：显示详细信息(verbose) -h ：打印 # 显示安装进度(hash) rpm -ivh x.rpm xx.rpm xxx.rpm rpm 选项 包名 -nodeps ： 不检测依赖性安装 -replacefiles ：替换文件安装 -replacepkgs ：替换软件包安装 -force ：强制安装 -test ：测试安装 -prefix ：指定安装路径 软件的启动和管理service 服务名 start | stop | restart | status stat: 启动服务 stop: 停止服务 restart: 重启服务 status: 查看服务状态 检测端口： netstat -tlun | grep 80RPM 包的升级 rpm -Uvh 包名 ： 如没安装过则直接安装 rpm -Fvh 包名 ： 如没有安装，则不安装 RPM 包的卸载 (e 时 erase) rpm -e 包名 RPM 命令查询软件包 (-q, -qa, -i ,-p, -l, -f ,-R ) rpm 选项 查询对象 -q ：表示查询， query -qa ：查询系统中所有安装的软件包 -qi ：查询软件包的详细信息 i = information -ql ：查询软件包的文件列表 -qf ：查询系统文件属于哪个RPM包 -qR ：查询软件包的依赖关系 RPM 包验证和数字证书(数字签名) rpm 包校验 -Va ：校验系统中已安装的软件包 -V ：校验已安装的包名 -Vf ：校验某个系统文件是否被修改 提取RPM包文件(cpio命令) cpio 用于从归档包中存入和读取文件 cpio 选项 -o ： 指 copy-out 模式，把数据备份到文件库中 -v ： 显示备份过程 -c ： 使用较新的protable format 存储方式 -B ： 设定输入/输出块为5120Bytes，而不是模式的512Bytes -i ： 指 copy-in ，把数据从文件库中恢复 -d ： 还原时自动新建目录 -u ： 自动使用较新的文件覆盖较旧的文件 -p ： 指复制模式 YUM 源配置 Yum 源配置文件： /etc/yum.repos.d/ ， 文件扩展名为：”*.repo” 参数： [base]: 容器名称 name：容器说明 mirrorlist：镜像站点 baseurl：源服务器的地址 enable：此容器是否生效， 不写或写enable表示生效，0为不生效 gpgcheck：为1表示RPM的数字证书生效，0为不生效 gpgkey：数字证书的公钥文件保存位置 Yum 查询、安装、升级、卸载 yum list : 列出已安装的和可安装的软件名 yum list 包名 : 查询安装情况 yum search 关键字 : 查找与关键字相关的所有软件包 yum info 包名 : 查询执行软件包的详细信息 Yum 安装命令 yum -y install 包名 install ： 安装 -y ： 自动回答yes Yum 升级命令 yum -y update ： 升级所有软件包 yum -y update 包名 ： 升级特定的软件包 Yum 卸载命令 yum remote 包名 ：卸载指定的软件包 Yum 查询软件组包含的软件 yum groupinfo 软件组名 ： 查询软件组包含的软件 Yum 安装软件组 yum groupinstall 软件组名 ： 安装指定软件组，组名由grouplist查询出来 Yum 卸载软件组 yum groupremove 软件组名 ： 卸载指定软件组 Linux 源码包安装和卸载 首先安装 gcc 和 make rpm -q gcc | yum -y install gcc rpm -q make | yum -y install make 下载源码包，如: xxx.tar.gz 解压： tar -zxvf xxx.tar.gz 进入解压目录 检测系统环境是否符合安装要求： ./configure 定义需要的功能选项： ./configure –prefix=安装路径 执行 ./configure–help 查询支持的功能 编译： make 正式安装软件： make install 重装：在make前，要执行 make clean ，他会清空 Makefile 文件或编译产生的 .o 头文件 Linux 源码包卸载 rm -rf /usr/local/xxx ： 删除软件的安装目录，删除前需停止服务 Linux 源码包快速升级 使用补丁更新源码包： 省去./configure 生成新的 Makefile文件，还省去了编译 Linux 补丁文件的生成和使用 diff 选项 old new -a ： 将任何文档当作文本文档处理 -b ： 忽略空格造成的不同 -B ： 忽略空白行造成的不同 -l ： 忽略大小写造成的不同 -N ： 比较两个目录时，如某个文件只在一个目录，则另一个目录视为空 -r ： 比较目录时，递归比较子目录 -u ： 使用同一输出格式 1. 创建两个文件 mkdir test | cd test | vi old.txt | vim new.txt 2. 利用diff命令，比较两个文件(old.txt 和 new.txt)的不同，并生成补丁文件 (txt.patch)，执行一下代码： diff -Naur /roor/test/old.txt /root/text/new.txt &lt; txt.patch给软件打入补丁 1. 下载补丁文件 2. 复制补丁文件到源码包解压目录中 cp xxx.diff 软件包名 3. 给旧软件打入补丁 cd 软件目录 | vi xxx.diff 4. 重新编译 软件包源码 make 3. 安装 软件 make install Linux 用户和用户组管理UID 和 GID (用户ID 和 组ID) /etc/passwd 系统用户配置文件，存储系统所有用户的基本信息，所有用户有读操作 表达的含义： 用户名： 密码：UID(用户ID) ：GID(组ID) ：描述性信息 ： 主目录 ： 默认Shell 用户名： 代表用户身份的字符串 密 码 ：x 表示此用户设有密码， 真正的密码保存在 /etc/shadow 文件中 UID ： 用户ID，识别不同的用户 0~65535 0 ： 超级用户 1 ~ 499 ： 系统用户 500 ~ 65535 ： 普通用户 GID ： Group ID ，组ID 初始组： 如：建立用户lamp的同时，建立 lamp组作为lamp用户的初始组 附加组： 指用户可以加入多个其他的用户组，并拥有这些组的权限 描述性信息： 主目录： 用户登陆后有操作权限的访问目录，用户的主目录 默认的Shell：Linux的解释器，用户和Linux内核沟通的桥梁，默认 bash /bin/bash/etc/shadow (影子文件) 用户名：加密密码：最后一次修改时间：最小修改时间间隔：密码有效期：密码需要变更前的警告天数：密码过期后的款期时间：账号失效时间：保留字段 忘记密码： 1.重启进入单用户模式， 系统会提供root权限的bash 接口，用 passwd命令修改账号密码； 2.通过挂载根目录，修改 /etc/shadow，将账户的root密码清空/etc/group 用户组配置文件，用户组的所有信息存放在此文件中 组名：密码：GID：该用户组中的用户列表 /etc/gshadow 组名：加密密码：组管理员：组附加用户列表 初始组和附加组 添加新用户： useradd user 添加新群组： groupadd group 将用户xxx加入到xxx群组： usermod -G group user 查找： grep ‘user’ /etc/passwd /etc/group /etc/gshadow 一个用户可以所属多个附加组，但只能有一个初始组 查看用户所属全部群组: gourps/etc/login.defs :创建用户的默认设置文件 useradd ： 添加新的系统用户 useradd 选项 用户名 -u UID : 手工指定用户的UID，UID 不要小于500 -d 主目录 ： 手工指定用户的主目录，必须是绝对路径，注意权限 -c 用户说明 ： 手工指定 /etc/passwd 文件中各用户信息中第5哥字段的描述性内容，可随意配置 -g 组名 ： 手工指定用户的初始组 -G 组名 ： 指定用户的附加组 -s shell ：手工指定用户的登录 Shell ，默认是 /bin/bash -e 日期 ： 指定用户的失效日期 格式为 “YYYY-MM-DD” /etc/shadow 文件的第八个字段 -o ： 允许创建的用户的UID 相同，例如：useradd -u 0 -o usertest -m ： 建立用户时强制建立用户的家目录 -r ： 创建系统用户 UID 在 1 ~ 499 /etc/default/useradd 文件 passwd ：修改用户密码 passwd 选项 用户名 -S ：查询用户密码的状态 = /etc/shadow -l ：暂时锁定用户 -u ：解锁用户 –stdin ：通过管道符输出的数据作为用户的密码，主要用于批量添加用户 -n ： 天数 不能修改密码期限 /etc/shadow 第4个字段 -x ： 天数，设置密码有效期 第5个字段 -w ： 天数 用户密码过期的警告天数 第6个字段 -i ： 日期，用户密码失效日期 第7个字段 usermod ： 修改用户信息 usermod 选项 用户名 -c ： 用户说明：修改用户的说明信息 修改 /etc/paswd 文件目标用户信息的第5个字段 -d ： 主目录： 修改用户的主目录 6 -e ： 日期：修改用户的失效日期 8 -g ： 组名：修改用户的初始组 4 -u ： UID： 修改用户的UID 3 -G ： 组名：修改用户的附加组，把用户加入其他用户组 -l ： 修改用户名称 -L ： 临时锁定用户 -U ： 解锁用户 -s ： shell： 修改用户的登录Shell]]></content>
      <categories>
        <category>Linux</category>
        <category>Ubuntu</category>
        <category>Centos</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP]]></title>
    <url>%2F2019%2F08%2F09%2FPHP-Note%2F</url>
    <content type="text"><![CDATA[iFaithFreedom TODO ListPHP基础PHP进阶PHP高阶More…]]></content>
      <categories>
        <category>PHP</category>
        <category>Laravel</category>
        <category>ThinkPHP</category>
        <category>Yii</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim]]></title>
    <url>%2F2019%2F08%2F09%2FVim-Note%2F</url>
    <content type="text"><![CDATA[iFaithFreedom 6 种模式普通模式 插入模式 可视模式 选择模式 命令行模式 Ex模式 普通模式ddndddjdGdggdbdw 插入模式iIaAxXsS 可视模式与普通模式相似 选择模式Ctrl + vShift + v 命令行模式：执行命令/ ：搜索? ：搜索! ：过滤命令 Ex模式与命令行模式相似，在使用 :visual 命令离开Ex模式前，可一次执行多条命令 文件操作filename = x.x-r x.x:-R x.x: x.x: n x.x: /pattern x.x: -c command x.x 编辑操作i: 光标所在处插入I: 所在行的第一个非空格符处开始插入o: 光标所在行的下一行输入新的一行O: 光标所在行的上一行输入新的一行a: 光标所在的下一个字符处开始输入A: 光标所在行的最后一个字符处开始输入r: 取代光标所在的那个一字符一次R: 取代光标所在的文字，直到按下 ESC为止 查找文本/abc:/^abc:/abc$:?abc:n:N: 替换文本r:R::s/x/x1/g::x1,x2s/y1/y2/g::g/x1/x2/g 删除文本x: 向后删除一个字符 X: 向前删除一个字符 nx：连续向后删除n个字符dd: 删除光标所在的一整行ndd: 删除光标所在的向下n行dG: 删除光标所在到最后一行的所有数据d$: 删除光标所在处到最后一个字符d0: 删除光标所在处到该行的最前面一个字符D: 删除光标末尾的字符:x1,x2d p: 粘贴被删除的文本内容 复制文本p: 粘贴通过复制下的行数和字符P: 会增加行数yy: 复制光标所在的那一行nyy: 复制光标所在的向下n行y1G: 复制光标所在行的第一行的所有数据y0: 复制光标所在的那个字符到该行行首的所有数据y$: 复制光标所在的那个字符到该行行尾的所有数据yw:J: 将光标所在行与下一行的数据结合成同一行c: 重复删除多个数据u: 复原前一个动作Ctrl+r: 重做上一个动作 保存退出:wq 保存并退出:wq! 强制保存并退出:q 离开vim:q! 强制退出不保存:w 将文本保存:w! 若文件为只读时，强制写入该档案。但取决于权限:w xxx.xx: 将编辑的数据保存成另一个档案，类似于另存:x!:n1,n2 w filename : 将n1到n2的内容存储成filename这个档案ZZ: 文件没有改动，则不保存离开，若改动，则保存后离开:! command: 暂时离开vim到指令模式下执行命令 方向键h : 向左 H : 屏幕上方那一行的第一个字符j : 向下 M : 屏幕中央那一行的第一个字符k : 向上 L : 屏幕下方…l : 向右 G : 移到档案的最后一行Ctrl + f : 屏幕向下一页Ctrl + b : 屏幕向上一页Ctrl + d : 屏幕向下移动半页Ctrl + u : 屏幕向上移动半页 : 光标移动到非空格符的下一行 ： 光标移动到非空格符的上一行n : n 表示数字，按下数字再按空格键 光标以单词位单位移动w|W :b|B :e|E :nw|nW :nb|nB : 光标移动至行首或行尾0 | ^ : 光标移动到行首$ : 光标移动到行尾n$ : 光标移动到指定字符fx :Fx : 光标移动到指定行gg : 移到档案第一行G : 移到档案最后一行nG : 移动到档案的第n行:n : 光标向下移动n行 光标移动到匹配的括号处% : 将光标先定位到 “{“ ,然后再使用 “ % “ 命令，可定位到 “ } “ 批量注释和自定义注释快捷键s/^/#/g :eg: :1,10s/^/#/g : 取消连续行注释:1,10s/^#//g : :map 快捷键 执行命令Vim map Vim]]></content>
      <categories>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git]]></title>
    <url>%2F2019%2F08%2F09%2FGit-Note%2F</url>
    <content type="text"><![CDATA[iFaithFreedom Git建Git仓库两种场景： 1. 把已有的项目代码纳入Git管理cd 项目代码所在的文件夹git init 2. 新建的项目直接用Git管理cd 某个文件夹git init your_project # 会在当前路径下创建和项目名称同名的文件夹cd your_project Git 分离头指针在没有绑定分支的情况下，git status 会显示 HEAD， 后面需要 git branch xxx head_id 如果没有保存，会被当作垃圾清理掉HEAD branchgit checkout -b xxx yyy // 基于yyy 创建 xxx 分支 HEAD 可脱离分支，独立存在git diff // 比较两个commit 的不同 git diff HEAD HEAD^ | HEAD～n 查看不同提交的指定文件的差异git diff 分支1 分支2 -- 文件 // 比较不同分支的差异 git diff 分支指针1 分支指针2 -- 文件 // 用分支比较文件的差异正确删除文件的方法git rm xxx // 删除xxx 文件开发中临时加塞了紧急任务的处理方法git stash // 把现在做的工作任务存放到不影响接下来要做的工作环境中去 git stash list // 查看所有的stash 任务的列表 git status git stash apply // 弹出最新的stash， 不保留stash 的任务 git stash pop // 弹出最新的stash 工作，存放起来的任务还在指定不需要Git管理的文件.gitignore // 文件中添加不需要被提交的文件类型将Git仓库备份到本地git clone --bare // 不在工作区的仓库 哑协议： git clone --bare 本地仓库.git 新建仓库name.git添加公钥到Github SSH and GPG keys在Github 创建个人仓库把本地仓库同步到Githubgit remote add xxx git@github.com:aspire_8/xxx.git // 新增远程Github仓库 git remote remove xxx // 删除远程Github仓库 git remote rename oldName newName // 更改远程Github仓库的名称 git push xxx -all // 提交本地所有分支到远端一般出错的情况在推送前，需要先 拉取 远程仓库到本地 git pull // 拉取远程到本地并且合并，等同于 git fetch + git merge git fetch // 仅仅把远端的拉到本地 git merge 远端分支/本地分支(master) // 合并分支把不相干的两个分支合并git merge --allow-unrelater-histories 远端仓库/本地仓库不同人修改了同文件的不同区域的处理方案git push不同人修改了同文件的同一区域的处理方案global: git pull vim xxx.xx git push local : git pull vim xxx.xx git push 会出错，local没办法提交，解决方案 vim xxx.xx // 把修改的同一地方，删除其中一个人的修改，删除git的提示信息 git status -&gt; git commit -am &apos;解决冲突&apos; -&gt; git push同时变更了文件名和文件内容的处理方案global 在更改同一文件名和内容之后 local 在本地修改文件内容， git pull 的时候，git会弹出界面提示修改的信息，同时也会在被更改文件中，添加local修改的内容 把同一文件改成不同文件名的处理方案global: 修改xxx.xx 为 xxxa.xx，local: 修改 xxx.xx 为 xxb.xx global: git push local: git pull , git rm xxx.xx, git rm xxa.xx, git add xxb.xx, git commit -m &apos;delete xxx.xx xxa.xx&apos; git push禁止向集成分支执行push -f 操作git push -f 示例: git log --oneline // 查看历史日志 git reset --hard commitID // 在本地使用reset 恢复到 任意一个commit的历史，如果使用 -f 提交的话，远程仓库所有被提交的commit之前的改动都会被删除掉，很危险！！！ 禁止向集成分支执行变更历史的操作]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生活日记]]></title>
    <url>%2F2019%2F08%2F08%2Farticle%2F</url>
    <content type="text"><![CDATA[记： 七夕节，回家做晚饭，吃完饭大概八点多，躺了一会，出去散了个步，回到家十点半，洗了个澡，十一点。然后闲着无聊，开始着手部署博客项目。到现在是8.8号凌晨 两点多。阿哈，真累！ 以后要养成记笔记的习惯，哈哈，不然学会的东西很快就会忘记的额～！ vim docker linux]]></content>
      <categories>
        <category>Life</category>
        <category>Year</category>
        <category>Month</category>
        <category>Day</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
</search>
