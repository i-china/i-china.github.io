<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Socket]]></title>
    <url>%2F2019%2F08%2F29%2FSocket-Note%2F</url>
    <content type="text"><![CDATA[iFaithFreedom 123@Author : Hale Lv@Created Time : 2019-08-29 21:26:32@Description : Socketsocket： 套接字，通信技术就是两台联网的计算机之间交换数据的技术。 原意是插座，是计算机之间进行通信的一种约定或一种方式。 通过socket，计算机可接收、可发送数据 典型应用：web服务器和浏览器：浏览器获取用户输入的URL，向服务器发起请求，服务器分析接收到的URL，将对应的网页内容返回给浏览器，浏览器再经过解析和渲染，将文字、图片、视频元素呈现给用户 为了表示和区分已经打开的文件，Linux给每个文件分配一个ID整数，被称为：文件描述符File Descriptor如： 0： 输入文件 stdin，键盘 1: 输出文件 stdout ，显示器 网络连接也是一个文件，也有文件描述符 socket() 创建网络连接，打开一个网络文件，返回值即文件描述符。有文件描述符，即可使用普通的文件操作函数来传输数据，如： read() ：读取从远程计算机传来的数据 write()：向远程计算机写入数据 Windows 系统中的socket Windows：文件句柄 Liunx ： 文件描述符套接字的类型，socket的类型 有很多如：DARPA Internet 地址： Internet套接字、 本地节点的路径名：Unix套接字，CCITT X.25地址：X.25套接字等。 Internet 套接字：最常用、具有代表性 Internet套接字的数据传输方式： 1. 流格式套接字 SOCK_STREAM 流格式套接字：Stream Sockets 也叫&quot;面向连接的套接字&quot;，使用SOCK_STREAM 表示 SOCK_STREAM： 是一种可靠、双向的通信流数据。可准确无误到达另一台计算机，可损坏或丢失、可重新发送 SOCK_STREAM 的特征： 1. 数据在传输过程中不会消失 2. 数据是按照顺序传输的 3. 数据的发送和接收不是同步的。也成 不存在数据边界 使用TCP协议 The Transmission Control Protocol，传输控制协议，TCP控制数据按照顺序到达并且没有错误 IP Internet Protocol 网络协议，控制数据如何从源头到达目的地，即路由 2. 数据报格式套接字 SOCK_DGRAM 数据报格式套接字 Datagram Sockets 也叫 无连接的套接字，使用SOCK_DGRAM表示 只管传输数据，不做数据校验，如损坏或丢失，不补救，无法重传。 SOCK_DGRAM 的特征： 1. 强调快速传输而非传输顺序 2. 传输的数据肯跟丢失或损坏 3. 限制每次传输的数据大小 4. 数据的发送和接收是同步的，存在数据边界 SCOK_DGRAM：是一种不可靠、不按传序传递的、以追求速度为目的的套接字 使用UDP协议 User Datagram Protocol 用户数据报协议 面向连接和无连接的套接字 流格式套接字Stream Sockets： 面向连接的套接字，基于TCP协议 数据报格式套接字 Datagram Sockets： 无连接的套接字，基于UDP协议 无连接的套接字 每个数据包可选择不同的路径 每个数据包之间是独立的 面向连接的套接字 路径是由路由器维护的，所有路由器都要存储该路径的信息 优缺点： 无连接套接字传输效率高，不可靠、丢失数据报、捣乱数据 有连接套接字可靠、传输效率低，耗费资源 有连接的套接字TCP：HTTP、FTP等 无连接的套接字UDP：DNS、即时聊天工具等OSI 网络七层模型 OSI模型:Open System Interconnection： 开发式系统互联 七层：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层 TCP/Ip 模型： 网络接口层、网络层、传输层、应用层 网络接口：针对不同物理网络的连接形式的协议，如：Ethernet、FDDI、ATM 网络层：负责数据的传输，路径及地址选择，常用协议：IP ARP(地址解析协议) 传输层：确认数据传输及进行纠错处理，常用协议：TCP、UDP(用户数据报协议) 应用层：各种服务及应用程序通过该层利用网络，常用协议：HTTP、FTP、SMTP(简单邮件传输协议)等 发送数据包时，程序或软件是通过应用层访问网络，产生的数据会一层一层往下传输，到最后的王略接口层，通过网线发送到网上，每传一层，协议增加一层包装，比原始数据多了四层包装。 接收数据包时：从网络接口层一层一层网上传，每传一层就拆开一层包装，到最后的应用层，最原始的数据。 socket：在传输层的基础上，使用TCP/IP协议，不能访问网页，访问网页需要HTTP协议 计算机通信的原则： 1. 同一层次进行通信， 2. 功能必须相同 3. 数据只能逐层传输，不能跃层 4. 可使用下层提供的服务，并向上层提供服务 TCP/IP协议族 协议： Protocol 是网络通信过程中的约定或合同，双方必须都遵守才能正常收发数据。 协议是一种规范，通信双方需使用同一协议才能通信， TCP/IP模型包含 TCP、IP、UDP、Telnet、FTP、SMTP等]]></content>
      <categories>
        <category>Socket</category>
      </categories>
      <tags>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac]]></title>
    <url>%2F2019%2F08%2F26%2FMac-Note%2F</url>
    <content type="text"><![CDATA[Hale's Mac Mac 开发相关]]></content>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker]]></title>
    <url>%2F2019%2F08%2F16%2FDocker-Note%2F</url>
    <content type="text"><![CDATA[iFaithFreedom Docker 基础1234567891011121314151617181920212223install windwos: Control Panel -&gt; open: Hyper-V 和 容器[Docker.exe](https://www.docker.com/products/docker-desktop)Mac os : [Docker.dmg](https://www.docker.com/products/docker-desktop)Linux : wget -qO- https://get.docker.com/ | sh usermod -aG docker your-userWindows Server : Install-Module DockerProvider -Force Install-Package Docker -ProviderName DockerProvider -ForceUpdate Docker apt update apt remove docker docker-engine docker-ce docker.io -y wget -qO- https://get.docker.com/ | sh systemctl enable docker // 设置开机启动 systemctl is-enabled docker // 检测是否开机启动Docker Storage Driver: 存储驱动 /etc/docker/daemon.json : &#123;&quot;storage-driver&quot;:&quot;overlay2&quot;&#125; docker system info // 检查docker当前的存储驱动类型 运维角度看Docker1234567891011docker version镜像：docker image ls 容器：docker container run -it ubuntu:latest /bin/bash // -it 交互模式 ps -ef // 查看全部进程 docker container ls // 系统内全部处于运行状态的容器 docker container exec // 将shell连接到一个运行中的容器终端 docker container exec -it &lt;options&gt; &lt;container-name or container-id&gt; &lt;command/app&gt; Ctrl + PQ // 退出容器 docker container stop &lt;container-name or container-id&gt; // 停止容器 docker container rm &lt;container-name or container-id&gt; // 删除容器 docker container ls -a // 列出所有容器 包括已删除的 开发角度看Docker123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131 clone web应用代码 cd xxx -&gt; ls -l -&gt; cat Dockfile -&gt; docker image build // 根据Dockerfile中的指令来创建新的镜像 -&gt; docker image build -t xxx:latet .Docker 引擎 engine [总体逻辑](http://c.biancheng.net/uploads/allimg/190416/4-1Z416140U0537.gif) 组成： Docker Client、 Docker daemon、 Contained 、runc [引擎架构](http://c.biancheng.net/uploads/allimg/190416/4-1Z41614102M63.gif)启动一个新的容器 docker container run --name ctr1 -it alpine:latest sh [启动过程](http://c.biancheng.net/uploads/allimg/190416/4-1Z4161413112O.gif)daemon 作用 镜像管理、镜像构建、REST API、身份验证、安全、核心网络以及编排Docker镜像 docker container run docker service create // 从某个镜像启动一个或多个容器拉取镜像 docker image pull xxx:latest // xxx 为镜像名 latest 为版本 docker image ls // 检查docker主机本地仓库是否包含镜像 镜像仓库服务 Image Registry 镜像命名和标签 拉取镜像：docker image pull &lt;repository&gt;:&lt;tag&gt; docker image pull ubuntu:latest // 从官方ubuntu库拉取标签为latest的镜像 拉取某组织的镜像: docker image pull microsoft/powershell:nanoserver 为镜像打多个标签 docker image pull -a nigelpoulton/tu-demo 返回镜像列表内容 docker image ls --filter dangling=true // 返回没有标签的镜像(悬虚镜像)，显示为 &lt;none&gt;:&lt;none&gt; 移除全部的悬虚镜像: docker image prune 过滤器： dangding: 返回悬虚镜像(true), 非悬虚镜像(false) before : 需要镜像名称或者id，返回在之前被创建的全部镜像 since : 类似before，返回指定镜像之后创建的全部镜像 label : 根据标注(label)的名称或者值，进行过滤 docker image ls --filter=reference=&quot;*.latest&quot; docker image ls --format &quot;&#123;&#123;.Size&#125;&#125;&quot; // 通过Go模板对输出内容格式化 docker image ls --format &quot;&#123;&#123;.Repository&#125;&#125;:&#123;&#123;.Tag&#125;&#125;:&#123;&#123;.Size&#125;&#125;&quot;搜索Docker Hub docker search xxx // xxx 为 仓库名称 docker search xxx --filter &quot;is-official=true&quot; // 返回官方镜像 docker search xxx --filter &quot;is-automated=true&quot; // 显示自动创建的仓库镜像和分层 Docker 镜像由一些 松耦合 的只读镜像层组成 查看镜像分层： docker image inspect xxx:latest 查看镜像的构建历史记录： docker history [镜像层](http://c.biancheng.net/uploads/allimg/190416/4-1Z416164115364.gif) 共享镜像层 docker image pull -a xxx/xxx 本地产看镜像摘要： docker image ls --digests xxx 在docker主机删除镜像： docker image rm xxx:latest 多层架构的镜像 [Multi-architecture Image](http://c.biancheng.net/uploads/allimg/190416/4-1Z416164446156.gif) 删除本地镜像： docker image rm container-id 获取本地全部镜像: docker image ls -q 删除本地全部镜像: docker image rm $(docker image ls -q) -f Docker 镜像常用命令 docker image pull // 下载镜像 docker image pull xxx:xxx // 下载指定镜像 docker image ls // 列出全部镜像 docker image inspect // 列出镜像层数数据和元数据 docker image rm // 删除镜像 docker image rm xxx:xxx // 删除指定镜像Docker 容器 docker container run // 启动容器 docker container run &lt;image&gt; &lt;app&gt; // 指定启动所需的镜像及要运行的应用 docker container run xxx:xxx sleep 10 // shell连接到容器 10s 的时间 docker container stop // 手动停止容器运行 docker container start // 再次启动该容器 docker container rm // 删除容器容器和虚拟机 [](http://c.biancheng.net/uploads/allimg/190417/4-1Z41G01336346.gif)检擦Docker daemon docker version 如果server 部分有错，需要 usermod -aG docker &lt;user&gt; 添加到本地docker 组 检查docker daemon状态 service docker status systemctl is-active docker 启动一个简单容器 docker container run docker container run &lt;options&gt; &lt;im- age&gt;:&lt;tag&gt; &lt;app&gt; docekr 默认非TLS网络端口为 2375 ， TLS端口为 2376容器进程： ps -ef 查看正在运行的容器列表 docker container ls 启动容器后，重新连接到Docker docker container exec -it &lt;container-name or container-id&gt; bash 停止容器 docker container stop &lt;container-id or container-name&gt;删除容器 docker container rm &lt;container-id&gt;容器生命周期 docker container run --name percy -it xxx:xxx /bin/bash Ctrl - PQ 组合键退出当前容器优雅地停止容器 docker container stop // 向容器内的PID 1进程发送 SIGTERM 信号，优雅结束10s时间 没有预警停止容器 docker container stop &lt;container&gt; -f docker container rm &lt;container&gt; -f // -f 不会发送 SIGTERM，直接发出 SIGKILL 利用重启策略进行容器的自我修复 容器支持的重启策略： always unless-stopped on-failed docker container run --name xxx -it --restart always xx sh exit docker container ls 1. 创建两容器 docker container run -d --name always --restart always alpine sleep 1d docker container run -d --name unless-stopped --restart unless-stopped alpine sleep 1d docker container ls 2. 停止两容器 docker container stop always unless-stopped docker container ls 3. 重启 Docker systemctl restart docker 4. 检查两状态 docker container ls -a 结论：always 重启了，unless-stopped 没有重启 Web服务器示例12345678910111213141516171819202122232425262728293031323334353637383940414243 docker container run -d --name webserver -p 80:8080 nigelpoulton/pluralsight -docker -ci // -d 后台模式 -p 80:8080 端口映射 将Docker主机的80端口映射到容器内的8080端口 docker container stop docker container pause docker container start docker container rm 查看容器详情 docker container inspect 快速清理 $() rm $(docker image ls -q) | ($docker container ls -aq) docker container rmDocker容器常用命令 docker container run // 启动新容器 docker container ls // 列出在运行(UP)， -a: 列出停止的(Exited) docker container exec // 连接该容器 -it &lt;container-name or container-id&gt; bash docker container stop // 停止运行中的容器 docker container start // 重启停止(Exited)状态的容器 &lt;container-id or contaienr -name&gt; docker container rm // 删除停止运行的容器 docker container inspect // 显示容器配置细节和运行时信息 &lt;container-id or container-name&gt;Docker应用容器化(将应用程序部署到容器中) 容器化：将应用整合到容器中并且运行起来的过程，能够简化应用的构建、部署和运行过程 完整的应用容器化过程分为以下步骤 1. 编写应用代码 2. 创建一个Dockfile，包括应用的描述、依赖、及如何运行应用 3. 对该Dockerfile 执行 docker image build 命令 4. 等待Docker将应用程序构建到Docker镜像中 [步骤](http://c.biancheng.net/uploads/allimg/190417/4-1Z41G51T3502.gif)单体应用容器化 步骤： 1， 获取应用代码 2. 分析 Dockfile 3. 构建应用镜像 4. 运行该应用 5. 测试应用 6. 容器应用化细节 7. 生产环境中的多阶段构建 8. 最佳实践登录到Docker Hub docker login // 登录到docker docker image push // 推送到docker docker image tag web:latest xxx/web:latest // 为镜像打标签 Dockerfile1234567891011121314151617181920212223242526272829303132333435docker image build // 读取Dockerfile，并将应用程序容器化Dockerfile 示例代码： # Linux x64 FROM xxx LABEL maintainer=&quot;mr_hale@163.com&quot; # install Node and NPM RUN apk and --update nodejs nodejs-npm # Copy app to /src COPY ./src WORKDIR /src # Install dependencies RUN npm install EXPOSE 8080 ENTRYPOINT [&quot;node&quot;,&quot;./app.js&quot;]解释： -t ： 为镜像打标签 -f ： 指定Dockerfile 的路径和名称，指定位于任意路径下的任意名称的Dockerfile FROM ：用于指定要构建的镜像的基础镜像，通常是Dockerfile 中的第一条指令 RUN ： 用于在镜像中执行命令，会创建新的镜像层，每个指令创建一个新的镜像层 COPY ： 用于将文件作为一个新的层添加到镜像中，使用COPY指令将应用代码赋值到镜像中 EXPOSE ： 记录应用所使用的网络端口 ENTRYPOINT ： 指定镜像以容器方式启动后默认运行的程序 LABEL ： ENV ： ONBUILD ： HEALTHCHECK ： CMD ： Dockers Compose1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798 与Docker Stack类似，在Docker节点上，以单引擎模式(Single-Engine Mode)进行多容器应用的部署和管理 如：一个间的示例应用可能有4个服务组成 1. Web前端 2. 订单管理 3. 品类管理 4. 后台数据库 Compose 用来部署和管理繁多的服务使用：首先编写定义多容器(多服务)应用的YAML文件，然后由 docker-compose 命令处理，基于Docker引擎API完成应用的部署安装： 使用curl下载二进制文件，然后 chmod 修改权限 检验： docker-compose --version 用 pip 安装 Docker Compose 的 python 包Docker Compose YML 配置文件及常用指令 YAML 定义多服务的应用，是JSON的子集，可使用JSON定义 默认使用文件名 docker-compose.yml, 也可使用-f参数指定具体文件 示例：包含 web-fe 、 redis 的小型Flask应用 能够对其访问者进行计数并将其保存到Redis的简单Web服务 version: &quot;1.0&quot; services: web-fe: build:. command: python app.py ports: - taget: 5000 published: 5000 networks: - counter-net volumes: - type: volume source: counter-vol target: /code redis: image: &quot;redis:alpine&quot; networks: counter-net: networks: counter-net: volumes: counter-vol: 包含4个一级key： version、services、networks、volumes version: 指定版本 services: 定义不同的应用服务，compose 会将每个服务部署到各自的容器中 networks：指引docker创建新的网络，默认 创建 bridge 网络，也可以使用driver属性指定网络类型,允许独立的容器连接到该网络上 networks: over-net: driver: overlay attachable: true volumes: 指定docker创建新的卷 定义了两个Key：web-fe 、redis，因此Docker Compose部署两容器，一个包含web-fe，一个redis web-fe服务定义中，包含以下指令： 1. build： 指定docker基于当前目录 (.) 下dockerfile来构建新景象，用于启动该服务的容器 2. command： 指定docker在容器中执行名为 app.py 的Python脚本作主程序 3. ports： 将容器内(-target)的5000端口映射到主机(published)的5000端口 4. networks：是的docker将服务连接到指定的网络上 5. volumes：将counter-vol卷(source:)挂载到容器内的 /code (target:) 6. image： redis:alpine 是的docker基于redis:alpine 镜像启动一个独立的名为redis的人弄国企，镜像会从docker hub上拉取下来 7. networks：配置redis容器连接到counter-net网络Docker-Compose 部署应用 在项目目录中，检查文件是否存在 app.py: 应用程序代码 Flask应用 docker-compose.yml: compose文件，定义了Docker如何部署应用 Dockerfile: 定义了如何构建web-fe服务所使用的镜像 requirements.txt: 列出了应用所依赖的python包启动应用： docker-compose up &amp; docker-compose -f prod-equus-bass.yml up // 基于名为 prod... 的compose文件部署应用 docker-compose up -d // 没有-d 用 &amp; 将终端窗口返回 FROM python:3.4-alpine &lt;&lt; 基础镜像 ADD ./code &lt;&lt; 将app复制到镜像中 WORKDIR /code &lt;&lt; 设置工作目录 RUN pip install -r requirements.txt &lt;&lt; 安装依赖 CMD [&quot;python&quot;,&quot;app.py&quot;] &lt;&lt; 设置默认启动命令若 .Services.redis 中指定了image: &quot;redis:alpine&quot;，会从docker hub拉取redis:alpine 镜像 docker container ls docker network ls docker volume ls使用Docker-Compose 子命令 docker-compose up -d // 拉取和构建的镜像保存在系统中 docker-compose ps // 列出容器名称、command、状态、网络端口 docker-compose top // 列出各个服务(容器)内运行的进程 docker-compose stop // 停止应用，但不删除 docker-compose rm // 删除应用相关的容器和网络，但不删除卷和镜像 docker-compose restart // 重启应用 docker-compose down // 停止和关闭应用 ./code [Dockerfile and Compose file](http://c.biancheng.net/uploads/allimg/190417/4-1Z41GJ242b5.gif) Docker Swarm1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192 集群管理工具，作用：把若干台Docker主句抽象为一个整体，通过一个入口统一管理各种Docker资源。 类似 Kubernetes，包含：企业级的Docker安全集群，微服务应用编排引擎 默认内置： 分布式集群存储、加密网络、公用TLS、安全集群接入令牌、简化数字证书管理的PKI 基于Docker引擎之上的独立产品 一个Swarm由一个或多个Docker节点组成，通过可靠的网络相连。 节点被配置为管理节点(Manager)和工作节点(Worker)， 管理节点负责集群控制面，进行诸如监控集群状态、分发任务至工作节点等操作。 工作节点接受来自管理节点的任务并执行 [Swarm](http://c.biancheng.net/uploads/allimg/190418/4-1Z41Q045505Y.gif) 集群搭建： [Swarm](http://c.biancheng.net/uploads/allimg/190418/4-1Z41Q24Z2332.gif) 每个节点装 Docker，并能够与Swarm的其他节点通信 防火墙开放以下端口： 2377/tcp: 用于客户端与Swarm进行安全通信 7946/tcp 与 7946/udp: 用于控制面gossip分发 4789/udp: 用于基于VXLAN的覆盖网络大体流程：初始化第一个管理节点 -&gt; 加入额外的管理节点 -&gt; 加入工作节点 -&gt; 完成初始化一个全新的Swarm： [Swarm](http://c.biancheng.net/uploads/allimg/190418/4-1Z41Q25041I0.gif) 在单引擎模式下的Docker 主机执行 docker swarm init 切换到swarm模式 接入额外的管理节点，并切换为Swarm模式 docker swarm init --advertise-addr 10.0.0.1:2377 --listen-addr 10.0.0.1:2377 docker swarm init // 初始化并设置为第一个管理节点，开始swarm模式 --advertise-addr // 指定其他节点用来连接到当前管理节点的IP和端口，可选 --listen-addr // 用于承载Swarm流量的IP和端口 docker node ls // 列出Swarm 节点 docker swarm join-token // 获取添加新的工作节点和管理节点到Swarm的命令和Token docker swarm join-token worker docker swarm join-token manager docker swarm join --token SWMTKN-1-0uahebax...ca... 10.0.0.1:2377 --advertise-addr 10.0.0.4:2377 --listen-addr 10.0.0.4:2377Swarm 管理器高可用性(HA) [Swarm HA](http://c.biancheng.net/uploads/allimg/190418/4-1Z41Q25541296.gif) [详细文章：](http://c.biancheng.net/view/3178.html) 内置的Swarm 安全机制锁定Swarm 启用锁： docker swarm init --autolock 解锁 ： docker swarm init --unlock Docker Swarm 服务的部署及操作 docker service create // 创建一个新的服务 docker service create --name web-fe -p 8080:8080 --replicas 5 xxx/xxx 与 docker container run 相似，--name：将其命名为 web-fa -p：映射端口 查看服务： docker service ls 查看服务副本列表及个副本的状态： docker service ps &lt;service-name or serviceid&gt; 查看服务详细信息： docker service inspect --pretty xxx // --pretty 易于阅读的格式 副本服务 VS 全局服务： 副本模式：服务的默认复制模式(Replication Mode) 是副本模式(replicated) 全局模式：global docker service create --mode global 服务的扩缩容： 大流量情况下： docker service scale web-fa=10 // 对web-fa服务扩容，将服务副本由5个增加到10个 检查操作是否成功： docker service ls 显示服务副本在各个节点上是均衡分布： dockers service ps 减少副本树： docker service scale web-fa=5 // 从10个降为5个 删除服务： docker service rm web-fa docker service ls 滚动升级： docker network create -d overlay uber-net // 创建网络并将服务接入网络 [](http://c.biancheng.net/uploads/allimg/190418/4-1Z41Q4221H59.gif) docker network ls // 查看网络是否创建成功 docker service create --name uber-svc --network uber-net -p 80:80 --replicas 12 xxxx/xxx docker service create --name uber-svc --network uber-net -publish published=80,target=80,mode=host --replicas 12 xxx/xxx docker service update // 更新运行中的服务 docker service ps docker inspect --prettyDocker Swarm 服务日志及相关配置 docker service log // 查看服务的日志 节点默认配置服务是 json-file 日志驱动，还有 journald(仅限systemctl的linux主机)、syslog、splunk、gelf json-file和journald 可用logs命令 docker service logs &lt;service-name&gt; 第三方日志驱动： &#123; &quot;log-driver&quot;:&quot;syslog&quot; &#125; docker service create --logdrive --log-opts // 强制某服务使用一个不同的日志驱动，会覆盖 daemon.json的配置 --follow ：进行跟踪 --tail : 显示最近的日志 --details ： 获取额外细节 Docker Swarm 汇总12345678910111213docker swarm init: 创建新的Swarm，成为第一管理节点docker swarm join-token: 加入管理节点和工作节点到现有Swarm docker swarm join-token manager: 获取新增管理节点 docker swarm join-token worker: 获取新增工作节点docker node ls: 列出Swarm中的所有节点及相关信息docker service create: 创建一个新服务docker service ls: 列出Swarm中运行的服务，如服务状态、副本等基本信息docker service ps &lt;service&gt;: 列出某个服务副本的信息docker service inspect: 获取关于服务的详细信息，--pretty 仅显示重要信息docker service scale: 对服务副本个数进行增减docker service update: 对运行中的服务属性进行变更docker service logs: 查看服务的日志docker serivce rm: 从Swarm中删除某服务，不做确认会删除服务的所有副本 Dockerfile1234567891011121314151617181920212223242526272829303132333435docker image build // 读取Dockerfile，并将应用程序容器化Dockerfile 示例代码： # Linux x64 FROM xxx LABEL maintainer=&quot;mr_hale@163.com&quot; # install Node and NPM RUN apk and --update nodejs nodejs-npm # Copy app to /src COPY ./src WORKDIR /src # Install dependencies RUN npm install EXPOSE 8080 ENTRYPOINT [&quot;node&quot;,&quot;./app.js&quot;]解释： -t ： 为镜像打标签 -f ： 指定Dockerfile 的路径和名称，指定位于任意路径下的任意名称的Dockerfile FROM ：用于指定要构建的镜像的基础镜像，通常是Dockerfile 中的第一条指令 RUN ： 用于在镜像中执行命令，会创建新的镜像层，每个指令创建一个新的镜像层 COPY ： 用于将文件作为一个新的层添加到镜像中，使用COPY指令将应用代码赋值到镜像中 EXPOSE ： 记录应用所使用的网络端口 ENTRYPOINT ： 指定镜像以容器方式启动后默认运行的程序 LABEL ： ENV ： ONBUILD ： HEALTHCHECK ： CMD ：]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel]]></title>
    <url>%2F2019%2F08%2F16%2FLaravel-Note%2F</url>
    <content type="text"><![CDATA[iFaithFreedom composer的安装和使用1234567891011121314151617181920&gt;&gt; php -r &quot;copy(&apos;https://getcomposer.org/installer&apos;, &apos;composer-setup.php&apos;);&quot;&gt;&gt; php composer-setup.php&gt;&gt; mv composer.phar /usr/local/bin/composer&gt;&gt; composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/&gt;&gt; 取消配置： composer config -g --unset repos.packagist&gt;&gt; composer install&gt;&gt; composer search xxx&gt;&gt; composer selfupdate&gt;&gt; composer show | composer show xxx &gt;&gt; curl -sS https://getcomposer.org/installer | php &gt;&gt; mv composer.phar /usr/local/bin/composer&gt;&gt; composer require xxx/xxx&gt;&gt; composer remove xxx/xxx | xxx &gt;&gt; composer.json &#123; &quot;require&quot;: &#123; &quot;xxx/xxx&quot;:&quot;1.0.*@beta&quot;, &quot;xxx/xxx&quot;:&quot;@dev&quot; &#125; &#125; Laravel 安装1234567891011121314151617181920212223242526Laravel install Tool: composer global require &quot;laravel/install&quot;添加laravel 到系统环境变量： export PATH=“root/.config/composer/vendor/bin:$PATH $HOME/.composer/vendor/bin 主要让系统找到laravel的可执行文件 laravel new xxxcomposer install laravel: composer create-project --prefer-dist laravel/laravel xxx &quot;5.5.*&quot;Web 服务器配置：Nginx: location / &#123; try_files $uri $uri/ /index.php?$query_string; &#125;具体看微信图片收藏中的配置信息php artisan servephp artisan --version | php artisan -Vphp artisan down | up// 设置时区在 app.php 中&apos;timezone&apos; =&gt; &apos;Asia/Shanghai&apos;;&apos;timezone&apos; =&gt; &apos;PRC&apos;;初始化完成后，修改.env配置文件，配置数据库等exec: php artisan migrate:install // 检测数据是否迁移成功 文章模块路由: 路由 模板表设计: 表设计 模型 页面逻辑： 文章列表 添加文章 编辑文章 删除文章 文章详情路由123456789101112131415161718192021- HTTP 方法：Route::get($uri,$callback);get | post | put | patch | delete | options | any | macth - 路由参数Route::get(&apos;uri1&apos;/&#123;param1&#125;/uri2/&#123;param2&#125;&apos;,function($param1,$param2)&#123; ...&#125;)-&gt;where(&apos;param&apos;,&apos;[a-zA-z0-9]+&apos;);- 路由分组Route::group([&apos;prefix&apos; =&gt; &apos;xxx&apos;],function()&#123; Route:;get(&apos;xxx&apos;,function()&#123; xxx &#125;);&#125;);Route::middleware([&apos;xxx&apos;,&apos;xxxx&apos;]) -&gt; group(function()&#123; Route::get(&apos;x&apos;,function()&#123; ... &#125;);&#125;); 模型绑定123Route::get(&apos;api/users/&#123;user&#125;&apos;,function(\App\User $user)&#123; return $user -&gt; email;&#125;); 创建控制器，路由123456789101112131415161718192021php artisan make:controller PostController Route: 文章列表Route:;get(&apos;/posts&apos;,&apos;\App\Http\Controllers\PostController@index&apos;);创建文章Route:;get(&apos;/posts/create&apos;,&apos;\App\Http\Controllers\PostController@create&apos;);Route:;post(&apos;/posts&apos;,&apos;\App\Http\Controllers\PostController@store&apos;);文章详情页Route:;post(&apos;/posts/&#123;post&#125;&apos;,&apos;\App\Http\Controllers\PostController@show&apos;);编辑文章Route:;get(&apos;/posts/&#123;post&#125;/edit&apos;,&apos;\App\Http\Controllers\PostController@edit&apos;);Route:;put(&apos;/posts/&#123;post&#125;&apos;,&apos;\App\Http\Controllers\PostController@update&apos;);删除文章Route:;get(&apos;/posts/&#123;post&#125;/delete&apos;,&apos;\App\Http\Controllers\PostController@delete&apos;);-- 控制器Controller:namespace \App\Http\Controllers;use Illuminate\Http\Request;class PostController exntends Controller &#123; public function xxx()&#123; ... &#125;&#125; 页面渲染创建文章 编辑文章 文章列表 文章详情 在控制器进行页面渲染：1234567891011Extends Controller:public function index()&#123; $arrs = [ [&apos;title&apos; =&gt; &apos;totle ...&apos;], [&apos;title&apos; =&gt; &apos;titles ...&apos;], [&apos;ok&apos; =&gt; &apos;okoko&apos;], ]; return view(&apos;post/index&apos;,[&apos;arrs&apos; =&gt; $arr]); // 指 post文件夹下的index.blade.php 页面&#125;-- 传递参数$tit = &apos;a tit&apos;;view(&apos;post/index&apos;,[&apos;title&apos; =&gt; &apos;text&apos;,&apos;isTrue&apos; =&gt; false,&apos;arrs&apos; =&gt; $arrs] );view(&apos;post/index&apos;,compact(&apos;tit&apos;,&apos;arrs&apos;)); view(&apos;post/index&apos;,compact(&apos;arrs&apos;)); – Blade模板 1234567891011121314151617181920212223242526272829303132333435363738模板语法：&#123;&#123; &#125;&#125; @if @foreach 参数传递： 继承模板：extends/ section/ yield/ content引入视图：include -- index.blade.php &#123;&#123;$title&#125;&#125; // 解析控制器中传递的变量值@if($isTrue == true) Message @endif@foreach($arrs as $arr) &#123;&#123;$arr&#125;&#125;@endforeach- 文章模块页面模板调整提取 layout提取 footer提取 navlayout/main.blade.php公用头部@yield(&apos;content&apos;)公用尾部单独拆解layout/footer.blade.phpfooter 的页面内容layout/nav.blade.phpnav 的页面内容模板集成与包含post/index.blade.php@extends(&apos;layout.main&apos;)@section(&apos;content&apos;)@include(&apos;layout.nav&apos;)index 中的页面内容@include(layout.footer)@endsection 文章模块数据表12345678910111213141516171819202122232425使用 migrate 创建数据表外键 user_id时间 created_at/updated_atmigration： 数据库同步迁移php artisan make:migration create_posts_table // 格式：create_ 数据表名_table 在创建好的create_posts_table.php中pubic function up()&#123; // 创建表用crate 更新表用 table Scheme::create(&apos;posts&apos;,function(Blueprint $table)&#123; // 创建表 $table -&gt; increment(&apos;id&apos;); $table -&gt; string(&apos;title&apos;,100) -&gt; default(&apos;&apos;); $table -&gt; text(&apos;content&apos;); $table -&gt; integer(&apos;user_id&apos;) -&gt; default(0); $table -&gt; timestamps(); &#125;);&#125;public function down()&#123; Scheme::dropIfExists(&apos;posts&apos;); // 删除表&#125;// 如果报错 SQL max key length 767 bytes，就需要在 app\Providers 文件的boot() 方法中添加 一下代码public function boot()&#123; Schema::defaultStringLength(191); // 191 = 797 / 4 &#125;php artisan migrate // 完成数据表的迁移数据库的回滚php artisan migrate:rollback 表名 posts123456789101112131415161718192021ORM: 创建posts 的模型: php artisan make:model Posttinker 的使用:php artisan think基本的增删改查增加: $post = new \App\Post(); $post -&gt; title = &apos;title text&apos;; $post -&gt; content = &apos;content text&apos;; $post -&gt; save();查找：\App\Post::find(3);\App\Post::where(&apos;title&apos;,&apos;titel text&apos;) -&gt; get() | -&gt; first();更新：$post = \App\Post::find(3);$post -&gt; title = &apos;new title text&apos;;删除:$post = \App\Post::find(3);$post -&gt; delete(); 文章列表逻辑模型查找 页面渲染 时间格式 数据填充 字符截断 分页在列表控制器中实现 12345678910111213141516171819202122232425262728293031323334353637383940PostController.phpuse \App\Post;public function index()&#123; $posts = Post::orderBy(&apos;created_at&apos;,&apos;desc&apos;) -&gt; get(); // 模型查找 return view(&apos;posts/index&apos;,compact(&apos;posts&apos;)); // 页面渲染&#125;接着在模板中修改页面渲染：如果传递过来的是数组：@foreach($arrs as $arr)&#123;&#123;$arr[&apos;title&apos;]&#125;&#125;@endforeach如果传递过来的是对象@foreach($posts as $post)&#123;&#123;$post -&gt; title&#125;&#125; // post 的 title 属性 和其他属性&#123;&#123;$post -&gt; created_at&#125;&#125; | &#123;&#123;$pos -&gt; id&#125;&#125; | &#123;&#123;$post -&gt; content&#125;&#125; | &#123;&#123;$post -&gt; updated_at&#125;&#125;@endforeach时间格式渲染：&#123;&#123;$post -&gt; created_at -&gt; toFormattedDateString()&#125;&#125; // 格式化时间数据填充：在 database\factories\ModelFactory.php 文件中设置以下代码$factory -&gt; define(App\Post::class,function(Faker\Generator $faker)&#123; return [ &apos;title&apos; =&gt; $faker -&gt; sentence(6); // 6个单词 &apos;content&apos; =&gt; $faker -&gt; paragraph(10); // 10个句子 ];&#125;);php artisan tinker: factory(App\Post::class,20) -&gt; create(); //生成 make-&gt; (); //演示分页：控制器PostController index() $posts = Post::orderBy(&apos;created_at&apos;,&apos;desc&apos;) -&gt; paginate(n); // n 一个页面显示的数量模板 view/post/index.blade.php&#123;&#123;$posts -&gt; links()&#125;&#125; 字符截取：&#123;&#123;str__limit($post -&gt; content,&apos;100&apos;,&apos;...&apos;)&#125;&#125; // str__limit() 100：显示的数量 ... 显示文本 文章添加逻辑1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950控制器模板 form 中传递的参数名和数据库字段名保持一致文章列表 详情页面 创建页面 创建逻辑 编辑页面 编辑逻辑控制器对应的方法中在接收传递数据的内容调试时使用 dd(\Request::all()); == dd(request()); // dd(request(&apos;title&apos;)); dd = dump and die CSRF在模板页面需要设置 csrf_token() 字段&lt;input type=&apos;hidden&apos; name=&apos;_token&apos; value=&quot;&#123;&#123;csrf_token()&#125;&#125;&quot;&gt; == &#123;&#123;csrf_field()&#125;&#125;保存model1. 第一种方式$post = new Post();$post -&gt; title = request(&apos;title&apos;); // 通过request 获取title数据$post -&gt; content = request(&apos;content&apos;); // 通过request 获取content数据$post -&gt; save(); // 通过 save() 进行保存2. 第二种方式$params = [&apos;title&apos; =&gt; request(&apos;title&apos;), &apos;content&apos; =&gt; request(&apos;content&apos;)];Post::create($params);3. 第三种方式是第二种方式的简写Post::create(request([&apos;title&apos;,&apos;content&apos;]))；如果报错，create方法需要在模型中设置相对应的规则app/Post.php class Post extends Model&#123; protected $guarded = []; // 不可以注入数据的字段 为空的话，所有数据都可以注入 protected $fillable = [&apos;title&apos;,&apos;content&apos;]; // 可以注入数据的字段&#125;此处可以把$guarded $fillable 提取到新的model 类文件中, post.php 集成新的model类就可以简写很多代码验证和错误提示控制器做数据的验证：public function store()&#123; // 验证 $this -&gt; validate(request()[ &apos;title&apos; =&gt; &apos;required|string|max:100|min:5&apos;, &apos;content&apos; =&gt; &apos;required|string|min:10&apos; ]);&#125; // 逻辑 $post = Post::create(request([&apos;title&apos;,&apos;content&apos;])); // 渲染 return redirect(&apos;/posts&apos;);视图层做错误的提示：@if(count($errors) &gt; 0)@foreach($errors as $error) &#123;&#123;$error&#125;&#125;@endforeach @endif错误提示本地化resources/lang/zh/ 复制 en中的文件到zh中，中文汉化放到validation.php中， 在config/app.php 中修改 locale en 为 zh 富文本编辑器的使用12345678下载wangEdit2 js 和其他的模板中对标签的格式化&#123;!! str_limit($post -&gt; content),&apos;100&apos;,&apos;...&apos; !!&#125;图片上传设置 路由Route::post(&apos;/posts/image/upload&apos;,&apos;\App\Http\PostController@imageUpload&apos;);控制器这一部分不是最重要的，暂时不细研究 文章编辑逻辑12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849路由：Route::get(&apos;/posts/&#123;post&#125;/edit&apos;,&apos;\App\Http\PostController@edit&apos;); // 传递 post 模型绑定控制器:如果路由中有传递 模型绑定，那么控制器也需要在相对应的方法中注入模型参数 public function edit(Post $post)&#123; return view(&apos;/posts/edit&apos;,compact(&apos;posts&apos;));&#125;CSRF 视图层：&#123;&#123; method_field(&apos;PUT&apos;) &#125;&#125; // 视图层&#123;&#123; csrf_field() &#125;&#125;&#123;&#123; $posts -&gt; title &#125;&#125; //&#123;&#123; $posts -&gt; content &#125;&#125; 更新 Model:路由:Route::put(&apos;/posts/&#123;post&#125;/&apos;,&apos;\App\Http\PostController@update&apos;);控制器 PostController:public function update(Post $post)&#123; // 验证 $this -&gt; validate(requset()[ &apos;title&apos; =&gt; &apos;required|string|max:100|min:5&apos;, &apos;content&apos; =&gt; &apos;required|string|min:10&apos; ]); // 逻辑 $post -&gt; title = request(&apos;title&apos;); $post -&gt; content = request(&apos;content&apos;); $post -&gt; save(); // 渲染 return redirect(&apos;/posts/&#123;$post -&gt; id&#125;&apos;);&#125;视图层：错误提示代码提取到 layout/error.blade.phpedit.blade.php@extends(&apos;layout.main&apos;)@section(&apos;content&apos;)some html code ... @include(&apos;layout.error&apos;)@endsection删除文章：路由: Route::get(&apos;/posts/&#123;post&#125;&apos;,&apos;\App\Http\PostController@delete&apos;);控制器:public function delete(Post $post)&#123; // TODO: 用户的权限认证 $post -&gt; delete(); return redirect(&apos;/posts&apos;);&#125;]]></content>
      <categories>
        <category>PHP</category>
        <category>Laravel</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Error]]></title>
    <url>%2F2019%2F08%2F14%2FError-Note%2F</url>
    <content type="text"><![CDATA[积累工作中常见错误 TODO List 积累错误]]></content>
      <categories>
        <category>Error</category>
      </categories>
      <tags>
        <tag>Error</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Design]]></title>
    <url>%2F2019%2F08%2F14%2FDesign-Note%2F</url>
    <content type="text"><![CDATA[设计模式 TODO: 设计模式创造型设计模式 简单工厂 工厂方法 抽象工厂 构建器 原型 单例 结构型设计模式 适配器 桥梁 组合 装饰 门面 享元 代理 行为型设计模式 责任链 命令行 迭代器 中介者 备忘录 观察者 访问者 策略 状态 模版方法 设计模式创造型 结构型 行为型 创造型设计模式 简单工厂： 只是为客户端生成一个实例，而不会向客户端公开任何实例化逻辑 工厂时用户创建其他对象的对象，正式工厂是一种函数或方法，它从一些方法调用返回变化的原型或类的对象，这被假定为&quot;新&quot; 程序化示例： 首先，定义一个门界面和实现 12345678910111213141516171819202122interface Door &#123; public function getWidth(): float; public function getHeight(): float;&#125;clas WoodenDoor implements Door &#123; protected $width; protected $height; public function __construct(float $width, float $height) &#123; $this -&gt; width = $width; $this -&gt; height = $height; &#125; public function getWidth(): float &#123; return $this -&gt; width; &#125; public function getHeight(): float &#123; return $this -&gt; height; &#125;&#125; 我们有我们的门工厂、门，并返回它 12345class DoorFactory &#123; public static function makeDoor($width, $height): Door &#123; return new WoodenDoor($width, $height); &#125;&#125; 然后它可以用作 12345678// Make me a door of 300 x 300$door = DoorFactory::makeDoor(300,300);echo &apos;Width: &apos; . $door -&gt; getWidth();echo &apos;Height: &apos;. $door -&gt; getHeight();// Make me a door of 100 x 100$door2 = DoorFactory::makeDoor(100,100); 用处：当创建一个对象不仅仅是一些分配而且涉及一些逻辑时，将它放在专用工厂中，而不是在任何地方重复相同的代码时有意义的 工厂方法 提供了一种将实例化逻辑委托给子类的方法 处理创建对象的问题，无需指定将要创建的对象的确切类。在接口中指定并由子类实现，或者在基类中实现并可选地由派生类覆盖，而不是通过调用构造函数 程序化示例： 123456789101112131415interface Interviewer &#123; public function askQuestions();&#125;class Developer implements Interviewer &#123; public function askQuestions() &#123; echo &apos;Factory Design Patterns &apos;; &#125;&#125;class CommunityExecutive implements Interviewer &#123; public function askQuestions() &#123; echo &apos;Asking about community building &apos;; &#125;&#125; 创造 HiringManager 123456789abstract class HiringManager &#123; // Factory method abstract protected function makeInterviewer(): Interviewer; public function takeInterview() &#123; $interviewer = $this -&gt; makeInterviewer(); $interviewer -&gt; askQuestions(); &#125;&#125; 任何子类可以延长并提供所需的 1234567891011class DevelopmentManager extends HiringManager &#123; protected function makeInterviewer(): Interviewer &#123; return new Developer(); &#125;&#125;class MarketingManager extends HiringManager &#123; protected function makeInterviewer(): Interviewer &#123; return new CommunityExecutive(); &#125;&#125; 12345$devManager = new DevelopmentManager();$devManager -&gt; takeInterview(); // Output: Asking about design patterns $marketingManager = new MarketingManager();$marketingManager -&gt; takeInterview(); // Output : Asking about community building 用处： 在类中有一些通用处理但在运行时动态决定所需的子类时用，当客户端不知道他需要什么样子的子类时 抽象工厂 将个人 相关\依赖工厂组在一起而不指定其具体类别的工厂 提供了一种封装一组具有共同主题但没有指定具体类的单个工厂的方法 程序化示例123456789101112131415interface Door &#123; public function getDescription();&#125;class WooderDoor implements Door &#123; public function getDescription() &#123; echo &apos;I am a wooden door&apos;; &#125;&#125;class IronDoor implements Door &#123; public function getDescription() &#123; echo &apos;I am an iron door&apos;; &#125;&#125; 为每种门类型都配备一些装配专家 123456789101112131415interface DoorFittingExpert &#123; public function getDescription();&#125;class Weler implements DoorFittingExpert &#123; public function getDescription() &#123; echo &apos;i can only fit iron doors &apos;; &#125;&#125;class Carpenter implements DoorFittingExpert &#123; public function getDescription() &#123; echo &apos;I can only fit wooden doors &apos;; &#125;&#125; 有抽象工厂，制作相关对象的家庭，即木门工厂将创建一个木门和木门配件，门专家 12345678910111213141516171819202122232425262728interface DoorFactory &#123; public function makeDoor(): Door; public function makeFittingExpert(): DoorFittingExpert;&#125;// Wooden factory to return carpenter and wooden door class WoodenDoorFactory implements DoorFactory &#123; public function makeDoor(): Door &#123; return new WoodenDoor(); &#125; public function makeFittingExpert(): DoorFittingExpert &#123; return new Carpenter(); &#125;&#125;// Iron Door factory to get iron door and the relevant fitting expert class IronDoorFactory implements DoorFactory &#123; public function makeDoor(): Door &#123; return new IronDoor(); &#125; public function makeFittingExpert(): DoorFittingExpert &#123; return new Welder(); &#125;&#125;// Iron d 可用作： 12345678910111213141516$woodenFactory = new WoodenDoorFactory();$door = $woodenFactory -&gt; makeDoor();$expert = $woodenFactory -&gt; makeFittingExpert();$door -&gt; getDescription(); // Output: i am a wooden door$expert -&gt; getDescription();// Same for Iron Factory $ironFactory = new IronDoorFactory();$door = $ironFactory -&gt; makeDoor();$expert = $ironFactory -&gt; makeFittingExpert();$door -&gt; getDescription();$expert -&gt; getDescription(); 木门工厂疯转 各种函数用法： 当存在互相关联的依赖关系时，涉及非简单的创建逻辑 构建器 允许创建不同风格的对象，同时避免构造函数污染，当有几种风格的物体时很有用，或在创建对象时设计很多步骤 目的：找到伸缩构造器反模式的解决方案 程序化示例：12345678910111213141516class Burger &#123; protected $size; protected $cheese = false; protected $pepperoni = false; protected $lettuce = false; protected $tomato = false; public function __construct(BurgerBuilder $builder) &#123; $this -&gt; size = $builder -&gt; size; $this -&gt; cheese = $builder -&gt; cheese; $this -&gt; pepperoni = $builder -&gt; pepperoni; $this -&gt; lettuce = $builder -&gt; lettuce; $this -&gt; tomato = $builder -&gt; tomato; &#125;&#125; 然后有建设者 123456789101112131415161718192021222324252627282930313233343536class BurgerBuilder &#123; public $size; public $cheese = false; public $pepperoni = false; public $lettuce = false; public $tomato = false; public function __construct(int $size) &#123; $this -&gt; size = $size; &#125; public function addPepperoni() &#123; $this -&gt; pepperoni = true; return $this; &#125; public function addLettuce() &#123; $this -&gt; lettuce = true; return $this; &#125; public function addCheese() &#123; $this -&gt; cheese = true; return $this; &#125; public function addTomato() &#123; $this -&gt; tomato = true; return $this; &#125; public function build(): Burger &#123; return new Burger($this); &#125;&#125; 用法： 12345$burger = (new BurgerBuilder(14)) -&gt; addPepperoni() -&gt; addLettuce() -&gt; addTomato() -&gt; build(); 用处： 当可能存在几种类型的对象并避免构造函数伸缩时，与工厂模式区别在于：当创建时一步过程时，将使用工厂模式，而当创建是多步骤过程时，将使用构造器模式 原型 通过克隆基于现有对象创建对象, 允许创建现有对象的副本并进行修改，而不是从头开始创建对象并进行设置 程序化示例12345678910111213141516171819202122232425class Sheep &#123; protected $name; protected $category; public function __construct(string $name, string $category = &apos;Mountain Sheep&apos;) &#123; $this -&gt; name = $name; $this -&gt; category = $category; &#125; public function setName(string $name) &#123; $this -&gt; name = $name; &#125; public function getName() &#123; return $this -&gt; name; &#125; public function setCategory(string $category) &#123; $this -&gt; category = $category; &#125; public function getCategory() &#123; return $this -&gt; category; &#125;&#125; 用法： 123456789$original = new Sheep(&apos;Hale&apos;);echo $original -&gt; getName(); // Haleecho $original -&gt; getCategory() // Mountain Sheep// Clone and Modify what is required$cloned = clone $original;$cloned -&gt; setName(&apos;Lv&apos;);echo $cloned -&gt; getName(); // Lvecho $cloned -&gt; getCategory(); // Mountain Sheep 可用魔术方法 __clone() 来修改克隆方法用处： 当需要一个与现有对象类似的对象时，或者与克隆相比，创建的成本会很高 单例 确保只创建特定类的一个对象 程序化示例12345678910111213141516171819202122final Class President &#123; private static $instance; private function __construct() &#123; // Hide the constructor &#125; public static function getInstance(): President &#123; if(!self::$instance) &#123; self::$instance = new self(); &#125; return self::$instance; &#125; private function __clone() &#123; // Disable cloning &#125; private function __wakeup() &#123; // Disable unserialize &#125;&#125; 用法： 1234$president1 = President::getInstance();$president2 = President::getInstance();var_dump($president1 === $president2); // true 结构型设计模式适配器 桥梁 组合 装饰 门面 享元 代理 适配器： 在适配器中包装其他不兼容的对象，以使其与另一个类兼容。 允许将现有类的接口用作另一个接口，通常用于使现有类与其他类一起工作而无需修改其源代码 程序化示例 123456789101112131415interface Lion &#123; public function roar();&#125;class AfricanLion implements Lion &#123; public function roar()&#123; &#125;&#125;class AsianLion implements Lion &#123; public function roar()&#123; &#125;&#125; 实现任何Lion接口可以进行搜索 12345class Hunter &#123; public function hunt(Lion $lion) &#123; $lion -&gt; roar(); &#125;&#125; 12345678910111213class Wilddog &#123; public function bark() &#123; &#125;&#125;// Adapter around wild dog to make it compatible with our game class WildDogAdapter implements Lion &#123; protected $dog; public function __construct(WildDog $dog) &#123; $this -&gt; dog = $dog; &#125;&#125; 12345$wildDog = new WildDog();$wildDogAdapter = new WildDogAdapter($wildDog);$hunter = new Hunter();$hunter -&gt; hunt($wildDogAdapter); 桥梁模式 优先于集成的组合,实现细节从层次结构推送到具有单独层次结构的另一个对象 程序化示例 12345678910111213141516171819202122232425262728interface WebPage &#123; public function __construct(Theme $theme); public function getContent();&#125;class About implements WebPage &#123; protected $theme; public function __construct(Theme $theme) &#123; $this -&gt; theme = $theme; &#125; public function getContent() &#123; return &apos;About page in&apos; . $this -&gt; theme -&gt; getColor(); &#125;&#125;class Careers implements WebPage &#123; protected $theme; public function __construct(Theme $theme) &#123; $this -&gt; theme = $theme; &#125; public function getContent() &#123; return &apos;Careers page in &apos; . $this -&gt; theme -&gt; getColor(); &#125;&#125; 123456789101112131415161718192021interface Theme &#123; public function getColor();&#125;class DarkTheme implements Theme &#123; public function getColor() &#123; return &apos;Dark Black&apos;; &#125;&#125;class LightTheme implements Theme &#123; public function getColor() &#123; return &apos;Off white&apos;; &#125;&#125;class AquaTheme implements Theme &#123; public function getColor() &#123; return &apos;Light theme&apos;; &#125;&#125; 1234567$darkTheme = new DarkTheme();$about = new About($darkTheme);$careers = new Careers($darkTheme);echo $about -&gt; getContent(); // about page in dark blackecho $careers -&gt; getContent(); // Careers page in Dark Black 组合模式 复合模式允许客户以统一的方式处理单个对象 程序化示例 12345678910111213141516171819202122232425262728293031323334interface Employee &#123; public function __construct(string $name , float $salary); public function getName(): string; public function setSalary(float $salary); public function getSalary(): flaot; public function getRoles(): array;&#125;class Developer implements Employee &#123; protected $salary; protected $name; protected $roles; public function __construct(string $name, float $salary) &#123; $this -&gt; name = $name; $this -&gt; salary = $salary; &#125; public function getName(): string &#123; return $this -&gt; name; &#125; public function setSalary(float $salary) &#123; $this -&gt; salary = $salary; &#125; public function getSalary(): float &#123; return $this -&gt; salary; &#125; public function getRoles(): array &#123; return $this -&gt; roles; &#125;&#125; 12345678910111213141516class Organization &#123; protected $employees; public function addEmployee(Employee $employee) &#123; $this -&gt; employees[] = $employee; &#125; public function getNetSalaries(): float &#123; $netSalary = 0; foreach($this -&gt; employees as $emploess) &#123; $netSalary += $employee -&gt; getSalary(); &#125; return $netSalary; &#125;&#125; 123456789$john = new Developer(&apos;John Doe&apos;, 12000);$hale = new Designer(&apos;Hale Lv&apos;, 15000);// Add them to organization()$organization = new Organization();$organization -&gt; addEmployee($john);$organization -&gt; addEmployee($hale);echo &apos;Net Salaries: &apos; . $organization -&gt; getNetSalaries(); // Net Salaries : 27000 装饰模式 通过将对象包装在装饰器类的对象中来动态更改对象在运动时的行为 程序化示例 1234567891011121314interface Coffee &#123; public function getCost(); public function getDescription();&#125;class SimpleCoffee implements Coffee &#123; public function getCost() &#123; return 10; &#125; public function getDescription() &#123; return &apos;Simple Coffee&apos;; &#125;&#125; 添加组件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class MilkCoffee implements Coffee &#123; protected $coffee; public function __constrcut(Coffee $coffee) &#123; $this -&gt; coffee = $coffee; &#125; public function getCost() &#123; return $this -&gt; coffee -&gt; getCost + 2; &#125; public function getDescription() &#123; return $this -&gt; coffee -&gt; getDescription() . &apos; Milk &apos;; &#125;&#125;class WhipCoffee implements Coffee &#123; protected $coffee; public function __construct(Coffee $coffee) &#123; $this -&gt; coffee = $coffee; &#125; public function getCost() &#123; return $this -&gt; coffee -&gt; getCost() + 5; &#125; public function getDescription() &#123; return $this -&gt; coffee -&gt; getDescription() . &apos;whip&apos;; &#125;&#125;class VanlillaCoffee implements Coffee &#123; protected $coffee; public function __constrcut(Coffee $coffee) &#123; $this -&gt; coffee = $coffee; &#125; public function getCost() &#123; return $this -&gt; coffee = getCost() + 3; &#125; public function getDescription() &#123; return $this -. coffee -&gt; getDescription(). &apos; Valilla&apos;; &#125;&#125; 123456789101112131415$someCoffee = new SimpleCoffee();echo $someCoffee -&gt; getCost(); echo $someCoffee -&gt; getDescription();$someCoffee = new MilkCoffee($someCoffee);echo $someCoffee -&gt; getCost();echo $someCoffee -&gt; getDescription();$someCoffee = new WhipCoffee($someCoffee);echo $someCoffee -&gt; getCost();echo $someCoffee -&gt; getDescription();$someCoffee = new VanillaCoffee($someCoffee);echo $someCoffee -&gt; getCost();echo $someCoffee -&gt; getDescription(); 门面模式Facade 模式为复杂的子系统提供了简化的界面 外观是一个对象，它为更大的代码提供了简化的接口，如类库 程序化示例1234567891011121314151617181920212223242526272829class Computer &#123; public function getElectricShock() &#123; echo &apos;CDB&apos;; &#125; public function makeSound() &#123; echo &apos;Liunx&apos;; &#125; public function showLoadingScreen() &#123; echo &apos;Loding ... &apos;; &#125; public function bam() &#123; echo &apos;Ready to be used !&apos;; &#125; public function closeEverything() &#123; echo &apos;Biu biu biu ... !&apos;; &#125; public function sooth() &#123; echo &apos;zzzzz&apos;; &#125; public function pullCurrent() &#123; echo &apos;Hahaha!&apos;; &#125;&#125; 1234567891011121314151617181920class ComputerFacade &#123; protected $computer; pulic function __construct(Computer $computer) &#123; $this -&gt; computer = $computer; &#125; public function turnOn() &#123; $this -&gt; computer -&gt; getElectricShock(); $this -&gt; computer -&gt; makeSound(); $this -&gt; computer -&gt; showLoadingScreen(); $this -&gt; computer -&gt; bam(); &#125; public function turnOff() &#123; $this -&gt; computer -&gt; closeEverything(); $this -&gt; computer -&gt; pullCurrent(); $this -&gt; computer -&gt; sooth(); &#125;&#125; 123$computer = new ComputerFacade(new Computer());$computer -&gt; turnOn();$computer -&gt; turnOff(); 享元模式 通过尽可能多地与类似对象共享来最小化内存使用或计算开销 程序示例 123456789101112class KarakTea &#123;&#125;class TeaMaker &#123; protected $availableTea = []; public function make($preference) &#123; if(empty($this -&gt; availableTea[$preference])) &#123; $this -&gt; availableTea[$preference] = new KarakTea(); &#125; return $this -&gt; availableTea[$preference]; &#125;&#125; 123456789101112131415161718class TeaShop &#123; protected $orders; protected $teaMaker; public function __construct(TeaMaker $teaMaker) &#123; $this -&gt; teaMaker = $teaMaker; &#125; public function takeOrder(string $teaType, int $table) &#123; $this -&gt; orders[$table] = $this -&gt; teaMaker -&gt; make(teaType); &#125; public function serve() &#123; foreach($this -&gt; orders as $table =&gt; $tea) &#123; echo &apos;Serving tea to table &apos; . $table; &#125; &#125;&#125; 12345678$teaMaker = new TeaMaker();$shop = new TeaShop($teaMaker);$shop -&gt; takeOrder(&apos;Less Sugar&apos;);$shop -&gt; takeOrder(&apos;More Milk&apos;);$shop -&gt; takeOrder(&apos;Without Sugar&apos;, 5);$shop -&gt; serve(); 代理模式 类表示另一个类的功能 程序化示例 1234567891011121314interface Door &#123; public function open(); public function close();&#125;class LabDoor implements Door &#123; public function open() &#123; echo &apos;Opening lab door&apos;; &#125; public function close() &#123; echo &apos;Closing the lab door&apos;; &#125;&#125; 1234567891011121314151617181920212223class SecuredDoor &#123; protected $door; public function __constrcut(Door $door) &#123; $this -&gt; door = $door; &#125; public function open($password) &#123; if($this -&gt; authenticate($password)) &#123; $this -&gt; door -&gt; open(); &#125;else &#123; echo &apos;Big no! &apos;; &#125; &#125; public function authenticate($password) &#123; return $password === &apos;$ecr@t&apos;; &#125; public function close() &#123; $this -&gt; door -&gt; close(); &#125;&#125; 用法： 12345$door = new SecureDoor(new LabDoor());$door -&gt; open(&apos;invalid&apos;);$door -&gt; open(&apos;$ecr@t&apos;);$door -&gt; close(); 行为型设计模式责任链 命令行 迭代器 中介者 备忘录 观察者 访问者 策略 状态 模板 责任链 构建一系列对象,请求从一端进入并继续从一个对象到另一个对象，直到找到合适的处理程序 程序示例 123456789101112131415161718192021222324252627282930313233343536373839abstract class Account &#123; protected $successor; protected $balance; public function setNext(Account $account) &#123; $this -&gt; succcessor = $account; &#125; public function par(float $amountToPay) &#123; if($this -&gt; canPay($amountToPay)) &#123; echo sprintf(&apos;Paid %s using %s &apos; . PHP_EOL, $amountToPay, get_called_class()); &#125;else if($this -&gt; successor) &#123; echo sprintf(&apos;Cannot pay using %s. Proceeding..&apos; .PHP_EOL, get_called_class()); $this -&gt; successor -&gt; pay($amountToPay); &#125;else &#123; throw new Exception(&apos;None of the accounts have enough balance&apos;); &#125; &#125; public function canPay($amount): bool &#123; return $this -&gt; balance &gt;= $amount; // 原文是 &gt;= ,感觉应该是 = &#125;&#125;class Bank extends Account &#123; protected $balance; public function __construct(float $balance) &#123; $this -&gt; balance = $balance; &#125;&#125;class Bitcoin extends Account &#123; protected $balance; public function __constrcut(flaot $balance) &#123; $this -&gt; balance = $balance; &#125;&#125; 12345678$bank = new Bank(100);$paypal = new Paypal(200);$bitcoin = new Bitcoin(300);$bank -&gt; setNext($paypal);$paypal -&gt; setNext($bitcoin);$bank -&gt; pay(259); 命令行 将操作封装在对象中，提供将客户与接收器分离的方法. 对象用于封装执行动作或稍后触发事件所需的所有信息，此信息包括方法名称，拥有该方法的对象以及方法参数的值。 程序化示例 123456789class Bulb &#123; public function trunOn() &#123; echo &apos;Buld has been lit&apos;; &#125; public function turnOff() &#123; echo &apos;Darkness !&apos;; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445interface Command &#123; public function execute(); public function undo(); public function redo();&#125;class TurnOn implements Command &#123; protected $bulb; public function __construct(Bulb $bulb) &#123; $this -&gt; bulb = $bulb; &#125; public function execute() &#123; $this -&gt; bulb -&gt; turnOn(); &#125; public function undo() &#123; $this -&gt; bulb -&gt; turnOff(); &#125; public function redo() &#123; $this -&gt; execute(); &#125;&#125;class TurnOff implements Command &#123; protected $bulb; public function __constrcut(Bulb $bulb) &#123; $this -&gt; bulb = $bulb; &#125; public function execute() &#123; $this -&gt; bulb -&gt; turnOff(); &#125; public function undo() &#123; $this -&gt; bulb -&gt; turnOn(); &#125; public function redo() &#123; $this -&gt; execute(); &#125;&#125; 12345class RemoteControl &#123; public function submit(Command $command) &#123; $command -&gt; execute(); &#125;&#125; 12345678$bulb = new Bulb();$turnOn = new TurnOn($bulb);$turnOff = new TurnOff($bulb);$remote = new RemoteControl();$remote -&gt; submit($turnOn);$remote -&gt; submit($turnOff); 迭代器 提供了一种访问对象元素而不是暴露底层表示的方法 用于遍历容器并访问容器的元素,将算法与容器分离，因算法是特定于容器，so 不能解耦 程序化示例 1234567891011class RadioStation &#123; protected $frequency; public function __construct(float $frequency) &#123; $this -&gt; frequency = $frequency; &#125; public function getFrequency(): float &#123; return $this -&gt; frequency; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142use Countable;use Iterator;class StationList implements Countable, Iterator &#123; protected $stations = []; protected $counter = []; public function addStation(RadioStation $station) &#123; $this -&gt; stations[] = $station; &#125; public function removeStation(RadioStation $toRemove) &#123; $toRemoveFrequency = $toRemove -&gt; getFrequency(); $this -&gt; stations = array_filter($this -&gt; stations, function(RadioStation $station) use ($toRemoveFrequency) &#123; return $station -&gt; getFrequency() !== $toRemoveFrequency; &#125;); &#125; public function count(): int &#123; return count($this -&gt; stations); &#125; public function current(): RadioStation &#123; return $this -&gt; stations[$this -&gt; counter]; &#125; public function key() &#123; return $this -&gt; counter; &#125; public function next()&#123; $this -&gt; counter++; &#125; public function rewind() &#123; $this -&gt; counter = 0; &#125; public function valid(): bool &#123; return isset($this -&gt; stations[$this -&gt; counter]); &#125;&#125; 123456789101112$stationList = new StationList();$stationList -&gt; addStation(new RadioStation(89));$stationList -&gt; addStation(new RadioStation(90));$stationList -&gt; addStation(new RadioStation(100));$stationList -&gt; addStation(new RadioStation(120.3));foreach($stationList as $station) &#123; echo $station -&gt; getFrequency() . PHP_EOL;&#125;$stationList -&gt; removeStation(new RadioStation(89)); 中介者 添加第三方对象控制两个对象之间的交互,减少彼此通信的类之间的耦合，不需要了解彼此的实施。 中介模式定义了一个对象，该对象封装了一组对象的交互方式，可以改变程序的运行行为。 程序化示例 123456789101112interface ChatRoomMediator &#123; public function showMessage(User $user, string $message);&#125;class CharRoom implements CharRoomMediator &#123; public function showMessage(User $user, string $message) &#123; $time = date(&apos;M d, y H:i&apos;); $sender = $user -&gt; getName(); echo $time . &apos;[&apos; . $sender .&apos;]:&apos; . $message; &#125;&#125; 1234567891011121314151617class User &#123; protected $name; protected $charMediator; public function __constrcut(string $name, ChatRoomMediator $chatMediator) &#123; $this -&gt; name = $name; $this -&gt; chatMediator = $chatMediator; &#125; public function getName() &#123; return $this -&gt; name; &#125; public function send($message) &#123; $this -&gt; chatMediator -&gt; showMessage($this, $message); &#125;&#125; 1234567$mediator = new ChatRoom();$hale = new User(&apos;Hale Lv &apos;, $mediator);$judy = new User(&apos;Judy &apos;, $mediator);$hale -&gt; send(&apos;Hi there!&apos;);$judy -&gt; send(&apos;Hey!!!&apos;);]]></content>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NoSQL]]></title>
    <url>%2F2019%2F08%2F11%2FNoSQL-Note%2F</url>
    <content type="text"><![CDATA[NoSQL TODO ListRedis Memcached]]></content>
      <categories>
        <category>NoSQL</category>
        <category>Redis</category>
        <category>Memcached</category>
      </categories>
      <tags>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL]]></title>
    <url>%2F2019%2F08%2F11%2FMySQL-Note%2F</url>
    <content type="text"><![CDATA[MySQL TODO LIST基本语法常见用法集群缓存主从复制双主热备分库分表分布式架构 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667创建表： create table tb [if not exists] _name( `id` int(10) auto_incrementl, `name` varchar(20) not null default &apos;&apos;, `user_id` int(10) default 1, `salary` float unique, `create_at` time, primary key(id,user_id), contraint fk_name foreign key (field) references other_tb(id) ); 主键约束： primary key 外键约束： foreign key 非空约束： not null 唯一性约束：unique 默认约束：default value 自动增加： auto__increment查看表： describe describe tb_name / desc tb_name;查看表结构： show create table tb_name \G查看警告信息： show warnings;修改数据表: 修改表名： alter table tb_oldName rename tb_newName;修改自增ID值 alter table tb_name auto_increment = 1修改字段的数据类型： alter table tb_name modify id int(11);修改字段名： alter table tb_name change tb_old_field tb_new_field int(10);添加字段： alter table tb_7 add name varchar(100) [first|after id];删除字段： alter table tb_7 drop fieldName;修改字段的排列位置： alter table tb_7 modify name varchar(30) [first|after] id; 修改表的存储引擎： alter table tb_7 engine = myisam;删除表的外键约束： alter table tb_7 drop foreign key FK_Name;删除数据表: drop table [if exists] tb_name;删除没有被关联的表: drop table tb_name;删除被其他表关联的表的主表： 全部删除：删除会破坏表的参照完整性，先删除与之关联的子表，再删除父表，这样会删除两个表中的数据。 单独删除：如果保存子表，只需将关联表的外键约束条件取消，然后删除父表 alter table tb_name drop foreign key FK_Name; 123456789101112131415161718192021222324252627282930数据类型:整数类型: tinyint smallint mediumint int(integer) bigint浮点类型: 浮点类型：float double 定点类型：decimal字符串类型： char varchar binary varbinary blob text enum set二进制类型： bit binary varbinary tinyblob blob mediumblob longblob运算符： 算数运算： + - * / 比较运算:结果为 0，1 或者 null = &lt;=&gt; &lt;&gt; (!=) &lt;= &gt;= &gt; is null it not null least greatest between and isnull in not in like regexp 逻辑运算： false null not null and &amp;&amp; or || xor 位操作运算： | &amp; 异或：^ &lt;&lt; &gt;&gt; 取反：~ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879函数：数学函数： 绝对值函数： abc() 平方根函数|求余函数： mod(x,y) 获取整数函数： ceil(x), ceiling(x) , floor(x) 随机整数函数： rand() rand(x) 四舍五入函数： round(x), round(x,y), truncate(x,y) 符号函数： sign(x) 幂运算函数： pow(x,y), power(x,y), exp(x) 对数运算函数： log(x) , log10(x) 角度与弧度相互转换的函数： radians(x), degrees(x) 正弦函数： sin(x)， 反弦函数: asin(x) 余弦函数： cos(x), 反余弦函数： acos(x) 正切函数、反正切函数、余切函数字符串函数： 计算长度的函数： length(), char_length() 合并字符串的函数： concat(str,str1...), concat_ws(str,str1...) 替换字符串的函数： insert(str1, x ,len,str2) 大小写转换函数： lower(), upper() 获取指定长度的字符串的函数： left(s,n), right(s,n) 填充字符串的函数： lpad(str1,len,str2), rpad(str1,len,str2) 删除空格的函数： ltrim(s), rtrim(s), trim(s) 删除指定字符串的函数： trim(str1 from s) 重复生成字符串的函数： repeat(s,n) 比较字符串大小的函数： strcmp(str,str1) 获取字串的函数： substring(s,n,len), mid(s,n,len) 匹配字串开始位置的函数： locate(&apos;s&apos;,&apos;str&apos;); position(&apos;s&apos; in &apos;str&apos;); instr(&apos;str&apos;,&apos;s&apos;); 字符串逆序的函数： reverse(s) 返回指定位置的字符串的函数： 返回指定字符串位置的函数： field(s,s1,s2) 返回字串位置的函数： find_in_set(s1,s2) 选取字符串的函数： make_set(x,s1,s2...)日期和时间函数： 当前日期和时间的函数：curdate(), current_date(), curdate() 时间函数获取系统当前时间：curtime(), current_time(), curtime() 获取当前系统日期和时间： current_timestamp(), localtime(), now(), sysdate() Unix时间戳函数：unix_timestamp() 将UNIX时间戳转为普通格式时间： from_unixtime(&apos;1232131&apos;) 返回UTC日期的函数和返回UTC时间的函数：utc_date(), utc_time(), 返回月份的函数： month(date), monthname(date) 获取日期的函数： dayname(d)， dayofweek(d), weekday(d) 获取天数的函数： dayofyear(d), dayofmonth(d) 获取年份、季度、小时、分钟、秒钟的函数：year(), quarter(), minute(), second() 获取日期的指定值的函数： extract(type from d) 时间和秒钟转换的函数：time_to_sec(), sec_to_time(), 计算日期和时间的函数：date_add(), adddate(), date_sub(), subdate(), addtime(), datediff(),subtime(), 将日期和时间格式化的函数：date_format(), time_format(), get_format(), 条件判断函数： if(expr,v,v1) ifnull(v1,v2) case, case value when, case when系统信息函数: 获取版本号、连接数、数据库名的函数：select version(), connect_id(), show processlist() select database(), select schema() 获取用户名的函数：select user() | current_user() | system_user() 获取字符串的字符集和排序方式的函数：charset(&apos;abc&apos;), charset(convert(&apos;abc&apos; using latin1), charset(version)) 获取最后一个自动生成的ID值的函数：select last_insert_id() 加密函数： password(str) md5(str) 加密函数：encode(str,pswd_str) 解密函数：decode(crypt_str,pswd_str)其他函数： 格式化函数：format() 不同进制的数字进行转换的函数：conv() IP地址与数字相互转换的函数：inet_aton(), inet_ntoa() 加锁函数和解锁函数：select get_lock(), is_used_lock(), is_free_lock(), release_lock() 重复执行指定操作的函数：denchmark() 改变字符集的函数：convert() 改变数据类型的函数：cast(), convert() 123456789101112131415161718192021222324252627282930313233343536查询语句： 基本查询： select &#123; * | &#125; [from table_name [ where &lt;&gt;] [group by &lt;&gt;] [ having &lt;&gt; ] [ order by &lt;&gt; ] [ limit [&lt;&gt;,] &lt;row count&gt;] ] select filed,field1...fieldN from [table | view] where [&lt;condition&gt;] 单表查询： 查询所有字段：select * from table; 查询指定字段：select filed,field1... from table; 查询指定记录：select filed,filed1... from table where condition; 带 IN 关键字的查询：select filed,filed1... from table where filed in (a,z) order by field; 带 Between and 的范围查询：select filed from table where filed between a and z; 带 Like 的字符匹配查询：select filed from table where filed like &apos;%&apos; % 匹配任意长度的字符， _ 下划线只能匹配任意一个字符 查询空值：select filed from table where filed is null | is not null 带 And 的多条件查询：select field, field1 from table where filed &gt; condition and filed &gt; condition; 带 Or 的多条件查询：select field, filed1 from table where field = condition or filed1 = condition; 查询结果不重复：select distinct field from table; 对查询结果排序：select field,filed1 from table order by field | desc | asc 分组查询： gourp by field having condition 创建分组，使用having过滤分组， 在group by 字句中使用with rollup， 多字段分组 group by 和order by 一起使用 select filed,filed1 from table gourp by filed having count(filed1) &gt; condition;&lt;F8&gt;&lt;F9&gt; select filed,field1 from table gourp by filed with rollup; 用Limit 限制查询结果的数量：select * from table limit n | n,m; 集合函数查询： count(), sum() avg() max() min() 连接查询： 内连接：inner join select tb_1.field from table where tb_2.filed = tb_1.id; 外连接：left join, right join 复合条件连接查询： 子查询： 子查询： 合并查询： 为表和字段取别名： 正则表达式查询：]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo]]></title>
    <url>%2F2019%2F08%2F11%2FHexo-Note%2F</url>
    <content type="text"><![CDATA[Hexo 基础和语法 npm install -g hexo-clihexo init &lt;Folder&gt;npm installvim package.jsonhexo new [layout] &lt;title&gt;hexo generate = hexo ghexo publish [layout] &lt;filename&gt;hexo server -p xxxx -s --static -l --loghexo deploy = hexo dhexo render &lt;file1&gt; [file2] ... -o --outputhexo migratehexo clean = hexo chexo list &lt;type&gt;hexo versionhexo --safehexo --debughexo --silenthexo --config custom.ymlhexo --drafthexo --cwd /path/to/cwd npm install hexo-migrator-rss --savehexo migrate rss &lt;source&gt;npm install hexo-migrator-wordpress --savehexo migrate wordpress &lt;source&gt; Writehexo new [layout] &lt;title&gt;layout: post &gt; source/_posts page &gt; source draft &gt; source/_draftshexo new photo &quot;TEXT&quot; Front-Matter1234567891011121314151617181920212223242526272829title: TEXTdate: DATEupdated: UPDATE_TIMEcomments: truetags: TEXTcategories: TEXTpermalink: urlkeywords: TEXTcopyright: true Tag Plugins引用块&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125; content &#123;% endblockquote %&#125; 代码块&#123;% codeblock [title] [lang:language] [url] [link text] %&#125;code snippet&#123;% endcodeblock %&#125; 反引号代码块&#123;% pullquote [class] %&#125;content&#123;% endpullquote %&#125; SERVERnpm install hexo-server --savehexo server -p 5000hexo server -shexo server -i 192.168.1.1 MADE FILEShexo generatehexo generate --watchhexo generate --deployhexo deploy --generatehexo g -dhexo d -g DEPLOYnpm install hexo-deploy-git --savehexo deploydeploy: type: git repo: &lt;repository url&gt; branch: [branch_name] message: [message] SFTPnpm install hexo-deployed0-sftp --savevim _config.yml deploy: type: sftp host: &lt;host&gt; user: &lt;user&gt; pass: &lt;password&gt; remotePath: [remote path] port: [port] privateKey: [path/to/privateKey] passphrase: [passphrase] agent: [path/to/agent/socket] PERMALINKSvim _config.yml permalink_defaults: lang: en|zh-Hans THEMEgit clone git@github.com/&lt;username&gt;/xxx.git theme/xxx cd xxx npm install TEMPLATEindex 首页 post 文章 page 分页 archive 归档 category 分类 tag 标签 具体看官方APIHEXO-DOC]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript]]></title>
    <url>%2F2019%2F08%2F11%2FJavaScript-Note%2F</url>
    <content type="text"><![CDATA[iFaithFreeom JavaScript]]></content>
      <categories>
        <category>JavaScript</category>
        <category>JQuery</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx]]></title>
    <url>%2F2019%2F08%2F11%2FNginx-Note%2F</url>
    <content type="text"><![CDATA[iFaithFreedom TODO LIST基本语法常见用法虚拟主机反向代理缓存负载均衡 配置文件由指令与指令块构成Nginx_DOC每条指令以 ； 分号结尾，指令与参数间以空格符号分隔指令块以 {} 大括号将多条指令组织在一起include 语句允许组合多个配置文件以提升可维护性使用# 符号添加注释，提高可读性使用 $ 符号使用变量部分指令的参数支持正则表达式配置参数： 时间的单位s: seconds m: minutes h:hours d:days w:weeks M:months,30 days y:years,365 days 空间的单位bytes k/K: kilobytes m/M: megabytes g/G: gigabyteseg: &#123;12345678910111213141516 include mime.types; upstream xxx &#123; server 127.0.0.1:8000; &#125;&#125;server &#123; listen 443 http2; # Nginx Config syntax limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s; location ~* \.(gif|jpg|jpeg)$ &#123; proxy_cache my_cache; expires 3m;proxy_cache_key $host$uri$is_args$args; proxy_cache_valid 200 304 302 1d; proxy_pass http://xxx.xxx; &#125;&#125; 重载，热部署，日志切割Nginx 命令行：格式： nginx -s reload帮助： -？ -h使用指定的配置文件： -c指定配置指令： -g指定运行目录： -p发送信号： -s ： 立刻停止服务： stop 优雅的停止：quit 重载配置文件： reload 重新开始记录日志文件 reopen测试配置文件是否有语法错误： -t -T打印nginx的版本信息、编译信息等： -v -V 重载： nginx -s reload热部署：nginx 版本升级， 编译安装， kill -USR2 nginxID(ps -ef | grep nginx), kill -WINCH ID(进程号)日志切割：xxx.lg(日志文件) nginx -s reopen Nginx 配置静态资源Web服务器http { include mime.types; #default_type application/octet-stream; log_format main ‘$remote_addr - $remote_user [$time_local] “$request” ‘ ‘$status $body_bytes_sent “$http_referer” ‘ ‘“$http_user_agent” “$http_x_forwarded_for”‘; client_max_body_size 60M; proxy_cache_path /tmp/nginxcache levels=1:2 keys_zone=my_cache:10m max_size=10g inactive=60m use_temp_path=off; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; gzip on; gzip_min_lengt 1; gzip_comp_level 2; gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png; } server { listen 8080; server_name hale.dev; access_log logs/hale.dev.log main; location / { alias dirpath/; #autoindex on; # 开启目录浏览功能 #set $limit_rate 1k; # 限制访问速度 每秒传输1kb #index index.html index.htm; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; } nginx -s reloadNginx 搭建缓存功能的反向代理服务openresty实现反向代理 include vhost/****.conf;upstream local { server 127.0.0.1:8080;} server { server_name hale.dev; listen 80; location / { proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; #proxy_cache my_cache; #proxy_cache_key $host$uri$is_args$args; #proxy_cache_valid 200 304 302 1d; proxy_pass http://local; }} 此处的配置详情可以在Nginx官网 ngx__http__proxy_module 中获取GoAccess实现可视化并实时监控access日志]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown]]></title>
    <url>%2F2019%2F08%2F11%2FMarkDown-Note%2F</url>
    <content type="text"><![CDATA[MarkDown 基础、语法 斜体、粗体 *斜体* _斜体 _ **粗体** *** 加粗斜体 *** ~~ 删除线 ~~ 分级标题 # ## ## ### #### ##### ###### 超链接 TEXT[Your Message](https://i-china.github.io/) TExt[Your Text][https://i-china.win/ &quot;message&quot;] 锚点 Goto[Redirect](#TEXT) 列表 无序列表 * + - 有序列表 1. Text 2. Text 3. Text ... 代码缩进 * TEXT // * 后三空格 列表引用 &gt; TEXT &gt; TEXT 引用 列表嵌套 &gt;&gt;&gt; TEXT &gt;&gt; TEXT &gt; TEXT 其他要素 &gt; T1 &gt; T2 &gt; T3 &gt; T4 ... 插入图片 TEXT:![TEXT](URL &quot;TEXT&quot;) 内容目录 [TOC] 注脚 TEXT[^1] TEXT[^2] TEXT[^flag] [^1]: TEXT Comment [^2]: TEXT Comment [^flag]: TEXT FOR flag 公式$ 表示行内公式 $E=mc^2$$$ 整行公式 $$\sum_{i=1}^n a_i=0$$ 流程图st=&gt; start: START:&gt;url e=&gt;end: TEXT:&gt;url op1=&gt;operation: text|past // 有些复杂，不经常用，先不写了 表格居左：:---- 居中：:----:或者 ----- 居右：:----:TEXT|TEXT|TEXT-|-|-|TEXT|TEXT|TEXTTEXT|TEXT|TEXT-----------TEXT|TEXT-|-:TEXT TEXT | TEXT/TEXT 分割线* * *********- - ---------- 代码CODE()``` #include&lt;stdio.h&gt; ``` 换行行后 加两空格 文本&lt;center&gt; TEXT &lt;/center&gt;&lt;left&gt; TEXT &lt;/left&gt;&lt;right&gt; TEXT &lt;/right&gt;&lt;u&gt; TEXT &lt;/u&gt; 备注： 有些不清楚，需要随用随查！]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang]]></title>
    <url>%2F2019%2F08%2F09%2FGolang-Note%2F</url>
    <content type="text"><![CDATA[iFaithFreedom TODO List]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python]]></title>
    <url>%2F2019%2F08%2F09%2FPython-Note%2F</url>
    <content type="text"><![CDATA[Python Python 编程基础[编译型和解释型](http://c.biancheng.net/uploads/allimg/190211/2-1Z2111G33L03.gif) 领域： Web应用开发： 通过mod_wsgi模块，apache可运行python的web程序，Python定义WSGI标准应用接口协调HTTP服务器与基于Python的Web程序之间的通信。Web框架：Django、TurboGears、web2py等 操作系统管理、自动化运维开发： 例：Ubunut的Ubiquity安装器、RedHat、Fedora的Anaconda安装器等 游戏开发： 支持更多的特性和数据类型，例：文明 编写服务器软件： 支持各种网络协议，可编写服务器软件及网络爬虫，例：第三方库Twisted 科学计算： NumPy、SciPy、Matplotlip等 3和2的区别： print函数代替print语句 默认使用UTF-8编码 除法运算 异常 八进制字面量表示 不等于运算符 数据类型 Python 2to3：自动将Python2.x代码转换为Pyhton3.x代码安装 Linux 两种方式： 1. 命令行安装 apt update apt install python3.6 unlink /usr/bin/python // 取消旧python的映射 ln -s /usr/bin/python3.6 /usr/bin/python // python3环境的路径和版本要写正确 2. 源码安装 下载： wget python3.6下载路径 压缩： tar -zxvf python3.6.tgz 编译： ./configure –prefix=/usr/local/ make make install 第一个python12345678910111213141516171819202122232425262728293031323334353637383940414243代码编写 两种方式： 1. 在提示符 &gt;&gt;&gt; 直接输入： print(&quot;hello world&quot;) 2. 文本编辑器编写并执行python程序 vim hi.python print(&quot;hello world&quot;) python hi.python 注释： 单行注释： # 多行注释： 1. &apos;&apos;&apos; xxx...xxx &apos;&apos;&apos; 2. &quot;&quot;&quot; xxx...xxx &quot;&quot;&quot;中文编码声明注释： 1. # -*-coding:utf-8 -*- 2. # coding=utf-8 缩进规则： 冒号(:)和代码缩进编码规范(PEP8) PEP: Python Enhancement Proposal, 8代表Pyton代码的样式指南 1. 每个import语句只导入一个模块，避免导入多个 2. 不在行为加分号，不将两条命令放一行 3. 每行不超80字符，如超，用小括号连接 4. 用空行增强可读性，顶级定义空两行，方法定义空一行 5. 使用空格分隔 运算符、函数参数Python标识符命名规范 1. 字符、下划线、数字，数字不开头 2. 不与保留子相同 3. 不包含空格、@、%、$等特殊字符 4. 严格区分大小写 5. 下划线开头有特殊意义 单下划线： 不能直接访问的类属性，无法通过 from ... import * 的方式导入 双下划线： 类的私有成员 双下划线开头和结尾： 专用标识符关键字(保留子) 查看方式： import keyword keyword.kwlist内置函数 [内置函数](https://docs.python.org/zh-cn/3/library/functions.html) 变量类型和运算符数值类型(整形、浮点型、复数) 整形： 二进制：1 和 0 组成， 0b|0B 八进制：0～7 ， 0o|0O 十进制：普通的整数，不以0开头 十六进制：0～9 + A～F， 0x|0X 浮点型： 十进制形式：eg：3.14 科学计数：eg：2.3e2 复数： 虚部用j|J表示 字符串(长字符串、原始字符串) 长字符串： 三个引号：单引号、双引号 原始字符串： 需要’&#39;进行转义 bytes类型 由多个字节组成，以字节为单位进行操作，只负责以字节(二进制格式)序列来记录数据 将字符串转换为 bytes对象的三种方式： 1. 如内容是ASCII，在字符串之前添加 b 构建字节串值 2. 调用 bytes() 函数 3. 调用字符串本身的 encode() 方法 bool布尔类型 真：True ：1 假：False：0 len() 获取字符串长度或字节数 len(string)： 字符串的字符|字符串长度|一个字符串占用的字节数， string 进行长度统计的字符串 input() 获取用户输入的字符串 将用户输入的内容放到字符串中，返回一个字符串中 print() 高级用法 同时输出多个变量： eg：print(value,…sep=’’,end=’\n’,file=sys.stdout,flush=False) 格式化字符串(格式化输出) 对各种类型的数据进行格式化输出 print()函数包含三部分： 1. 格式化字符串，相当于字符串模版 2. 固定使用” % “ 作为分隔符 3. 对应的变量，多个用’()’括号括起来 转换说明符： %d， %i ： 十进制的整数 %o ： 八进制的整数 %x，%X ： 十六进制整数 %e ： 科学计数的浮点数 %E ： 科学计数的浮点数 %f，%F ： 十进制的浮点数 %g ： 智能选择%f或%e格式 %G ： 智能选择%F或%E格式 %c ： 格式化字符及其ASCII码 %r ： 使用repr()将变量或表达式转换为字符串 %s ： 使用str()将变量或字符串转换为字符串 转义字符 \ ： 一行未完，转到下一行继续写 &#39; ： 单引号 &quot; ： 双引号 \0 ： 空 \n ： 换行符 \r ： 回车符 \t ： 水平制表符 \a ： 响铃 \b ： 退格 \ ： 反斜线 \0dd ： 八进制数，dd代表字符，eg：\012代表换行 \xhh ： 十六进制数，hh代表字符，eg：\x0a 代表换行 数据类型转换 int(x) ： 将x转换为整数类型 lloat(x) ： 转为浮点型 complex(real,[,imag]) ： 创建一个复数 str(x) ： 转为字符串 repr(x) ： 转为表达式字符串 eval(x) ： 计算字符串中有效python表达式，返回一个对象 chr(x) ： 将整数x转为一个字符 ord(x) ： 将字符x转为对应的整数值 hex(x) ： 将整数x转为十六进制字符串 oct(x) ： 整数x转为八进制字符串 算术运算符 + ： 加 - ： 减 * ： 乘 / : 除 % : 取余，返回除法的余数 // : 整除，返回商的整数部分 ** : 幂，返回x的y次方 eg：2**4， 16 赋值运算符 = ： 基本赋值 扩展后的赋值运算符： += ： 加赋值 -= ： 减赋值 = ： 乘赋值 /= ： 除赋值 %= ： 取余赋值 *= ： 幂赋值 //= ： 取整数赋值 |= ： 按位或赋值 ^= ： 按位与赋值 &lt;&lt;= ： 左移赋值 &gt;&gt;= ： 右移赋值 位运算符 &amp; ： 按位与 | ： 按位或 ^ ： 按位异或 ～ ： 按位取反 &lt;&lt; ： 按位左移 &gt;&gt; ： 按位右移 详细说明 比较运算符 &gt; ： 大于 &gt;= ： 大于等于 &lt; ： 小于 &lt;= ： 小于等于 == ： 等于 != ： 不等于 is ： 判断两个变量引用的对象是否相同，不同返回False is not ： 判断两个变量引用的对象是否不相同，不同返回True 比较运算符 == 和 is 的区别： == ： 比较两个变量的值是否相等。 is ： 对比两个变量引用的是否是同一个对象 逻辑运算符 and ： 与 两个都为True，为True，否则为False or ： 或 一个为True，为True，两都为False，则为False not ： 非 只需一个为True，则为False 三目运算符(三元) 先对逻辑表达式求值，如果为True，则返回True_statements的值，如为False，则返回False_statements的值 A = 5 B = 3 st = “A大于B” if A &gt; B else “A小于B” 运算符优先级 优先级 列表、元组、字典、集合内置的四种常用数据结构： 列表(list)、 元组(tuple)、 字典(dict)、 集合(set) 列表和元组不同和相同： 相同：按顺序保存元素 不同：元组不可修改，列表可修改 字典和集合的相同和不同： 相同：数据是无序的 不同：字典可用key-value形式保存数据序列 序列：一块可存放多个值的连续内容空间，值按一定顺序排列，可通过值位置的编号(索引)访问他们 序列包括：字符串、列表、元祖、集合、字典。 字典和集合不支持索引、切片、相加、相乘等操作 字符串是一种常见的序列，可直接通过索引访问字符串内的字符 索引值从0开始递增，支持索引值负数，从右向左计数 序列切片：是访问序列中元素的另一种方法，可访问一定范围内的元素，通过切片，生成新的序列 snmae[start ：end ：step] sname：表示序列的名称 start：表示切片开始索引位置，默认为0，从开头进行切片 end： 表示切片的结束位置，若不指定，默认为序列的长度 step： 表示隔几个存储位置取一次元素 序列相加：两种相同类型的序列使用 “ + “ 运算符做相加操作，但不去重 相同类型：指 + 两侧都是序列类型，都为元组 或 都为字符串 序列相乘： 使用数字n乘以一个序列生成新的序列，eg : print(‘hi’ * 3) 检查元素是否包含在序列中：使用 in 关键字 value in sequence ： value 要检查的元素，sequence 指定的序列 序列相关的内置函数： len() ： 计算序列的长度，即返回序列中包含多少个元素 max() ： 最大元素 min() ： 最小元素 list() ： 将序列转为列表 str() ： 将序列转为字符串 sum() ： 计算元素和 sorted() ： 对元素排序 reversted() ： 反向序列中的元素 enumerate() ： 将序列组合为一个索引序列，用在for循环中 list列表python没有数组，有列表。 列表将所有元素放在一对中括号中[],相邻元素用逗号隔开，eg：[var1,var2,...varn]，个数不限，支持的数据类型即可。可以是：整数、实数、字符串、列表、元组、浮点数等 type([&apos;xxx&apos;,xxx,[xxx,&apos;xxx&apos;],xxx]) ：查看数据类型，数据类型为list，即为：列表 创建列表 使用 = 运算符创建列表， 使用赋值运算符 = 直接将列表赋值给变量 listname = [element1, element2,... elementn] 使用list()函数创建列表： list() 将 元组、区间等对象转换为 列表 a_tuple = (&apos;name&apos;,23) a_list = list(a_tuple) 访问列表元素 通过列表的索引获取指定的元素 或 直接使用 print() 函数 list_str[n] | print(list_str) 删除列表 使用 del 语句删除 del list_str 列表添加元素的三种方法 1. append()：在列表的末尾追加元素，传递列表或元组，视为一个元素，直接添加到列表中，形成包含列表和元组 list_str.append(obj) 2. extend()：不将被追加的列表或元组当作一个整体，只追加列表中的元素 list_str.extend(obj) 3. insert()：在列表中间增加元素 list_str.insert(index，obj) ： index 将元素插入到列表中指定位置处的索引值，将插入的对象视为一个整体 列表删除元素的三种方法 删除元素的三种场景： 1. 根据元素位置的索引值，用del语句 2. 元素的位置删除，用 list提供的remove 方法 3. 删除所有元素，用list提供的clear方法 删除元素的3中方法： 1. 根据索引值删除元素,类删除列表，用del语句 del list_str[n:m] 2. 根据元素值删除元素 remove 删除第一个和指定值相同的元素，如没有，则显示ValueError错误，删除前判断是否存在，长于count()方法组合使用 3. 删除列表所有元素 clear() : 清空列表的所有元素 list_str.clear() list列表修改元素 列表的元素类变量，可对列表的元素赋值，即可修改列表的元素 通过索引到列表元素赋值，可用正数索引，也可用负数索引 list_str = list(rang(1,5)) list_str[1:3] = [‘a’,’b’] 可用步长 list常用方法(count、index、pop、reverse、sort) 交互模式：查看列表包含的所有方法： dir(list) count() ：统计列表中某个元素出现的次数 listname.count(obj) index() ：定位某个元素在列表中出现的位置，即索引 listname.index(obj,start,end) : start、end：指定范围内搜索元素 pop() ：移除列表中指定索引处的元素，若不指定，默认移除列表中最后一个元素 listname.pop(index) reverse() ：反转列表中的元素 listname.reverse() sort() ：对列表元素进行排序 listname.sort(key=None,reserse=False) key ： 指定每个元素提取用于比较的健，key=str.lower：不区分大小写 reserse ：是否需要反转排序，默认False表示从小到大。True为从大到小排序 tuple元组按特定顺序排序的元素，序列不可变。不可边的列表，保存不可变的内容，用()定义，用，逗号分隔。元组可存储整数、实数、字符串、列表、元组等任何类型的数据 (&apos;xxx&apos;,[x,xx,&apos;xxx&apos;],(x,xx,xxx)) 创建元组 1. 使用 &quot;=&quot; 运算符直接创建元组 tupe_str = (x,xx,xxx) 2. 使用tuple()函数创建元组 tuple(data) list_str = [x,&apos;xx&apos;,xxx] tuple_str = tuple(list_str) 访问元组元素 使用元组各元素的索引值获取 tuple_str[n] 修改元组元素 元组不可改变序列，元素不可单独修改。 修改方法： 1. 对元组重新赋值： tuple_str = (x,xx,&apos;xxx&apos;) tuple_str = (&apos;x&apos;,&apos;xx&apos;,xxx) 2. 通过连接多个元组的方式向元组中添加新元素 tuple_str = (x,&apos;xx&apos;,xxx) tuple_str + (&apos;y&apos;,yy,&apos;yyy&apos;) 元组连接的必须是元组，否则抛出：TypeError 错误 删除元组 使用 del 语句删除： tuple_str = (&apos;x&apos;,xx,&apos;xxx&apos;) del(tuple_str) 元组使用场景： 1. 元组作为很多内置函数和序列类型方法的返回值存在，使用某些函数或方法，如返回元组类型，对元组进行处理。 2. 元组比列表访问和处理速度更快，如 对指定元素访问，且不修改时，使用元组 3. 元组在映射(和集合的成员)中可做 健 使用，列表不行。 元组和列表的区别： 同属序列类型，按照顺序存放在一组数据，数据类型不受限制 数据修改： 列表可修改 元组不可修改 字节：元组比列表少16个字节 列表是动态的，存储指针指向对应的元素 占用8个字节，元素可变，需要额外存储已经分配的长度大小 元组，长度固定，存储元素不可变，存储空间是固定的。字典dict ： 类列表，数据的集合，可变序列类型。无序可变序列，内容以 键值对 形式存放 特征： 通过键来读取元素 任意数据类型的无需集合 可变的，可任意嵌套 键必须是唯一 键必须不可变 创建字典 1. 花括号 { } 每个元素包含2部分： 键 : 值， 键和值用冒号分割，相邻元素用逗号分割，大括号{}包含 eg : dict_str = {&apos;name&apos;:&apos;hale&apos;,&apos;age&apos;:23} 同一字典 键值 必须唯一，键值可以是整数、字符串、元组 2. 通过 fromkeys() 创建字典 创建所有键值为空的字典 eg: dict_str = dict.formkeys(list, value=None) 各个键对应的值为空None， 通常用初始化字典，设置value的默认值 3. 通过 dict() 映射函数创建字典 eg： dict_str = dict(one=1,tow=2,thre=2) dict_str = [(&apos;one&apos;,1),(&apos;toe&apos;,2)] dict_str = [[&apos;one&apos;,1],[&apos;tow&apos;,2]] dict_str = ((&apos;one&apos;.1),(&apos;two&apos;,2)) dict_str = [&apos;one&apos;,&apos;two&apos;,&apos;three&apos;] 访问字典 通过 键 访问对应的元素值。 但字典元素是无序的 eg： dict_str[&apos;one&apos;] dict_str.get(key[,default]) // 通过 get 方法获取指定键的值 dict_str.get(&apos;two&apos;) 使用get() 方法，可为其设置默认值 删除字典 使用 del 语句 删除字典 eg： del(dict_str)字典基本操作(添加、修改、删除键值对) 字典无需 操作字典的方法： 1. 向现有字典添加键值对 2. 修改现有字典中的键值对 3. 删除指定键值对 4. 判断是否存在指定键值对 字典添加键值对 dict[key] = value dict ： 表示字典名称 key ： 要添加元素的键，不可重复 value： 要添加的值。支持的数据类型 修改键值对 不是修改某一键值对的键和值，只修改值 如 新添加的元素的键已存在，替换原键对应的值 删除键值对 del eg：del dict_str[&apos;one&apos;] 判断是否存在 使用 in 或者 not in 运算符 eg：&apos;one&apos; in dict_str | &apos;two&apos; not in dict_str字典方法攻略 keys() 、values() 、 items() keys() ：返回字典中的所有键 dict_str.keys() values() ： 返回字典中所有键对应的值 dict_str.values() items() ： 返回字典中所有的键值对 dict_str.items() 返回数据的两个方法： list() ： 将返回的数据转换为 列表 list(dict_str.keys()) 利用多重赋值，李彤循环结构将键或值分别赋给不同的变量 for k in dict_str.keys(): print(k,end=’ ‘) for v in dict_str.values(): …v for k,v in dict_str.items(): print(‘key: ‘,k,’value: ‘,v) copy() 方法 返回一个具有相同键值对的新字典 dict_str.copy() // copy 将字典 的数据 拷贝给 字典other 拷贝原理，有深、有浅。 copy为深拷贝 update() 方法 使用一个字典所包含的键值对更新已有的字典 如果已存在的键值对，原value会被覆盖，如不存在，即添加 pop() 方法 获取指定 key 对应的 value，并删除这个键值对 dict_stc.pop(&apos;key&apos;) popitem() 随机弹出字典中的一个键值对，弹出字典最后一个键值对，底层存储的最后一个键值对 dict_str.popitem() setdefault() 方法 根据 key 获取对应 value 的值，如获取的key在字典中不存在，会设置默认的value，然后返回该key对应的value dict_str.setdefault(&apos;one&apos;,23) 使用字典格式化字符串 在字符串模板中按 key 指定变量， 然后通过字典为字符串模板中的 key 设置值 字符串模板中使用key people = &apos;name: %(name)s , price: %(price)0.2f, sex: %(sex)s&apos; object = {&apos;name&apos;:&apos;Hale&apos;,&apos;price&apos;:23,&apos;sex&apos;:&apos;man&apos;} print(people % object)Set 集合 保存不重复的元素，集合中的元素是唯一的，set集合是无序的 集合将所有元素放在一堆大括号中{}，元素用 ‘,’ 分割 {key,key2,keyN} 只能存储不可变的数据类型，即 整形、浮点型、字符串、元组。 不可以存储 列表、字典、集合。 两种集合类型： 1. set 类型的集合 ： 可做 添加、删除元素的操作 2. frozenset 集合 ： 不可以 创建set集合 2种方式： 1. 使用 {} 创建 ：直接将集合赋值给变量 set_str = {key,key1,keyn...} 2. set()函数创建 set_str = set(iteration) iteration : 表示字符串、列表、元组、range对象等数据 访问set集合元素 访问集合元素使用循环结构 for key in set_str: print(key,end=&apos; &apos;) 删除set集合 del() del(set_str) 集合常用操作：向集合中添加、删除元素。以及集合之间做交集、并集、差集等运算。set集合基本操作(添加、删除、交集、并集、差集) 向set集合中添加元素 set_str.add(element) 只能是数字、字符串、元组或布尔类型，不能添加列表、字典、集合等可变数据 从set集合删除元素 set_str.remove(element) 如删除不存在的，抛出 KeyError错误 如不想提示KetError错误，可使用discard()方法 set集合做交集、并集、差集运算 交集： &amp; 取两集合公共的元素 set1 &amp; set2 并集： | 取两集合全部的元素 set1 | set2 差集： - 取一个集合中另一集合没有的元素 set1 - set2 对称差集： ^ 取集合A和B中不属于A&amp;B的元素 set1 ^ set2 set集合方法 dir(set) add、clear、copy、difference、difference_update、discard、intersection、intersection_update、isdisjoint、issubset、i是superset、pop、remove、symmetric_difference、symmetric_difference_update、union、update frozenset 集合(set 集合不可变版本) 特点： 1. 当集合元素不需要改变时，使用frozenset代替set更安全 2. API不需要改变时，必须用frozenset代替set。如 集合元素不可变，set只能包含frozenset s = set() f = frozenset(‘key’) s.add(f) 深入底层字典和集合 字典和集合是进行过性能高度优化的数据结构 字典和集合的工作原理： 数据机构 字典和集合的内部结构都是一张哈希表 对字典：表存储了哈希值(hash)、键和值 对集合：哈希表内只存储单一的元素 哈希表插入数据 哈希表查找数据 哈希表删除元素 字符串常用方法详解拼接字符串、截取字符串、格式化字符串字符串拼接(+拼接数字)使用加号 (+) 作为字符串的拼接运算符 字符串拼接数字 先将数字转换为 字符串 数字转换为字符串： str() repr() 直接拼接字符串和数字，会报错截取字符串(字符串切片) 通过索引来操作字符： string[index] // index 表示索引值，从0开始递增，最后一个为-1 使用范围获取字符串的中间值： string[start: end: step] string : 要截取的字符串 start : 要截取的第一个字符所在的索引，默认为0 end ：要截取最后一个字符所在的索引。如不指定，默认字符串的长度 step ：从start字符开始，step 距离获取一个字符，end索引出的字符。step默认值为1 支持用 in 运算符判断是hi否包含某个子串 split() : 分割字符串 将一个字符串按照指定的分隔符切分成多个子串，字串被保存在列表中，不包含分隔符 str.split(sep,maxsplit) 1. str：要分割的字符串 2. set：指定分隔符，默认使用空字符分割 3. maxsplit：可选参数，指定分割的次数，如不指定，次数不限 join() ：合并字符串 将列表(或元组)中多个字符串采用固定的分隔符连接在一起 join_str = str.join(iterable) 1. join_str : 合并后生成的新字符串 2. str ： 指定合并时的分隔符 3. iterator： 做合并操作的源字符串数据，允许：列表、元组等 count() ：统计字符串出现的次数 用于检索指定字符串在另一个字符中出现的次数，如检索的字符串不存在，返回 0，否则返回出现的次数 str.count(sub[,start[,end]]) 1. str : 原字符串 2. sub : 要检索的字符串 3. start : 起始位置 4. end : 终止位置 find() ：检测字符串中是否包含某字串 检索字符串中是否包含目标字符串，如包含：出现第一次该字符串的索引，返回-1 1. str：原字符串 2. sub：目标字符串 3. start： 起始位置，若不指定，默认从头开始索引 4. end ：结束位置，若不指定，一直检索到结尾 rfind() ：字符串从右边开始检索 index() ：检测字符串中是否包含某子串 检索是否包含指定的字符串，若指定的字符串不存在，抛出异常 str.index(sub[,start[,end]]) 1. str : 原字符串 2. sub : 子字符串 3. start : 起始位置，默认从头开始 4. end : 结束位置，默认到结尾 startswith() 和 endswith startswith() ： 检索字符串是否以指定字符串开头，是返回True，反之False str.startswith(sub[,start[,end]]) 1. str ： 原字符串 2. sub ： 要检索的字串 3. start ：起始位置，默认从头开始 4. end ： 结束索引 end.swith(sub[,start[,end]]) : 是否以指定字符结尾，是返回True，反之Flase str.endswith(sub[,start[,end]]) 1. str : 原字符串 2. sub : 检索的字符串 3. start : 起始位置 4. end : 结束位置 字符串大小写转换的三种函数title() : 将字符串中每个单词的首字符转为大写，其他转为小写 str.title() str 要进行转换的字符串 lower() : 将字符串所有大写字符转为小写 str.lower() upper() : 将字符串所有小写字母转为大写 str.upper()去除字符串中空格(删除指定字符)的3种方法 去除字符串中的空格和特殊字符 特殊字符： 制表符 \t、回车符 \r 、换行符 \n strip() lstrip() rstrip() 1. strip() : 删除字符串前后(左右两侧)的空格或特殊字符 str.strip([chars]) str : 原字符串 chars ：指定要删除的字符，可同时指定多个，若不指定，默认为空格、制表符、回车符、换行符等特殊字符 2. lstrip() : 删除字符左边的空格或特殊字符 str.lstrip([chars]) 3. rstrip() : 删除字符右边的空格或特殊字符 str.rstrip([chars]) format() 格式化输出 str.format(args) str : 指定字符串显示样式 args: 指定要进行格式化转换的项，如多项，逗号分割 str 格式： { [index][:[fill] align] [sign] [#] [width] [.precision] [type] ]} index : 指定 ；后边设置的格式要作用到args中第几个数据，索引值从0开始 fill : 指定空白处填充的字符 align : 指定数据的对齐方式 &lt; : 左对齐 &gt; : 右对齐 = : 右对齐，放在填充内容的最左侧，只对数字类型有效 ^ : 居中，和width参数一起使用 sign： + ： - ： 空格： # ： width ：指定输出数据时所占的宽度 .precision : 指定保留的小数位数 type ：指定输出数据的具体类型 s ： 字符串 d ： 十进制整数 c ： 将十进制整数自动转换为对应的Unicode字符 e|E ： 转为科学技术后，再格式化输出 g|G ： 自动再e|f E|F 中切换 b ： 将十进制自动转换为二进制，再格式化 o ： 转为八进制，再格式化 x|X ： 转为十六进制 f|F ： 转为浮点数 % ： 显示百分比，默认小数点后6位 encode() 和 decode() 字符串编码转换 2中常用字符串类型： str 、bytes。 str：Unicode 。 bytes：二进制数据。使用encode 和decode 进行转换 encode() : 将str类型转换为bytes类型，成为 编码 str.encode([encoding=”utf-8”][,errors=”strict”]) str ：要进行转换的字符串 encoding=”utf-8” : 采用的字符编码，默认位utf-8 中文：gb2312 errors=”strict” : 指定错误处理方法： strict : 遇到非法字符就抛出异常 ignore : 忽略非法字符 replace: 用 “?” 替换非法字符 xmlcharrefreplace: 使用xml的字符引用 decode() ： 将bytes类型的二进制数据转换为str类型，过程称为&quot;解码&quot; bytes.decode([encoding=&quot;utf-8&quot;][,errors=&quot;strict&quot;]) bytes : 要进行转换的二进制数据 encoding=&quot;utf-8&quot;: 解码时采用的字符编码 errors=&quot;strict&quot;dir() 和 help() 帮助函数 dir() : 列出指定类或模块名包含的全部内容，包括函数、方法、类、变量等 help() : 查看某个函数或方法的帮助文档 流程控制两种基本流程控制结构： 分支结构、循环结构 分支结构： 实现根本条件来选择性地执行某段代码 循环结构： 实现根据循环条件重复执行某段代码 if语句：分支 while、for in 循环 break 和 continue 控制程序的循环结构if条件语句可分3中形式： if、if else、 if elif else if 表达式： 代码块 if 表达式： 代码块 1 else： 代码块 2 if 表达式 1： 代码块 1 elif 表达式 2： 代码块 2 elif 表达式 3： 代码块 3 ... else : 代码块 n if 表达式真假值判断方法： if 表达式的值 是 布尔值，要么是真 True，假为False 假 False： False、None、0、 &quot;&quot; 、()、[]、{} if else 语句用法规范 1. 代码块不要忘记缩进 2. if 代码块不要随意缩进 3. if 表达式不要遗忘冒号 if 语句嵌套 if condition 1: if condition 2: code1 else: code2 if condition 1: if condition 2: code 1 else: code 2 else: if condition 3: code 3 else: code 4 pass 语句及作用 占位 assert 断言函数及用法 对于对一个bool表达式进行断言，如为True，继续向下执行，否则引发 AssertionError错误 会让程序奔溃，测试、调试的辅助工具 eg： age = input(&apos;enter age&apos;) age = int(age) assert 30 &lt; age &lt; 100 print(&apos;your age at 30 ~ 100&apos;)while 循环语句如果条件condition为真，一直重复执行代码块 while 条件表达式： 代码块 执行流程：判断条件表达式的值，如果为True 真，执行代码块语句，执行完毕，重新判断条件表达式的值是否为真，如为真，继续执行代码块，直到表达式的值为假False，才终止循环 使用while循环遍历列表和元组 列表和元组有索引，通过while循环、列表和元组的索引来遍历列表和元组中的所有元素 eg： tuple_str = (&apos;name&apos;,&apos;age&apos;,&apos;sex&apos;) i = 0 while(i &lt; len(tuple_str)): print(tuple_str[i]) i += 1for循环用法循环语句有2种，while 和for 用于遍历字符串、列表、元组、字典、集合等序列类型 for 迭代变量 in 字符串|列表|元组|字典|集合： 代码块 迭代变量：用来存放从序列类型变量中读取的元素，一般不再循环中对迭代变量赋值，代码块值具有相同缩进格式的多行代码。也称为循环体 for 进行数值循环 如 0 ～100 的累加 r = 0; for i in range(101): r += i print(r) range() : 生成一系列连续的整数，用于for循环中 range(start,end,step) 1. start : 计数的初始值，默认从0开始 2. end : 计数的计数值，不能省略 3. step : 指定步长，两个数之间的间隔，如省略，默认为1 for i in range(1,10,2): print(i,end=&apos; &apos;) for循环遍历列表和元组 列表或元组有几个元素，for循环的循环体就执行几次，迭代变量会依次被赋值为元素的值 isinstance() 函数用于判断某个变量是否为指定类型的实例 for 循环遍历字典 1. items() ： 返回字典中所有key-value对的列表 2. keys() ： 所有key的列表 3. values() ： 所有value 的列表循环结构中else用法 while 和 for循环，可都跟 else 代码块，作用：当循环条件为False，程序最先执行else代码块的代码 for 循环可使用else代码块，当for把所有元素遍历一次后，会执行else代码块， for 和while 循环嵌套 for 和 while 可循环嵌套 for i in range(1,10): j = 0 while j &lt; 3: print(“i %d, j %d”,(i,j)) j += 1 循环可以两层或者更多层嵌套 列表推导式for表达式 利用range区间、元组、列表、字典、集合等数据类型，快速生成一个列表 [表达式 for 迭代变量 in 可迭代对象 [if 条件表达式]] for 迭代变量 in 可迭代对象 表达式 元组推导式 利用range区间、元组、列表、字典、集合等，生成一个列表 (表达式 for 迭代变量 in 可迭代对象[if 条件表达式]) 使用元组推导式获得新元组或新元组中的元素，有三种方式： 1. 使用tuple()，直接将生成器对象转换为元组 a = (x for x in range(1,10)) print(tuple(a)) 2. 使用for循环遍历生成器对象，获得各个元素 a = (x for x in range(1,10)) for i in a: print(i,end=’ ‘) print(tuple(a)) 3. 使用 next() 方法遍历生成器对象，获得各个元素 a = (x for x in range(3)) print(a.next()) a = tuple(a) 无论是for循环遍历生成器对象，还是next()遍历，遍历后原生成器对象不复存 字典推导式 使用字典推导式可以借助列表、元组、字典、集合以及range区间，快速生成复合需求的字典 {表达式 for 迭代变量 in 可迭代对象 [if 条件表达式]} [] 扩起来的可省略 集合推导式 集合推导式可借助 列表、元组、字典、集合以及range区间，快速生成符合需求的集合 {表达式 for 迭代变量 in 可迭代对象 [if 条件表达式]} 集合推导式和字典推导式的区别： 如果表达式以键值对(key:value)的形式，则是字典推导式，反之是集合推导式 zip函数用法 可把两个列表 压缩 为一个zip对象(可迭代对象)，可使用一个循环并行遍历两个列表 a = [‘a’,’c’,’dd’] b = [1,3,2] [x for x in zip(a,b)] zip函数压缩得到的可迭代对象所包含的元素是由原列表元素组成的元组 reversed 函数及用法 反向遍历，可接收各种序列(元组、列表、区间等)，返回一个反序排列的法代器 reversed()可对列表、元组进行反转 sorted函数及用法 与reversed 函数类似，接收一个可迭代对象作为参数，返回一个对元素排序的列表 不会改变传入的可迭代对象，而是返回新的、排序好的列表 sorted 可传入一个 reverse 参数，也可传入一个 key 参数 2种强制离开循环体的方法： 1. continue ： 可跳过执行本次循环体中剩余的代码，转而执行下一次的循环 2. break ： 完全终止当前循环 函数和lambda表达式函数是执行特定任务的一段代码，通过一段代码定义成函数，并为该函数指定一个函数名，可多次调用。可代码复用lambda表达式：可作为表达式、函数参数或函数返回值，可让代码更简洁。 函数(函数定义、函数调用) 函数定义需注意3点： 1. 函数需要几个关键的需要动态变化的数据，这些数据被定义成函数的参数 2. 函数需要传几个重要的数据(就是调用该函数的人希望得到的数据)，这些数据被定义成返回值。 3. 函数的内部实现过程。函数的定义def 函数名(形参列表): // 由零条到多条可执行语句组成的代码块 [return 返回值] 函数名：函数名是合法的标识符，单词的字符全小写，但此语单词用下划线分隔 形参列表：定义该函数可接收的参数。形参列表由多个形参名组成，多个用逗号隔开，定义函数指定了形参列表，就必须传入相应的参数值，谁调用函数谁负责为形参赋值。函数的调用 调用函数就是执行函数 函数名(形参值) 函数名：是调用的函数的名称，形参值：指当初创建函数传入的各个形参的值。即创建函数有多少个形参，就传入多少个值，顺序必须和创建函数一致。函数名后的小括号不能省略。 为函数提供说明文档 使用内置的 help()函数查看帮助文档。 很重要 可为函数编写说明文档， 写在函数声明之后、函数体之前。 可通过help()函数查看，也可通过函数的 doc 属性访问函数的说明文档 def hi(): ‘’’ 这是说明文档的内容，输出 hi ‘’’ print(‘hi’) 使用help()函数查看该函数的说明文档 help(hi) 函数值传递和引用传递(包括形式参数和实际参数的区别)函数参数作用：传递数据给函数，令其对接收的数据做具体的操作处理 形式参数(形参) 和 实际参数(实参)的区别： 形式参数：在定义函数时，函数名后面括号中的参数就是形式参数 def hi(name): print(name) 实际参数：在调用函数时，函数名后面括号中的参数成为实际参数，函数的调用者给函数的参数。 name = &apos;hale&apos; hi(name) 函数参数的传递方式分为2种：值传递和引用(地址)传递 1. 值传递：参数类型不可变类型(字符串、数字、元组) 2. 引用(地址)传递： 实参类型为可变类型(列表、字典) 值传递和引用传递的区别： 函数参数进行值传递后，如形参的值改变，不影响实参的值。 函数参数进行引用传递后，若改变形参的值，实参的值也一同改变 def name(name): name(&apos;hale&apos;) def name(name): name = [&apos;adam&apos;]函数参数传递机制1.值传递：实际是将实际参数值的副本(复制品)传入函数，本身不受影响 值传递会在主程序和swap函数分配两块栈区，用于保存局部变量，实际上在swap 函数战区产生了两个变量，并将主程序栈区的两个变量赋值给swap栈区的两个参数：即对swap函数的两个变量进行初始化。系统存在两个变量，只是存在于不同的栈区中。函数参数的引用传递 如实际参数的数据类型是可变对象(列表、字典)，函数参数的传递方式将采用引用传递方式。但引用传递方式的底层实现，采用的依然是值传递的方式 程序创建了一个字典对象，定义了一个引用变量，其实就是一个指针 指向字典对象， 此时内存中有两个东西：对象本身和只想该对象的引用变量， 具体内容点击 结论： 1. 不管类型的参数，对参数直接使用 = 符号复制是没用的，使用 = 符号复制不能改变参数 2. 如函数修改数据，则通过把数据包装成列表、字典等可变对象，然后把列表、字典等对象作为参数传入函数，在函数中通过列表、字典的方法，可改变数据。python 位置参数 也称 必备参数，指必须按照正确的顺序将实际参数传到函数中，调用函数时传入实际参数的数量和位置必须和定义函数保持一致。 实参和形参数量必须一致 如数量不一致抛出 TypeError异常 实参和形参位置必须一致 若不一致，会出现两中结果： 1. 抛出 TypeError 异常 2. 产生的结果和预期不符 函数关键字参数用法 指使用形式参数的名字来确定输入的参数值，此方式指定函数参数，不需要位置一致，只需参数名正确即可！ def obj(name,age): obj(age,name)函数默认参数设置在定义函数时，直接给形式参数指定默认值 def 函数名(...，形参名 = 默认值)： 代码块 在调用函数时关键字参数必须位于位置参数的后面，在定义函数时指定了默认值的参数(关键字参数)必须在没有默认值的参数之后可变参数函数用法 可变参数：不定长参数，传入函数中的实际参数是任意个数。主要形式： 1. 可变参数：形参前添加一个 ‘ * ‘ parameter parameter 表示形参名，可接收任意多个实际参数，并放到一个元组中 def kebian(name,obj): for i in obj: print(b) kebian(‘hale’,’judy’,’jally’) obj 参数可传入多个字符串作为参数值，本质就是一个元组，将参数的多个值集成一个元组 可变的形参可处于形参列表的任意位置 2. 可变参数：形参前添加两个 ‘ * ‘ parameter parameter 表示形参名，可接任意多个以关键字参数赋值的实际参数，并放到一个字典中。 def obj(name,age,sex, *height,weight): print(name,age,sex) obj(‘hale’,’jally’,’judy’,100,200,110,220) 前三为普通参数，两个字符串收集成元组，最后两个关键字收集为字典 逆向参数收集 指在程序已有列表、元组、字典等对象，把他们的元素 拆开 后传给函数的参数。需在传入的列表、元组参数前添加一个星号，在字典参数前添加两个星号 def obj(name,age): objs = [&apos;hale&apos;,23] obj(objs) 可变参数，如程序将一个元组传给参数，使用逆向收集 def obj(name,*ages): print(name) print(ages) ages = (12,23,32) obj(&apos;hale&apos;,*ages)return 函数返回值 用def 创建函数时，可用return 指定返回的值，该返回值可是任意类型，但return在同意函数值可出现一次，只要执行，就会结束函数。 return [返回值] 指定返回值后，在调用函数时，将该函数赋值给一个变量，用变量保存函数的返回值，也可将函数作为其他函数的实际参数 def name(names): pass def age(name(name)): pass 函数返回多个值的方法 将多个值包装成列表后返回，也可直接返回多个值，自动将多个返回值封装成元组 函数递归 在函数体内调用它本身，递归包含了一种隐式的循环。重复执行某段代码， 递归调用，必须在某个时刻函数的返回值是确定的，否则死循环。 递归一定要向已知方向进行 def fn(n): if n = 10: return 1 elif n = 20: return 2 else : return fn(n+2) - 2*fn(n + 1) 变量作用域(全局和局部)变量的有效范围：全局和局部 局部变量：指在函数内部定义并使用的变量，只在函数内部有效 在执行函数时，为该函数分配一块&quot;临时内存空间&quot;，所有局部变量保存在临时变量中，执行完后，释放内存空间，局部变量失效。离开此函数不能再访问，否则抛出NameError def name(): i_name = &apos;Hale&apos; name() 全局变量：指能作用于函数内部的变量，可在各个函数外部使用，也可在各函数内部使用 定义方式： 1. 在函数体外的变量，一定为全局变量： i_name = &apos;Hale&apos; def name(): print(i_name) 2. 在函数体内定义使用 global 关键字对变量修饰，即为全局变量 def name(): global your_name = &apos;Judy&apos; 获取指定作用域范围中的变量 1. globals() : 该函数返回全局范围内所有变量组成的 变量字典 2. locals() : 返回当前局部范围内所有变量组成的 变量字典 3. vars(object) : 获取在制定对象范围内所有变量组成的 变量字典 如不传入 object 参数， vars 和 locals 作用完全相同 globals 和 locals 的区别： 1. local 获取当前局部范围内所有变量组成的 变量字典， 如全局范围内(在函数外)调用locals 函数，获取全局范围内所有变量组成的 变量字典。 而 globals 无论在哪，获取的都是全局的变量字典 2. 一般，locals 和 globals 获取的 变量字典 只被访问，不被修改。实际上都可被修改，修改改变全局变量本身。 locals 获取的局部范围内的 变量字典 不会影响局部变量 全局变量和局部变量的遮蔽现象 全局变量所有函数体内被访问，若函数体中定义了与全局变量同名的变量，会发生遮蔽。 两种方式避免遮蔽： 1. 访问被遮蔽的全局变量， globals 函数来实现 2. 在函数中声明全局变量， 使用global 语句来声明全局变量局部函数及用法(包含 nonlocal 关键字) 在函数体内定义函数，被放在函数体内的函数称为 局部函数 默认情况下，局部函数对外隐藏，在封闭函数内有效，封闭函数返回局部函数，以便在其他作用域中使用局部函数 局部函数内的变量会遮蔽他所在函数内的局部变量 在函数体内声明的变量，赋值语句不是定义新的局部变量，而是访问他所在函数体内的局部变量。 nonlocal 关键字， 可声明访问赋值语句只是访问该函数内的局部变量 函数高级用法函数本身是一个对象，即可用于赋值，也可用作其他函数的参数，还可作为其他函数的返回值 使用函数变量 所有函数都是 function 对象，即可把函数本省赋值给变量，就像把整数、浮点数、列表、元组赋值给变量一样 使用函数作为函数形参 若调用函数能动态传入 某些逻辑代码，就需要在函数中定义函数形参，即可在调用该函数时传入不同的函数作为参数 使用函数作为返回值 使用函数作为其他函数的返回值lambda 表达式及用法使用 lambda 表达式代替局部函数 lambda [parameter_list] : 表达式 lambda 几个要点： 1. lambda 必须使用lambda 关键字定义 2. 在 lambda 关键字后、冒号左边的参数列表，可没有参数，也可有多个，多个用逗号隔开，冒号右边是该lambda表达式的返回值 本质：就是匿名的、单行函数体的函数 lambda x，y ：x + y -------------------- def add (x , y): return x + y lambda 两个用途： 1. 单行函数： 使用lambda 可省去定义函数的过程，代码更简洁 2. 不需要多次复用的代码，lambda表达式使用完后立即释放，提高了性能类和对象封装、继承、多态面向对象： 一切皆对象面向对象编程(Object-oriented Programming, OOP)，是一种封装代码的方法 代码封装：隐藏实现功能的具体代码，仅留接口 分为两部分描述： 1. 表面特征： 颜色、外观等 2. 行为：爬、运动 所有变量都是对象， 面向对象相关术语： 类： 即模版，可创建出多个具体实例。称为：类的实例化 对象： 创造出的实例，称为对象 属性： 类中所有变量 称为属性 方法： 类中所有函数 称为方法定义类 类：仅充当图纸，根据图纸创造对象。 先定义、在创建类的实物对象，通过实例对象实现特定的功能。类名：每个单词首字母大写，单词与单词不能有分隔符 创建类使用 class 关键字 class 类名： N个类属性 N个类方法 __init__()类构造方法 用于创建对象使用，没创建一个类的实例对象时，会自动调用它。 def __init__(self,...): 代码块 可包含多个参数，但必须包含 self 此参数，必须作为第一个，类的构造方法至少要一个self参数，self 不需要手动传递参数,python自动给 self传值。 class Person { &apos;&apos;&apos; commit &apos;&apos;&apos; def __init__(self): print(&apos;构造方法&apos;) }类对象的创建和使用class 语句只创建类，需手动创建类的对象，创建类对象的过程称为类的实例化 类名(参数) class Person { def __init__(self,name,age): self.name = name self.age = age } p = Person(&apos;Hale&apos;,23) 类对象的使用 作用： 1. 操作对象的实例变量，即访问、修改实例对象的值，以及给对象添加、删除实例变量 2. 调用对象的方法。 类对象访问变量或方法 使用已创建好的对象访问类中的实例变量 对象名.变量名 使用类对象调用类中方法 对象名.方法名(参数) 对象与变量名及方法名 用 &apos; . &apos; 连接 给类对象动态添加变量 为已创建好的对象动态增加实例变量，只要为它的新变量赋值 xxx.yyy = [&apos;xxxx&apos;,&apos;xxxx&apos;] 删除变量： del xxx.yyy 给类对象动态添加方法 如果希望动态增加的方法能自动绑定到第一个参数，可借助于types模块下的MethodType 进行包装 self 用法 python 类方法中的self 参数相当于 C++中的 this 指针 同一个类可产生多个对象，当某个对象调用类方法时，该对象会把自身的引用作为第一个参数自动传给该方法，python自动绑定类方法的第一个参数指向调用该方法的对象，即解释器知道操作哪个对象的方法 对构造方法，self 参数 代表 该 构造方法 正在初始化的对象 class Obj { def __ini__(self): pass def __name(self): pass def __jump(self): self.name() } 当self参数作为对象的默认引用时，可访问self参数，也可当成实例方法的返回值 class ReturnSelf { def obj(self): if hasattr(self,&apos;age&apos;): self.age += 1 else: self.age = 1 return self } rs = ReturnSelf() // 实例化类变量和实例变量(类属性和实例属性) 类中定义的属性和方法，在外部，无法调用。 可把类看做独立的作用域，称为 类命名空间，类属性定义在类命令空间内的变量 类属性 可分为： 类属性也称类变量，和 实例属性也称实例变量 类变量： 指定义在类中，但在各个类方法外的变量，类变量的特点是：所有类的实例化和对象都可共享类变量的值，即类变量可在所有实例化对象中作为公用资源 类变量推荐直接用类名访问，也可用对象名访问 改变类变量的值会作用于该类所有的实例化对象 实例变量(实例属性) 指：定义在类的方法中的属性，特点：只作用于调用方法的对象 实例变量只能通过对象名访问，无法通过类名直接访问 class Obj { name = ‘hale’ age = 23 def change(self,name,age): self.name = name self.age = age } one = Obj() one.change(‘judy’,24) print(one.name,one.age) // Judy 24 print(Obj.name,Obj.age) // Hale 23 实例方法、静态方法和类方法详解 分为： 类方法、实例方法、静态方法 类实例方法 实例方法： 至少需要包含一个self参数，用于绑定调用此方法的实例对象，可用类对象、也可用类名调用 p = Person{} p.say(&apos;xxx&apos;) Person.say(person,&apos;xxx&apos;) 类方法 类方法： 至少包含一个参数，名为： cls， 自动将类本身绑定给 cls 参数， cls命名不规定，可随意命名 类方法需要使用 @classmethod 修饰 class Obj: # @classmethod 修饰的方法是类方法 @classmethod def name(cls): print(&apos;Class Method:&apos;,cls) 如没有 @classmethod ，会将 name方法认定为 实例方法，而不是类方法 类静态方法 静态方法和函数唯一区别： 静态方法定义在类空间，而函数定义在程序所在的空间中 静态方法没有类似 self cls 特殊的参数，因此不会对包含的参数做任何类或对象的绑定。此方法中无法调用任何类和对象的属性和方法，其和类关系不大 静态方法使用 @staticmethod 修饰 class Obj: @staticmethod def name(p): print(&apos;static Method&apos;, p) 静态方法的调用：可用类名，也可用类对象 Obj.name(&apos;Class Name&apos;) o = Obj() b.name(&apos;Class Object&apos;)类调用实例方法 # 定义全局空间的foo函数 def foo(): pass # 全局空间的bar变量 bar = 20 class Obj: # 定义Obj空间的bar变量 def foo(): pass bar = 200 # 调用Obj空间的函数和变量 foo() Obj.foo() 总结： python类可调用实例方法，使用类调用实例方法，不会自动为方法的第一个参数self绑定参数值，程序必须显式为参数self传参，称为：未绑定方法 property 函数：定义属性 属性名 = property(fget=NOne, fset=None, fdel=None, doc=None) fget：制定获取该属性值的类方法， fset：指定设置该属性值的方法， fdel：指定删除该属性值的方法，doc： 提供说明此函数的作用 类似property 函数合成的属性被称为计算属性，并不存储任何状态，值通过某种算法得到，当程序对该值赋值时，被赋的值也会被存储到其他实例变量中 @parperty 装饰器 既保护类的封装特性，又可以用 对象.属性 操作类属性，除了 property 函数，还提供 @property 装饰器，可直接通过方法名来访问方法， @preperty def 方法名(self) 代码块 要想实现修改 xx 属性的值，还为xx属性添加 setter方法，可用 setter装饰器 @方法名.setter def 方法名(self,value): 代码块 可用 deleter 装饰器 删除指定属性 @方法名.deleter def 方法名(self): 代码块 @函数装饰器及用法 内置的函数装饰器： @staticmethod @classmethod @property 自定义函数装饰器： 1. 将被修饰的函数(函数B) 作为参数传给 @ 符号引用的函数(函数A) 2. 将函数B替换(装饰) 成第一步的返回值 封装机制及实现方法目的： 隐藏类的实现细节 使用预定义方法访问，可加入控制逻辑，限制对属性的不合理访问 进行数据检查，保证完整性 便于修改，提高可维护性 实现封装的两方面： 1. 将对象的属性和实现细节隐藏起来，不可直接访问 2. 暴露方法，对属性安全访问和操作 定义： 类的成员命名以双下划线开头，就能隐藏 class User: def __hide(self): pass def getname(self): return self.__name继承机制及作用实现继承的类称为 子类， 被继承的类称为 父类，也叫 基类、超类 子类继承父来的语法：在定义类时，将多个父类放在子类后的圆括号内 class 类名(父类1，父类2,...): 类定义部分 Python是多继承机制，一个类可继承多个父类 object 类是所有类的父类，直接父类、间接父类 子类是对父类的扩展，子类是一种特殊的父类 从子类的角度看，子类扩展(extend)类父类，从父类的角度看，父类派生出(derive)出子类， class Fruit: def name(self): pass class Animal: def name(self): class Obj(Fruit,Animal): pass父类方法重写 子类与父类同名的方法为方法重写(Override)，也叫方法覆盖 使用未绑定方法调用被重写的方法 super()函数：调用父类的构造方法 子类继承父类的构造方法，如子类有多个直接父类，优先选择最前面父类的构造方法 如果子类重写了父类的构造方法，子类的构造方法必须调用父类的构造方法 子类调用父类构造方法的2种方式： 1. 使用未绑定，构造方法是实例方法，可通过此方式来调用 2. 使用super()函数调用父类的构造方法 当子类继承多个父类时，super()只调用第一个父类的构造方法，其他父类构造方法只能使用 未绑定 的方式调用 slots(两侧得都有两下划线): 限制类实例动态添加属性和方法 slots 属性的值是一个元组，该元组的所有元素列出了该类的实例允许动态添加的所有属性名和方法名 type(): 动态创建类 type 可指定三个参数： 1. 参数一： 创建的类名 2. 参数二： 该类继承的父类集合，使用元组指定多个父类 3. 参数三： 该字典对象为该类绑定的类变量和方法 MetaClass 元类 创建类的来，即创建类后，再由类来创建实例进行应用，使用元类可在创建类时动态修改类定义 定义元类： 类名以MetaClass 结尾，元类需要定义并实现 new()方法，一定要有返回值 new()方法作用： 使用class定义新类时，如指定了元类，new方法会被自动执行 多态同一变量完全可在不同的时间应用不同的对象，当同一变量在调用同一方法，可呈现多种行为 class Bird: def move(self,filed): print(&apos;bird %s&apos; % filed) class Dog: def move(self,filed): print(&apos;dog %s&apos; % field) b = Bird() b.move(&apos;sky&apos;) d = Dog() d.move(&apos;road&apos;)枚举类定义和使用 定义方式： 1. 使用Enum 列出多个枚举值来创建枚举类 2. 通过继承Enum 基类来派生枚举类 import enum s = enum.Enum(‘name’,(‘hale’,’judy’,’jally’)) 可通过枚举类变量名或枚举值来访问指定枚举对象 members 属性，返回一个dict字典，包含了该枚举的所有实例，遍历 members属性访问枚举的所有实例 枚举构造器 可定义构造器，为枚举定义构造器后，在定义枚举实例时，必须为构造器参数设置值异常处理机制异常机制主要依赖try、except、else、finally、raise 五个关键字 1. try 关键字后的代码块简称 try块，放置 引发异常的代码 2. 在except 后对应的是异常类型和一个代码块，表明该 except 块处理这种类型的daimakaui 3. 多个except 后放一个 else 块，程序不出现异常还是执行 else 块 4. finally 块用于回收在 try 打开的无力资源，异常机制保证 finally 块总被执行 5. raise 用于引发实际的异常，可单独作为语句使用，引发具体异常对象 常见异常类型 语法错误 和 运行时错误 语法错误： 解析代码是出现的错误，报出 SyntaxError 语法错误 运行时错误： 逻辑错误 常见异常类型 AssertionError ： 当assert 关键字后的条件为假时，程序停止并抛出此异常 AttributeError ： 试图访问的对象属性不存在时，抛出 IndexError ： 索引超出序列范围 KeyError ： 字典中查找一个不存在的关键字时 NameError ： 尝试访问一个未声明的变量时 TypeError ： 不同类型数据之间的无效操作 ZeroDivisionError ： 除法运算中除数为 0 引发此异常异常处理机制try except 异常处理 try: 可能产生异常的代码块 except ([Error1,Error2,…]) [as e]: // ErrorN 表明处理异常的具体类型 处理异常的代码块1 except ([Error3,Error4,…]) [as e]: // as e 表示将异常类型赋值给变量 e 处理异常的代码块2 执行流程： 1. 先执行 try 中的代码块，如出现异常，自动生成异常对象，提交给Python解释器，称为引发异常 2. 解释器收到异常，寻找处理该异常对象的except块，如找到合适的except块，则把异常对象交给except块，如找不到，则终止。 try: name = input(‘Enter name’) except (ValueError, ArithmeticError): print(‘error’) except : print(‘no error’) 访问异常信息 通过except块添加 as e 来访问异常对象的相关信息，当解释器决定调用某个except块来处理该异常对象时，会将异常对象赋值给except 块后的异常变量 异常对象包含的属性和方法： args ： 返回异常的错误编号和描述字符串 errno ： 返回异常的错误编号 strerror ： 返回异常的描述字符串 with_traceback() ： 处理异常的传播轨迹信息 异常类的继承体系 异常类派生于 BaseException， [继承关系](http://c.biancheng.net/uploads/allimg/190215/2-1Z2151H054Q0.gif) BaseException 主要子类是 Exception，不管是系统的异常类，还是用户自定义的异常类，都应该从Exception派生 1. 如发生数值类型错误，则调用ValueError 对应的except块处理该异常 2. 如发生逻辑错误： 2/0，则调用ArthmeticError 对应的except块处理该异常 3. 如运行时发生其他异常，异常对象是Exception类或其他子类的实例，则调用Exception对应的except块处理该异常 注： 先捕获小异常，再捕获大异常。try except else 异常处理结构 作用：指定当try块中没有发现异常时要执行的代码，若try中发现异常，则else块中的语句不会执行 try: r = 20 / int(input(‘enter num’)) except ValueError: pass except ArithmeticError: pass else: print(‘no error’) try except finally : 资源回收 完整异常处理语法结构： try: xxx except SubException as e: xxx except SubException as e: xxx else: xxx finally: xxx 在异常处理语法结构中，只有try块是必须的 1. 如没有try块，就没有except 和 finally 块 2. except 和 finally 块可选，可同时出现，也可出现其一 3. 可有多个except块，但捕获父类异常的except块位于捕获子类异常的后面 4. 不能只有try块，没有except finally块 5. 多个except 位于try块后，finally块位于所有except块之后 不要在finally块中使用如return 或 raise 等导致方法终止的语句，若在finally中使用return 或 raise 语句，会导致 try 块、except、中的return、raise语句失效 raise 用法 如需自行引发异常，则使用raise语句 raise [exceptionName [(reason)]] raise 语句三种用法 1. raise： 单独一个raise。 引发当前上下文中捕获的异常，如在except中，引发 RuntimeError异常 2. raise异常类名称： 指定异常类的默认实例 3. raise异常类名称： 引发指定异常的同时，附带异常的描述信息 raise 不需要参数 class Demo: def __init__(self,init_price): self.init_price = init_price def bid(self,bid_price): try: xxx except Exception as e: xxx raise except 和 raise 同时使用 实现通过多个方法协作处理同一个异常，可在except中结合raise语句来完成 try: xx except Exception as e: raise AuctionException(&apos;error message by self&apos;) raise AuctionException(e) 对异常的处理分为两个部分： 1. 应用后台需要通过日志来记录异常发生的详细情况 2. 根据异常向应用使用者传达某种提示 用户自定义异常对原始异常进行包装 raise AuctionException(e) 被称为： 异常包装或异常转译 自定义异常类 自定义异常需继承Exception 基类 或Exception的子类， class AuctionException(Exception): passsys.exc_info(): 获取异常信息捕获异常的2种方式获得更多的异常信息： 1. 使用 sys 模块中的 exc_info 方法 2. 使用 traceback 模块中的相关函数 两个方法返回异常全部信息：exc_info 和 last_traceback exc_info ： 将当前的异常信息以元组的形式返回，该元组包含三个元素， type、value、traceback type： 异常类型的名称 value： 捕获到的异常实例 traceback： 是一个traceback 对象 try: pass except: print(sys.exc_info())traceback模块： 获取异常信息使用traceback 模块查看异常传播轨迹，现将traceback模块引入，提供两个方法： 1. traceback.print_exec() ： 将异常传播轨迹信息输出到控制台或指定文件中 2. format_exc() ： 将异常传播轨迹信息转换为 字符串 print_exception(etype,value,tb[,limit[,file]]) 三个参数用于分别指定异常的信息： etype ： 指定异常类型 value ： 指定异常值 tb ： 指定异常的traceback 信息 print_exc([limit[,file]]) print_exc 自动处理except块所捕获的异常，涉及两个参数 1. limit ： 限制显式异常传播的层数 2. file ： 指定将异常传播轨迹信息输出到指定文件中，如不指定该参数，默认输出到控制台 import traceback def xxx(): raise SelfException(&apos;by self&apos;) try: xxx() except: traceback.print_exec(file=open(&apos;log.txt&apos;,&apos;a&apos;))自定义异常类及用法自定义一个异常类，通常应继承自 Exception类，直接继承Exception。也可继承自从Exception 继承而来的类，间接继承Exception [异常继承图](http://c.biancheng.net/uploads/allimg/190819/2-1ZQ9154321244.gif)异常机制使用细节 成功的异常处理4个小目标 1. 使程序代码混乱最小化 2. 捕获并保留诊断信息 3. 通知合适的人员 4. 采用合适的方式结束异常活动 不要过度使用异常 1. 把异常和普通错误混淆 2. 使用异常处理代替流程控制 3. 不要使用过于庞大的try块 4. 不要忽略捕获到的异常 assert 调试程序 assert 条件表达式 [,描述信息] assert 语句作用： 当条件表示式为真时，什么也不做，如果为假，则assert抛出 AssertionError异常 age = input(‘enter age’) name = input(‘enter name’) assert 20 &lt; age &lt; 100 , ‘age at 20 ~ 100’ assert 可与 try except 异常处理语句配合使用 try: age = input(‘enter age’) assert 20 &lt; age &lt; 100 , ‘age at 20 ~ 100’ except AssertionError as e: print(‘age is error’) 类特殊成员(属性和方法特殊： 方法名、属性名前后添加双下划线。 可重写或调用方法来实现特殊的功能如： 构造方法： __init__ ，通过重写类中的此方法实现自己的初始化逻辑 __repr__()方法 ： 显式属性 __del__方法： 销毁对象 __dir__用法 ： 列出对象的所有属性(方法)名 __dict__属性： 查看对象内部所有属性名和属性值组成的字典 setattr() , getattr() , hasattr() issubclass , isinstance ： 检查类型 __call__ __getitem__ , __setitem__ , __delitem__ , __len__, __contains__ __iter__ , __reversed__ ：实现迭代器 生成器详解 __repr__()方法： 显式属性 class xxx: def __init__(self,xx,xxx): self.xx = xx self.xxx = xxx x = xxx(&apos;xx&apos;,&apos;xxx&apos;) __repr__(): 所有的类都是object类的子类，所以所有的对象都具有 __repr__()方法 此方法：用于实现： 当程序直接打印该对象时，系统输出该对象的 自我描述 信息，用来告诉外界该对象具有的状态信息 此方法返回该对象实现类的 &quot;类名+object at + 内存地址&quot;，如 class obj: def __init__(self,xx,xxx): self.xx = xxx self.xxx = xxx def __repr__(self): return &quot;self.xx&quot; + self.xx + \ ,&quot;self.xxx&quot; + self.xxx x = obj(&apos;xx&apos;,&apos;xxx&apos;) 重写__repr__() 总是返回该对象的所有令人感兴趣的信息所组成的字符串，如下格式的字符串 类名 [field1 = 值1， filed1 = 值2 ,...] __del__方法： 销毁对象 与 __init__() 方法对象， __init__() 方法用于初始化对象， __del__() 方法用于销毁python对象，在任何对象被系统收回之时，会自动调用该对象的 __del__() 方法 如不需要一个对象时，必须把对象占用的内存空间释放，称为垃圾回收(GC, Garbage Collector) Python 采用自动引用计数(ARC) 方式来回收对象所占用的空间 当对象被垃圾回收时，自动调用该对象的 __del__方法，当对象的引用计数变为0时，对象才会被回收 class Obj: del __init__(self,xx): self.xx = xx def __del__(self): pass o = Obj(&apos;xx&apos;) x = o del x 若父类提供 __del__()方法，则系统重写 __del__() 方法时必须显式调用父类的 __del__()方法，保证合理回收父类实例的部分属性 __dir__用法：列出对象的所有属性(方法)名 用于列出该对象内部的所有属性包活方法名，该方法将会返回包含所有属性方法名的序列 当程序对某个对象执行 dir 函数时，将该对象的__dir__() 方法返回值进行排序，然后包装成 列表 class obj: def __init__(self,xxx): self.xxx = xxx def info(): pass x = obj print(x.__dir__()) 不仅输出对对象定义的xxx 、info属性和方法，还有系统内置的属性和方法，如 __repr__, __del__方法 __dict__属性： 查看对象内部所有属性名和属性值组成的字典 即可看对象的所有内部状态，也可通过字典语法来访问或修改指定属性的值 class obj: def __init__(self,xxx): self.xxx = xxx x = obj print(x.__dict__) print(x.__dict__(xxx))setattr(), getattr(), hasattr() 函数用法动态检测对象是否包含某些属性或方法相关的函数： 1. hasattr(obj,name) : 检查obj对象是否包含名为 name 的属性或方法 2. getattr(object,name[,default]) : 获取object对象中名为 name 的属性的属性值 3. setattr(obj,name,value,/) : 将obj对象的 name 属性设为 value class obj: def __init__(self,xx,xxx): self.xx = xx self.xxx = xxx def info(): pass x = obj print(hasattr(x,&apos;xxx&apos;)) // True print(getattr(x,&apos;xxx&apos;)) // True setattr(x,&apos;xx&apos;,&apos;yy&apos;) print(x.xx) setattr() 可改变 对象的属性值，若对象设置的属性不存在，可添加属性issubclass 和 isinstance 函数 ： 检查类型issubclass(cls, clsss_or_tuple) : 检查cls是否为后一个类或元组包含的多个类中任意类的子类 isinstance(obj, class_or_tuple) : 检查obj是否为后一个类或元组包含的多个类中任意类的对象 区别： issubclass 第一个参数是类名，判断是否为子类 isinstance 第一个是变量，判断是否为该类或子类的实例 第二参数都可使用 元组 __base__属性 ： 通过该属性可查看该类的所有直接父类，该属性返回所有直接父类组成的元组 class x: pass class xx: pass class xxx(x,xx): pass print(x.__base__) print(xx.__base__) __subclasses__()方法 ： 查看该类的所有直接子类，返回该类的所有组成的列表 print(x.__subclasses__() __call__方法 hasattr 函数判断指定属性或方法是否存在， __call__属性： 进一步判断该属性或方法是否可调用 class x: def __init__(self,xx,xxx): self.xx = xx self.xxx = xxx def ValidLogin(self): pass x = x(&apos;xx&apos;,&apos;xxx&apos;) print(x.xx,&apos;__call__&apos;) print(x.xxx,&apos;__call__&apos;) __getitem__ , __setitem__ , __delitem__ , __len__ , __contains__ 序列的特征 可包含多个元素，相关的特殊方法： __len__(self) ： 返回值决定序列中元素的个数 __getitem__(self,key) ： 获取指定索引对应的元素，key是整数值或slice对象，会引发 KeyError异常 __contains__(self,item) ： 判断序列是否包含指定元素 __setitem__(self,key,value) ： 指定设置索引对应的元素，key 是整数值或slice对象，否则引发 KeyError异常 __delitem__(self,key) ： 删除指定索引对应的元素 def xx(key): if not isinstace(key,int) : raise TypeError(&apos;must int&apos;) if key &lt; 0 : raise IndexError(&apos;is ini&apos;) class xxx: def __init__(self): self.__changed = {} self.deleted = [] def __len__(self): pass def __getitem__(self,key): pass def __setitem__(self,key,value): pass def __delitem(self,key): passiter 和 reversed ：实现迭代器for循环遍历列表、元组和字典等对象都是可迭代的，都属于迭代器 实现迭代器，需实现两个方法： 1. __iter__(self) : 该方法返回一个迭代器，必须包含一个 __next__() 方法，返回迭代器的下一个元素 2. __reversed__(self) : 为内奸的reversed 反转函数提供支持，对指定迭代器执行反转时 class x: def __init__(self,len): self.first = 0 self.sec = 1 self.__len = len def __next__(self): if self.__len == 0: raise StopIteration self.first, self.sec = self.sec, self.first + self.sec self.__len -= 1 return self.first def __iter__(self): return self生成器生成器与迭代器的区别在于： 迭代器通常是先定义一个迭代器类，通过创建实例来创建迭代器。 生成器：先定义一个包含 yield 语句的函数，然后通过调用该函数来创建生成器 创建生成器 创建生成器的步骤： 1. 定义一个包含 yield 语句的函数 2. 调用第一步创建的函数得到生成器 def xxx(val,step): xx = 0 for i in range(val): xx += i * step yield xx yield xx 语句的作用： 1. 每次返回一个值，类return 语句 2. 冻结执行，每次执行到yield 语句时会被暂停两种方式创建生成器： 1. 使用 for 循环的生成器推导式 2. 调用带 yield 语句的生成器函数 生成器的方法： 1. 外部程序通过 send 方法发送数据 2. 生成器函数使用 yield 语句接收收据 生成器两个常用方法： 1. close ：用于停止生成器 2. throw ：用于在生成器内部(yield语句内) 引发一个异常模块和包常用 sys、OS 、 traceback 三个模块模块化编程 模块： Modules， 模块就是Python程序， 代码的可重复性体现在，编写好模块后，需用到该模块中的某个功能(由变量、函数、类实现)，无需重复性工作，直接导入该模块即可使用该功能 封装特性的结构： 1. 容器： 例 列表、元组、字符串、字典等，都是对数据的封装 2. 函数： 对Python代码的封装 3. 类： 对方法和属性的封装，对函数和数据的封装 语法格式： 模块名.函数导入模块： import 1. import 模块名1 [as 别名] , 模块名2 [as 别名2],... : 导入指定模块中的所有成员(变量、函数、类等)。 当使用模块中的成员时，需要该模块名(或别名)作为前缀 2. from 模块名 import 成员名1 [as 别名1], 成员名2 [as 别名2] ,... : 只会导入模块中指定的成员，非全部成员，使用该成员时，无需任何前缀，直接使用成员名或别名 第二种from 模块名 import * ： 可导入指定模块中的所有成员 import 模块名 as 别名 1. 导入整个模块： import sys 2. 导入整个模块，指定别名： import sys as s 3. 导入多个模块： import sys，os 4. 导入多个模块，同时指定别名： import sys as s, os as o from 模块名 import 成员名 as 别名 1. 导入模块的成员 ： from sys import argv 2. 导入模块成员，指定别名 ： from sys import argv as v 3. 导入模块成员，一次导入多个成员 ： from sys import argv ， winver 4. 导入多个模块，指定别名 ： from sys import argv as v， winver as w 不推荐使用 from import 导入模块所有成员自定义模块 模块文件的文件名是它的模块名，如 xxx.py 的模块名就是 xxx 自定义模块编写测试代码 如直接运行模块文件，程序会执行该模块的函数，如其他程序导入该模块，不应该执行该模块的函数 要实现这个效果，需借助 python 内置的 __name__ 变量，当直接运行模块时， name 变量的值为 __main__; 而将模块被导入其他程序并运行该程序，处于模块中 __name__ 变量的值就编程类模块名。 如希望函数只有在直接运行模块文件时才执行，则可增加判断，即只有当 __name__ == &apos;__main__&apos; 时才调用函数 __name__ == &apos;__main__&apos; : __name__ :内置的系统变量，用于标识所在模块的模块名， 作用： 确保只有单独运行该模块时，此表达式才成立，才可以进入此判断语法，执行其中的测试代码，反之，如只是作为模块导入到其他程序文件中， 则此表达式不成立，若运行，不执行判断语句汇中的代码导入模块的三种方式当时用import 语句导入模块后，会按顺序查找指定的模块文件 1. 当前目录，即当前执行的程序程序文件所在目录下查找 2. 到Pythonpath 环境变量下的每个目录下查找 3. 到python 默认的安装目录下查找 自定义的模块： 1. 向sys.path 中临时添加模块文件存储位置的完整路径 2. 将模块放在sys.path 变量中已包含的模块加载路径中 3. 设置系统环境变量 导入模块方式一： 临时添加模块完整路径 导入模块方式二： 将模块保存到指定位置 导入模块方式三： 设置环境变量 linux 设置环境变量： vim ~/.bash_profile PATHONPATH=.:/pythondir/python_module export PYTHONPATH导入模块的本质 将xxx.py 中的全部代码加载到内存并执行，然后将整个模块内容赋值给与模块同名的变量，该变量的类型是module，而在该模块中定义的所有程序单元都相当于该module对象的成员 导入同一模块多次，只执行一次 __all__ 变量 将变量的值设置为一个列表，只有该列表中的成员才会被暴露出来 def xx(): pass def xxx(): pass __all__ = [&apos;xx&apos;,&apos;xxx&apos;] 意义：为模块定义开放的公公接口，只有 __all__变量列出的成员， 如使用模块内__all__ 列表之外的成员，两种解决方法 1. import 模块名 导入模块， 通过模块名前缀来调用模块内的成员 2. from 模块名 import 成员 ，导入指定成员 包： 存放多个模块的文件夹 包：就是文件夹，必须存在名为 &quot;__init__.py&quot; 的文件 每个包的目录下必须建立一个 __init__.py 的模块，可为空模块 作用： 将目录当成包来处理创建包，导入包 包的创建步骤： 1. 创建文件夹，名称为该包的包名 2. 文件夹内创建名为 __init__.py 的文件， 包的导入： 1. import 包名[.模块名[as 别名]] import xx.xxx 2. from 包名 import 模块名 [as 别名] from xx import xxx 3. from 包名.模块名 import 成员名 [as 别名] from xx.xxx import xxxx __init__.py 导入包等同于导入包中的__init__.py文件，可在此文件中编写功能代码。 包作用是包含多个模块，因此此文件作用是导入该包内的其他模块 查看模块(变量、函数、类)方法 2种方式： 1. dir() dir(xxx) 2. __all__ xxx.__all__ __doc__属性：查看文档 help(string.capwords) print(string.capwords.__doc__) __file__属性：查看模块的源文件路径 import string string.__file__ 第三方模块(库)下载和安装(通过pip命令) pip install | uninstall | list 模块名常见模块日期、时间、正则表达式、JSON支持、容器等 sys 模块用法 和解释器关系密切的标准库，帮助访问和解释器联系密切的变量和函数 import sys [e for e in dir(sys) if not e.startswith(&apos;__&apos;)] // 双下划线 没有 __all__变量sys模块包含全部成员 包括变量、函数等 sys成员： sys.argv ： 获取运行python 程序的命令行参数 sys.path ： 一个字符串列表，每个字符串都是一个目录名，使用import导入模块时，解释器从这些目录中查找指定的模块 sys.exit() ： 引发SystemExit 异常退出程序 sys.modules ： 返回模块名和载入模块对应关系的字典 sys.platform ： 是字符串，标识解释器运行平台名称，即操作系统名称 sys.stdin、sys.stdout、sys.stderr ： 类文件流对象，表示 标准输入、输出、错误 sys.flags ： 只读属性返回运行py命令时指定的旗标 sys.getrefcount(object) ： 返回指定对象的引用计数，当objet对象引用计数为0，系统会回收该对象 sys.getfilesystemencoding(object) ： 返回系统中保存文件所用的字符集 sys.getrecursionlimit() ： 返回当前支持的递归深度 sys.getswitchinterval() ： 返回解释器中线程切换的时间间隔，通过setswitchinterval 函数改变 sys.implementation ： 返回当前py解释器的实现 sys.maxsize ： 返回整数支持的最大值，32: 2**31 -1 64: 2**63-1 sys.executable ： 返回解释器在从磁盘的存放路径 sys.byteorder ： 显示本地字节序的指示符 sys.copyright ： 返回与解释器有关的版权信息 sys.version ： 返回解释器版本的版本信息 sys.winver ： 返回解释器的主版本号 sys获取运行参数： sys 模块的argv 属性可获取运行py程序的命令行参数，argv是一个列表 python argv xx.py &quot;xxx&quot; 动态修改模块加载路径： import sys sys.path.append(&apos;E:\xxx&apos;)os 模块及用法 代表程序所在的操作系统，用于获取程序运行所在操作系统的相关信息 import os os.__all__ ： 查看该模块所包含的全部变量和函数 os.name ：返回依赖模块操作系统的名称，如 posix、nt、java等 os.environ ： 所有环境变量组的字典 os.sep ： 路径分隔符 os.fsencode(filename) ： 对类路径 path-like 的文件名进行编码 os.fsdecode(filename) ： 对类路径 path-like 的文件名解码 os.PathLie ： 是类，代表 类路径对象 os.getenv(key,default=None) ： 指定环境变量的值 os.getlogin() ： 系统登录用户名。 os.getuid、os.getgroups、os.getgid 等函数，获取用户 ID 、用户组、组ID os.getpid() ： 进程ID os.getppid() ： 进程的父ID os.putenv(key,value) ： 设置环境变量 os.cpu_count() ： 系统的CPU数量 os.pathsep ： 系统上多条路径之间的分隔符。如 ； ： os.linesep ： 系统的换行符 os.urandom(size) ： 加密使用、最多由N个字节组成的bytes对象 os 进程管理函数： os.system(command) ： 运行操作系统上的指定命令 os.abor() ： 生成一个SIGABRT 信号给当前进程，UNIX上默认生成内核转储；windows 退出返回3 os.execl(path,arg0,arg1,...) ： 一系列功能类似的函数，如： os.execle、os.execlp等 os.forkpty() ： fork 一个子进程 os.kill(pid, sig) ： 将sig 信号发送到pid对应的过程，用于结束进程 os.killpg(pgid,sig) ： 发送到 pgid 对应的进程组 os.popen(cmd, mode=&apos;r&apos;,buffering=-1) ： 向cmd命令打开读写管道，buffering村冲参数，返回文件对象用于读写字符串，而不是字节 os.startfile(path,operation) ： 对指定文件使用关联工具执行operation对应的操作 random 模块及用法 查看该模块所包含的全部变量和函数： import random random.__all__ random 模块常用函数： random.seed(a=None,version=2) ： 指定种子来初始化伪随机数生成器 random.randrange(start,stop[,step]) ： 返回从start开始到stop结束，步长为 step的随机数 random.randin(a,b) ： 生成一个范围为 a &lt;= N &lt;= b 的随机数 random.choice(seq) ： 从seq 中随机抽取一个元素，如为空，抛 IndexError异常 random.choices(seq,weights=None,cum_weights=None,k=1) ： 从seq 抽元素，weigths指定被抽取的权重 random.shuffle(x[,random]) ： 对 x 序列执行洗牌 随机排序 操作 random.sample(population,k) ： 从population序列中随机抽取k个独立元素 random.random() ： 生成从包含0.0 到不包含1.0之间的随机浮点数 random.uniform(a,b) ： 生成一个范围 a ～ b 的随机数 random.expovariate(lambd) ： 生成呈指数分布的随机数，lambda 参数time 模块查看time模块包含的全部属性和函数 import time time.__all__ | [e for e in dir(time) if not e.startswith(&apos;__&apos;)] time.struct_time ： 代表一个时间对象，包含9个属性 tm_year 年 tm_mon 月 | tm_mday 日 | tm_hour 时 | tm_min 分 tm.sec 秒 | tm_wday 周 | tm_yday 一年内第几天 | tm_isdst 夏令时 time 函数： time.asctime([t]) ： 将时间元组或struct_time转换为时间字符串 time.ctime([secs]) ： 以秒数的时间转换时间字符串 time.gmtime([secs]) ： 将秒数的时间转为 struct_time 对象 time.localtime([secs]) ： time.mktime(t) time.perf_counter() time.process_time() time.sleep(secs) time.strftime(format[,t]) time.time() time.timezone time.tzname [详细点击](http://c.biancheng.net/view/2420.html)json 模块JSON： JavaScript Object Notation ，即javascript对象符号，数据交换格式 两种数据结构： 1. 由 key-value 对组成的数据结构 2. 有序集合， 在python中对应于列表 使用JSON语法创建对象： object = { xxx:xxxx, // 字符串用双引号包含 yyy:yyyy, } JSON创建数组： arr = [value1,value2,...] JSON for Python JSON 类型转换 Python 类型 对象(object) 字典(dict) 数组(array) 列表(list) 字符串(string) 字符串(str) 整数(number(int)) 整数(int) true True false False null None Python类型转换为 JSON类型 字典(dict) 对象(object) 列表(list)和元组(tuple) 数组(array) 字符串(str) 字符串(string) 整形、浮点型、派生的枚举 数值型(number) True true False false None null 查看模块所有属性和函数： import json -&gt; json.__all__ 常用函数和类的功能： json.dump(obj,fp,*,skipkeys=False...) // 将obj对象转换成json字符串输出到fp流中 json.dumps(obj,*,skipkeys=False,...) // 将obj对象转换为JSON字符串，并返回该JSON字符串 json.load(fp,*,cls=NONE,object_hook=None,...) // 从fp流读取JSON字符串，将其恢复成JSON对象， fp支持write()方法的类文件对象 json.loads(s,fp,*,encoding=None,cls=None,object_hook=None,...) // 将JSON字符串s恢复为JSON对象正则表达式Regular Expression 描述一种字符串匹配的模式，检查一个字符串是否含有某个子串，也可从字符串中提取匹配的子串，或对字符串中匹配的子串执行替换操作，可用来开发数据抓取、网络爬虫等查看该模块所包含的属性和函数： import re -&gt; re.__all__ 函数作用： re.complie(pattern, flags=0) : 将正则表达式字符串编译成 _sre.SRE_Pattern 对象， 该对象代表正则表达式编译之后在内存中的对象，可缓存并复用正则表达式字符串，如多次使用同一正则表达式字符串，则可先编译它。 pattern ： 所编译的正则表达式字符串， flags ： 匹配旗标， re.match(pattern , string, flags=0) : 从字符串开始位置匹配正则表达式，如匹配不成功，match 函数返回None， pattern ： 正则表达式。 string ：匹配的字符串。 flags ： 正则表达式的匹配旗标。 re.search(pattern, string, flags=0) : 扫描整个字符串，返回字符串中第一处匹配pattern的匹配对象， pattern ： 正则表达式。 string ：被匹配的字符串。 flags ： 匹配旗标 re.findall(pattern, string, flags=0) : 扫描整个字符串，返回字符串中所有匹配pattern的子串组成的列表。 pattern ： 正则表达式。 string ：被匹配的字符串。 flags ： 匹配旗标 re.finditer(pattern, string, flags=0) ： 扫描整个字符串，返回字符串所有匹配pattern 的子串组成的迭代器。 pattern ： 正则表达式。 string ：被匹配的字符串。 flags ： 匹配旗标 findall、finditer 、search 的区别： search 只返回字符串中第一处匹配pattern的子串，findall和finditer 返回字符串中所有匹配pattern的子串 re.fullmatch(pattern,string, flags=0) ：要求整个字符串匹配 pattern，如匹配返回包含匹配信息的 _sre.SRE_Match对象，否则 None re.sub(pattern,repl,string,count=0,flags=0) ：将string字符串中所有匹配pattern的内容替换成repl repl ： 被替换的字符串，可是函数， count 控制替换的次数。 import re date = &apos;2019-08-22&apos; print(re.sub(r&apos;-&apos;,&apos;/&apos;,date)) r&apos;-&apos; ：是原始字符串， r ： 代表原始字符串，通过原始字符串，避免对字符串中的特殊字符转译 r&apos;(?P&lt;lang&gt;\w+)&apos; : 正则表达式用圆括号表达式创建一个组， &apos;?P&apos; 为该组起名为 lang ， \w+ 是正则表达式的内容，代表一个或多个任意字符， re.split(pattern,string, maxsplit=0, flags=0) ： 使用pattern对string进行分割，返回分割得到的多个子串组成的列表，maxsplit 参数控制分割的次数 re.purge() : 清楚正则表达式缓存 re.escape(pattern) ：对模式中除ASCII字符、数值、下划线之外的其他字符转义 re模块中的Match 对象是match 、search方法的返回值，包含了详细的正则表达式匹配信息，包含匹配的位置、子串 sre.SRE_Match 对象包含如下方法或属性： match.group([group1,...]) : 获取该匹配对象中指定组所匹配的字符串 match.__getitem__(g) ： match.group(g)的简化写法。 match.groups(default=None) : 返回match对象中所有组所匹配的字符串组成的元组 match,groupdict(default=None) ：返回match对象中所有组所匹配的字符串组成的字典 match.start([group]) ：获取该匹配对象中指定组所匹配的字符串的开始位置 match.end([group]) ：获取结束位置 match,span([group]) ：获取开始和结束位置，相当于同时返回 start 和 end方法的返回值 match.pos : 该属性返回传给正则表达式对象的search , match等方法的pos参数 match.lastindex : 返回最后一个匹配的捕获组的整数索引，如没有，则返回None match.lastgroup : 返回最后一个匹配的捕获组的名字，如没有，则返回None match.re : 返回执行正则表达式匹配时所用的正则表达式 match.string : 返回执行正则表达式时所用的字符串set 和 frozenset 集合操作set 集合是可变容器，可改变容器中的元素， frozenset集合，是set的不可变版本，他的元素不可变set集合： 两个特征： 1. set 不记录元素的添加顺序 2. 元素不允许重复 [e for e in dir(set) if not e.startswith(&apos;__&apos;)] add添加 、 remove 删除元素、discard 删除元素、clear 清空 remove 和 discard 区别： remove 报KeyError异常。discard 不报 set 支持的运算符： &lt;= : 相当于调用 issubset() 方法，判断前面的set集合是否为后面set集合的子集合 &gt;= ：调用issuperset 方法，判断是否为后面set集合的父集合 - ： 调用difference ，前面的set集合减去后面的set集合的元素 &amp; ： 调用intersection，获取两个set集合的交集 ^ ： 计算两个集合异或的结果，即两个集合的并集减去交集的元素frozenset 集合是set的不可变版本，set集合中不改变集合本身的方法，fronzenset 都支持 作用： 1. 当集合元素不需要改变时，使用frozenset 代替 set更安全 2. 当某些api需要不可变对象时，必须用frozenset代替setqueue (双端队列) 模块栈：一种特殊的线性表，允许一端进行插入、删除操作。这个端为栈定(top),另一端为栈底(botton) 从栈顶插入一个元素称为： 进栈， 压入栈。 push 从栈顶删除一个元素称为： 出栈， 弹出栈。 pop 栈，陷入栈的元素位于栈底，上面元素出栈后，栈底的元素才能出栈。 栈 是一种 后进先出(LIFO)的线性表 队列是一种特殊的线性表，只允许在表的前段(font) 删除，在后端(rear) 插入。 插入的操作的端为 队尾， 删除操作的端为 队头 队列：元素是从队列的rear 端进。 队列是一种 先进先出FIFO 的线性表。 双端队列deque 代表特殊的队列， 在两端同时进行插入、删除操作，deque 即可为队列使用，也可为 栈 使用 deque 位于 collections 包下，[e for e in dir(collections.deque)if not e.startswith(&apos;__&apos;)] from collections import deque 双端队列的特征， deque 的左边 left 相当于 它的队头front， 右边right 相当于它的队列尾rear append 和 appendleft ：在deque的右边或左边添加元素， 即在默认队列尾添加元素 pop 和 popleft ：在deque的右边或左边弹出元素，默认在队列尾弹出元素 extend 和 extendleft ： 在deque的右边或左边添加多个元素，默认在队列尾添加多个元素 deque 中clear 方法用于清空队列，insert 方法是线性表的方法，指定位置插入元素 deque 中 rotate 方法。将队列的队尾元素移动到队头，使之首位相连heapq 堆操作 小顶堆的任意子树是小顶堆，大顶堆的任意子树是大顶堆 import heapq -&gt; heapq.__all__ 函数功能： heappush(heap,item) ： 将item元素加入堆 heappop(heap) : 将堆中最小元素弹出 heapify(heap) : 将堆属性应用到列表上 headpreplace(heap,x) : 将堆中最小元素弹出，并将元素x入堆 merge(*iterables, key=None, reverse=False) ： 将多个有序的堆合并为一个大的有序堆，然后输出 headppushpop(heap,item) ： 将item入堆，然后弹出并返回堆中最小的元素 nlargest(n,iterable,key=None) ： 返回队中最大的n个元素 nsmallest(n,iterable,key=None) : 返回堆中最小的n个元素 ChainMap 使用链的方式将多个 dict 链在一起，允许程序可直接获取任意一个dict所包含的key对应的value ChainMap 相当于把多个dict合并为一个大的dict，Counter 类 可自动统计容器中个元素出现的次数 本质是一个特殊的dict，key是所包含的元素，value记录key出现的次数 Counter 继承了dict， 提供三个常用的方法： 1. elements ： 返回该counter 所包含的全部元素组成的迭代器 2. most_common([n]) ：返回Counter 中出现最多的n个元素 3. subtract([iterable-or-mapping]) ： 计算counter 的减法，计算减去之后各元素出现的次数 可把Counter对象转换为 set集合、list列表、dict字典等，可对Counter执行 加、减、交、并运： 加： 将两个Counter对象中各Key 出现的次数相加，保留为正的元素 减： 相减，保留出现次数为正的元素 并： 出现key且各key对应的次数的最小数 求正： 只保留出现次数为0 或正数的key-value对 求负： 保留次数为负的 key-value 对，将次数改为正数 defaultdict ： 是dict 的子类，与dict 的区别： 根据不存在的key访问dict中对应的value，会引发KeyError异常，defaultdict则提供default_factory属性， 指定的函数为不存在的key来生成valuenamedtuple 工厂函数功能 可创建一个tuple类的子类，为tuple的每个元素指定字段名，可根据字段名访问namedtuple的各元素，根据索引来访问namedtuple的各元素 namedtuple(typename,field_names, * , verbose=False, rename=False,module=None) typename : 指定所创建的tuple子类的类名，等于用户定义一个新类 field_names ： 字符串序列，使用单个字符串代表所有字段名，用空格、逗号隔开 rename ： 如参数为True， 无效字段名会被自动替换为位置名 verbose ： 参数为True， 当子类被创建后，该类定义会被立即打印出来 module ： 自定义类的__module__属性将被设为该参数值 Python 为命名元组提供的方法和属性： _make(iterable) ：类方法，根据序列或可迭代对象创建命名元组对象 _asdict() : 将当前命名元组对象转换为OrderdDict 字典 _replace(**kwargs) ： 替换命名元组中一个或多个字段的值 _source ： 返回定义该命名元组的源代码 _fileds ： 返回该命名元组中所有字段组成的元组 OrderdDict用法： 是dict的子类，可 维护 添加 key-value 对的顺序， 先添加key-value对排的前面，后添加的key-value对排的后面 两个方法： 1. popitem(last=True) ： 弹出并返回最左边的最后加入的key-value对，将last参数设为False，则弹出并返回最左边最先加入的key-value对 2. move_to_end(key,last=True) : 将指定的key-value对移动到最右边最后加入，将last改为False，则将指定的key-value对移动到最左右最先加入itertools模块：生成迭代器先导入 import itertools 模块， [e for e dir(itertools) if not e.startswith(&apos;__&apos;)] 三个生成无限迭代器的函数： 1. count(start,[step]) ：生成start、start+step、start+2*step,...的迭代器，step默认为1。 count(10) 生成的迭代器包含： 10，11，12，13，14.。。 2. cycle(p) : 对序列p生成无限循环p0，p1.。。的迭代器。cycle(&apos;ABCD&apos;) 包含：A,B,C,D,A,B,C,D,... 3. repeat(elem [,n]) ： 生成无限个 elem元素重复的迭代器. repeat(10,3) ：10，10，10， 在itertools 模块中常用的迭代器函数： accumulate(p,[func]) ： 生成根据序列p元素累加的迭代器 chain(p,q,...) : 将多个序列里的元素 链 在一起生成新的序列 compress(data,selectros) ： 根据selectors序列的值对data序列的元素进行过滤 dropwhile(pred,seq) : 使用pred函数对seq序列进行过滤，如计算为False，保留该元素到序列结束的全部元素 takewhile(pred,seq) ：使用pred函数对seq进行过滤，去掉从该元素序列结束的全部元素 filterfalse(pred,seq)：使用pred函数对seq序列进行过滤，保留seq中使用pred计算为True的元素 islice(seq,[start,]stop[,step]) ：类似于slice，返回seq[start:stop:step]的结果 starmap(func,seq)：使用func对seq每个元素进行计算，结果为新的序列元素 zip_longest(p,q,...) ：将p、q序列中元素按索引合并成元组，元组作为新序列的元素 在itertools 模块中生成序列排列的工具函数： product(p,q,...[repeat = 1])：用序列p、q，。。。进行排序组合，相当于嵌套循环组合 permutations(p[,r]) ：从序列p中取出r个元素组成排序，将排序得到的元组作为新迭代器的元素 combinations(p,r) ：从序列p中取出r个元素组成全组合，元素不重复，将组合得到的元组作为新迭代器的元素 combinations with_replacement(p,r)：从序列p中取出r个元素组成全组合，元素可重复，将组合得到的元组作为新迭代器的元素functools 模块：包含函数装饰器和便捷的功能函数， import functools 常用函数装饰器和功能函数： functools.cmp_to_key(func) ：将老式的比较函数(func)转换为关键字函数(key function) py3不支持 @function.lru [更多](http://c.biancheng.net/view/2443.html)Tkinter (GUI图形洁面开发)GUI ：Graphics User Interface 图形用户界面。三要素：输入数据、处理数据、输出数据常用库： wxPython ： 跨平台GUI工具集 PyQt ： 是Py和Qt库的融合 PyGTK ： 基于老版本GTK+2的库提供绑定，借助于底层GTK+2提供的可视化元素和组件 Pywin32 ： 允许像VC使用Py开发win32应用 Kivy ： 开源库，使用同源代码创建的程序跨平台 Flexx ： 纯Py工具包，创建图形化界面程序，支持使用web技术进行界面渲染Tkinet GUI 编程组件及用法 学习GUI步骤为三步： 1. 包含的组件 2. 容器及容器对组件布局的方法 3. 掌握各组件的用法 [Tkinter GUI 关系](http://c.biancheng.net/view/2451.html) Tkinter的GUI组件有两个根父类，直接继承object类 1. Misc ： 所有组件的根父类 2. Wm ： 提供窗口管理器通行的功能函数 BaseWidget ： 所有组件的基类，派生类：Widget ，通用GUI组件，Tkinter 是所有GUI组件都是Widget的子类 各GUI组件的功能 Toplevel： 顶层 容器类 Button ： 按钮 按钮组件 Canvas ： 画布 绘图功能 Checkbutton： 复选框 可勾选的复选框 Entry ： 单行输入框 用户可输入容内 Frame ： 容器 装载其他GUI组件 Label ： 标签 显示不可编辑的文本或图标 LabelFrame ： 容器 容器组件，支持添加标题 Listbox ： 列表框 列出多个选项，供用户选择 Menu ： 菜单 菜单组件 Menubutton ： 菜单按钮 包含菜单的按钮 包括下拉式、层叠式 OptionMenu ： 菜单按钮 Menubutton的子类 Message ： 消息框 类标签，显示多行文本，Lable代替，废弃 PanedWindow： 分区窗口 该容器可划分为多个区域 Radiobutton ： 单选钮 单选按钮 Scale ： 滑动条 可设置起始值和结束值，显示当前精准值 Spinbox ： 微调选择器 可通过组件向上、向下选择不同的值 Scrollbar ： 滚动条 用于为组件(文本域、画布、列表框、文本框)提供滚动 Text ： 多行文本框 显示多行文本 initWidgets 方法实现的代码： 1.创建 GUI 组件 2.添加 GUI 组件 3.配置 GUI 组件 配置GUI组件的2种方法： 1. 以关键字参数的方式配置 2. 以字典语法进行配置 [GUI通用选项](http://c.biancheng.net/view/2451.html) TKinter Pack 布局管理器 [常用选项及功能]() anchor : 空间大于组件所需求的大小，决定被放置在容器的位置 expand : 指定当容器增大时是否拉伸组件 fill : 组件是否沿水平或垂直方向填充 ipadx : 指定组件在 x 方向上的内部留白 ipady : 在 y 方向上内部留白 padx : 在x方向上与其他组件的间距 pady : 在y方向上的间距 side : 设置组件的添加位置 Tkinter Grid 布局管理器 Grid 把组件空间分解为一个网格进行维护 Tkinter Grid 常用选项 column ： 指定将组件放哪列 columnspan : 指定组件横跨多少列 row ：指定放入哪行 sticky ：类 pack方法的anchor选项Tkinter Place 布局管理器 绝对布局 ： 要求程序显式指定每个组件的绝对位置或相对其他组件的位置 常用选项： x 指定组件的X坐标， x 为 0 代表最左边 y Y 坐标 最右边 relx 组件的X坐标 rely 组件的Y坐标 width 组件的宽度 height 组件的高度 relwidth 组件的宽度 relheight 组件的高度 bordermode 设置组件的宽度、高度 Tkinter Command 和 Bind 事件处理 command 绑定事件处理方法： 可通过command 来绑定，可绑函数或方法，单击时，触发绑定的函数或方法 bind 绑定事件处理方法： 无法为具体事件绑定事件处理方法 无法获取事件相关信息 bind()方法： 可为 任意 事件绑定事件处理方法 Tkinter 支持的鼠标、键盘事件 Tkinter ttk组件及用法 是Tinkter 包下的模块，界面美化、包装 Tkinter Variable类用法 支持GUI组件与变量进行双向绑定， 1. 如改变变量的值，GUI组件的显示内容或值也改变 2. 当GUI组件的内容改变时，值也改变 Tinkter 不能讲组件和普通变量进行绑定，只能和tkinter 包下的Variable类的子类进行绑定 1. StringVar() : 包装str值的变量 2. IntVar() : 整形值的变量 3. DoubleVar() ： 浮点值的变量 4. BooleanVar() : 包装bool值的变量Tkinter compound 选项使用方法如使组件同时显示文本和图片，可通过 compound 选型进行控制 属性值： 1. None ： 图片覆盖文字 2. LEFT 常量： 图片在左，文本在右 3. RIGHT 变量： 图片在右，文本在左 4. TOP 常量： 图片在上， 文本在下 5. BOTTON 常量： 图片在底，文本在上 6. CENTER 常量： 文本在图片上方Tkinter Entry 和 Text 控件用法 可接收用户输入的输入框组件，区别： Entry ： 单行。 Text： 多行 Tkinter Radiobutton 和 Checkbutton 用法 单选按钮，可绑定一个方法或函数。 将多个Radiobutton 编为一组，将多个Radiobutton绑定到同一个变量，当其中一个单选按钮被选中时，该变量随之改变。 Tkinter Listbox 和 Combobox 控件用法 列表框，通过列表框选择一个列表项。 创建 Listbox 的步骤： 1. 创建Listbox 对象，设置listbox的选择模式 2. 调用listbox的insert(self,index,*elements)添加选项 Tkinter Spinbox 控件 通过两个小箭头调整该组件内的值 Tkinter Scale 和 LabeledScale用法 代表一个滑动条，为滑动设置最大最小值 Scale 组件选项： from ： 最大值 to ： 最小值 resolution ： 滑动时的步长 lable ： 设置标签内容 length ： 设置轨道的长度 width ： 轨道的宽度 troughcolor ： 背景色 sliderlength ： 长度 sliderrelief ： 立体样式 showvalue ： 是否显示当前值 orient ： 设置方向 digits ： 设置有效数字位数 variable ： 与变量进行绑定 command ： 为该Scale 组件绑定事件处理，函数或方法 Tinkter LabelFrame 用法 是Frame容器改进版，为容器添加标签，可为普通文字标签，也可为GUI组件为标签 对标签进行定制： 1. labelwidget ： 将任意GUI组件作为标签 2. labelanchor ： 设置标签位置Tkinter Panedwindow 控件 管理窗口布局的容器，允许添加多个子组件，并为每个子组件划分一个区域，可用鼠标移动分隔线改变各子组件的大小 操作Panedwindow 容器中子组件的方法： 1. add(self,child,**kw) : 添加一个子组件 2. insert(self,pos,child,**kw) : 在pos 位置插入一个子组件 3. remove(self,child) ： 删除一个子组件，所在区域也删除 Tkinter OptionMenu控件 构建带菜单的按钮，可在按钮的四个方向上展开，通过direction选项控制 __init__(self,master,variable ,value,*values, **kwargs) 1. variable ； 指定该按钮上的菜单与哪个变量绑定 2. Value ： 默认选择菜单中的哪一项 3. values ： 将收集为此参数传入的多个值，为每个值创建一个菜单项 4. kwargs ： 为 OptinoMenu配置选项 Tkinter 对话框创建及使用 1. 对话框依赖类似于顶级窗口，创建时需指定master属性 2. 对话框有非模式noo-modal和模式modal，某个模块对话框被打开，位于它依赖的窗口之上。 Tkinter 在 simpledialog 和dialog 模式下分别提供了 SimpleDialog 类和 Dialog 类，可作为普通对话框使用 使用simpledialog 和dialog 创建对话框可指定： 1. title： 标题 2. text ：内容 3. button： 按钮 4. default：默认第几个按钮得到焦点 5. cancel： 指定对话框上角的X按钮关闭对话框 Tkinter 自定义对话框 自定义通过继承Toplevel 实现： 1. 继承Toplevel 实现自定义对话框需要为对话框指定 master 2. 调用Toplevel 的grab_set 方法 把对话框变为模式对话框，否则为非模式对话框Tkinter 输入对话框工具函数： 1. askinteger ； 生成一个让用户输入正数的对话框 2. askfloat ： 输入浮点数的对话框 3. askstring ： 输入字符串的对话框Tkinter 文件对话框创建和使用 直接返回用户选择文件的输入/输出流： 1. askiopenfile ： 打开单个文件的对话框 2. askopenfiles ： 打开多个文件的对话框 3. askopenfilename ： 打开单个文件的对话框，返回选择文件的文件路径 4. askopenfilenames ： 多个文件的对话框 5. asksavesfile ： 生成保存文件的对话框 6. asksaveasfilename ： 保存文件的对话框，返回所选择文件的文件路径 7. askdirectory ： 生成打开目录的对话框 生成打开文件的对话框工具函数： 1. defaulttextension ： 指定默认扩展名 2. filetypes ： 查看的文件类型 3. initaldir ： 初始化打开的目录 4. parent ： 指定该对话框的属主窗口 5. title ： 对话框的标题 6. multiple ： 允许多选 Tkinter askcolor 颜色选择对话框 函数选项： 1. parent ： 属主窗口 2. title ： 标题 3. color ： 颜色Tkinter 消息框 选项按钮 1. icon ： 定制图标 2. type ： 定制按钮的选项 showinfo 函数： 默认生成的消息框的图标是感叹号 Tkinter Menu 菜单 窗口菜单和右键菜单 添加菜单项的方法： 1. add_command() : 添加菜单项 2. add_checbutton(): 复选框 3. add_radiobutton(): 单选按钮 4. add_separator() : 菜单分隔条 添加菜单的三个方法选项： 1. label ： 指定菜单项的文本 2. command ： 指定绑定的事件处理方法 3. image ： 指定菜单项的图标 4. compound ： 图标位于文字的哪个方位 Menu窗口菜单： 创建菜单后，将菜单设为窗口的menu选项即可 add_command 为file_menu 添加多个菜单项 add_cascade 再次为file_menu添加子菜单 add_radiobutton 添加多个单选菜单项 Menu 右键菜单： 先创建菜单，为目标组件的右键菜单绑定处理函数, 点击右键，调用菜单post 方法即可Tkinter Canvas 画布完全攻略 绘制直线、矩形、椭圆等图形，提供create_rectangle 方法绘制和 create_oval 绘制椭圆，绘制方法： create_arc ： 绘制弧 create_bitmap ： 位图 create_image ： 图片 create_polygon ： 多边形 create_line ： 直线 create_text ： 文本 creat_window ： 绘制组件 绘制指定的选项： fill ： 填充颜色 outline ： 边框颜色 width ： 边框宽度 dash ： 边框虚线 stipple ： 位图平铺填充 start ： 开始角度 extend ： 绘制弧的角度 style ： 绘制弧样式 arrow ： 是否有箭头 arrowshape ： 箭头样式 joinstyle ： 连接点的风格 anchor ： 绘制文字 justify ： 文本对齐方式 Tkinter Canvas tag_bind ：指定图形项绑定事件处理函数或方法 tag_bind 方法： 用于为指定图形项绑定事件处理函数或方法，可用于响应用户动作 Tkinter Canvas 绘制动画 小球转动； 循环显示多张转动的小球图片 小球移动： 改变小球的坐标程序文件操作I/O文件基本操作常见操作： 创建、删除、修改权限、读取、写入等 1. 删除、修改权限：作用于文件本身，属于系统级操作 2. 写入、读取： 文件常用操作，作用于文本的内容，属于应用级操作 文件操作实现函数： 1. 打开文件： open 函数，返回文本对象 2. 对已打开的文件做读/写操作，读写，使用 read 、readline readlines 函数，写入：write 函数 3. 关闭文件： close open 函数：打开指定文件如要操作文件，需创建或者打开指定的文件，并创建一个文件对象，内置的 open 函数 file = open(file_name [, mode [, buffering]]) file: 表示要创建的文件对象 file_mode ： 要创建或打开文件的文件名称，需用引号扩起来，注意路径 mode ： 可选参数；指定文件的打开模式，如不写，默认只读r buffing ： 指定对文件做读写操作，是否使用缓存区open 函数文件打开模式： r ： 只读，指针在开头 rb ： 二进制格式，只读模式，指针位于开头，用于打开非文本文件，如图片 r+ ： 从头读取文件内容，从开头写入新的内容，新内容覆盖原有内容 rb+ ： 二进制格式读写模式打开，针对非文本文件，如音频文件 w ： 只读，清空文件原有内容 wb ：二进制格式、只读模式，音频文件 w+ ： 读写， 清空原有内容 wb+ ： 二进制格式、读写模式，非文本 a ：追加模式，只写权限，如文件不存在，则创建新文件 a+ ： 读写，指针位于末尾，如不存在，则新建 ab+ ： 二进制模式，追加模式，读写权限 [读写操作](http://c.biancheng.net/uploads/allimg/190228/2-1Z22QI61c59.gif) open 打开文件时，默认GBK编码，指定打开文件的编码格式； file = open(&apos;xx.txt&apos;,encoding=&quot;utf-8&quot;)open()是否需要缓冲区 一般建议打开缓冲，open函数，第三个参数是0或False，是不带缓冲的，若是1或True，则带缓冲 open 文件对象常用属性： file.closed ： 判断是否关闭 file.mode ： 返回访问模式 file.name ： 返回文件名 以文件格式和二进制格式打开文件的区别： 相同点： 都是以二进制格式打开文件 不同点： 对文件中换行符的处理不同 Win： \r\n 转换为 \n Unix/Linux ： 默认换行符是 \n 推荐使用 b 打开二进制文件read 函数： 按字节、字符读取文件 read 读取文件是字节、字符的区别： 取决于open函数打开文件时，是否使用 b 模式，如使用 b ，读取的是 字节， 如不是 b ，则是 字符 file.read([size]) read 抛出UnicodeDecodeErorr 异常的解决方案： 文本的额字符集和操作系统的字符集不匹配，解决方案： 1. 使用二进制模式读取， 然后用bytes 的decode 方法恢复为字符串 2. 采用 codecs 模块的open函数打开文件时指定字符集 readline 和 readlines ： 按行读取文件 readline ： 读取一行内容 。 readlines ： 读取文件内的所有行 readline ： file.readline([size]) file 为打开的文件对象， size 可选参数，指定读取每一行，一次最多读取的字符数，模式使用 r 或 r+ 读写 readlines ： file.readlines() : file 为文件打开对象， 模式使用r 或 r+ write 和 writelines ： 向文件中写入数据 file.write(string) :向文件中写入指定内容。 file。write(string) writefiles() 函数： 将字符串列表写入文件中。 向文件中写入多行数据时，不自动给各行添加换行符close ： 关闭文件 flie.close() 关闭使用open函数打开的文件 如不在关闭文件的前提下将数据写入到文件中，使用文件对象提供的flush 函数 seek 和 tell 函数 tell ：判断文件指针当前所处的位置 seek ：用于移动文件指针到文件的指定位置 file.tell() file.seek(offset[, whence]) file : 文件对象 whence ： 指定文件指针要放置的位置，0 开头，1当前位置，2文件尾 offset ： 相对于whence位置文件指针的偏移量with as 用法使用with as 语句操作上下文管理器 context manager，自动分配并且释放资源 with 表达式 [as target]: 代码块 即使没有关闭文件，修改文件内容的操作也能成功上下文管理器， python with as 底层原理 包含 __enter__() 和 __exit__() 方法的对象是上下文管理器，上下文管理器必须实现一下两个方法： 1. __enter__(self): 进入上下文管理器自动调用的方法，会在with as 执行前执行，返回值被赋值给 as 子句后的变量，可返回多个值，在as子句后可指定多个变量，必须用 () 括起来 2. __exit__(self,exc_typ`e,exc_value,exc_traceback ) ： 退出上下文管理器自动调用的方法，在with as 代码执行后执行，如with as 因异常终止，程序自动调用该方法，使用 sys.exc_info 得到的异常信息将作为调用该方法的参数 构建上下文管理器，实现的2种方式： 1. 基于类的上下文管理器 只要类实现 __enter__() __exit__ 这两个方法，就可使用with as来管理， 通过 __exit__ 方法的参数，可判断with 代码块执行是否遇到了异常， 2. 基于生成器的上下文管理器 使用基于生成器的上下文管理器时，不需要定义 __enter__() 和 __exit__()方法，但必须添加 装饰器 @contextmanager 基于类的上下文管理器灵活，适用于大型的系统开发 基于生成器的上下文管理器更方便、简洁、适用于小型程序 切记： 用__exit__() 或是 finally 块中释放资源 fileinput模块：逐行读取多个文件 把多个输入流合并在一起 fileinput.input (files = &quot;filename1,filenamex,...&quot;,inplace=False,backup=&quot;,bufsize=0,mode=&apos;r&apos;,openhook=None&quot;) files ：多个文件的路径列表 inplace ： 指定是否将标准输出的结果写回到文件，默认值为 False backup ： 指定备份文件的扩展名 bufsize ： 指定缓存区的大小，默认0 mode ： 打开文件的格式，默认 r openhook ： 控制文件的打开方式，如编码格式 fileinput 模块常用函数 fileinput.filename() ：返回读取文件的文件名 fileinput.fileno() ：返回文件描述 fileinput.lineno() ：返回读取的行号 fileinput.filelineno() ：返回读取的行在文件中的行号 fileinput.isfirstline() ： 读取的行在文件中是否为第一行 fileinput.isstdin() ： 是否从sys.stdin 读取 fileinput.nextfile() ： 关闭当前文件，开始读取下一个文件 fileinput.close() ： 关闭fileinput对象 linecache模块：随机读取文件指定行 从源文件随机读取指定行，并在内部使用缓存优化存储，会使用utf-8字符集 常用函数： linecache.getline(filename,lineno,module_globals=None)：读取指定模块中指定文件的指定行，filename指定文件名，lineno指定行号 linecache,clearcache() ：清空缓存 linecache.checkcache(filename=None) ：检查缓存是否有效，如没有指定文件名filename参数，默认检查所有缓存的数据 pathlib模块 提供了一组面向对象的类，代表各种操作系统上的路径 PuraPath 的两个子类： PurePosixPath:Unix风格的路径 PureWindowsPath：Windows风格的路径 PurePath ：使用此函数或他的子类来创建PurePath对象，创建时，可闯入单个路径字符串，也可传入多个路径字符串 PurePath类的属性和方法： 操作路径字符串，[](http://c.biancheng.net/view/2541.html) Path类功能和用法： Path 是PurePath的子类，可访问底层的文件系统，判断Path对应的路径是否存在，可对文件进行读写 os.path 模块函数 操作目录的方法，可操作系统的目录本身，如 exists():判断目录是否存在, getctime()：创建时间 getmtime()：修改时间 getatime()：访问时间 getsize()：文件大小 fnmatch模块：文件名的匹配 匹配支持的通配符： * ： 匹配任意个任意字符 ? ： 匹配一个任意字符 [字符序列] ：匹配中括号里字符序列中的任意字符， [!字符序列] ： 匹配不在中括号里字符序列中的任意字符 fnmatch.fnmatch(filename,pattern)：判断指定文件名是否匹配指定pattern fnmatch.fnmatchcase(filename,pattern)：匹配时不区分大小写 fnmatch.filter(names,pattern) ：对names列表进行过滤，返回names列表中匹配pattern的文件名组成的子集合。 fnmatch.translate(patteran)：将Unix shell风格的pattern转换为正则表达式pattern os模块： os模块与目录相关的函数： os.getcwd()：获取当前目录 os.chdir(path) ： 改变当前目录 os.fchdir(fd) ：通过文件描述改变当前目录 os.chroot(path)：改变当前进程的根目录 os.listdir(path)：返回paht对应目录下的所有文件和子目录 os.mkdir(path[,mode])：创建path对应的目录，mode指定目录的权限 os.makedirs(path[,mode])：类似mkdir ，可递归创建目录， os.rmdir(path)：删除path对应的空目录，如非空抛出 OSError异常，可先用os.remove()删除文件 os.removedirs(path) ：递归删除目录，类似rmdir os.rename(src,dst)：重命名文件或目录，将src命名为dst os.renames(old,new) ：对文件或目录进行递归重命名，类rename， os模块与权限相关的函数 os.access(path,mode)：检查path对应的文件或目录是否具有指定权限，第二参数的四个状态 os.F_OK ： 判断是否存在 os.R_OK ： 是否可读 os.W_OK ： 是否可写 os.X_OK ： 是否可执行 os.chrnod(path,mode) :更改权限， stat.S_IXOTH ：其他用户有执行权限 [更多](http://c.biancheng.net/view/2558.html) os.chown(path,uid,gid) ：更改文件的所有值，uid代表用户id，gid代表组id os.fchmod(fd,mode) ：改变一个文件的访问权限，fd代表文件 os.fchown(fd,uid,gid) ：改变文件的所有者&apos;&apos; os模块与文件访问函数 os.open(file,flags[,mode]) ：打开一个文件，设置打开选项，flags表示打开文件的旗标 ，支持多个选项 os.O_RDONLY ： 只读方式打开 os.O_WRONLY ： 只写方式 os.O_RDWR ： 读写方式 os.O_NONBLOCK ： 打开时不阻塞 os.O_APPEND ： 追加方式打开 os.O_CREAT ；创建并打开一个新文件 [更多](http://c.biancheng.net/view/2558.html) os.read(fd,n) ：从文件描述符fd中读取最多n个字符，返回读到的字符串 os.wirte(fd,str) ：将字符串写入文件描述符fd，返回写入的字符串长度 os.close(fd) : 关闭文件描述符fd os.lseek(fd,pos,how) ： 用于移动文件指针，how指定从哪里开始移动， os.fdopen(fd[,mode[,bufsize]]) ：通过fd打开，返回文件对象 os.closerange(fd_low,fd_high) : 关闭从fd_low 包含 到 fd_high 不包含范围的所有文件描述符 os.dup(fd) ： 复制文件描述符 os.dup2(fd,fd2) ： 讲一个fd 复制到另一个文件描述符 fd2中 os.ftruncate(fd,length) ： 将fd对应的文件截断到length长度，length参数不超文件大小 os.remove(path) ：删除path对应的文件 os.link(src,dst) ： 创建从src 到dst的硬连接 os.symlink(src,dst) ：创建从src到dst的符号链接 tempfile模块：生成临时文件和临时目录 常用函数： tempfile.TemporaryFile(mode=&apos;w+b&apos;,buffering=None,encoding=None,newline=None,suffix=None,prefix=None,dir=None) ：创建临时文件，返回类文件对象，支持I/O [More](http://c.biancheng.net/view/2560.html) tempfile.gettempdir() : 获取系统临时目录 创建临时文件的两种方式： 1. 手动创建临时文件，读写临时文件后需主动关闭，程序关闭时文件自动删除 2. 使用with语句创建临时文件，with语句自动关闭临时文件数据库编程数据库API(DB API)全局变量 3个全局变量： 1. apilevel ： 显示数据库模块的API版本号 2. threadsafety ： 指定数据库模块的线程安全等级，等级值为 0～3，3代表模块完全是线程安全的，1:部分安全 ，0： 完全不能共享该模块 3. paramstyle ： 指定SQL语句需要参数时，使用风格的参数，返回如下变量值： format ： 格式化字符串代表参数，使用 %s pyformat ： 使用扩展的格式代码代表参数 qmark ： 使用 ？ 问号代表参数 numeric ： 使用数字占位符 :N 代表参数，1 代表一个参数，2 也代表参数 named ： 使用命名占位符 :name 代表参数 数据库API的核心类 连接对象的方法和属性 cursor() ： 打开游标 commit() ： 提交事物 rollback()： 回滚事物 close() ： 关闭数据库连接 isolation_level: 返回或指定数据库连接中事物的隔离级别 in_transaction: 判断当前是否处于事物中 cursor ： 返回游标对象，游标对象是 Python DB API的核心对象，用于执行各种SQL语句，包括DDL、DML、select 查询语句等，使用游标执行不同的SQL语句返回不同的数据。 游标对象的属性和方法： execute(sql[,parameters]) ： 执行SQL语句，parameters 参数用于为SQL语句中的参数指定值 executemany(sql,seq_of_parameters) ：重复执行SQL语句，通过第二个参数指定值，序列有多少个元素，SQL语句被执行多少次 executescript(sql_script) ：直接执行包含多条SQL语句的SQL脚本 fetchone() : 获取查询结果集的下一行，如没有，则返回None fetchmany(size=cursor.arraysize) ：返回查询结果集的下N行组成的列表，如没有，返回空 fetchall() : 返回查询结果集的全部行组成的列表 close() : 关闭游标 rowcount ： 只读属性返回受SQL语句影响的行数，修改的记录条数也可通过该属性获取 lastrowid ：获取最后修改行的rowid arraysize ： 设置或获取fetchmany 默认获取的记录条数，默认为 1 desciption ： 获取最后一次查询返回所有列的信息，只读 connection ： 返回创建游标的数据库连接对象，属性只读 操作数据库的基本流程 1. 调用 connect 方法打开数据库连接，返回数据库连接对象 2. 通过数据库连接对象打开游标 3. 使用游标执行SQL语句 包括 DDL、DML、select查询语句，如执行的是查询语句，则处理查询数据 4. 关闭游标 5. 关闭数据库连接 [图示](http://c.biancheng.net/uploads/allimg/190301/2-1Z301153400E3.gif) SQLite 创建数据库表 是一种嵌入式数据库，数据库是一个文件，SQLite将整个数据库包括定义表、索引以及数据本身，作为一个单独的、可跨平台使用的文件存储在主机中。不需要安装。直接导入 连接数据库： connect() 函数 conn = sqlite3.connect(&apos;xx.db&apos;) // xx.db 是一个数据库,如不存在，在当前目录下创建对应的文件 创建数据库： import sqlite3 conn = sqlite3.connect(&apos;xx.db &apos;) c = conn.cursor() c.execute(&apos;&apos;&apos; create table user_tb( id interger primary key autoincrement, name text, pass text, gender text)&apos;&apos;&apos; ) c.execute(&apos;&apos;&apos; create table post_tb id integer primary key autoincrement, post_name text, post_author text, post_number real, user_id integer, foreign key(user_id) references user_tb(id)&apos;&apos;&apos;) c.close() conn.close() SQLite 支持 NULL、INTEGER、REAL浮点数、TEXT文本、BLOD大二进制对象 SQLite execute 和 executemany 游标的execute 方法可执行DML 操纵语言 的 insert 、update、delete 语句，对数据库执行插入、修改和删除数据操作 调用execute 方法执行insert 可向数据库插入数据 向数据库插入一条数据： // 导入访问SQLite的模块 import sqlite3 // 打开或创建数据库， 可用 :memory: 代表创建内存中的数据库 conn = sqlite3.connect(&apos;xx.db&apos;) // xx.db 指创建时指定的数据库文件 // 获取游标 c = conn.cursor() // 调用执行 insert 语句插入数据 c.execute(&apos;insert into user_tb values (null,?,?,?)&apos;, (&apos;xxx&apos;,&apos;xxx&apos;,&apos;xxx&apos;)) c.execute(&apos;insert into xxx_tb values (null,?,?,?)&apos; (&apos;xx&apos;,&apos;xx&apos;,&apos;xx&apos;)) // 提交事物 conn.commit() // 关闭游标 c.close() // 关闭连接 conn.close() executemany ： 多次执行同一条SQl语句 import sqlite3 conn = sqlite3.connect(&apos;xx.db&apos;) c = conn.cursor() c.executemany(&apos;inert into xxx_tb values (null,?,?,?)&apos;, ( (&apos;xx&apos;,&apos;xxx&apos;,&apos;xxxx&apos;), (&apos;aa&apos;,&apos;aaa&apos;,&apos;aaaa&apos;), (&apos;bb&apos;,&apos;bbb&apos;,&apos;bbbb&apos;), (&apos;zz&apos;,&apos;zzz&apos;,&apos;zzzz&apos;) )) conn.commit() c.close() conn.close() update | delete import sqlite3 conn = sqlite3.connect(&apos;xx.db&apos;) c = conn.cursor() c.execute(&apos; update user_tb set xxx=? where xx=? &apos;, ((&apos;aa&apos;,1), (&apos;bb&apos;,2) )) print(&apos;change numbers : &apos;, c.rowcount) conn.commit() c.close() conn.close() SQLite : fetchone() , fetchmany() and fetchall: select 语句执行查询结果， 通过游标的 fetchone 、fetchmany、fecthall获取查询结果，fetchone 获取一条，fetchmany 获取多条， fetchall 获取全部 import sqlite3 conn = sqlite3.connect(&apos;xx.db&apos;) c = conn.cursor() c.execute(&apos;select * from user_tb where xx &gt; ?&apos;,(2,)) print(&apos;result : &apos;, c.rowcount) for col in (c.description): print([col[0],end&apos;\t&apos;]) print(&apos;\n------&apos;) where True: row = c.fetchone() if not row: break print(row) print(row[1] + &apos; -&gt; &apos; + row[2]) c.close() conn.close() 可修改部分代码： while True: // 指定抓起的条数记录，返回由条数组成的列表 rows = c.fetchmany(3) // 判断rows是否为None if not row: break // 再次使用循环遍历获取的列表 for r in rows: print(r) 避免使用fetchall获取查询的全部记录，如数据量过大，会导致内存开销过大，导致系统崩溃！ SQLite： executescript 可执行一段SQL脚本 import sqlite3 conn = sqlite3.connect(&apos;xx.db&apos;) c = conn.cursor() c.executescript(&apos;&apos;&apos; insert into user_tb values (null,&apos;aaa&apos;,&apos;aaa&apos;,&apos;aaaa&apos;), insert into user_tb values (null,&apos;bbb&apos;,&apos;bbb&apos;,&apos;bbbb&apos;), create table item_tb (id integer primary key autoincrement, name, price) &apos;&apos;&apos;) conn.commit() c.close() conn.close() 简化： SQLite 提供了3个方法为数据库连接对象 1. execute(sql[,parameters]) : 执行一条SQL语句 2. executemany(sql[, parameters]) : 根据序列重复执行SQL语句 3. executescipt(sql_script) ： 执行SQL脚本 只是游标对象的3个方法的快捷方式 SQLite： create_function 方法： 注册自定义函数 create_function 方法包含的三个参数： 1. name ： 指定注册的自定义函数的名字 2. num_params ： 指定自定义函数所需参数的个数 3. func ： 指定自定义函数对应的函数 为SQL语句注册一个自定义函数，可在SQL语句中使用该自定义函数 import sqlite3 def reverse_ext(st): return &apos;[&apos; + st[::-1] + &apos;]&apos; conn = sqlite3.connect(&apos;xx.db&apos;) // xx.db 代表数据库文件 conn.create_function(&apos;enc&apos;,reverse_ext) c = conn.cursor() c.execute(&apos;insert into user_tb values(null,?,enc(&gt;),?)&apos; , (&apos;xx&apos;,&apos;xx&apos;,&apos;xxx&apos;)) conn.commit() c.close() conn.close() SQLite create_aggregate() : 自定以聚集函数 SQL提供的5个聚集函数： 1. sum() : 统计总和 2. avg() ：统计平均值 3. count() ： 统计记录条数 4. max() ： 统计最大数 5. min() ： 统计最小数 可使用数据库连接对象提供的 create_aggregate(name,num_params,aggregate_class)方法，用于注册一个自定义的聚集函数 create_aggregate 方法包含3个方法： 1. name ： 指定自定义聚集函数的名字 2. num_params ： 指定聚集函数所需的参数 3. aggregate_class ： 指定聚集函数的实现类，该类必须实现 step(self,pargams,..) 和 finalize(self) 方法，step方法返回每条记录各执行一次，finalize 方法只在最后执行一次，返回值作为聚集函数最后的返回值 SQLite： create_collation ： 创建自定义比较函数 create_collation(name, callable) 注册一个自定义的比较函数 2个参数： 1. name ： 指定自定义比较函数的名字 2. callable ： 指定自定义比较函数对应的函数，包含两参数，对两个参数进行比较，如返回正整数，第一个参数更大，如是负整数，第二个参数更大，如返回0，则相等 import sqlite3 def my_collate(str1,str2): if st1[1:-1] == str2[1:-1]: return 0; elif ... conn = sqlite3.connect(&apos;xx.db&apos;) conn.creat_collation(&apos;sub_cmp&apos;,my_callate) c = conn.cursor() c.execute(&apos;seleft * from xxx_tb where field = ?&apos;, (1)) for row in c: print(row) conn.commit() c.close conn.close() MySQL 数据库 查看已安装的模块： pip list pip show packagename pip show mysql-connector-python 卸载已安装的模块： pip uninstall packagename 安装模块： pip install packagename pip install mysql-connector-python pip install packagename == 1.0 // 可指定版本 MySQL 数据库执行DDL 语句 import mysql.connector conn = mysql.connector.connect(user=&apos;root&apos;,password=&apos;root&apos;, host=&apos;127.0.0.1|localhost&apos;,post=&apos;3306&apos;, database=&apos;python&apos;,use_unicode=True) c = conn.cursor() c.execute(&apos;&apos;&apos; create table user_tb ( user_id int primary key auto_increment, name varchar(100), pass varchar(200), gender varchar(100) )&apos;&apos;&apos;) c.execute(&apos;&apos;&apos; create table order_tb ( order_id int primary key auto_increment, item_name varchar(100), item_price double, item_number double, user_id int, foreign key(user_id) reference user_tb(user_id) )&apos;&apos;&apos;) c.close() conn.close() MySQL 数据库执行DML 语句 可使用游标的execute 方法执行DML的 insert 、upadte、delete import mysql-connector conn = mysql-connector.connect(user=&apos;root&apos;,password=&apos;hale&apos;,host=&apos;localhost&apos;,port=&apos;3306&apos;,database=&apos;python&apos;,use_unicode=True) c = conn.cursor() c.execute(&apos;insert into user_tb values(null, %s,%s,$s)&apos;,(&apos;aa&apos;,&apos;aaa&apos;,&apos;aaaa&apos;)) c.executemany(&apos;insert into order_tb values (null,%s ,%s,%s,%s)&apos;, ((&apos;a&apos;,&apos;aa&apos;,&apos;aaa&apos;),(&apos;b&apos;,&apos;bb&apos;,&apos;bbb&apos;),(&apos;c&apos;,&apos;cc&apos;,&apos;ccc&apos;))) conn.commit() c.close() conn.close() 使用 %s 作为占位符 update c.executemany(&apos;update user_tb set name=%s where user_id = %s &apos;, ((&apos;e&apos;,&apos;ee&apos;,&apos;eee&apos;),(&apos;w&apos;,&apos;ww&apos;,&apos;www&apos;))) print(&apos;change : &apos;, c.rowcount) conn.comm mysql数据库模块连接对象有一个 autocommit ，如属性设置为True ，则关闭连接的事物支持，每次执行DML语句后会自动提交，无需调用 commit 方法提交事物 import mysql.connector conn = mysql.connector.connect(user=&apos;root&apos;,password=&apos;hale&apos;,host=&apos;localhost&apos;,port=&apos;3306&apos;,database=&apos;python&apos;,use_unicode=True) conn.autocommit = True MySQL 数据库执行查询语句 import mysql.connector conn = mysql.connector.connect(user=&apos;root&apos;,password=&apos;hale&apos;,host=&apos;localhost&apos;,port=&apos;3306&apos;,database=&apos;python&apos;,use_unicode=True) c = conn.cursor() c.execute(&apos;selecet * from user_tb where user_id &gt; %s&apos;, (1,)) for col in (c.description): print(col[0],end=&apos;\t&apos;) print(&apos;\n -------&apos;) for row in c: print(row) print(row[1] + &apos; -&gt; &apos; + row[2]) c.close() conn.close() 游标对象支持 fetchone() fetchmany() fetchall() c.execute(&apos;select * from ueer_tb where user_id &gt; %s&apos;,(1,)) where True: rows = c.fetchmany(3) if not rows: break for r in rows: print(r) MySQl callproc : 调用数据库存储过程 callproc(self,procname,args=0) procname : 代表存储过程的名字， args 参数用于存储过程传入参数 result_args = c.callproc(&apos;add_pro&apos;,2,1,0) PyMySQl模块下载和安装 类Connector/Python、PyMySQL ，称为接口程序，通过此对象，可对另外一个对象操作 安装PyMySQL模块： pip install PyMySQL import pymysql import pymysql conn = pymysql.connect(host=&apos;localhost&apos;,root=&apos;root&apos;,password=&apos;pass&apos;,db=&apos;python&apos;,charset=&apos;utf8mb4&apos;) c = conn.cursor() c.execute(&apos;select Version()&apos;) while True: rows = c.fetchmany(3): if not rows: break for i in rows: print(i) c.close() conn.close() 创建数据库： import pymysql conn = pymysql.connect(&apos;localhost&apos;,&apos;root&apos;,&apos;root&apos;,&apos;python&apos;) cursor = conn.cursor() cursor.execute(&apos;Drop table if exists tb_name&apos;) sql = &apos;&apos;&apos; create table user_tb ( user_id int primary key auto_increment, name varchar(100), email varchar(10), pass varchar(100) )&apos;&apos;&apos; cursor.execute(sql) cursor.close() conn.close() 数据库插入操作 import pymysql conn = pymysql.connect(&apos;localhost&apos;,&apos;root&apos;,&apos;root&apos;,&apos;py_db&apos;) cursor = conn.cursor() sql = &apos;&apos;&apos; insert into user_tb (name,pass) values (&apos;%s&apos;,&apos;%s&apos;) % (&apos;aa&apos;,&apos;aa&apos;)&apos;&apos;&apos; try: cursor.execute(sql) conn.commit() except: conn.rollback() conn.close()并发编程(多进程、多线程)进程和线程 区别进程： 操作系统资源分配的基本单位，通常是一个程序 线程： 任务调度和执行的基本单位，是进程的组成部分 可运行多个进程(程序)，同一进程可多个线程同时执行(通过CPU调度，每个时间片中只有一个线程执行 内存方面：进程分配不同的内存控件，线程不分配 开销方面： 进程有独立的代码和数据空间程序上下文，进程切换开销大，线程是轻量级的进程，同一类线程共享代码和数据空间，有独立的运行栈和计数器，线程切换开销小 单线程： 当一个进程中只有一个线程时 多线程： 当一个进程中有多个线程时 创建线程的两种方式：相关模块： 1. _thread ： 提供低级别的原始的线程支持，及简单的锁，功能有限，不建议使用 2. threading ： 提供丰富的多线程支持，推荐使用 创建方式： 1. 使用 threading 中的 Thread 类的构造器创建线程，直接对类 threding.Thread 进程实例化，并调用对象的 start 方法创建线程 2. 继承 threading 模块中的 Thread 类创建线程类，用 threading.Theread 派生出一个新的子类， 将新建类实例化，并调用 start 方法创建线程 调用Thread 类的构造器创建线程： 直接调用 threading.Thread 类构造器创建线程： __init__(self,gourp=None,target=None,name=None,args=(),kwargs=None,*,daemon=None) group: 指定该线程所属的线程组， target： 指定该线程要调度的目标方法 args ： 指定一个元组，以位置参数形式为target 指定的函数传入参数，元组的第一个参数传给target函数的第一个参数，第二个传给target第二个参数，以此类推 kwargs ：指定一个字典，以关键字参数的形式为target指定的函数传参 daemon ： 指定所构建的线程是否为后代线程 通过Thread 类的构造器创建并启动多线程的步骤： 1. 调用Thread类的构造器创建线程对象，创建时，target参数指定的函数将作为线程执行体 2. 调用线程对象的start() 方法启动该线程 import threading // 定义普通的action函数，作为线程执行体 def action(max): for i in range(max): print(threading.current_thred().getName() + &quot; &quot; + str(i)) // 主程序、祝线程的执行体 for i range(100): print(threading.current_thread().getName() + &quot; &quot; + str(i)) if i == 20: t1 = threading.Thread(target=action,args=(100,)) t1.start() t2 = threading.Thread(target=action,args=(100,)) t2.start() print(&apos;master thread is run over !&apos;) 1. 创建一个Thread对象，线程的target 为 action， 将action函数作为线程主体执行，接下来的程序调用start 来启动t1线程 2. 再次创建线程，创建和启动与第一个线程完全相同 显式创建并启动了两个线程，但实际上有三个，当程序运行后，至少创建一个主线程，主线程的线程执行代码就是程序中的主程序，没放在任何函数中的代码 用到的函数和方法： threading.current_thread(): 是threading 模块的函数，总是返回当前正在执行的线程对象 getName ：Thread类的实例方法，返回调用他的线程名字 在Threading模块中，经常用到的函数： threading.enumerate() : 正运行线程的list threading.activeCount ： 返回正在运行的线程数量，与 len(threading.enumerate()) 继承Thread类创建线程类 步骤： 1. 定义Thread 类的子类，并重写run方法，run方法方法体代表线程需要完成的任务，因此 run方法称为 线程执行体 2. 创建Thread 子类的实例，即创建线程对象 3. 调用线程对象的start 方法来启动线程 import threading class FKThread(threading.Thread): def __init__(self): threading.Thread.__init__(self) self.i = 0 def run(self): while self.i &lt; 100: print(threading.current_thread().getName() + &quot; &quot; + str(self.i)) self.i += 1 for i in range(100): print(threading.current_thread().getName() + &quot; &quot; + str(i) ) if i == 20: ft1 = FKThread() ft1.start() ft2 = FKThread() ft2.start() print(&apos;threading is ok !&apos;)Python 线程的生命周日(新建、就绪、运行、阻塞、死亡)线程的新建和就绪状态 [具体](http://c.biancheng.net/view/2606.html) 程序新建Thread对象或Thread子类的对象后，线程处于新建状态。 线程对象调用start 方法，会处于就绪状态，解释器会为其创建方法调用栈和程序计数器。启动线程用start 方法，不是run方法。 start 方法启动线程，系统把该run方法当成线程执行体处理。 import threading def action(max): for i in range(max): print(threading.current_thread().name + &quot; &quot; + str(i)) for i in range(100): print(threading.current_thread().name + &quot; &quot; + str(i)) if i == 20: threading.Thread(target=action,args=(100,)).run() threading.Thread(target=action,args=(100,)).run() 如果程序对同一线程重复调用start方法，会引发 RuntimeError警告 线程运行和阻塞状态 如处于就绪状态的线程获得了CPU，执行run方法的线程执行体，该线程处于运行状态 在一个具有多处理器的机器上，会有多个线程并行执行 Parallel。当线程数大于处理器时，依然存在多个线程在同一CPU上轮换 进入阻塞状态的情况： 1. 线程调用 sleep 方法主动放弃其所占用的处理器资源 2. 线程调用了一个阻塞式I/O方法，返回之前，线程被阻塞 3. 线程试图获取一个锁对象，但锁对象被其他线程持有 4. 线程在等待某个通知 Notify 解除阻塞，重新进入就绪状态的情况： 1. 调用sleep方法的线程经过了指定的时间 2. 线程调用的阻塞模式I/O方法已经返回 3. 线程成功获得了试图获取的锁对象 4. 线程等待某个通知时，其他线程发出通知Notify， 线程死亡 线程死亡的方式： 1. run方法或代表线程执行体的target 函数执行完成，线程正常结束 2. 线程抛出一个未捕获的Exception 或 Error 测试某个线程是否四万过的方法：调用线程对象的is_alive()方法，当线程处于就绪、运行、阻塞三种状态，方法返回True，当线程处于新建、死亡状态时，方法返回False import threading def action(max): for i in range(100): print(threading.current_thread().name + &quot; &quot; + str(i)) // 创建线程对象 sd = threading.Thread(target=action,args=(100,)) for i in range(300): print(threading.current_thread().name + &quot; &quot; + str(i)) if i == 20: sd.start() print(sd.is_alive()) // 试图启动死亡线程 if i &gt; 20 and not(sd.is_alive()): sd.start() Thread join() 用法 让一个线程等待另一个线程完成的join方法，当在某个程序执行流中调用其他线程的join方法，调用线程将被阻塞，直接被join方法加入额join线程执行完成 import threading def action(max): for i in range(max): print(threading.current_thread().name + &quot; &quot; + str(i)) threading.Thread(target=action,args=(100,),name=&quot;new threading&quot;).start() for i in range(100): if i == 20: jt = threading.Thread(target=action, args=(100,), name=&quot;join threading&quot;) jt.start() jt.join() print(threading.current_thread().name + &quot; &quot; + str(i)) Python守护线程及作用 后台线程Daemon Thread： 后台运行，任务时为其他线程提供服务。又称 &quot;精灵线程&quot;。 特征：所有前台死亡，后台会自动死亡 调用Thread对象的daemon属性可将指定线程设置为后台线程， import threading def action(max): for i in range(max): print(threading.current_thread().naem + &quot; &quot; + str(i)) t = threading.Thread(target=action, args=(100.), name=&quot;daemon threading&quot;) // 将此线程设置为后台线程 t.daemon = True t.start() for i in range(100): print(threading.currenct_thread().name + &quot; &quot; + str(i)) 创建线程的两种方法： 1. 主动将线程的daemon 属性设置为True 2. 后台线程启动的线程默认时后台线程 将daemon 属性设为True，必须在start方法调用之前进行，否则引发 RuntimeError异常 sleep 函数用法： 线程睡眠 如需让当前线程暂停一段时间，并进入阻塞状态，可调用 time 模块的 sleep(secs)函数实现，secs参数为指定线程阻塞多少秒 import time for i in range(10): print(&quot;now time : %s&quot; % time.ctime()) time.sleep(1) 互斥锁Lock: 解决多线程安全问题 多线程优势在于并发性，可同时运行多个任务， 互斥锁解决数据不同步问题 类银行取钱： 1. 用户输入账号、密码，系统判断用户输入信息是否匹配 2. 输入金额 3. 系统判断余额是否大于取款金额 4. 若大于，则成功，如小于，则失败 并发取款： class Account: def __init__(self,account_no,balance): self.account_no = account_no self.balanace = balance 取钱： import threading import time import Account def draw(account,draw_amount): if account.blance &gt;= draw_amount: print(threading.current_thread().name + &quot; get RMB successful &quot; + str(draw_amount)) account.balance -= draw_amount print(&apos;yu e &apos; + str(accnout.balance)) else: print(threading.current_thread().name + &apos;get RMB error &apos;) user = Account.Account(&apos;12345&apos;,1000) threading.Thread(name=&apos;A&apos;,target=draw, args=(user,100)).start() threading.Thread(name=&apos;B&apos;,target=draw, args=(user,200)).start() [LOCK](http://c.biancheng.net/view/5107.html) 互斥锁同步线程 python的threading模块引入互斥锁，解决run方法体不具有线程安全性，threading模块提供了lock和Rlock两个类，提供了两个方法来加互斥锁和释放互斥锁： 1. acquire(blocking=True, timeout=-1):请求对lock或Rlock加锁，timeout参数指定加锁的秒数 2. release() : 释放锁 lock 和 Rlock 的区别： threading.lock: 一个基本的锁对象，每次只能锁一次，其余的锁请求，徐等待锁释放后才能获取 threading.Rlock: 代表可重入锁，同一线程可多次锁定，也可多次释放，如使用Rlock，acquire和release 方法必须成对出现 class X: def m(): self.lock.acquire() try: paxx finally: self.lock.release() 线程安全的类具有的特征： 1. 该类的对象可被多个线程安全地访问 2. 每个线程在调用该对象的任意方法后，可得到正确的结果 3. 每个线程在调用该对象的任意方法后，该对象依然保持合理的状态 减少线程安全带来的负面影响的策略： 1. 不对线程安全类的所有方法进行同步，只对改变竞争资源方法进行同步 2. 在单线程环境中使用线程不安全版本保证性能，在多线程环境中使用线程安全版本 死锁： 如何避免死锁 当两个线程相互等待对方释放同步监视器时会发生死锁，在进行多线程编程时采取措施避免死锁 [死锁](http://c.biancheng.net/view/2620.html) 避免死锁的方式： 1. 避免多次锁定，避免同一个线程对多个Lock进行锁定 2. 具有相同的加锁顺序 3. 使用定时锁 4. 死锁检测 Python condition实现线程通信 线程调度具有一定的透明性，程序无法准确控制线程的轮换执行。如有需要，可通过线程通信保证线程协调运行， Condition对象保持协调。Condition可让那些已经得到lock对象却无法继续执行的线程释放Lock对象，Condition可唤醒其他处于等待状态的线程 Condition类提供的方法： 1. acquire([timeout])/release(): 调用Condition 关联的lock的acquire或release 方法 2. wait([timeout]) : 导致当前进程进入Condition的等待池等待通知并释放锁，知道其他调用该Condition的Notify或notify_all() 方法来唤醒该线程 3. notify() : 唤醒在该Condition 等待池中的单个线程并通知它，收到通知自动调用acquire 方法尝试加锁。 4. notify_all() : 唤醒在该Condition 等待吃中等待的所有线程并通知他们 [More](http://c.biancheng.net/view/2622.html) Queure 队列实现线程通信 queue模块提供阻塞队列，用于实现线程通信。主要提供三个类： 主要区别在于进队列、出队列的不同 1. queue.Queue(maxsize=0): 代表FIFO 先进先出的常规队列，maxsize 可限制队列的大小。 如maxsize为0 或负数，表示该队列的大小无限制 2. queue.LifoQueue(maxsize=0): 代表LIFO 后进先出，与Queue区别是出队列的顺序不同 3. PriorityQueue(maxsize=0): 代表优先级队列， 优先级最小的元素先出队列 三个队列类的属性和方法提供的属性和方法： Queue.qsize(): 返回队列的实际大小，即该队列中包含的元素个数 Queue.empty(): 判断是否为空 Queue.full() : 判断队列是否已满 Queue.put(item,block=True,timeout=None): 向队列中放入元素，如已满，且block参数为True阻塞，timeout指定阻塞时间，如timeout为None，则代表一直阻塞， Queue.put_nowait(item): 向队列中放入元素，不阻塞。 Queue.get(item,block=True,timeout=None):从队列中取出元素，如队列已满，则block参数为True阻塞。 Queue.get_nowait(item): 从队列中取出元素，不阻塞 普通的Queue的功能和用法： import queue bq = queue.Queue(3) bq.put(&apos;Python&apos;) bq.put(&apos;PHP&apos;) print(&apos;123213&apos;) bq.put(&apos;Queue&apos;) print(&apos;2222&apos;) 利用Queue实现线程通信 import threading import time import queue def product(qu): str_tuple = (&apos;python&apos;,&apos;golang&apos;,&apos;php &apos;) for i in range(9999): print(threading.current_thread().name + &quot; Product Env&quot;) time.sleep(0.2) qu.put(str_tuple[i % 3]) print(threading.current_thread().name + &apos;product ok&apos;) def consume(qu): while True: print(threading.current_thread().name + &apos;take money&apos; ) time.sleep(0.2) t = qu.get() print(threading.current_thread().name + &apos;take ok %s &apos;% t) qu = queue.Queue(maxsize = 1) threading.Thread(target=product,args=(qu,)).start() threading.Thread(target=product,args=(qu,)).start() threading.Thread(target=product,args=(qu,)).start() threading.Thread(target=consume,args=(qu,)).start() Event 实现线程通信 间的线程通信机制，一个线程发出一个Evnet，另一个线程可通信该Evnet 被触发 Event 是一个内部旗标，可通过Event 的set方法将旗标设置为True，可调用clear方法将旗标设置为False，可调用wait 方法来阻塞当前进程。 Event方法： 1. is_set(): 返回Event 的内部旗标是否为True 2. set() : 把Event的内部旗标设置为True，并唤醒所有处于等待状态的进程 3. clear() : 将Event的内部旗标设置为False，调用wait方法阻塞当前进程 4. wait(timeout=None): 阻塞当前进程 import threading import time event = threading.Event() def cal(name): print(&apos;%s start &apos; % threading.currentThread().getName()) print(&apos;%s status&apos; % name) event.wait() print(&apos;%s get message&apos; % threading.currentThread().getName()) print(&apos;%s is status&apos; % name) threading.Thread(target=cal,args=(&apos;Ai&apos;,)).start() threading.Thread(target=cal,args=(&apos;Bi&apos;,)).start() time.sleep(3) print(&apos;=====&apos;) print(&apos;master thread event&apos;) event.set() [More](http://c.biancheng.net/view/2626.html) 线程池及其原理和使用 当启动新线程的时，使用线程池可提升性能 。线程池在系统启动时即创建大量空闲的线程。 线程池的使用： 基类是concurrent.futures模块中的Executor。提供两个子类，即 ThreadPoolExecutor 和 ProcessPoolExecutor。 ThreadPollExecutor 用于创建线程池，ProcessPoolExecutor创建进程池 Executor提供的常用方法： submit(fn,args,**kwargs): 将fn函数提交给线程池， *args 代表传给fn函数的参数，*kwargs 代表以关键字参数的形式给fn函数传入参数 map(func,*iterables,timeout=None,chunksize=1):类全局函数 map(func,*iterables)，该函数加你个启动多个线程，以异步方式立即对iterables执行map处理 shotdown(wait=True): 关闭线程池 submit方法返回Future对象，Future 提供的方法 cancel()：取消该Future代表的线程任务，如任务正在执行，不可取消，返回False cancelled ：返回线程任务是否被成功取消 running ： 如正在执行，不可取消，返回False done ；如任务被成功取消，返回True result(timeout=None) : 获取线程返回的结果，如任务还未完成，该方法会阻塞当前线程，timeout指定组赛的秒数 exception(timeout=None):任务引发的异常，如任务成功完成，没异常，则返回None add_done_callback(fn):为该Future 的线程注册一个 回调函数，任务完成，自动出发fn函数。 使用线程池执行线程任务的步骤： 1. 调用ThreadPoolExecutor 类的构造器创建一个线程池 2. 定义一个普通函数作为线程任务 3. 调用ThreadPoolExecutor对象的submi方法来提交线程任务 4. 调用ThreadPoolExecutor对象的shutdown方法来关闭线程池 from concurrent.futures import ThreadPoolExecutor import threading import time def action(max): sum = 0 for i in range(max): print(threading.current_therad().name() + &apos; &apos; + str(i)) sum += i return sum pool = ThreadPoolExecutor(max_workers=2) future1 = pool.submit(action,50) future2 = pool.submit(action,100) print(future1.done()) time.sleep(3) print(future2.done()) print(future1.result()) pool.shutdown() 获取执行结果 1.调用result方法获取线程任务的返回值。 2.通过Future的add_done_callback()方法添加回调函数 线程池实现了上下文管理协议Context Manage Protocol，程序可用with语句来管理线程池，避免手动关闭线程池 map方法会为iterables的每个元素启动一个线程，以并发方式执行func函数，相当于启动len(iterables)个线程，并收集每个线程的执行结果。 threading local函数：返回线程局部变量 threding 提供local函数，可返回一个线程局部变量，使用线程局部变量可很简捷隔离多线程访问的竞争资源。 线程局部变量Thread local Variable，为每个使用该变量的线程提供一个变量的副本， 线程局部变量的作用： import threading from concurrent.futures import ThreadPoolExecutor data = threading.local() def action(max): for i in range(max): try: data.x += i except: data.x = i print(&quot; data %d&quot; % (threading.current_thread().name,data.x)) with ThreadPoolExecutor(max_workers=2) as pool: pool.submit(action,10) pool.submit(action,10) Timer 定时器：控制函数在特定时间执行 Thread类的子类Timer，可用于控制指定函数在特定时间内执行一次， from threading import Timer def hi(): print(&apos;hi&apos;) t = Timer(10.0, hi) t.start() 取消Timer的调度 cancel 函数 schedule 任务调度及用法 如需执行更复杂的任务调度，使用sched模块，提供了 sched.scheduler类，该类代表一个任务调度器 sched.scheduler(timefunc=time.monotonic,delayfunc=time.sleep) 构造器支持两个参数： 1. timefunc : 指定生成时间戳的时间函数，默认使用time.monotonic 生成时间戳 2. delayfunc; 指定阻塞程序的函数，默认使用 time.sleep 函数阻塞程序 [More](http://c.biancheng.net/view/2630.html) sched.scheduler 调度器常用属性和方法： scheduler.enterabs(time,priority,action,argument=(),kwargs={}): 指定time时间点执行action函数，argument 和 kwargs 用于向 action函数传入参数，arg...使用位置的形式传入参数。 kwargs 使用关键字传入参数 scheduler.enter(delay,priority,action, argument=(),kwargs={}): delay 指定多少秒后执行action任务。作用同上 scheduler.cancel(event): 取消任务 scheduler.empty(): 判断调度器队列是否为空 scheduler.run(blocking=True): 运行所有需要调度的任务 scheduler.queue： 只读属性返回该调度器的调度队列 import sched,time improt threading s = sched.scheduler() def print_time(name=&apos;default&apos;): print(&apos; %$ de time %s&apos; % (name,time.ctime())) print(&apos;master threading time&apos;, time.ctime()) s.enter(10,1,print_time) s.enter(3,2,print_time,argument=(&apos;wei zhi hanshu &apos;)) s.enter(5,2,print_time,kwargs=[&apos;name&apos;:&apos;guanjianzi hanshu &apos;]) s.run() print(&apos;master &apos;, time.ctime()) os.fork方法：创建新进程 多进程实现并发编程 fork 方法作用： 程序会启动两个进程(一个主进程，一个fork出来的子进程)来执行从os.fork() 开始的所有代码 fork方法不需要函数,有返回值表明哪个进程在执行: 1. 如果fork返回0， 表明fork出来的子进程在执行 2. 如fork返回非0， 表明父进程在执行，返回fork出来的子进程的进程ID import os print(&apos;master %s &apos; % os.getpid()) pid = os.fork() print(&apos;worker in %s &apos; % os.getpid()) if pid == 0: print(&apos;origin id %s master id %s&apos; % (os.getpid(),os.getppid())) else: print(&apos;me %s makr son id %s&apos; % (os.getpid(),pid)) print(&apos;thread over %s &apos; % os.getpid()) Process 创建进程的2种方法 1. 指定函数作为target ，创建Process对象即可创建新进程 2. 继承Process 类，重写run方法来创建进程类，创建process子类的实例作为进程 Process 类的属性和方法： 1. run() : 实现进程的执行体 2. start ： 启动进程 3. join([timeout]) ： 类线程的join方法 4. name ： 设置和访问进程的名字 5. is_alive ：判断进程是否活着 6. daemon ： 判断是否设置进程的后台状态 7. pid ： 返回进程的ID 8. authkey ：返回进程的授权key 9. terminate ： 中断该进程 以指定函数作为target 创建新进程 import multiprocessing import os def action(max): for i in range(max): print(&apos;%s subprocess paterprocess %s id %d &apos; % (os.getpid(),os.getppid(), i)) if __name__ == &apos;__main__&apos;: for i in range(100): print(&apos;parent %s id %d&apos; % (os.getpid(), i)) if i == 20: mp1 = multiprocessing.Process(target=action,args=(100,)) mp1.start() mp2 = multiprocessing.Process(target=action,args=(100,)) mp2.start() mp2.join() print(&apos;master process is ok&apos;) 继承Process 类 创建子进程 步骤： 1. 定义继承Process 的子类，重写run方法准备作为进程执行提 2. 创建Process 子类的实例 3. 调用 Process 子类的实例的start方法来启动进程 import multiprocessing import os class MyProcess(multiprocessing.Process): def __init__(self,max): self.max = max super().__init__() def run(self): for i in range(self.max): print(&apos;%s subprocess %s parent process %d &apos; % (os.getpid(),os.getppid(),i)) if __name__ == &apos;__main__&apos;: for i in range(100): print(&apos;%s master process %d &apos; % (os.getpid(),i)) if i == 20: mp1 = MyProcess(100) mp1.start() mp2 = MyProcess(100) mp2.start() mp2.join() print(&apos;master process is ok!&apos;) 设置进程启动的3种方式 1. spawn ：父进程启动解释器进程，子进程继承run方法所需的资源。不必要的文件描述和handler都不被继承，效率比fork或forkserver方式要低得多。 Windows 只支持spawn方式 2. fork： 通过os.fork 启动解释器， 子进程继承父进程所有资源，子进程等效于父进程 3. forkserver ： 启动一个服务器进程，当再次启动新进程，父进程会连接到该服务器进程。请求由服务器进程来fork新进程 multiprocessing 模块提供set_start_method 函数，用于设置启动进程的方式，必须将这行设置代码放在所有与多进程相关代码之前。 if __name__ == &apos;__main__&apos;: multiprocessing.set_start_method(&apos;spawn&apos;) q = multiprocessing.Queue() mp = multiprocessing.Process(target=foo,args=(q,)) mp.start() print(q.get()) mp.join() 多进程和多线程优缺点 都使用并行机制提升系统运行效率，区别在于运行时所占内存分布不同，多线程共用一套内存的代码块区间，而多进程是各用一套独立的内存区间 多进程有点在于 稳定性好，一个子进程奔溃，不影响主进程和其余进程，此特性多用多进程来实现守护服务器的功能 多进程创建进程的代价非常大，操作系统会给每个进程分配固定的资源，会对进程的总数有一点的限制。 多线程效率高 ，用于批处理任务等功能。 不足：一个线程奔溃整个进程奔溃。 场景： 计算密集型的任务，多线程效率更高。 IO密集型的任务，如文件操作，网络爬虫，采用多线程 IO密集型操作，消耗时间是等待时间，Python会释放GIL供新的线程使用，实现线程间的切换。 将多进程程序分布运行在不同的计算机上协同工作，每一进程内部，由多个线程并行工作 最佳线程数量 = ()(线程等待时间+线程CPU时间) / 线程CPU时间) * CPU数量 使用进程池管理进程 如需启动多个进程，可使用进程池管理进程，程序可通过multiprocess模块的pool函数创建进程池： multiprocessing.pool.Pool类 进程池常用方法： 1. apply(func[,args[,kwds]]) : 将func函数提交给进程池处理，args 传给func的位置参数， kwds代表传给func的关键字参数，会被阻塞直到func函数执行完成 2. apply_async(func[,args[,kwds[,callback[,error_callback]]]]): 异步，不被阻塞。callback指定func函数完成后的回调函数，error_callback 指定fun指定回调函数 3. map(func,iterable[,chunksize]) : 类python的map全局函数，使用新进程对iterable的每个元素执行func函数 4. imap(func,iterable[,chunksize]): map方法的延迟版本 5. imap_unordered(func,iterable[,chunksize]):类imap，不保证元素顺序一致 6. starmap(func,iterable[,chunksize]): 类map方法，要求iterable的元素是iterable对象， 7. close ： 关闭进程池，不再接收新任务，把进程池中的所有任务执行完后再关闭自己 8. terminate ： 立即中止进程池 9. join ： 等待所有进程完成 import multiprocessing import time import os def action(name=&apos;default&apos;): print(&apos;%s process param %s &apos; % (os.getpid(),name)) time.sleep(3) if __name__ == &apos;__main__&apos;: pool = multiprocessing.Pool(processes=4) pool.apply_async(action) pool.apply_async(actino,args=(&apos;location parame:&apos;,)) pool.apply_async(action,kwds={&apos;name&apos;:&apos;kwords params&apos;}) pool.join() 线程池同样实现上下文管理协议，可使用with子句来管理进程池，避免程序主动关闭进程池 import multiprocessing import time import os def action(max): sum = 0 for i in range(max): print(&apos;%s %d &apos; % (os.getpid(),i)) sum += i return sum if __name__ == &apos;__main__&apos;: with multiprocessing.Pool(processes=4) as pool: results = pool.map(action,(50,100,200)) print(&apos;---&apos;) for r in results: print(r) 进程间通信的2种实现方法 Queue Pipe 进程通信提供的2种机制： 1. Queue ： 一个进程向Queue中放入数据，另一个进程从Queue中读取数据 2. Pipe ： Pipe代表连接两个进程的管道，程序可调用Pipe函数时会产生两个连接段，分别交给两个进程，进程可从连接端读取数据，也可向该连接端写入数据 使用Queeu实现进程间通信 multiprocessing 模块下的Queue和queue 模块下的Queue类似，都提供qsize 、empyt、full、put、put_nowwait、get、get_nowait 等方法，区别： multiprecessing 模块下的Queue为进程提供服务， 而queue模块下的Queue为线程提供服务 import multiprecessing def f(q): print(&apos;%s &apos; % multiprocessing.current_process().pid) q.quit(&apos;Python&apos;) if __name__ == &apos;__main__&apos;: q = multiprocessing.Queue() p = multiprocessing.Process(target=f,args=(q,)) p.start() print(&apos;%s &apos; % multiprocessing.current_process().pid) print(q.get()) p.join 使用Pipe实现进程间通信 程序调用 multiprocessing.Pipe() 创建一个管道，返回两个PipeConnection对象，代表管道的两个连接端，一个管道有两个连接端，分别用于连接通信的两个进程 PipeConnection对象包含的常用方法： 1. send(obj) : 发送一个obj给管道的另一端，另一端使用 recv方法接收， 该obj需是可picklable的python序列化机制，如该对象序列化超过32MB，可引发ValueError异常 2. recv ：接收另一端通过send方法发送过来的数据 3. fileno：关于连接所使用的问价描述器 4. close ： 关闭连接 5. poll([timeout]):返回连接中是否有数据可读取 6. send_types(buffer[,offset[,size]]: 发送字节数据，使用recv_bytes 或 recv_bytes_into 方法接收 7. recv_bytes([maxlength])):通过send_bytes方法发送的数据，maxlength指定最多接收的字节数，返回接收到的字节数据 8. recv_bytes_into(buffer[,offset]): 类recv_bytes方法，将接收到的数据放在buffer中 import multiprocessing def f(conn): print(&apos;%s &apos; % multiprocessing.current_process().pid) conn.send(&apos;Python&apos;) if __name__ == &apos;__main__&apos;: parent_conn,child_conn = multiprocessing.Pipe() p = multiprocessing.Process(target=f, args=(child_conn,)) p.start() print(&apos;%s get data&apos; % multiprocessing.current_process().pid) print(parent_conn.recv()) p.join()网络编程计算机网路的功能： 1. 资源共享 2. 信息传输与集中处理 3. 均衡负荷与分布处理 4. 总和信息服务 常见的类型有： 局域网LAN、城域网MAN、广域网WAN。 通信协议：负责对传输速率、传输代码、代码结构、传输控制步骤、出错控制等指定处理标准。 通信协议由三部分组成： 1. 语义： 决定双方对话的类型 2. 语法： 决定双方对话的格式 3. 交换： 决定通信双方的应答关系 OSI ： Open System Interconnection ：将网络简化，以模块化的方式来设计网络 OSI七层： 物理层、链路层、网络层、传输层、会话层、表示层、应用层。 通信协议：是网络通信的基础，IP：Internet Protocol 称为 网际协议，支持网间互联的数据报协议，提供来网间连接的完善功能。TCP：Transmission Control Protocol，传输控制协议，规定一种可靠的数据信息传送服务，可单独使用，功能是互补的，两个协议统称为 TCP/IP 协议 IP地址和端口号 IP地址用于唯一标识网络中的一个通信实体。 IP地址是数字型，是一额32位整数 NIC：Internet Network Information Center ： 统一负责全球IP地址的规划和管理，分为 InterNIC、APNIC、RIPE 三个网络信息中心负责IP地址分配。亚太地区通过APNIC，总部设在日本东京大学 IP地址分为 A、B、C、D、E五类。每个类别的网络标识和主机标识各有规则： 1. A 类： 10.0.0.0 ～ 10.255.255.255 2. B 类： 172.16.0.0 ～ 172.31.255.255 3. C 类： 192.168.0.0 ～ 192.168.255.255 IP地址是一个通信实体，每个通信实体可有多个通信程序同时提供网络服务，还需提供使用端口 端口：是一个16位整数，用于将数据交给哪个通信程序处理。端口是应用程序与外界交流的出入口，是一种抽象的软件结构，包括数据结构和 I/O 缓冲区 端口分为三类： 1. 公认端口(Well Known Port): 端口号为 0～1023，绑定特定的服务 2. 注册端口(Registered Port): 端口号为 1024～49151 3. 动态和/或私有端口(Dynamic and / or Private Port): 端口号为 49152～65535，是应用程序使用的动态端口 网络编程模块 网络模型大致分为四层，各有对应的网络协议提供支持 1. 网络接口层： LAN、MAN、WAN 2. 网络层： ICMP、IGMP、IP、ARP、RARP 3. 传输层： TCP、UDP 4. 应用层： SMTP、FTP、DNS、SNMP、NFS、HTTP、TELNET 网络层协议主要是IP，是互联网协议的基础，ICMP、IGMP、ARP、RARP等协议是IP协议族的子协议，很少直接基于网络层进行应用程序编程 Python标准库中的网络相关模块 socket ： 基于传输层TCP、UDP协议进行网络编程的模块 asyncore ： socket 模块的异步版，支持基于传输层协议的异步通信 asynchat ： asyncore 的增强版 cgi ： 基于CGI：Common Gateway Interface，早期动态网站的技术支持 email ： E-mail 和MIME消息处理模块 ftplib ： 支持FTP协议的客户端模块 httplib、http.client ： 支持HTTP协议以及HTTP客户端的模块 imaplib ： 支持IMAP4协议的客户端模块 mailbox ： 操作不同格式邮箱的模块 mailcap ： 支持Mailcap文件 nntplib ： NTTP协议 smtplib ： SMTP 协议，发送邮件的客户端模块 poplib ： 支持POP3协议 telnetlib ： 支持TELNET 协议 urllib及其子模块： 支持URL处理的模块 xmlrpc、xmlrpc.server、xmlrpc.client ：支持XML-RPC协议的服务和客户端模块 urllib.parset 模块： URL：Uniform Resource Locator 对象代表统一资源定位器，指向互联网资源的指针。资源可以是文件、目录、或复杂对象的引用。 URL可由协议名、主机、端口和资源路径组成 protocol://host:port/path 1. urllib.request:最核心的子模块，包含打开和读取URL的各种函数 2. urllib.error ： 包含urllib.request 子模块所引发的各种异常 3. urllib.parset ： 解析URL 4. urllib.robotparset ： 解析robots.txt 文件 通过使用urllib模块可打开任意URl所指向的资源，可完整下载远程页面，与re模块结合使用，可提取页面中的各种信息，即网络爬虫的初步原理 urllib.parse 子模块中用于解析URL地址和查询字符串的函数： 1. urllib.parse.urlparset(urlstring,scheme=&quot;,allow_fragments=True&quot;):解析URL字符串，返回ParseResult 对象，获取解析出的数据 2. urllib.parse.urlunparse(parts): 是上一函数的反向操作，解析结果反向拼接URL地址 3. urllib,parse.parse_qs(qs,keep_blank_values=False,strict_parsing=False,encoding=&apos;utf-8&apos;,errors=&apos;replace&apos;):解析查询字符串(application/x-www-forn--=urlencoded 类型的数据)，以dict形式返回解析结果 4. urllib.parse.urlencode(query,deseq=False,safe=&apos;&apos;,encoding=None,errors=None,quote_via=quote_plus): 将字典形式或列表形式的请求参数恢复成请求字符串。相当与parse_qs、parse_qsl 的逆函数 5. urllin.parse.urljoin(base,url,allow_fragments=True): 将一个base_url和另一个资源URL连接成代表绝对地址的URl from urllib.parse import * result = urlparse(&apos;https://www.baidu.com&apos;) print(result) print(&apos;scheme:&apos;, result.scheme,result[0]) print(&apos;hostname and port:&apos;, result.netloc,result[1]) ... print(result.geturl()) ParseResult 各属性与元组索引的对应关系 scheme 0 返回URL的scheme scheme参数 netloc 1 网络位置部分主机名和端口 空字符串 path 2 资源路径 空字符串 params 3 资源路径的附加参数 query 4 查询字符串 fragment 5 Fragment标识符 username 用户名 None password 密码 hostname 主机名 port 端口 None urlunparse ： 把一个 ParseResult 对象或元组恢复成URL字符串 result = urlunparse((&apos;http&apos;,&apos;www.baidu.com:80&apos;,&apos;index.php&apos;,&apos;text&apos;,&apos;name=hale&apos;,frag)) print(result) parse_qs() parse_qsl() ： l代表list，用于解析查询字符串，返回值不同， urljoin 负责将两个URL拼接在一起，返回代表绝对值的URL，可出现三种情况： 1. URL只是一个相对路径path 2. 被拼接的URl是一个根路径path 3. URL是一个绝对的path urllib.requset 模块读取资源用法 urllib.request.urlopen(url,data=None)：用于打开url指定的资源，并从中读取数据，根据url的不同，返回值发生变化，如url是一个HTTP地址，该方法返回一个http.client.HTTPResponse对象 from urllib.request import * // 打开URL对应的资源 result = urlopen(&apos;http://www.baidu.com/index.php&apos;) // 按字节读取数据 data = result.read(333) // 将字节数据恢复成字符串 print(data.decode(&apos;utf-8&apos;)) // 用context manager 管理打开的URL资源 with urlopen(&apos;http://www.baidu.com/index.php&apos;) as f: // 按字节读取数据 data = f.read(333) // 将字节数据恢复成字符串 print(data.decode(&apos;utf-8&apos;)) 使用urlopen函数时，可通过data属性向被请求的URL发送数据： from urllib.request import * with urlopen(url=&apos;https://www.baidu.com/index.php&apos;,data=&apos;test&apos;.encode(&apos;utf-8&apos;)) as f: print(f.read().decode(&apos;utf-8&apos;)) 通过urlopen 函数发送POST请求参数，可通过data 属性来实现： import urllib.parse params = urllib.parse.urlencode({&apos;name&apos;:&apos;hale&apos;,&apos;password&apos;:&apos;password&apos;}) params = params.encode(&apos;utf-8&apos;) with urlopen(&apos;https://www.baidu.com/index.php&apos;,data=params) as f: print(f.read().decode(&apos;utf-8&apos;)) urllib.request.Request对象的构造函器： urllib.request.Request(url,data=None,headers={},origin_req_host=None,unverifiable=False,method=None) Request 可通过method指定请求方法，也可通过data指定请求方法，可通过 headers 指定请求头 from urllib.request import * params = &apos;put request&apos;.encode(&apos;utf-8&apos;) req = Request(url=&apos;https://www.baidu.com/index.php&apos;,data=params,method=&apos;PUT&apos;) with urlopen(req) as f: print(f.status) print(f.read().decode(&apos;utf-8&apos;)) 使用Request对象添加请求头 // 创建Request对象 req = Request(&apos;https://www.baidu.com/index.php&apos;) // 添加请求头 req.add_header(&apos;Referer&apos;,&apos;https://www.baidu.com&apos;) with urlopen(req) as f: print(f.status) print(f.read().decode(&apos;utf-8&apos;)) 通过Request 的add_header 方法添加一个Referer 请求头， 实现多线程下载的步骤： from urllib.request import * import threading class DownUtil: def __init__(self,path,target_file,thread_num): self.path = path self.thread_num = thread_rum self.threads = [] def download(self): req = Request(url=self.path,method=&apos;GET&apos;) ... 1. 使用 urlopen 方法打开远程资源 2. 获取指定的URL对象所指向资源的大小，通过Content-Length响应头获取 3. 计算每个线程应该下载网络资源的哪个部分，从哪个节点开始，到哪个字节结束 4. 依次创建并启动多个线程 from DownUtil import * du = DownUtil(&apos;https://www.baidu.com/&apos; + &apos;from/logo.png&apos;,&apos;a.png&apos;,3) du.download() def show_process(): print(&apos;ok : %.2f&apos; % du.get_complete_rate()) global t if du.get_complete_rate() &lt; 1: t = threading.Timer(0.1,show_process) t = threading.Timer(0.1,show_process) t.start() http.cookiejar模块：管理cookie 如使用urllib.request 模块来访问被保护页面，维修与服务器之间的sesion，借助于 cookie 管理器 使用OpenerDirector 对象来发送请求，步骤： 1. 创建 http.cookiejar.CookieJar 对象或其子类的对象 2. 以CookieJar对象为参数，创建urllib.rquest.HTTPCookieProcessor对象，该对象负责调用CookieJar来管理cookie 3. 以HTTPCookieProcessor对象为参数，调用urllib.reques.build_opener()函数创建OpenerDirector对象 4. 使用OpenerDirector对象来发送请求，通过HTTPCookieProcessor调用CookieJar管理cookie from urllib.request import * import http.cookiejar, urllib.parse cookie_jar = http.cookiejar.MozillaCookieJar(&apos;a.txt&apos;) cookie_processor = HTTPCookieProcessor(cookie_jar) opener = build_opener(cookie_processor) user_agent = r&apos;Mozialla ...&apos; header = {&apos;User-Agent&apos;:user_agent,&apos;Connection&apos;:&apos;keep-alive&apos;} [More](http://c.biancheng.net/view/2646.html) TCP协议、IP协议的关系 TCP/IP通信协议是可靠的网络协议，在通信的两端各建立一个socket，形成虚拟的网络链路，建立虚拟的网络链路，两端的程序可通过该链路进行通信。 使用socket对象来代表两端的通信端口并通过socket进行网络通信 IP是Internet 的关键协议，全称：Internet Protocol，即Internet协议，简称：IP协议。IP协议负责将消息从一个主机传送到另一个主机，信息被分割成一个个小包 TCP：端对端协议，TCP协议让他们之间建立一个虚拟链路，用于发送和接收数据 TCP协议负责收集数据包，并按照顺序传送，接收端接收到数据包后再将其正确地还原。TCP协议保证数据包传送无误，采用重发机制，即当一个通信实体发送一个消息给另一个通信实体后，需要接收到的另一个通信实体的确认信息，如没有收到确认信息，则会重发信息 只有把TCP和IP两个协议结合，才能保证Internet在复杂的环境下正常运行。socket 建立TCP连接在使用socket之前，须建立socket对象，通过该类的构造器来创建socket实例： socket.socket(family=AF_INET,type=SOCK_STREAM, proto=0,fileno=None) 1.family 参数用于指定网络类型，socket.AF_UNIX：UNIX网络、socket.AF_INET 基于IPv4协议的网络 和socket.AF_INET6 基于IPv6协议的网络 这三个变量 2. type参数用于指定网络的Sock类型，支持SOCK_STREAM默认值，创建基于TCP协议的socket、SOCK_DGRAM 创建基于UDP协议的socket 和SOCK_RAW 创建原始socket。常用 SOCK_STREAM和SOCK_DGRAM 3. proto参数用于指定协议号， 默认0，可忽略 socket 对象提供的常用方法： 1. socket.accept： 作为服务端使用的socket调用该方法接收来自客户端的连接 2. socket.bind(address)：将该socket绑定到指定address，address可是一个元组，包含IP地址和端口 3. socket.close ： 关闭连接，回收资源 4. socket.connect(address): 连接远程服务器 5. socket.connect_ex(address): 当程序出错时，不抛出异常，返回错误标识符 6. socket.listen([backlog]): 服务器使用socket调用该方法进行监听 7. socket.makefile(mode=&apos;r&apos;,buffering=None,*,encoding=None,errors=None,newline=None): 创建和该socket关联的文件对象 8. socket.recv(bufsize[,flags]): 返回值是(bytes,address)元组 9. socket.recvmsg(bufsize[,ancbufsize[,flags]]): 不仅接收来自socket的数据，还接收来自socket的辅助数据，返回值是一个长度为4的元组(data.ancdata,msg_flags,address). 10. socket.recvmg_into(butters[,nbytes[,flags]]):类socket.recvmsg ，将接收的数据放入buffers中 11. socket.recvfrom_into(buffer[,nbytes[,flags]]):将接收到的数据放入buffer中 12. socket.recv_into([buffer[,nbytes[,flags]]]): 类recv方法，将接收到的数据放入buffer中 13. socket.send(bytes[,flags]): 向socket发送数据，该socket必须与远程socket建立连接，基于TCP协议的网络中发送数据 14. socket.sendto(bytes,addresss)：向socket发送数据，没有与远程socket连接，基于UDP协议发送数据 15. socket.sendfile(file,offset=0,count=None):将整个文件内容发送出去，直到遇到EOF 16. socket.shutdown(how):关闭连接，how用于设置关闭方法 TCP通信的服务器端编程的基本步骤： 1. 服务器端先创建一个socket对象 2. 服务器端socket将自己绑定到指定IP地址和端口 3. 服务器端socket调用listen 方法监听网络 4. 程序采用循环不断调用socket 的accept方法接收来自客户端的连接 // 创建socket对象 s = socket.socket() // 将socket 绑定到本机IP地址和端口 s.bind(&apos;192.168.0.123&apos;,8888) // 服务器开始监听客户端的连接 s.listen() while True: c,addr = s.accept() 客户端先创建一个socket对象，将该socket绑定到指定的ip地址和端口号，然后调用connect方法建立与服务器的连接，就可建立一个基于TCP协议的网络连接 TCP通信的客户端的基本步骤如下： 1. 客户端先创建一个socket对象 2. 客户端socket调用connect方法连接到远程服务器 socket提供大量方法发送和接收数据： 1. 发送数据：使用send方法，注意：sendto方法用于UDP协议的通信 2. 接收数据：使用recv_xxx方法 import socket s = socket.socket() s.bind((&apos;192.168.1.88&apos;,999)) s.listen() while True: c, addr = s.accept() print(c) print(&apos;connect addrss&apos;, addr) c.send(&apos;himessge &apos;.encode(&apos;utf-8&apos;)) c.close() 从socket中获取服务器发送的数据 import socket s = socket.socket() s.connect((&apos;192.168.1.88&apos;,999)) print(&apos;--%s--&apos;s.recv(1024).decode(&apos;utf-8&apos;)) s.close() 多线程实现socket通信 由于socket的recv方法在成功读取到数据之前。线程会被阻塞，因此，服务器为每个socket单独启动一个线程，每个线程负责与一个客户端进行通信 服务器端使用list来保存所有的socket import socket import threading socket_list = [] ss = scoket.socket() ss.bind((&apos;192.168.1.14&apos;,999)) ss.listen() def read_from_client(s): try: return s.recv(2048).decode(&apos;utf-8&apos;) except: socket_list.remove(s): def server_target(s): try: while True: content = read_from_client(s) print(content) if content is None: break for client_s in socket_list: client_s.send(content.encode(&apos;utf-8&apos;)) except e: print(e.strerror) while True: s,addr = ss.accept() socket_list.append(s) threading.Thread(target=server_target,args=(s,)).start() socket shutdown 方法 以bytes对象作为通信的最小数据单位，服务器端在处理信息时是针对每个bytes进行的，一些协议中，通信数据单位可需多个bytes对象 shutdown(how)方法，可只关闭socket的输入或输出部分，用以表示数据已经发送完成 shutdown方法的how参数的参数值： SHUT_RD： 关闭socket的输入部分，可通过socket输出数据 SHUT_WR： 关闭socket的输出部分，通过该socket读取数据 SHUT_RDWR： 全关闭，该socket既不能读取数据，也不能写入数据 服务器端先向客户端发送数据发送多条数据，当数据发送完成后，该socket对象调用shutdown方法来关闭输出部分 import socket s = socket.socket() s.bind((&apos;192.168.1.88&apos;,999)) s.listen() skt,addr = s.accept() skt.send(&apos;server first data&apos;.encode(&apos;utf-8&apos;)) skt.send(&apos;server second data&apos;.encode(&apos;utf-8&apos;)) skt.shutdown(socket.SHUT_WR) while True: line = skt.recv(2048).decode(&apos;utf-8&apos;) if line is None or line == &apos;&apos;: break print(line) skt.close() s.close() selectors 模块：实现非阻塞式编程 selectors 允许以非阻塞方式进行通信，selector相当于一个事件注册中心，只要将socket的所有事件注册给selectors管理，当检测到socket中的特定事件后，程序调用相应的监听方法进行处理 selectors主要支持两种事件： 1. selectros.EVENT_READ: 当socket有数据可读时触发该事件，有客户端连接时也触发 2. selectors.EVENT_WRITE： 当socket将要写数据时触发该事件 selectors实现非阻塞式编程的步骤如下： 1. 创建selectors对象 2. 通过selectors对象为socket的selectors.EVENT_READ或selectors.EVENT_WRITE事件注册监听器函数，当socket有数据读写时，系统负责触发所注册的监听器函数 3. 在监听器函数中处理socket通信 使用seletros实现非阻塞通信的服务器端： import seletors, socket sel = seletors.DefaultSelector() def read(skt,mask): try: data = skt.recv(1024) if data: for s in socket_list: s.send(data) else: print(&apos;close &apos;,skt) sel.unregisters(skt) skt.close() socket_list.remove(skt) except: print(&apos;close&apos;) sel.unregister(skt) skt.close() socket_list.remove(skt) socket_list = [] def accept(sock, mask): conn,addr = sock.accept() socket_list.append(conn) conn.setblocking(False) sel.register(conn,selectors.EVENT_READ,read) sock = socket.socket() sock.bind((&apos;192.168.1.1&apos;,999)) sock.listen() sock.setblocking(Flase) UDP协议及优缺点 UDP：User Datagram Protocol：用户数据报协议 UDP 面向非连接的协议，是在正式通信前不必与对象先建立连接，不管对方状态，直接发送数据， UDP协议无法控制，是一种不可靠的协议 UDP协议适用于一次只传送少量数据、对可靠性要求不高的应用环境 作用：完成网络数据流和数据报之间的转换在信息的发送端，UDP协议将网络数据流封装为数据报，然后将数据发送出去，在信息的接收端，UDP协议将数据报转换为实际数据内容 UDP协议和TCP协议的简单对比： 1. TCP协议：可靠，传输大小无限制，需要建立连接，差错控制开销大 2. UDP协议：不可靠，差错控制开销小，传输大小限制在64Kb以下，不需要建立连接。 socket发送和接收数据：基于UDP协议 创建socket，通过type参数指定socket的类型，将参数指定为 SOCK_DGRAM，即创建基于UDP协议的socket 通过两个方法发送和接收数据 1. socket.sendto(bytes,address): 将bytes数据发送到address地址 2. socket.recvfrom(bufsize[,flags]):接收数据，返回socket中的数据和数来源地址 import socket PORT = 999 DATA_LEN = 4096 books = (&apos;one&apos;,&apos;tow&apos;,&apos;three&apos;) s = socket.socket(type=socket.SOCK_DGRAM) s.bind((&apos;192.168.1.1&apos;,PORT)) for i in range(1000): data ,addr = s.recvfrom(DATA_LEN) print(data,decode(&apos;utf-8&apos;)) send_data = books[i % 4].encode(&apos;utf-8&apos;) s.sendto(send_data,addr) s.close() 来自服务器端的数据，客户端程序代码： import socket PORT = 3000 DATA_LEN = 4096 DEST_IP = &apos;192.168.1.1&apos; s = socket.socket(type=socker.SOCK_DGRAM) while True: line = input(&apos;&apos;) if line is None or line == &apos;exit&apos;: break data = line.encode(&apos;utf-8&apos;) s.sendto(data,(DEST_IP,PORT)) data = s.recv(DATA_LEN) print(data.decode(&apos;utf-8&apos;)) s.close() UDP 多点广播原理及实现 多点广播，将数据以广播方式发送到多个客户端 创建socket对象后，将该socket加入指定的多点广播地址中，socket使用setsockopt 方法加入指定组 创建仅发送数据报的socket对象， 使用默认地址、随机端口即可。 如创建接收数据报的socket对象，将对象绑定到指定端口 多点广播可设置广播信息的TTL(Time-To-Live)，TTL参数用于设置数据报最多可跨过的网络个数： 1. TTL的值为0：指定数据报应停留在本地主机中 2. 1: 指定将数据报发送到本地局域网中，此值为默认值 3. TTL的值为 32 时： 只能将数据报发送到本站点的网络上 4. 。。64 ： 数据报应被保留在本地区 5. 128 ： 被保留在本大洲 6. 255 ： 数据可被发送到所有地方 socket实现一个基于广播的多人聊天室，只需要一个socket、两个线程，socket用于发送数据、接收数据。主线程负责读取用户的键盘输入内容，并向socekt发送数据，子线程负责从socket中读取数据 import time,socket,threading, os senderIP = &apos;192.168.1.99&apos; senderPORT = 999 myGroup = &apos;230.0.0.1&apos; s = socket.socekt(type=socket.SOCK_DGRAM) s.bind ((&apos;0.0.0.0&apos;,senderPORT)) s.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICASE_TTL,64) s.setsockopt(socket.SOL_SOCKET. socket.SO_REUSEADDR, 1) status = s.setsockopt(socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP, socket.inet_aton(mygroup)) ... [More](http://c.biancheng.net/view/2663.html) smtplib 模块： 发送邮件 底层的处理由smtplib封装，3步发送邮件： 1. 连接STMP服务器，使用用户名、密码登录服务器 2. 创建EmailMessage 对象，该对象代表邮件本身 3. 调用代表与SMTP服务器连接的对象的sendmail方法发送邮件 import smtplib from email.message import EmailMessage smtp_server = &apos;smtp.qq.com&apos; from_addr = &apos;mr_hale@qq.com&apos; password = &apos;password&apos; to_addr = &apos;mr_hale@163.com&apos; conn = smtplib.SMTP_SSL(smtp_server,465) conn.set_debuglevel(1) conn.login(from_addr,password) msg = EmailMessage() msg.set_content(&apos;hi&apos;,&apos;plain&apos;,&apos;utf-8&apos;) conn.sendmail(from_addr,[to_add],msg.as_string()) conn.quit() 基于SSL的SMTP服务器的默认端口是465 常见参数： 1. maintype ：指定附件的主类型，如image代表附件图片 2. subtype ： 附件的子类型，如指定为png，代表附件是png图片，子类型受主类型的限制 3. filename ： 指定附件的文件名 4. cid = img ： 指定附件的资源ID，可通过资源ID引用该资源 import smtplib, email.utils from emial.message import EmailMessage smtp_server = &apos;smtp.qq.com&apos; from_arrd = &apos;mr_hale@qq.com&apos; password = &apos;pass&apos; to_addr = &apos;mr_hale@163.com&apos; conn = smtplib.SMTP_SSL(smtp_server,465) conn.set_debuglevel(1) conn.login(from_addr,password) msg = EmailMessage() first_id ,second_id = email.util.make_msgid(), email.utils.make_msgid() msg.set_connect(&apos;&lt;h1&gt;hi&lt;/hi&gt;&apos;) msg[&apos;subject&apos;] = &apos;subject&apos; msg[&apos;from&apos;] = &apos;mr_hale@qq.com&apos; msg[&apos;to&apos;] = &apos;mr_hale@163.com&apos; with open(&apos;file_Path:/xx.png&apos;,&apos;rb&apos;) as f: msg.add_attchment(f.read(),maintype=&apos;image&apos;, subtype=&apos;jpeg&apos;,filename=&apos;xxx.png&apos;,cid=first_id) with open(&apos;path_dir/xx.gif&apos;,&apos;rb&apos;) as f: msg.add_attachment(f.read(),maintype=&apos;image&apos;,subtype=&apos;gif&apos;,filename=&apos;xxx.gif&apos;,cid=second_id) with open(&apos;xxx.pdf&apos;,&apos;rb&apos;) as f: msg.add_attachment(f.read(),maintype=&apos;application&apos;,subtype=&apos;pdf&apos;,filename=&apos;xxx.pdf&apos;) conn.sendmail(from_arrd,[to_addr],msg.as_string()) conn.quit() poplib 模块： 收取邮件 提供poplib.POP3 和poplib.POP3_SSL 两个类，用于连接POP服务器和基于SSL的POP服务器 POP3 协议属于请求，响应式交互协议，当客户端连接服务器后，客户端向POP服务器发送请求，而POP服务器对客户端生成响应数据，客户端可通过响应数据下载得到邮件内容 POP3的命令和数据都基于ASCII文本，以 CR 和 LF(/r/n)作为行结束符，响应数据包括一个表示返回状态的符号(+/)和描述信息 请求和响应的标准格式： 请求标准格式： 命令[参数] CRLF 响应标准格式： +OK /[-ERR] description CRLF POP3协议客户端的命令和服务器端对象的响应数据： 1. user name ： 向POP服务器发送登录的用户名 2. pass string ： 向POP服务器发送登录的密码 3. quit： 退出POP服务器 4. stat ：统计邮件服务器状态，包括邮件数和总大小 5. list[msg_no] : 列出全部邮件或指定邮件，返回邮件编号和大小 6. retr msg_no : 获取指定邮件的内容，编号从1开始 7. del msg_no ： 删除指定邮件 8. noop ： 空操作，仅用于于服务器保持连接 9. rset ： 用于撤销dele命令 接收邮件的步骤： 1. 使用poplib.POP3 或 poplib.POP3_SSL 按 POP3 协议从服务器下载邮件 2. 使用 email.parser.Parset 或 email.parser.BytesParser解析邮件内容，得到EmailMessage对象，从EmailMessage 对象中读取邮件内容 import poplib, os.path , mimetypes from email.parser import BytesParser, Parser from email.policy import default emial = &apos;mr_hale@163.com&apos; password = &apos;password&apos; pop3_server = &apos;pop.qq.com&apos; conn = poplib.POP3_SSL(pop3_server, 995) conn.set_debuglevel(1) print(conn.getwelcome().decode(&apos;utf-8&apos;)) conn.user(email) conn.pass_(password) message_num, total_size = conn.stat() print(&apos;email num %s total %s&apos; % (message_num,total_size)) resp, mails, octets = conn.list() print(resp, mails) resp, data, octets = conn.retr(len(mails)) msg_data = b&apos;\r\n&apos;.join(data) mg = BytesParser(policy=default).parsebytes(msg_data) [More](http://c.biancheng.net/view/2667.html) 程序在创建BytesParser 解析字节串格式的邮件数据 或 Parser 解析字符串格式的邮件数据时，必须指定 policy=default， 否则 BytesParser或Parser 解析邮件数据得到的就是过时的Message对象123@Author : Hale Lv@Created Time : 2019-08-27 20:41:18@Description : pydoc 模块：查看、生成帮助文档在控制器中使用help 函数和 __doc__ 属性查看函数、类、方法的文档 借助自带的pydoc模块，方便查看、生成帮助文档，是HTML格式 创建名为 HI_doc.py 的文件 MY_NAME = &apos;Python DOC&apos; def say_hi(name): &apos;&apos;&apos; 定义一个say hi的函数 返回对指定用户打招呼的字符串 &apos;&apos;&apos; print(&apos;run hi func&apos;) return name + &apos;welcome !&apos; def run(load): &apos;&apos;&apos; 走路ing &apos;&apos;&apos; print(&apos;run run func&apos;) return &apos;run &apos; + load class User: NAME = &apos;Hale&apos; &apos;&apos;&apos; 定义一个用户的类 命名名字为Hale &apos;&apos;&apos; def __init__(self,name,age): &apos;&apos;&apos; name 为初始化的name值 age 初始化该用户的age &apos;&apos;&apos; self.name = name self.age = age def eat(food): &apos;&apos;&apos; 定义用户在吃东西的方法 food 代表正在吃的东西 &apos;&apos;&apos; print(&apos;%s eat %s&apos; % (self.user, food)) 定义了一个HI_doc.py 源文件，即定义了一个HI_doc 模块， 该模块为函数、类、方法都提供文档 pydoc在控制台中查看文档 使用pydoc模块在控制台查看HTML文档 python -m pydoc 模块名 -m ： 选项，表示运行指定模块，运行pydoc模块，模块名参数代表程序要查看的模块 python -m pydoc HI_doc pydoc 模块中的全部内容： CLASSES 部分： 列出该模块所包含的全部类 FUINCTIONS ： 列出包含的全部函数 DATA ： 全部成员变量 FILE： 源文件 pydoc 生成HTML文档 python -m pydoc -w 模块名 -m ：代表模块0 -w 选项： 代表 write，表明输出HTML文档 pydoc 为指定目录生成HTML文档，为指定目录下的所有模块生成HTML文档： python -m pydoc -w 目录名 启动本地服务器查看文档信息 启动本地服务器产看文档信息的两个命令 1. python -m pydoc -p 端口号 指定端口启动HTTP服务器，通过浏览器查看Python的所有模块的文档信息： 2. python -m pydoc -b 第一部分：显示python内置的核心模块 第二部分：显示当前目录下的所有模块 第三部分：显示当前目录下的所有模块， pydoc 查找模块 python -m pydoc -k 被搜索的模块的部分内容doctest模块： 文档测试文档测试工具可以提取说明文档中的测试用例，其中 &quot;&gt;&gt;&gt;&quot; 之后的内容表示测试用例，下一行代表测试用例的输出结果 def squre(x): &apos;&apos;&apos; 计算平方的函数 eg : &gt;&gt;&gt; squre(2) 4 &gt;&gt;&gt; squre(4) 16 &apos;&apos;&apos; return x * 2 # 故意写错的 class User: &apos;&apos;&apos; 定义一个代表用户的类，包括属性： name - 代表名字 age - 代表年龄 例如： &gt;&gt;&gt; u = User(&apos;hale&apos;,23) &gt;&gt;&gt; u.name &apos;hale&apos; &gt;&gt;&gt; u.age 23ß &apos;&apos;&apos; if __name__ == &apos;__main__&apos;: import doctest doctest.testmdo() 测试结果包含的内容： 1. 第一部分：显示在哪个源文件的哪一行 2. 第二部分：Failed example，显示是哪个测试用例出错了 3. 第三部分：Expected 显示程序期望的输出结果，即在&quot;&gt;&gt;&gt;命令&quot;的下一行给出的运行结果 4. 第四部分：Got ，显示程序实际运行产生的输出结果，只有输出结果与期望结果一致，才表明测试用例通过 可见：为文档注释提供doctest模块，程序只要导入该模块，并调用模块的testmod 函数即可。 testmod 自动提取模块的说明文档的测试用例，并执行这些测试用例，最终生成测试报告。unittest(PyUnit)单元测试框架 PyUnit unittest 是单元测试框架，编写和运行可重复的测试。 PyUnit 是xUnit体系的一个成员，xUnix是众多测试框架的总称。主要用于进行白盒测试和回归测试 好处： 可以使测试代码与产品代码分离 针对某一个类的测试代码只需要进行较少的改动，便于另一个类的测试 开源，方便对PyUnit的扩展 特征： 1. 使用断言方法判断期望值和实际值的差异，返回bool值 2. 测试驱动设备可使用共同的初始化变量或实例 3. 测试包结构便于组织和继承运行 PyUnit(unittest)用法： 通过给定参数执行函数，判断函数的实际输出结果和期望的输出结果是否一致，测试用例提供执行函数和方法， 获取他们的执行结果，然后使用断言方法来判断 开发方式称为：测试驱动开发，强调先编写测试用例，然后在编写函数和方法，例：开发A功能的fun_a函数，采用测试驱动开发的步骤： 1. 为fun_a 函数编写测试用例，使用大量不同的参数组合来执行fun_a函数，并断言该函数的执行结果与业务期望的执行结果匹配 2. 编写、修改fun_a 函数 3. 运行fun_a函数的测试用例，如不能完全通过，则重复第2步和第3步，直到fun_a的所有测试用例全部通过 开发一个简单的 fk_math.py 程序，包含两个函数，分别用于计算一元一次方程的解和二元一次方程的解 def one_equation(a,b): &apos;&apos;&apos; 一元一次方程的解 返回方程解 &apos;&apos;&apos; if a == 0: raise ValueError(&apos;参数错误&apos;) else: return b / a def two_equation(a,b,c): &apos;&apos;&apos; 一元二次方程 &apos;&apos;&apos; if a == 0: raise ValueError(&quot;参数错误&quot;) elif b * b - 4 * a * c &lt; 0: raise ValueError(&apos;方程在有理数范围内无解&apos;) elif b * b - 4 * a * c == 0: return -b / (2 * a) else: r1 = (-b + (b * b - 4 * a * c) ** 0.5 ) / 2 /a r2 = (-b + (b * b - 4 * a * c) ** 0.5 ) / 2 /a return r1, r2 unittest要求单元测试类必须继承 unittest.TestCase，该类中的测试方法需要满足： 1. 测试方法应该没有返回值 2. 测试方法不应该有任何参数 3. 测试方法应以test开头 import unittest from fk_math import * class TestFkMath(unittest.TestCase): def test_one_equation(self): self.assertEqual(one_equation(5,9), -1.8) with self.assertRaises(ValueError): one_euqation(0,9) def test_two_equation(self): r1,r2 = two_equation(1,-3,2) self.assertCountEqual((r1,r2),(1.0,2.0),&apos;求解出错&apos;) ... with self.assertRaises(ValueError): two_equation(0,9,3) ... unittest.TestCase内置大量assertXxx方法执行断言： assertEqual(a,b) a == b assertNotEqual(a,b) a != b assertTrue(x) bool(x) is True assertFalse(x) bool(x) is False assertIsNot(a,b) a is not b assertIs(a,b) a is b assertIsNone(x) x is None assertIsNotNone(x) x is not None [More](http://c.biancheng.net/view/2679.html) TestCase 包含断言方法 assertAlmostEqual(a,b) round(a-b,7) == 0 assertNotAlmostEqual(a,b) round(a-b,7) != 0 assertGreater(a,b) a &gt; b TestCase 包含针对特定类型的断言方法 assertMultiLineEqual(a,b) 字符串string assertSequenceEqual(a,b) 序列sequence assertListEqual(a,b) 列表list assertTupleEqual(a,b) 元组tuple assertSetEqual(a,b) 集合set 或 frozenset assertDictEqual(a,b) 字典dict 运行测试 两种方式： 1. 通过代码调用测试用例，通过调用unittest.main() 运行当前源文件中所有测试用例 if __name__ == &apos;__main__&apos;: unittest.main() 2. 使用unittest 模块运行测试用例，语法： python -m unittest 测试文件 测试结果： 1. . ：代表测试通过 2. F ： 代表失败，F ： failure 3. E ： 出错 E ： error 4. s ： 跳过该测试 s ： skip TestSuite 测试包及用法 可组织多个测试用例， 还可嵌套测试包，使用测试运行器 TestRunner 来运行该测试包所包含的所有测试用例 // 开发一个程序 hello.py def say_hello(): return &apos;hi&apos; def add(a,b): return a + b // 为上面程序提供测试类 test_hello.py import unittest from hello improt * class TestHello(unittest.TestCase): def test_say_hell(self): self.assertEqual(say_hello(),&apos;Hello world.&apos;) def test_add(self): self.assertEqual(add(2,1),5) self.assertEqual(add(3,6),7) 将 test_fk_math 和 test_hello.py 放在同一目录，可通过TestSuite将他们组织在一起，然后使用TestRunner来运行该测试包 import unittest from test_fk_math import TestFkMath test_cases = (TestHello, TestFkMath) def whole_suite(): // 创建测试加载器 loader = unittest.TestLoader() // 创建测试包 suite = unittest.TestSuit() // 遍历所有测试类 for test_class in test_cases: // 从测试类中加载测试用例 tests = loaders.loadTestsFromTestCase(test_class) // 将测试用例添加到测试包 suite.addTests(tests) return suite if __name__ == &apos;__main__&apos;: // 创建测试运行器 runner = unittest.TexTestRunner(verbosity=2) runner.run(whole_suite()) 把测试报告输出到该类文件对象中 修改__main__ 部分代码： if __name__ == &apos;__main__&apos;: with open(&apos;fk_test_report.txt&apos;,&apos;a&apos;) as f: runner = unittest.TextTextRunner(verbosity=2,stream=f) runner.run(whole_suite()) 单元测试setUp 和 tearDown 用法 测试用例类：TestCase的子类、测试包TestSuit、测试运行器TestRunner、测试固件TestFixture的概念： 1. 测试用例类：是单个的测试单元，负责检查特定输入和对应的输出是否匹配， 2. 测试包： 组合多个测试用例， 可嵌套测试包 3. 测试运行器：负责组织、运行测试用例，向用户呈现测试结果 4. 测试固件： 代表执行一个或多个测试用例所需的准备工作，及相关联的准备操作，包括：创建临时数据库、创建目录、开启服务器进程等。 unittest.TestCase包含setUp 和 tearDown 两个方法，其实setUp方法用于初始化测试固件， tearDown 方法用于销毁测试固件。运行每个测试用例以 test_ 开头的方法之前自动执行setUp方法来初始化测试固件，并在每个测试用例结束后自动执行tearDown方法销毁测试固件 import unittest from hello import * class TestHello(unittest.TestCase): def test_say_hello(unittest.TestCase): self.assertEqual(say_hello(),&apos;Hello world&apos;) def test_add(self): self.assertEqual(add(3,5),7) def setUp(self): print(&apos;---- setUp model--- &apos;) def tearDown(self): print(&apos;----tearDown-----&apos;) python -m unittest -v fixture_test.py unittest跳过测试用例 unittest 自动测试每一个测试用例 以test开头的方法，如跳过某个测试用例，通过两种方式： 1. 使用 skipXxx 装饰器 跳过测试用例，unittest 提供3个装饰器，分别是 @unittest.skip(reason) , @unittest.skipif(condition,reason), @unittest.skipUnless(condition,reason),其中 skip 代表无条件跳过，skiplf 代表当condition为True时跳过，skipUnless 代表当condition为False时跳过 2. 使用TestCase 的skipTest 方法来跳过测试用例 import unittest from hello import * class TestHello(uniitest.TestCase): def test_say_hello(self): self.assertEqual(say_hello(),&apos;hi hello&apos;) @unittest.skip(say_hello(),&apos;hello world&apos;) def test_add(self): self.assertEqual(add(3,4),7) ... @unittest.skip装饰器跳过了test_add 测试方法 python -m unittest skip_test.py 测试结果中，s 代表跳过第一个测试用例，. 代表第二个测试用例通过 可使用TestCase 的skipTest 方法跳过测试用例： import unittest from hello import * class TestHello(unittest.TestCase): def test_say_hello(self): self.assertEqual(say_hello(),&apos;hi&apos;) def test_add(self): self.skipTest(add(3,4),5) ... python -m unittest -v skip_test.py -v : 生成更详细的测试报告123@Author : Hale Lv@Created Time : 2019-08-28 12:01:48@Description : 打包和发布 zipapp 和 PyInstaller用于将Python 应用打包为一个 .pyz 文件，无论多少个源文件和依赖包，使用zipapp可将他们大包为一个 .pyz 文件。 zipapp 模块： 将一个 python模块或多个模块打包为一个Python应用，可发布为Windows 的可执行程序 生成可执行的Python档案包 zipapp 是一个可直接运行的模块，将单个python文件或整个目录下的所有文件打包为可执行的档案包 python -m zipapp source [options] source ：代表要打包的Python源程序或目录，参数可是单个的pyhton文件，也可是文件夹。 option 选项： -o &lt;output&gt;, --output=&lt;output&gt;: 指定输出档案包的文件名，如不指定该选项，生成的档案包的文件名默认是source 参数值，并加上 .pyz后缀 -p &lt;interpreter&gt;, --python=&lt;interpreter&gt; : 指定Python解释器， -m &lt;mainfn&gt;, --main=&lt;mainfn&gt; : 指定Python程序的入口函数，该选项应为： pkg.mod:fn 形式，pkg.mod 是一个档案包中的包或模块，fn是指定模块中的函数，如不指定，默认从模块中的 __main__.py 文件开始执行 -c ， --compress ： 指定是否对档案包进行压缩来减少文件的大小，默认不压缩 --info ： 用于诊断时显示档案包中的解释器 -h ， --help ： 该选项用于显示 zipapp 模块中的帮助信息 建立一个app 子目录， 包办多个python程序，如：say.py def say(name): return &apos;hi&apos; + name 在该目录下开发一个app.py 程序来使用 say 模块： from say import * def main(): print(&apos;start run&apos;) print(say(&apos;hale&apos;)) 在命令行中进入该目录(app目录的父目录)： python -m zipapp app -o first.pyz -m &quot;app:main&quot; 指定将当前目录下的app子目下的所有Py源文件打包为一个档案包，-o 选项指定生成档案包的文件名为 first.pyz； -m ： 指定使用app.py 模块中的main函数作为程序入口 python -m zipapp app -m &quot;app:main&quot; 没有-o， 使用默认的输出文件名，生成一个 app.pyz文件zipapp 创建独立应用如需使用第三方模块和包 创建独立启动的应用 自带依赖模块和包，执行2个步骤： 1. 将应用依赖的模块和包下载到应用目录中 2. 使用zipapp将应用和依赖模块一起打包为档案包 在app目录中创建一个dbapp子目录，在dbapp中创建一个__main__.py 文件作为程序入口，打包档案包时不需指定入口 from exec_select import * query_db() exec_select.py 文件： import mysql.connector def query_db(): conn = conn.connector.connect(user=&apos;user&apos;,&apos;passwor&apos;=&apos;pass&apos;,host=&apos;localhost&apos;,port=&apos;3306&apos;,database=&apos;dbname&apos;,use_unicode=True) c = conn.cursor() c.execute(&apos;select * from user_tb where user_id &gt; %s&apos;,(2,)) for col in (c.description): print(col[0],end=&apos;\t&apos;) print(&apos;\n-----&apos;) for row in c: print(row) print(row[1] + &apos;--&gt;&apos; + row[2]) c.close() conn.close() 1. 将dbapp子目录下的应用打包为独立应用： python -m pip install -r requirements.txt --target dbapp 使用 pip 安装模块，python -m pip install 表示安装模块， -target 指定要安装到指定目录下， 此处安装到dbapp子目录下。-r 指定安装哪些模块，使用requirements.txt 列出要安装的模块和包 -r 选项支持两个值： 1. 直接指定要安装的模块或包 2. 使用清单文件指定要安装的模块和包 如：pip 模块提示找不到 requirements.txt 文件，需在当前目录下添加一个requirements.txt 文件，在该文件中增加： mysql-connector-python 如模块需要依赖多个模块，则在requirements.txt 文件中定义多行，每行定义一个模块。 2. 如pip在dbapp子目录生成 .dist-info 目录，删除即可 3. 使用zipap 模块执行打包操作，如dbapp子目录下包含了 __main__.py 文件，则不需指定 -m 选项 python -m zipapp dbapp 卸载在python目录下安装的mysql-connector-python 模块： pip uninstall mysql-connector-pythonPyInstaller 安装和使用 默认不包含PyInstaller 模块， 需自行安装 pip install pyinstaller PyInstaller生成可执行程序 pyinstaller 选项 Python 源文件 单文件、多文件，使用pyinstaller 编译作为程序入口的python 程序即可 先创建一个app目录，在该目录下创建一个 app.py 文件 from say_hello import * def main(): print(&apos;start run&apos;) print(say_hello(&apos;hale&apos;)) if __name__ == &apos;__main__&apos;: main() 进入此app目录，执行： pyinstaller -F app.py 执行完毕，会生成 dist目录、app.exe 文件 -F 选项： 指定生成单独的EXE 文件， —D ：指定生成一个目录作为程序 pyinstaller -D app.py 执行完毕，生成dist目录， 包含大量.dll 文件和 .pyz 文件 PyInstaller 支持的常用选项 -F， -onefile ： 产生单个的可执行文件 -D， --onedir ： 产生一个目录(包含多个文件)作为可执行程序 -a， --ascii ： 不包含Unicode 字符集支持 -d， --debug ： 产生debug 版本的可执行文件 -w， --windowed，--noconsolc ： 指定程序运行时不显示命令行窗口(仅对windwos有效) -c， --nowindowed，-console ： 指定命令行窗口运行程序 -o DIR， --out=DIR ： 指定spec文件的生成目录，如没指定，默认使用当前目录来生成spec文件 -p DIR，--path=NAME ： 设置python导入模块的路径，可用路径分隔符(win:&apos;,&apos;,unix:&apos;:&apos;来分割多个路径) -n NAME，--name=NAME ： 指定项目的名字 如省略，第一个脚本的主文件名将作为spec的名字 -h ： 查看选项的详细信息 创建带图形的用户界面，可访问数据库的应用 在app所在目录创建一个dbapp目录，并在该目录下创建python程序，exec_select.py 负责查询数据， main.py 负责创建图形用户界面来显示查询结果 exec_select.py 代码： import mysql.connector def query_db(): conn = mysql.connector.connect(user=&apos;root&apos;,password=&apos;pass&apos;,host=&apos;localhost&apos;,port=&apos;3306&apos;,database=&apos;dbname&apos;,use_unicode=True) c = conn.cursor() c.execute(&apos;select * from user_tb where user_id &gt; %s&apos;,(2,)) description = c.description rows = c.fetchall() c.close() conn.close() return description, rows main.py 文件代码： from exec_select import * from tkinkter import * def main(): description,rows = query_db() win = Tk() win.title(&apos;query db&apos;) for i, col in enumerate(description): lb = Button(win,text=col[0],padx=50,pady=0) lb.grid(row=0,colunm=i) for i, row in enumerate(rows): for j in range(len(row)): en = Label(win, text=row[j]) en.grid(row=i+1,column=j) win.mainloop() if __name__ == &apos;__main__&apos;: main() Pyinstaller -F -w main.py123@Author : Hale Lv@Created Time : 2019-08-28 15:32:33@Description : 数据可视化 Matplotlib, PygalMatplotlib是Python 2D 绘图库，符号格式的数据，通过Matplotlib 方便制作折线图、柱状图、散点图等各种高质量的数据图 安装： 1. pip install matplotlib 2. python -m pip install matplotlib python -m pydoc -p 8899 // 文档 Matplotlib plot 函数： 生成折线图 给出对应的 x轴、y轴数据， 调用pyplot子模块下的plot函数即可生成简单的折线图 如：生成2013年～2019年的销售数据 import matplotlib.pyplot as plt x_data = [&apos;2013&apos;,&apos;2014&apos;,&apos;2015&apos;,&apos;2016&apos;,&apos;2017&apos;,&apos;2018&apos;,&apos;2019&apos;] y_data = [123000,1232131,2131421,23532,453,645363,54654645] plt.plot(x_data,y_data) plt.show() plot函数支持创建具有单条折线的折线图，也支持多条折线复式折线图，调用plot函数传入多个分别x轴和y轴数据的list列表即可。 import matplotlib.pyplot as plt x_data = [&apos;2018&apos;,&apos;2019&apos;] y_data = [5555555,666666] y_data1 = [777777,8888888] plt.plot(x_data,y_data,y_data1) plt.show() plot函数可传参数指定折线的样子，如 线宽、颜色、样式等，例： import matplotlib.pyplot as plt x_data = [&apos;2016&apos;,&apos;2017&apos;,&apos;2018&apos;,&apos;2019&apos;] y_data = [100000,200000,300000,400000,500000] y_data1 = [900000,800000,70000,40000,32222] plt.plot(x_data,y_data,color=&apos;red&apos;,linewidth=2.0, linestyle=&apos;--&apos;) plt.plot(x_data,y_data1,color=&apos;blue&apos;,linewidth=3.0,linestyle=&apos;-.&apos;) plt.show() color: 颜色， linewidth ： 线宽 、 linestyle ： 折线样式 linestyle 折线样式，字符串参数值： - ： 代表实线，默认值 -- ： 代表虚线 . ： 代表点线 -. : 代表短线、点相同的虚线 Matplotlib legend : 为每条折线添加图例 对于复式折线图，应为每条折线添加图例，通过legend 函数实现，可传入两个list参数，第一个list参数 handles参数，用于引用折线图赏的每条折线，第二个list参数labels 代表为每条折线所添加的图形 为两条折线添加图例： import matplotlib.plot as plt x_data = [&apos;2018&apos;,&apos;2019&apos;] y_data = [200000,3000000] y_data1 = [30000,500000] ln1 = plt.plot(x_data,y_data,color=&apos;red&apos;,linewidth=2.0, linestyle=&apos;--&apos;) ln2 = plt.plot(x_data,y_data1,color=&apos;gary&apos;,linewidth=3.0,linestyle=&apos;-.&apos;) plt.legend(handler=[ln2,ln1],labels=[&apos;Python&apos;,&apos;PHP&apos;],loc=&apos;lower right&apos;) plt.show() loc参数指定图例的添加位置，参数支持的参数值： &apos;base&apos;: 自动选择最佳位置 &apos;upper right&apos;: 将图例放在右上角 &apos;upper left&apos;: 左上角 &apos;lower left&apos;: 左下角 &apos;lower right&apos;: 右下角 &apos;right&apos;: 右边 &apos;center left&apos;: 左边剧中 &apos;center right&apos;: 右边剧中 &apos;lower center&apos;: 底部剧中 &apos;upper center&apos;: 顶部剧中 &apos;center&apos;: 将图例放在中心 在程序中修改 Matplotlib 的默认字体，步骤： 1. 使用 matplotlib.fnot_manager 子模块下的FontProperties 类加载中文字体 2. 在调用legend 函数时通过 prop 属性指定中文字体 improt matplotlin.font_manager as fm my_font = fm.FontProperties(fname=&apos;/usr/font/powerline.ttf&apos;) plt.legend(handles=[ln2,ln1], labels=[&apos;你好&apos;,&apos;Python基础&apos;],loc=&apos;lower right&apos;,prop=my_font) 使用 legend 函数时可不指定handles参数，只传入labels参数 plt.legend(labels=[&apos;Python 中文&apos;,&apos;PHP基础&apos;],loc=&apos;center&apos;,proc=my_font) Matplotlib 可在调用 plot 函数时为每条折线分别传入label参数， import matplotlib.pyplot as plt x = [&apos;2018&apos;,&apos;2019&apos;] y1 = [1233,312321] y2 = [123213214,32131] plt.plot(x,y1,color=&apos;red&apos;,linewidth=2.0,linestyle=&apos;-.&apos;,label=&apos;Python你好&apos;) plt.plot(x,y2,color=&apos;blue&apos;,linewidth=3.0,linestyle=&apos;--&apos;,lebale=&apos;PHP再见&apos;) import matplotlib.font_manager as fm my_font = fm.FontProperties(fname=&apos;font dir&apos;) plt.legend(loc=&apos;best&apos;) plt.show()Matplotlib time, xlabel, ylabel , xticks, yticks : 设置坐标轴调用 xlabel 、 ylabel 函数设置x轴、y轴，通过title 函数设置整个数据图的标题，调用xticks 、yticks 改变x轴、y轴的刻度值 为数据图添加名称、标题、坐标轴刻度值 import matplotlib.pyplot as plt x = [&apos;2018&apos;,&apos;2019&apos;] y1 = [111111,2222] y2 = [1233213,3213213213] plt.plot(x,y1,color=&apos;red&apos;,linewidth=2.0,linestyle=&apos;--&apos;,label=&apos;Hi PYthon你好&apos;) plt.plot(x,y2,color=&apos;blue&apos;,linewidth=3.0,linestyle=&apos;-.&apos;,label=&apos;PHP 再见&apos;) import matplotlib.font_manager as fm font = fm.FontProperties(fname=&apos;font dir .ttf&apos;) plt.legend(loc=&apos;best&apos;) plt.xlabel(&apos;年份&apos;) plt.ylabel(&apos;教程销量&apos;) plt.title(&apos;Python 开发指南&apos;) plt.yticks([1000,100000,1000000],[r&apos;挺好&apos;,r&apos;优秀&apos;,r&apos;火爆&apos;) plt.show() 如要对x轴、y轴进行更细致的控制，可调用 gca 函数来获取坐标轴信息对象，对坐标轴进行控制 对坐标轴的详细控制： import matplotlib.pyplot as plt x = ... plt.yticks([1000,100000,10000],[r&apos;justsoso&apos;,r&apos;good&apos;,r&apos;great&apos;]) ax = plt.gca() ax,xaxis.set_ticks_position(&apos;bottom&apos;) ax.yaxis.set_ticks_position(&apos;left&apos;) ax.spines[&apos;right&apos;].set_color(&apos;none&apos;) ax.spines[&apos;top&apos;].set_color(&apos;none&apos;) ax.spines[&apos;buttom&apos;].set_position((&apos;data&apos;,8000)) plt.show() Matplotlin subplot : 创建子图 subplot(nrows,ncols,index,**kwargs) : nrows: 指定将数据区域分为多少行，ncols ：将数据图区域分为多少列，index 指定获取第几个区域。 subplot 支持直接传入一个三位数的参数， 第一位数为 nrows 参数，第二位数为 ncols，第三位数为 index 参数 import matplotlib.pyplot as plt import numpy as np plt.figure() [More](http://c.biancheng.net/view/2711.html) Matplotlib pie : 绘制饼图 [More](http://c.biancheng.net/view/2713.html) Matplotlib 绘制柱状图 bar 、barh 函数 [More](http://c.biancheng.net/view/2716.html) Matplotlib scatter : 绘制散点图 [More](http://c.biancheng.net/view/2718.html) Matplotlib contour 、 contourf ： 绘制等高线 [More](http://c.biancheng.net/view/2718.html) plot_surface(Axes3D): 绘制3D图形 X、Y数据决定坐标点， Z轴数据决定X、Y坐标点对应的高度 [More](http://c.biancheng.net/view/2720.html) Pygal 模块安装和使用 数据图库，以面向对象的方式创建各种数据图 Pygal 模块安装： 1. pip install pygal 2. python -m pip install pygal 查看文档： python -m pydoc -p 9990 Pygal 数据图入门 生成数据图的步骤： 1. 创建Pygal 数据图对象，不同的数据图提供不同的类，如：柱状图使用pygal.Bar 类， 饼状图：pygal.Pie 类， 折线图：pygal.Line类，等等 2. 调用数据图对象的add 方法添加数据 3. 调用Config 对象的属性配置数据图 4. 调用数据图对象的render_to_xxx 方法将数据图渲染到指定的输出节点 import matplotlib.pyplot as plt import numpy as np from mpl_toolkits.mplot3d import Axes3D fig = plt.figure(figsize=(12, 8)) ax = Axes3D(fig) delta = 0.125 // 生成代表X轴数据的列表 x = np.arange(-3.0, 3.0, delta) 生成代表Y轴数据的列表 y = np.arange(-2.0, 2.0, delta) 对x、y数据执行网格化 X, Y = np.meshgrid(x, y) Z1 = np.exp(-X**2 - Y**2) Z2 = np.exp(-(X - 1)**2 - (Y - 1)**2) 计算Z轴数据（高度数据） Z = (Z1 - Z2) * 2 绘制3D图形 ax.plot_surface(X, Y, Z, rstride=1, # rstride（row）指定行的跨度 cstride=1, # cstride(column)指定列的跨度 cmap=plt.get_cmap(&apos;rainbow&apos;)) # 设置颜色映射 设置Z轴范围 ax.set_zlim(-2, 2) 设置标题 plt.title(&quot;3D图&quot;) plt.show()&quot;&quot;)&apos;&apos;)) Pygal 模块安装和使用 以面向对象的方式创建各种数据图 Pygal 模块安装 1. pip install pygal 2. python -m pip install pygal python -m pydoc -p 9999 Pygal 数据图 使用面向对象的方式生成数据图的步骤： 1. 创建pygal数据图对象，pygal 为不同的图像提供不同的类， 柱状图：pygal.Bar 。 饼状图：pygal.Pie类， 折线图: pygal.Line类 2. 调用数据图对象的add 方法添加数据 3. 调用 Config 对象的属性配置数据图 4. 调用数据对象的render_to_xxx 方法将数据渲染到指定的输出节点 import pygal x_data = [&apos;2011&apos;, &apos;2012&apos;, &apos;2013&apos;, &apos;2014&apos;, &apos;2015&apos;, &apos;2016&apos;, &apos;2017&apos;] y_data = [58000, 60200, 63000, 71000, 84000, 90500, 107000] y_data2 = [52000, 54200, 51500,58300, 56800, 59500, 62700] bar = pygal.Bar() bar.add(&apos;C语言基础&apos;, y_data) bar.add(&apos;Python语言基础&apos;, y_data2) bar.x_labels = x_data bar.title = &apos;编程教程的历年销量&apos; bar.x_title = &apos;年份&apos; bar.y_title = &apos;销量&apos; bar.render_to_file(&apos;fk_books.svg&apos;)&apos;&apos;)&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;)&apos;&apos;)&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;] 虽然没有X、Y轴没有名称，都可通过pygal.Bar 对象来配置，为pygal.Bar对象的title、x_labels、x_title、y_title属性赋值 [More](http://c.biancheng.net/view/2721.html) Pygal 常见数据图：折线图、柱状图、饼图、点图、仪表图、雷达图等 折线图：pygal.Line 类 [More](http://c.biancheng.net/view/2731.html) Python读取csv文件 csv: 以文本存储的表格数据,每行代表一行数据,每行数据中每个单元格内的数据以逗号隔开 使用csv模块读取csv文件: 1. 创建csv模块的读取器 2. 循环调用csv读取器的next方法逐行读取csv文件内容,next返回list列表代表一行数据,list列表的每个元素代表一个单元格数据 import csv filename = &apos;xxx.csv&apos; with open(filename) as f: reader = csv.reader(f) header_row = next(reader) print(hreader_row) first_row next(reader) print(first_row) [More](http://c.biancheng.net/view/2734.html) Python 读取 JSON 文件 JSON格式的数据会被转换为Python的list列表或dict字典 import json filename = &apos;xxx.json&apos; with open(filename) as f: xx_list = json.load(f) for xx_dict in xx_list: if xx_dict[&apos;Year&apos;] == 2016 and xx_dict[&apos;Country Code&apos;] == &apos;CHN&apos;: print(xx_dict[&apos;Country Name&apos;],xx_dict[&apos;Value&apos;]) 调用json的load函数加载JSON数据，返回一个list列表，遍历该list列表即可访问到制定年份、国家的值 Python 读取网络数据 request库和re模块 网络支持库:urllib.通过该库下的request模块向远程发送HTTP请求,获取服务器响应,思路:使用urllib.request 向 网站发送请求,获取该网站的响应,然后使用python的re模块来解析服务器响应,从中获得数据 import re from datatime import datetime from datatime import timedelta from matplotlib import pyplot as plt from urllib.request import * def get_html(city,year,month): url = &apos;http://lishi.tianqi.com/&apos; + &apos;city&apos; + &apos;/&apos; + str(year) + str(month) + &apos;.html&apos; request = Request(url) request.add_header(&apos;User-Agent&apos;,&apos;xx&apos;) response = urlopen(request) return response.read().decode(&apos;gbk&apos;) dates,highs,lows = [], [], [] city = &apos;guangzhou&apos; year = &apos;2019&apos; months = [&apos;01&apos;,&apos;02&apos;,...,&apos;12&apos;] prev_day = datetime(2019,2,14) for month in months: html = get_html(city,year,month) text = &apos;&apos;.join(html.split()) pattern = re,compile(&apos;&lt;divclass=&quot;tqtong&quot;&apos;) ...123@Author : Hale Lv@Created Time : 2019-08-29 13:27:28@Description : Python Scrapy 爬虫框架网络爬虫：自动获取多个页面中的所有天气信息，使用正则表达式、XPath 来提取页面中所有的链接 &lt;a.../&gt;元素，顺着这些链接递归打来对应的页面，然后提取页面中的信息 网路爬虫具体的核心工作： 1. 通过网络向指定的URL发送请求，获取服务器响应内容 2. 使用如正则表达式、XPath等提取页面中需要的信息 3. 高效地识别响应页面中的链接信息，顺着这些链接递归执行第1、2、3步 4. 使用多线程有效地管理网络通信交互 网络爬虫的核心工作: 1. 向URL发送请求,获取服务器响应内容,此核心工作是所有网络爬虫都需要做的通用工作,通用工作由爬虫框架来实现,可提供更稳定的性能.提高开发效率 2. 提取页面中感兴趣的信息.使用XPath提取信息的效率更高,正则表达式效率比较低 3. 识别响应页面中的链接信心,使用XPath效率高,正则表达式则底 4. 多线程管理: 核心工作是通用,由框架完成 Scrapy 是一个专业,高效的爬虫框架.试用专业的Twisted包,基于事件驱动的网络引擎包,使用lxml专业的XML处理包,cssselect高效地提取HTML页面的有效信息,同时也提供了有效的线程管理 Scrapy 安装 pip install scrapy python -m pip install scrapy Scrapy需要依赖的第三方包： 1. pyOpenSSL: 用于支持SSL：Security Socket Layer 2. cryptography: 用于加密的包 3. CFFI ：调用C的接口库 4. zope.interface : 为Python缺少接口而提供扩展的库 5. lxml ：一个处理XML、HTML文档的库，比python内置的xml模块更好用 6. cssselect ： 处理css选择器的扩展包 7. Twisted ： 为python提供的基于事件驱动的网络引擎包 pip install Twisted-xxx-xxx-xxx.whl Scrapy 项目创建 创建一个名为 xxxSplider的项目： scrapy startproject xxxSplider scrapy 是Scrapy框架提供的命令； startproject 是scrapy 的子命令，用于创建项目； xxxSplider是要创建的项目名 scrapy 提供的子命令： startproject: 创建项目 fetch ：从指定URL获取响应 gensplider ：生成蜘蛛 shell ：启动交互式控制台 version : 查看Scrapy版本 项目目录和文件: scrapy.cfg: 项目的总配置文件，无需修改 xxxSplider :项目的Python模块，程序将从此处导入Python代码 xxxSplider/items.py ：用于定义项目用到的Item类，Item是一个DTO数据传输对象，定义N个属性，该类需由开发者来定义 xxxSplider/pipelines.py ：项目的管道文件，负责处理爬取到的信息 xxxSplider/settings.py : 项目的配置文件 xxxSplider/spiders : 存放项目所需的蜘蛛，负责抓取项目感兴趣的信息 Scrapy包含的核心组件： 调度器： 由Scrapy框架实现，负责调度下载中间件从网络上下载资源 下载器： 由Scrapy框架实现，负责从网络上下载数据，下载得到的数据会由Scrapy引擎自动交给蜘蛛 蜘蛛：由开发者实现，负责从下载数据中提取有效信息，提取到的信息会由Scrapy引擎以Item对象的形式转交给Pipeline Pipeline：该组件由开发者实现，该组件接收到Item对象，包含蜘蛛提取的信息后，可将这些信息写入文件或数据库中 Scrapy Shell 调式工具及用法 使用shell调式工具抓取页面中的信息： scrapy shell https://wwww.zhihu.com/xxx/xxx/ 让Scrapy伪装为浏览器，需在发送请求时设置 User-Agent头 scrapy shell -s USER_AGENT=&apos;Mozilla/5.0/xxx/xxx&apos; https://www.zhipin.com/xxx/xxx 使用XPath 或 CSS 选择器提取感兴趣的信息 XPath简化写法： nodename 匹配此节点的所有内容 / 匹配根字节 // 匹配任意位置的节点 . 匹配当前节点 .. 匹配父节点 @ 匹配属性 使用//div匹配页面中任意位置处的&lt;div.../&gt;元素，也可使用//div/span匹配页面中任意位置处的 &lt;div...&gt;元素内的&lt;span.../&gt;子元素 XPath支持谓词，在节点后增加一个方括号，在方括号内放一个限制表达式对该节点进行限制 使用//div[@class]来匹配页面中任意位置处、由class属性的 &lt;div.../&gt;元素，也可使用 //div/span[1]匹配页面中任意位置处的 &lt;div.../&gt;元素内的最后一个 &lt;span.../&gt;子元素 使用 //div/span/[last()]来匹配页面中任意位置处的 &lt;div.../&gt;元素内的最后一个 &lt;span.../&gt;子元素 使用 //div/span[last()-1] 匹配页面中任意位置处的 &lt;div.../&gt;元素内的倒数第二个 &lt;span.../&gt;子元素 XPath : //div[@class=&quot;job-primary&quot;] extract() 提取节点的内容 [More](http://c.biancheng.net/view/2750.html) Scrapy 爬虫项目开发过程详解 步骤： 1. 定义 Item 类，该类仅用于定义项目需要爬虫的N个属性，如：名称、工资、公司等信息，可在items.py 中增加如下类定义： import scrapy class xxSpliderItem(scrapy.Item): title = scrapy.Field() salary = scrapy.Field() company = scrapy.Field() url = scrapy.Field() addr = scrapy.Field() industry = scrapy.Field() publish = scrapy.Field() 2. 编写Spider类，将该Spider 类文件放在spiders目录下， 需要使用XPath或CSS选择器来提取HTML中感兴趣的信息 创建Splider： scrapy genspider [options] &lt;name&gt; &lt;domain&gt; 在命令行中进入xxxSpider 目录下，执行如下命令行创建一个Spider： scrapy genspider job_position &quot;xxx.com&quot; 可在xxSpider项目的xxxSpider/spider 目录下找到一个job_position.py，包含的内容如下： import scrapy class JobPositionSpider(scrapy.Spider): name = &apos;job_position&apos; allowd_domains = [&apos;zhipin.com&apos;] start_urls = [&apos;https://zhipin.com/xxx/xx/&apos;] def parse(self,response): pass 是Spider类的模板，该类的name属性用于指定该Spider的名字，allow_domains用于限制该Spider所爬取的域名，start_urls 指定该Spider会自动爬取的页面URl Spider 需继承scrapy,Spider，并重写parse(slef,response)方法， 注意字符集问题 开发者要做的两件事情： 1. 将要爬取的各页面URL定义在start_urls列表中 2. 在parse(self,response)方法中通过XPath或CSS选择器提取项目感兴趣的信息 import scrapy 3. 编写pipelines.py 文件，该文件负责将所爬取的数据写入文件或数据库中 [More](http://c.biancheng.net/view/2753.html) scrapy 爬虫数据保存到MySQL数据库 将爬虫的信息写入到文件中之外，也可通过修改Pipeline文件将数据库存到数据库中 创建数据库： CREATE TABLE job_inf ( id int(11) not null primary key auto_increment, title varchar(100), salary varchar(100) url varchar(100), ... ) 修改Pipeline文件，将爬取到的信息保存到MySQL数据库中： improt mysql.connector class xxxPipeline(object): def __init__(self): self.conn = mysql.connector.connect(user=&apos;root&apos;,password=&apos;pass&apos;,host=&apos;localhost&apos;,port=&apos;3306&apos;,database=&apos;dbname&apos;,use_unicode=True) self.cur = self.conn.cursor() def close_spider(self,spider): print(&apos;---------close mysql----&apos;) self.cur.close() slef.conn.close() def process_item(self,item,spider): self.cur.execute(&apos;insert into job_inf values(null,%s,%s,%s,%s,...%s)&apos;,(item[&apos;title&apos;],item[&apos;salary&apos;],item[&apos;company&apos;],...item[&apos;xxx&apos;])) self.conn.commit() 程序为该Pipeline类定义了构造器，用于初始化数据库链接、游标，还为该Pipeline类重写了close_spider方法， 负责关闭构造器中初始化的数据库资源 Scrapy 突破反爬虫机制]]></content>
      <categories>
        <category>Python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux]]></title>
    <url>%2F2019%2F08%2F09%2FLinux-Note%2F</url>
    <content type="text"><![CDATA[Linux TODO ListCentos Ubuntu Linux 文件和目录管理cd: 切换目录 cd 选项~ ： 当前用户的主目录 ~用户名：指定用户的主目录 - ： 上次所在的目录 . : 当前目录 ..: 上级目录 pwd：显示当前路径 whoami：当前登陆的用户 ls： 查看目录下文件 ls 选项 文件 -a: 全部文件 -A: 全部不包括. .. -d: 目录本身 -f: 以文件名排序 -F: 再文件或目录后加上类型的指示符号 -h: 以易读方式显示 -i:显示inode节点信息 -n: 以UID和GID代替用户名和群组 -r: 将排序结果反向输出 -R: 列出目录下所有文件 -S: 以文件容量大小排序 -t: 以时间排序 -l: 使用长格式列出文件和目录信息 ls:第一列： 权限 第二列：计数(硬连接数) 第三列：所有者 第四列：所属组 第五列：大小 第六列：文件修改时间 第七列: 文件名和目录名 mkdir：创建目录文件夹 mkdir 选项 文件目录名 -p: 递归创立目录 -m: 自定义目录权限 rmdir: 删除空目录 rmdir 选项 文件目录名 -p：递归删除空目录 rmdir touch：创建文件及修改文件时间戳 touch 选项 文件名 选项： -a：访问时间 -c：时间参数 -d：修订日期 -m：修改时间 -t：修订时间 ln：在文件之间建立链接(硬链接和软链接) ln 选项 源文件 目标文件 -s：建立软链接文件，不加-s 则建立硬链接 -f：强制 如果目标文件存在，则删除后再建立链接文件 cp：复制文件和目录 cp 选项 源文件 目标文件 -a：相当于 -d -p -r 的集合 -d：如源文件为软链接，则复制出的目标文件也为软链接 -i：询问 是否覆盖 -l：把目标文件建立为源文件的硬链接，而不是复制源文件 -s：把目标文件建立为源文件的软连接，而不是复制。。。 -p：复制后目标文件保留源文件的属性 所有者、所属组、权限和时间 -r：递归复制，用于复制父母 -u：若目标文件比源文件有差异，则使用该选项更新目标文件，用于对文件的升级和备用 rm：删除文件或目录 rm 选项 文件或目录 -f： 强制删除 -i: 删除前给出提示 -r： 递归删除，用于目录 mv：移动文件或改名 mv 选项 文件或目录 -f：强制覆盖，不询问，直接覆盖 -i：交互移动，询问是否覆盖 -n：如果目标文件已存在，不会覆盖移动，也不询问 -v: 显示文件或目录移动过程 -u: 若目标文件存在，两者相比，源文件更新，对目标文件进行升级 打包(归档)和压缩tar：打包 tar 选项 源文件或目录 -c：将多个文件或目录打包 -A：追加tar文件到归档文件 -f：指定包的文件名 -v：显示打包过程 -x：对tar包做 解压 -C：指定解压包位置 -z：压缩和解压缩”.tar.gz” -j：压缩和解压缩”.tar.bz2” tar.gz: -zxvf -zcvftar.bz2: -jxvf -jcvf zip: 压缩文件和目录 zip 选项 压缩包名 源文件或源目录列表 -r： 递归压缩目录，所有文件以及目录全部压缩 -m： 压缩后，删除源文件 -v： 显示详细的压缩过程 -q： 不显示命令执行过程 -压缩级别： 1~9 -1 代表压缩速度最快 -9 代表压缩效果更好 -u： 更新压缩文件，往压缩文件添加新文件 unzip：解压zip文件 unzip 选项 压缩包名 -d 目录： 将压缩文件解压到指定目录下 -n： 解压时不覆盖存在的文件 -o： 解压时覆盖已经存在的文件，无需确认 -v： 查看压缩文件的详细信息 -t： 测试有无损坏，并不解压 -x 文件列表: 解压文件，但不包含文件列表中指定的文件 gzip：压缩文件或目录 gzip 选项 源文件 -c：将压缩数据输出到标准输出中，保留源文件 -d：对压缩文件解压 -r：递归压缩指定目录下以及目录下的所有文件 -l：对每一个压缩文件 显示字段 压缩文件大小 未压缩大小 压缩比 未压缩名称 -数字 ：指定压缩等级， -1 等级最低，压缩比最差 gunzip：解压缩文件或目录 gunzip 选项 文件 -r：递归处理，解压缩指定目录下所有文件 -c：把解压缩后的文件输出到标准设备 -f：强制解压缩文件，不理会是否已存在 -l：列出压缩文件内容 -v：显示命令执行过程 -t：测试压缩文件是否正常，不做任何操作 bzip2：压缩文件 bz2格式 bzip2 选项 源文件 -d: 执行解压缩 -k: 解压缩完成后，删除源文件，要保留源文件，需使用此选项 -f：再解压或解压缩时，若同名，默认不覆盖，此选项会强制覆盖现有文件 -t：测试压缩或解压缩的完整性 -v：显示详细信息 -数字： -1 等级最低，压缩比最差 -9 压缩比最高 bunzip2 bz2 格式的及压缩命令 bunzip2 选项 -k: 解压缩后，默认删除压缩文件，若要保留，使用此参数 -f： 解压缩时，若同名，默认不覆盖，若要覆盖，使用此参数 -v： 显示命令执行过程 -L: 列出压缩文件内容 三剑客 grep sed awkcat： 连接文件并打印输出到标准输出设备 cat 选项 文件名 -A：列出所有隐藏符号 -E: 列出每行结尾的回车符$ -n：对输出的所有行进行编号 -b：只对非空行进行编号 -T：把Tab键 ^| 显示 -V：列出特殊字符 -s：连续2行以上的空白行，替换为1行的空白行 &gt;: 合并 &gt;&gt;：追加 more：分屏显示文件内容 more 选项 文件名 -f：计算行数 实际的行数， -p：清屏后显示内容 -c：先显示内容再清楚旧的资料 -s：连续两行以上的空白行，就替换为一行的空白行 -u：不显示下引号 +n：从第n行开始显示文件内容，n代表数字 -n：一次显示的行数，n表示数字 交互指令及功能 h或？： 帮助信息 q或Q ： 退出 v： 在当前行启动一个编辑器 ：f 显示当前文件的文件名和行号 !&lt;命令&gt;：在子shell中执行指定命令 回车：向下移动一行 空格：向上移动一行 Ctrl+l：刷新屏幕 =： 显示当前行的行号 ‘： 转到上一次搜索开始的地方 Ctrl+f： 向下滚动一页 .：重复上次输入的命令 /字符串：搜索指定的字符串 d：向下移动半页 b：向上移动半页 head：显示文件开头的内容 head 选项 文件名 -nK： K表示行数，除了文件最后K行外，显示剩余的全部内容 -cK： K表示字节，除了文件最后K字节，显示剩余全部的内容 -v： 显示文件名 less： 查看文件内容 less 选项 文件名 -N： 显示每行的行号 -S： 行过长时舍弃超出部分 -e： 文件显示结束后，自动离开 -g： 只标志最后搜索到的关键词 -Q： 不使用警告音 -i： 忽略搜索时的大小写 -m： 显示类似more的百分比 -f: 强迫打开特殊文件 -s: 显示连续行为一行 -b： 设置缓冲区的大小 -o： 将less输出的内容保存到指定文件中 -x： 将tab键显示为规定的数字空格 交互指令及功能 / ? n N b d h|H q|Q y 空格键 回车键 PgDn PgUp Ctrl + f Ctrl + b Ctrl + d Ctrl + u j k G g ZZ v [ ] p u tail： 显示文件结尾的内容 tail 选项 文件名 -nK： K指行数，从文件的第K行开始输出 -cK： K指字节数，从文件第K个字节开始输出 -f： 输出文件变化后新增加的数据 grep： 查找文件内容 正则表达式正则表达式的通配符 c* ： 匹配0个空白或多个字符c(c为任一字符) . ： 匹配任何一个字符，只能是一个字符 [xyz]：匹配方括号中的任意一个字符 [^xyz]：匹配除方括号中字符外的所有字符 ^ ： 锁定行的开头 $ ： 锁定行的结尾 需结合反斜杠 \， grep 命令基本格式： grep 选项 模式 文件名 -c ：列出文件中包含模式的行数 -i ：忽略模式中的字母大小写 -l ：列出带有匹配行的文件名 -n ：在每一行的最前面列出行号 -v ：列出没有匹配模式的行 -w ：把表达式当作一个完整的单字符来搜寻，忽略部分匹配的行sed 根据脚本命令处理文本文件中的数据，命令从命令行输入，或存储在一个文本文件中，此命令执行数据顺序： 1.每次仅读取一行内容 2. 根据规格命令匹配并修改数据 3.将执行结果输出sed 选项 脚本命令 文件名 -e 脚本命令： 将其后跟的脚本命令添加到已有的命令中 -f 脚本命令文件： 将其后文件中的脚本命令添加到已有的命令中 -n ： 所有脚本指定执行完毕后，自动输出处理后的内容，需使用print来输出 -i ： 直接修改源文件，慎用！ sed 脚本命令 sed s 替换脚本命令： [address]s/pattern/reloacement/flags address : 指定要操作的具体行 pattern ：需要替换的内容 replacement：要替换的新内容 sed s 命令 flags 标记及功能 n ： 1-512 之间数字，表示指定要替换的字符串出现第n次时才进行替换 g ： 匹配到的所有内容进行替换 p ： 打印与替换命令中指定的模式匹配的行 与-n选项使用 w file ：将缓冲区中的内容写道指定的file文件中 &amp; ： 用正则表达式匹配到的内容进行替换 \n ： 匹配第n个字串，该字串之前在pattern中用 \(\) 指定 \ ： 转义 sed d 替换脚本命令 需要删除文本中的特定行，用d脚本命令，删除指定行中的所有内容，如忘记指定具体行，删删除所有内容 [address]d sed a | sed i 脚本命令 a 表示在指定行的后面附加一行，i表示在指定行的前面插入一行 [address]a(i或) \新文本内容 sed c 替换脚本命令 c 表示将指定行中的所有内容，替换成该选项后面的字符串 [address]c\用于替换的新文本 sed y 转换脚本命令 y 转换命令唯一可以处理单个字符 [address]y/inchars/outchars/ sed p 打印脚本命令 p 搜索符号条件的行，输出该行的内容 [address]p sed w 脚本命令 w 将文本中指定行的内容写入文件 [address]w filename sed r 脚本命令 r 将一个独立文件的数据插入到当前数据流的指定位置 [address]r filename sed q 退出脚本命令 q 使sed命令在第一次匹配任务结束后，退出sed程序sed 脚本命令的寻址方式 两种： 1.[address]脚本命令 2.address{ 多个脚本命令 }awk 文本数据处理工具基本格式： awk 选项 &apos;脚本命令&apos; 文件名 -F fs ：指定以fs作为输入行的分隔符，默认以分隔符为空格或制表符 -f file ：从脚本文件中读取awk脚本指令，取代直接在命令行中输入指令 -v var=val：在执行前，设置一个变量var，初始值为 val awk 使用数据字段变量 $0 ：代表整个文本行 $1 ： 代表文本行的第1个数据字段 $2 : 。。。第2个数据字符按 $n : 代表第n个数据字段 awk 脚本命令使用多个命令 awk &apos;{ $a = &quot;some text&quot; print $0 }&apos; awk 从文件中读取程序 awk -F: -f awk.sh /etc/passwd awk BEGIN 关键字 awk &apos;BEGIN&apos; {print &quot;text&quot;} awk END 关键字 awk &apos;ENG&apos; {print &quot;text&quot;}软件安装相关RPM 包安装、卸载、升级 /etc/ ：配置文件安装目录 /usr/bin/ ：可执行的命令安装目录 /usr/lib/ ：程序所使用的函数库保存位置 /usr/share/doc/ ：基本的软件使用手册保存位置 /usr/share/man/ ：帮助文件保存位置RPM 包的安装 rpm -ivh 包名 -i ：安装(install) -v ：显示详细信息(verbose) -h ：打印 # 显示安装进度(hash) rpm -ivh x.rpm xx.rpm xxx.rpm rpm 选项 包名 -nodeps ： 不检测依赖性安装 -replacefiles ：替换文件安装 -replacepkgs ：替换软件包安装 -force ：强制安装 -test ：测试安装 -prefix ：指定安装路径 软件的启动和管理service 服务名 start | stop | restart | status stat: 启动服务 stop: 停止服务 restart: 重启服务 status: 查看服务状态 检测端口： netstat -tlun | grep 80RPM 包的升级 rpm -Uvh 包名 ： 如没安装过则直接安装 rpm -Fvh 包名 ： 如没有安装，则不安装 RPM 包的卸载 (e 时 erase) rpm -e 包名 RPM 命令查询软件包 (-q, -qa, -i ,-p, -l, -f ,-R ) rpm 选项 查询对象 -q ：表示查询， query -qa ：查询系统中所有安装的软件包 -qi ：查询软件包的详细信息 i = information -ql ：查询软件包的文件列表 -qf ：查询系统文件属于哪个RPM包 -qR ：查询软件包的依赖关系 RPM 包验证和数字证书(数字签名) rpm 包校验 -Va ：校验系统中已安装的软件包 -V ：校验已安装的包名 -Vf ：校验某个系统文件是否被修改 提取RPM包文件(cpio命令) cpio 用于从归档包中存入和读取文件 cpio 选项 -o ： 指 copy-out 模式，把数据备份到文件库中 -v ： 显示备份过程 -c ： 使用较新的protable format 存储方式 -B ： 设定输入/输出块为5120Bytes，而不是模式的512Bytes -i ： 指 copy-in ，把数据从文件库中恢复 -d ： 还原时自动新建目录 -u ： 自动使用较新的文件覆盖较旧的文件 -p ： 指复制模式 YUM 源配置 Yum 源配置文件： /etc/yum.repos.d/ ， 文件扩展名为：”*.repo” 参数： [base]: 容器名称 name：容器说明 mirrorlist：镜像站点 baseurl：源服务器的地址 enable：此容器是否生效， 不写或写enable表示生效，0为不生效 gpgcheck：为1表示RPM的数字证书生效，0为不生效 gpgkey：数字证书的公钥文件保存位置 Yum 查询、安装、升级、卸载 yum list : 列出已安装的和可安装的软件名 yum list 包名 : 查询安装情况 yum search 关键字 : 查找与关键字相关的所有软件包 yum info 包名 : 查询执行软件包的详细信息 Yum 安装命令 yum -y install 包名 install ： 安装 -y ： 自动回答yes Yum 升级命令 yum -y update ： 升级所有软件包 yum -y update 包名 ： 升级特定的软件包 Yum 卸载命令 yum remote 包名 ：卸载指定的软件包 Yum 查询软件组包含的软件 yum groupinfo 软件组名 ： 查询软件组包含的软件 Yum 安装软件组 yum groupinstall 软件组名 ： 安装指定软件组，组名由grouplist查询出来 Yum 卸载软件组 yum groupremove 软件组名 ： 卸载指定软件组 Linux 源码包安装和卸载 首先安装 gcc 和 make rpm -q gcc | yum -y install gcc rpm -q make | yum -y install make 下载源码包，如: xxx.tar.gz 解压： tar -zxvf xxx.tar.gz 进入解压目录 检测系统环境是否符合安装要求： ./configure 定义需要的功能选项： ./configure –prefix=安装路径 执行 ./configure–help 查询支持的功能 编译： make 正式安装软件： make install 重装：在make前，要执行 make clean ，他会清空 Makefile 文件或编译产生的 .o 头文件 Linux 源码包卸载 rm -rf /usr/local/xxx ： 删除软件的安装目录，删除前需停止服务 Linux 源码包快速升级 使用补丁更新源码包： 省去./configure 生成新的 Makefile文件，还省去了编译 Linux 补丁文件的生成和使用 diff 选项 old new -a ： 将任何文档当作文本文档处理 -b ： 忽略空格造成的不同 -B ： 忽略空白行造成的不同 -l ： 忽略大小写造成的不同 -N ： 比较两个目录时，如某个文件只在一个目录，则另一个目录视为空 -r ： 比较目录时，递归比较子目录 -u ： 使用同一输出格式 1. 创建两个文件 mkdir test | cd test | vi old.txt | vim new.txt 2. 利用diff命令，比较两个文件(old.txt 和 new.txt)的不同，并生成补丁文件 (txt.patch)，执行一下代码： diff -Naur /roor/test/old.txt /root/text/new.txt &lt; txt.patch给软件打入补丁 1. 下载补丁文件 2. 复制补丁文件到源码包解压目录中 cp xxx.diff 软件包名 3. 给旧软件打入补丁 cd 软件目录 | vi xxx.diff 4. 重新编译 软件包源码 make 3. 安装 软件 make install Linux 用户和用户组管理UID 和 GID (用户ID 和 组ID) /etc/passwd 系统用户配置文件，存储系统所有用户的基本信息，所有用户有读操作 表达的含义： 用户名： 密码：UID(用户ID) ：GID(组ID) ：描述性信息 ： 主目录 ： 默认Shell 用户名： 代表用户身份的字符串 密 码 ：x 表示此用户设有密码， 真正的密码保存在 /etc/shadow 文件中 UID ： 用户ID，识别不同的用户 0~65535 0 ： 超级用户 1 ~ 499 ： 系统用户 500 ~ 65535 ： 普通用户 GID ： Group ID ，组ID 初始组： 如：建立用户lamp的同时，建立 lamp组作为lamp用户的初始组 附加组： 指用户可以加入多个其他的用户组，并拥有这些组的权限 描述性信息： 主目录： 用户登陆后有操作权限的访问目录，用户的主目录 默认的Shell：Linux的解释器，用户和Linux内核沟通的桥梁，默认 bash /bin/bash/etc/shadow (影子文件) 用户名：加密密码：最后一次修改时间：最小修改时间间隔：密码有效期：密码需要变更前的警告天数：密码过期后的款期时间：账号失效时间：保留字段 忘记密码： 1.重启进入单用户模式， 系统会提供root权限的bash 接口，用 passwd命令修改账号密码； 2.通过挂载根目录，修改 /etc/shadow，将账户的root密码清空/etc/group 用户组配置文件，用户组的所有信息存放在此文件中 组名：密码：GID：该用户组中的用户列表 /etc/gshadow 组名：加密密码：组管理员：组附加用户列表 初始组和附加组 添加新用户： useradd user 添加新群组： groupadd group 将用户xxx加入到xxx群组： usermod -G group user 查找： grep ‘user’ /etc/passwd /etc/group /etc/gshadow 一个用户可以所属多个附加组，但只能有一个初始组 查看用户所属全部群组: gourps/etc/login.defs :创建用户的默认设置文件 useradd ： 添加新的系统用户 useradd 选项 用户名 -u UID : 手工指定用户的UID，UID 不要小于500 -d 主目录 ： 手工指定用户的主目录，必须是绝对路径，注意权限 -c 用户说明 ： 手工指定 /etc/passwd 文件中各用户信息中第5哥字段的描述性内容，可随意配置 -g 组名 ： 手工指定用户的初始组 -G 组名 ： 指定用户的附加组 -s shell ：手工指定用户的登录 Shell ，默认是 /bin/bash -e 日期 ： 指定用户的失效日期 格式为 “YYYY-MM-DD” /etc/shadow 文件的第八个字段 -o ： 允许创建的用户的UID 相同，例如：useradd -u 0 -o usertest -m ： 建立用户时强制建立用户的家目录 -r ： 创建系统用户 UID 在 1 ~ 499 /etc/default/useradd 文件 passwd ：修改用户密码 passwd 选项 用户名 -S ：查询用户密码的状态 = /etc/shadow -l ：暂时锁定用户 -u ：解锁用户 –stdin ：通过管道符输出的数据作为用户的密码，主要用于批量添加用户 -n ： 天数 不能修改密码期限 /etc/shadow 第4个字段 -x ： 天数，设置密码有效期 第5个字段 -w ： 天数 用户密码过期的警告天数 第6个字段 -i ： 日期，用户密码失效日期 第7个字段 usermod ： 修改用户信息 usermod 选项 用户名 -c ： 用户说明：修改用户的说明信息 修改 /etc/paswd 文件目标用户信息的第5个字段 -d ： 主目录： 修改用户的主目录 6 -e ： 日期：修改用户的失效日期 8 -g ： 组名：修改用户的初始组 4 -u ： UID： 修改用户的UID 3 -G ： 组名：修改用户的附加组，把用户加入其他用户组 -l ： 修改用户名称 -L ： 临时锁定用户 -U ： 解锁用户 -s ： shell： 修改用户的登录Shell chage ： 修改用户密码状态 chage 选项 用户名 -l ： 列出用户的详细密码状态 -d ： 日期 /etc/shadow 第3个字段 -m ： 天数 修改密码最短保留天数 第4个字段 -M ： 天数 修改密码的有效期 第5个字段 -W ： 天数 修改密码过期前的警告天数 第6个字段 -i ： 天数 修改密码过期后的宽限天数 第7个字段 -E ： 日期 修改账号失效日期 第8个字段 userdel : 删除用户 userdel -r 用户名 -r : 在删除用户的同时删除用户的家目录 id ： 查看用户的UID 和GID id 用户名 su ： 用户间切换 su 选项 用户名 - ： 当前用户不仅切换为指定用户的身份，刚工作环境也切换为此用户的环境包括 PATH变量、MAIL变量等，可省略用户名，默认为root -l ： 同-，但后面需要添加欲切换的使用者账号 -p ： 切换为指定用户的身份，但不改变当前的工作环境 -m ： 同 -p -c ： 仅切换用户执行一次命令，执行后自动切换回来 su 和 su - 的区别 工作环境 groupadd ： 添加用户组 groupadd 选项 用户 -g GID ： 指定组ID -r ： 创建系统群组 groupmod ： 修改用户组 groupmod 选项 用户名 -g GID ： 修改组ID -n 新组名 ： 修改组名 groupdel ： 删除用户组 groupdel 组名 gpasswd ： 把用户添加进组或从组中删除 gpasswd 选项 组名 ： 选项为空时，给群组设置密码，仅root用户可用 - A user1,… ： 将群组控制权交给 user1，… 等用户管理， 是将 user1，等用户为群组的管理员，仅root用户可用 -M user1，… ：将user1等加入到群组中，仅root可用 -r ： 移除群组的密码，仅root可用 -R ： 让群组的密码失效，仅root可用 -a user ： 将user 用户加入到群组中 -d user ： 将user 用户从群组中移除 newgrp ： 切换用户的有效组 newgrp 组名 权限管理针对不同的用户，设置不同的文件访问权限，包括读、写、删除等 ls -al // 查看文件或目录的权限信息chgrp：修改文件和目录的所属组 chgrp [-R] 所属组 文件名(目录名) -R: 递归 修改 所属组chown：修改文件和目录的所有者和所属组 chown [-R] 所有者 文件后目录 -R: 递归 修改 所有者 chown [-R] 所有者:所属组 文件或目录 权限位 文件权限 3 种， 文件 读(r), 写(w), 执行(x) 每行的第一列表示权限，共11位，第一位表示具体类型，最后以为收SELinux安全规则管理 读、写、执行 共 9 位字符 rw- r– r– // 所有者、所属群组、其他用户 r ： 4 w ： 2 x ： 1 chmod： 修改文件或目录的权限 chmod [-R] 权限值 文件名 -R ：递归 设定 权限 chmod [字母 u、g、o、a ] +|-|= r|w|x 文件或目录 u：用户 g：群组 o：其他 a：所有 +：加入 -：删除 =：设定 umask： 令新建文件和目录拥有默认权限 umask // 默认值：root用户 0022， 普通用户：0002 默认权限由4个八进制数组成，第一个数代表所有者的特殊权限 (SetUID, SetGID, Sticky BIT) 最后3位022 才是真正用到的umask权限 可转换为 — -w- -w- 文件或目录初始权限 = 文件或目录最大默认权限 - umask权限 文件最大默认权限是666：-rw-rw-rw- 666 - 033 = 633 目录最大权限默认是777 drwxrwxrwx 777 - 022 = 755 默认权限修改方法： umask 022 umask 033 ACL 访问控制权限 三种身份： 文件所有者、所属群组、其他用户 三种权限： 读 r 、 写 w 、 访问 x 权限前的字符，表示文件的具体类型，d：目录，-：普通文件，|：表示连接文件，b：设备文件 ACL：Access Control List (访问控制列表)，ACL可实现单一用户设定访问文件的权限，除了传统方式，还可以用ACL进行设定 mount ：查看系统挂载的分区 dumpe2fs -h /dev/sda1 // dumpe2fs 查询指定分区文件系统详细信息 -h：仅显示超级块中的信息，不显示磁盘块组的信息 mount -o remount,acl / // 重新挂载根分区，并加入ACL权限，针对分区 ACL权限设置(setfacl 和 getfacl) getfacl 文件名 // 查看文件或目录设定的ACl权限信息 setfacl 选项 文件名 // 设定用户或群组对指定文件的访问权限 -m ： 设定ACl权限 // setfacl -m u:user:rx /dir -x : 删除指定用户 // setfacl -x u:user /dir -b : 删除所有的ACL权限 // setfacl -b /dir -d ： 设定默认ACL权限 // setfacl -m d:u:user:rwx 文件名 群组: d:g:group:rwx -R : 递归设定ACL权限 // setfacl -m u:user:rwx -R /dir -k ： 删除默认ACL权限 mask： 有效权限 指用户或群组能拥有的最大ACL权限，给用户或群组设定的ACl权限不能超过mask规定的权限范围，超出部分无效 SetUID(SUID)文件特殊权限 仅适用于可执行文件，对设有SUID的文件有执行权限，执行此文件时，会以文件所有者的身份去执行，执行结束，身份的切换也消失 chmod u-s /usr/bin/passwd ： 取消SetUID SUID 特点： 只有可执行文件才能设定SetUID权限，对目录无效 对文件拥有执行(x)权限 执行文件时，以文件所有者的身份执行 SetUID 权限只在文件执行过程有效，执行完毕，也消失 不要轻易设置SetUID权限，有重大安全隐患 Stick BIT (SBIT)文件特殊权限 仅对目录有效，设定SBIT权限，目录下创建的文件和目录，只有自己和root有修改和删除权限 Chattr：修改文件系统的权限属性 chattr [+-=] [属性] 文件或目录 +：添加属性 -：移除拥有的属性 =：设定一些属性 i：对文件设定i属性，不允许删除、改名、添加、修改。 对目录设置i属性，只能修改，不能建立、删除文件 a：文件：只增加数据，不能修改、删除。 目录：在目录中只建立和修改文件，不能删除文件 u：文件或目录：删除时，内容保存，能恢复。防止意外删除文件或目录 s：与u相反，删除文件或目录，会彻底删除，不可恢复 lsattr：查看文件系统属性 lsattr 选项 文件或目录名 -a：不带文件或目录，显示所有文件和目录，包括隐藏 -d: 目录：列出本身的隐藏属性，布列出包含文件或子目录的隐藏属性 -R： 与-d相反， 目录：连同子目录隐藏信息数据一并显示 sudo：系统权限管理 sudo [-b] [-u 新使用者账号] 要执行的命令 -b:将后续的命令放到背景中让系统自行运行，对当前shell无影响 -u： 后面+切换的用户名，无用户名则为root -l： sudo -l，用于显示当前用户可用sudo执行命令 文件系统管理Centos6.3 默认为Ext4 兼容Ext3 最大1EB文件系统和16TB文件 无限数量子目录 Extents 连续数据块概念 多块分配、延迟分配、持久项分配 快速FSCK、日志校验、无日志模式、在线碎片整理、inode增强、默认穷barrier等 支持的文件系统 Ext：最早的文件系统 Ext2：1993年发布，最大支持16TB分区，2TB文件 Ext3：带日志功能 Ext4：上面以写 swap：交换分区，类似虚拟内存，当内存不够时，交换分区代替，必须分区 NFS： 网络文件系统Network File System，本地通过挂载使用远程共享的资源 iso9660：关盘的标准文件下体哦那个 fat： 类windows fatl6文件系统 vfat：类windows fat32文件系统 最大支持32G文曲和4G文件啊你 NTFS： windows 所有，2TB分区 64G文件 ufs：Sun公司系统Solaris SunOS采用的文件系统 proc：内存的虚拟文件系统，/proc sysfs： =proc tmpfs： 基于内存的虚拟文件系统，可使用swap交换分区df：查看文件系统硬盘使用情况 df 选项 目录或文件名 -a：显示所有系统信息 -m: 以MB显示容量 -k：以KB显示 -h: 以KB、MB、GB等自行显示 -T：显示分区的文件系统名称 -i: 不用硬盘容量显示，以含有inode的数量显示du: 统计目录或文件所占磁盘空间大小 du 选项 目录或文件名 -a： 显示每个子文件的磁盘占用量，默认统计子目录的磁盘占用量 -h: 人性化显示磁盘占用量 -s： 统计总磁盘占用量，不列出子目录和子文件的磁盘占用量 mount： 挂载Linux系统外的文件 mount -l：mount显示系统已挂载的设备信息， -l 额外显示卷标名称 -a： 自动检查 /etc/fstab 文件中有无疏漏被挂载的设备文件，有，则自动挂载。开机主动读取/etc/fstab 文件中的内容 mount -t系统类型 -L卷标名 -o特殊选项 -n设备文件名挂载点 -t：系统类型，指欲挂载的文件系统类型：Ext2、Ext3、Ext4等 -L: 卷标名 利用文件系统的卷标名称进行挂载 -n：系统将实际挂载的情况写入 /etc/mtab 文件中。若不写入，使用此选项 -o：特殊选项：可指定挂载的额外选项，如读写权限、同步异步 umount：卸载文件系统 umount 设备文件名或挂载点 fsck：检测和修复文件系统 fsck 选项 分区设备文件名 -a: 自动修复，不提示 -r: 互助的修复模式，会询问 -A： 按照/etc/fstab 配置文件的内容，检查文件内罗列的全部文件系统 -t 文件系统类型： 指定要检查的文件系统类型 -C： 显示检查分区的进度条 -f： 强制检测 -y： 自动修复=-a，但有些文件系统只支持-y dumpe2fs：查看文件系统信息 dumpe2fs -h 文件名 -h： 仅列出superblock(超级块)的数据信息 fdisk： 给硬盘分区 fdisk -l ：列出系统分区 最高支持2TB的硬盘分区 fdisk 设备文件名 创建分区 parted：创建分区 parted 硬盘设备文件名 具体操作见 交互命令 mkfs： 格式化分区(为分区写入文件系统) mkfs -t 文件系统格式 分区设备文件名 mke2fs：格式化硬盘(给硬盘写入文件系统) mke2fs 选项 分区设备文件名 -t 文件系统： 指定格式化为如： ext2、ext3、ext4 -b 字节：指定block大小 -i 字节：指定字节 inode 的比例 -j： 建立带有ext3 日志功能的文件系统 -L 卷标名： 给文件系统设置卷标名 swap： 分区及作用 交换分区 建立swap分区的步骤 1. 分区 fdisk或parted 2. 格式化 mkswap 格式化为 swap分区 3. 使用swap分区 分区：fdisk /dev/sdb 格式化： mkswap /dev/sdb1 使用： 加入swap分区 swapon 分区设备文件名 高级文件系统管理磁盘配额、 LVM(逻辑卷管理)、 RAID(磁盘阵列) 磁盘配额：限制普通用户在分区中使用的容量和文件个数 LVM： 在不停机和不损失数据的情况下修改分区带线啊哦 RAID：有多块硬盘或分区组成，拥有数据冗余功能，在某块硬盘或分区损坏时，硬盘或分区保存的数据不丢失磁盘配额 Linux系统中限制特定的普通用户或用户组在指定的分区上占用的磁盘空间或文件个数 满足磁盘配额的条件： 1. 内核支持 grep CONFIG_QUOTA /boot/conrrfig-2…el6.i686 2. 安装Quota工具 rpm -qa | grep quota 3. 支持磁盘配额的分区必须开启磁盘配额功能 常见概念 用户配额和组配额 磁盘容量限制和文件个数限制 软限制和硬限制 宽限时间 磁盘配额启动的前期准备(设置挂载参数usrquota和grpquota) 添加方式： 1. 手动添加挂载参数： mount -o remout,usrquota,grpquota /home mount | grep home 2. 修改/etc/fstab文件。将挂载参数写入配置中 vi /etc/fstab LABEL = /home /home ext3 defaults.usrquota,grpquota 1 2 umount /home mount -a mount | grep home quotacheck：扫描文件系统并建立Quota记录文件 quotacheck [-avugfM] 文件系统 -a：扫描所有在/etc/mtab 中含有quota支持的filesystem，此参数后边的文件系统可不写 -u：针对使用者扫描文件与目录的使用情况，会创建 aquota.user -g：针对群组扫描文件与目录的使用情况，会创建aquota.group -v：显示扫描的详细过程 -f：强制扫描文件系统，并写入新的quota记录文件 -M：强制以读写的方式扫描文件系统，特殊情况下使用 quotaon：开始磁盘配额限制 quotaon [-avug] quotaon [-vug] 文件系统名称 -a：根据/etc/mtab 文件中对文件系统的配置，启动相关的Quota服务 -u：针对用户启动Quota -g：针对群组启动Quota -v：显示启动服务过程的详细信息 quotaoff：关闭磁盘配额限制 quotaoff [-avug] quotaoff [-vug] 文件系统名称 -a：根据/etc/mtab 文件，关闭已启动的Quota服务，如不使用-a选项，则后面需要明确协商特定的文件系统名称 -u：关闭针对用户启动的Quota服务 -g：关系针对群组启动的Quota服务 -v：显示服务过程的详细信息 edquota：修改用户(群组)的磁盘配额 edquota [-u用户名] [-g群组名] edquota -t edquota -p 源用户名 -u 新用户名 -u 用户名：进入配额的Vi编辑界面，修改针对用户的配置值 -g 群组名：修改针对群组的配置值 -t： 修改配额参数中的宽限时间 -p： 将源用户(或群组)的磁盘配额设置，复制给其他用户(或群组) edquota 命令配额限制信息 文件系统 filesystem：针对哪个文件系统或分区 磁盘容量 blocks： quota自己算的，单位为Kbytes，不要手动修改 磁盘容量的软限制 soft： 超过此限制值，登陆时会收到警告信息 磁盘容量的硬显示 hard： 要求用户使用的磁盘空间不超此限制值，单位为KB 文件数量 inodes： 当文件数量超过此值，会发出警告 文件数量的硬限制 hard： 用户拥有的文件数量不超此值 setquota：非交互式设置磁盘配额 setquota -u 用户名 容量软限制 容量硬限制 个数软限制 个数硬限制 分区名 quota和repquota查询磁盘配额方法 quota 查询用户或用户组的配额 quota 选项 用户名或组名 -u 用户名： 查询用户配额 -g 组名 ： 查询组配额 -v： 显示详细信息 -s： 以习惯单位显示容量大小 如 M、G repquota 查询整个分区的配额情况 repquota 选项 分区名 -a： 依据/etc/mtab 文件查询配额，如不加-a，就得加分区名 -u： 查询用户配额 -g： 查询组配额 -v： 显示详细信息 -s： 以易读单位显示容量大小 LVM逻辑卷管理机制(硬盘分区管理机制)LVM：Logical Volume Manager，逻辑卷管理，Linux下对硬盘分区的一种管理机制 物理卷(Physical Volume, PV)：真正的物理硬盘或分区 卷组(Volume Group, VG)：将多个物理卷组成了卷组，把卷组想象为一块逻辑硬盘 逻辑卷(Logical Volume, LV)：逻辑卷可被格式化和写入数据，可想象为分区 物理扩展(Physical Extend,PE)：PE保存数据的最小单元，默认是4MB 建立LVM的步骤： 1. 把物理硬盘分成分区 2. 把物理分区建立为物理卷PV 3. 把物理卷整合为卷组VG 4. 把卷组划分为逻辑卷LVPV物理卷：创建、查看、删除 1. 建立所需的物理分区，方式使用fdisk交互命令 建立物理卷； pvcreate 设备文件名 查看物理卷： pvscan pvdisplay 删除物理卷： pvremove /dev/sdb7 VG卷组：创建、激活、查看、扩容、减小、删除 建立卷组： vgcreate [-s PE 大小] 卷组名 物理卷名 激活卷组： 激活：vgchange -a y 卷组名 停用：vgchange -a n 卷组名 查看卷组： vgscan ： 查看系统中是否有卷组 vgdisplay： 查看卷组的详细状态 增加卷组容量： vgextend scvg /dev/sdb7 减少卷组容量： vgreduce scvg /dev/sdb7 删除卷组： vgremove scvg LV逻辑卷：创建、查看、调整大小、删除 建立逻辑卷： lvcreate 选项 -n 逻辑卷名 卷组名 -L：容量，逻辑大小，单位为MB、GB、TB -l：个数，按照PE个数指定逻辑大小 -n：逻辑卷名 查看逻辑卷： lvscan ： 查看系统中是否拥有逻辑卷 lvdisplay ： 查看逻辑卷的详细信息 调整逻辑卷大小： lvresie 选项 逻辑卷的设备文件名 -L: 容量 -l: 个数 删除逻辑卷： lvremove 逻辑卷的设备文件名LVM(逻辑卷管理) 删除 RAID(磁盘列阵) 图形界面配置RAID mdadm配置RAID 启动管理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186启动流程： Upstart 启动服务 取代了 System V init 1. 服务器加点，加载BIOS信息，BIOS进行系统检测，依照BIOS设定，找到第一个可以启动的设备(硬盘) 2. 读取第一个启动设备的MBR(主引导记录)，加载MBR中的Boot Loader(启动引导程序，最常见为GRUB) 3. 依照Boot Loader的设置加载内核，内核再进行一遍系统检测，系统一般会采用内核检测硬件的信息，而不一定采用BIOS的自检信息。内核再检测硬件的同时，还会通过加载动态模板的形式加载硬件的驱动 4. 内核启动系统的第一进程，也就是 /sbin/init 5. 由 /sbin/init 进程调用 /etc/init/rcS.conf 配置文件，通过这个配置调用/etc/rc.d/rc.sysint 配置文件。 而/etc/rc.d/rc.sysinit 配置文件是用来进行系统初始化的，主要用于配置计算机的初始化环境 6. 通过/etc/init/rcS.conf 配置文件调用 /etc/inittab 配置文件。 通过 /etc/inittab 配置文件来确定系统的默认运行级别 7. 确定默认运行级别后，调用/etc/init/rc.conf 配置文件 8. 通过/etc/init/rc.conf 配置文件调用并执行 /etc/rc.d/rc 脚本，并传入运行级别参数 9. /etc/rc.d/rc 确定传入的运行级别，然后运行相应的运行级别目录 /etc/rc[0-6].d/ 中的脚本 10. /etc/rc[0-6].d/ 目录中的脚本依据设定好的优先级一次启动和关闭 11. 最后执行/etc/rc.d/rc.local 中的程序 12. 如果是字符界面启动，就可以看到登陆界面，如是图形界面启动，则调用相应的X Window 接口 归纳：BIOS自检 -&gt; 启动GRUB -&gt; 加载内核 -&gt; 执行第一个进程 -&gt; 配置系统初始环境 BIOS 开机自检 通电后，进入BIOS： Basic Input/Ouput System 基本输入/输出系统 BIOS初始化的工作： 1. 检查硬件和外围设备， CPU、内存、风扇灯。 自建过程称为 POST(Power On Self Test) 2. 对硬件进行初始化，规定当前启动设备的先后顺序，选择由哪个设备来开机 3. 选择好开机设备后，会从该设备的MBR(主引导目录)读取Boot Loader(启动引导程序)并执行，启动引导程序用于引导操作系统启动，Linux系统默认使用GRUB 当MBR被加载到RAM之后，BIOS将控制权交给RAM，进入系统第二阶段 [MBR](http://c.biancheng.net/uploads/allimg/181022/2-1Q0221G321149.jpg) 启动引导程序的作用： BIOS作用是自检，从MBR读取启动引导程序。 启动引导程序作用： 1. 加载操操作系统的内核 2. 可选择的系统菜单，如双系统 3. 调用其他的启动引导程序，多系统启动的关键 [启动引导程序](http://c.biancheng.net/uploads/allimg/181022/2-1Q0221G60U34.jpg) Linux内核(内核模块)的加载过程 内存存放位置： /boot 的启动目录中 GRUB加载内核后，内核进行二次系统自检，内核替代BIOS接管Linux启动。 内核完成后，采用动态方式加载每个硬件的模块，模块为硬件的驱动。 initramfe虚拟文件系统 通过initramfs虚拟文件系统再内存中模拟处一个根目录，然后加载SCSI等硬件驱动，可加载真正的跟目录，之后调用Linux的第一个进程/sbin/init 优点： initramfs随着数据的增减自动增减容量 再initramfas和页面缓存之间没有重复数据 initramfs重复利用Linux caching的代码，没有增加内核尺寸 不需要额外的文件系统驱动 [](http://c.biancheng.net/uploads/allimg/181023/2-1Q023093PD60.jpg) Linux /sbin/init 初始化系统环境 内核加载完，完成硬件检测与驱动程序加载后，内核主动呼叫第一个进程/sbin/init, 此配置主要功能准备软件执行的环境：主机名、网络设定、语言、文件系统格式及其他服务的启动 /etc/rc.d/rc.sysinit 配置文件的工作： 获得网络环境和主机类型 测试设备：侦测系统上是否有usb设备，如有主动加载usb驱动程序，并挂载usb文件系统 开机启动画面Plymouth 判断是否启用SELinux 显示开机过程的欢迎画面 初始化硬件 用户自定义模块的加载 配置内核的参数 设置主机名 同步存储器 设备映射器及相关的初始化 初始化软件磁盘阵列(RAID) 初始化LVM的文件系统功能 检验磁盘文件系统(fsck) 设置磁盘配置(quota) 重新以可读写模式挂载系统磁盘 更新quota(非必要) 启动系统虚拟随机数生成器 配置机器(非必要) 清除开机过程中的临时文件 创建ICE目录 启动交换分区(swap) 将开机信息写入 /var/log/dmesg 文件中Linux /etc/inittab：设置(修改)系统默认运行级别 Linux有7个级别： 0 ：关机 1 ：单用户模式，类Windows安全模式，系统修复 2 ：不完全的命令行模式，不含NFS服务 3 ：完全的命令行模式，标准字符界面 4 ：系统保留 5 ：图形模式 6 ：重新启动 runlevel：查看系统的运行级别 系统默认运行级别：/etc/inittab 配置文件功能：确定系统的默认运行级别，即开机进入哪个运行级别 Linux /etc/rc.d/rc.local 配置文件 在 /etc/rc[06].d/ 目录中的程序启动后，系统启动完成。 [启动流程](http://c.biancheng.net/uploads/allimg/181023/2-1Q02310563a22.jpg)Linux 启动引导程序(GRUB)加载内核 GRUB加载内核的过程 加载操作系统的内核 可选择的操作系统菜单 调用其他启动引导程序，实现多系统引导 1. 执行GRUB主引导 1.5 识别不同的文件系统 2. 加载GRUB的配置文件Linux /boot/grub/ 目录分 1. 第一阶段启动引导的主程序 2. 第二阶段为主程序加载配置文件，包括环境参数文件GRUB磁盘分区表示法 ha：硬盘 第一个0：系统查找到的第一块硬盘，第二块为1|2？ 第二个0：硬盘的第一个分区 硬盘 分区 设备文件名 GRUB设备文件名 第一块SCSI硬盘 [内容太多](http://c.biancheng.net/view/1030.html)/boot/grub/grub.conf(GRUB配置文件)内容 [内容太多](http://c.biancheng.net/view/1032.html)多系统并存的GRUB配置文件内容分析 [多系统](http://c.biancheng.net/view/1033.html)GRUB手动安装方法 手动安装GRUB的情况 1. 不使用GRUB作为引导程序，而想要GRUB作为引导程序 2. MBR中的引导程序被覆盖，如安装linux后安windows，引导被覆盖 步骤： 1. 使用grul-install 命令 在启动分区安装GRUB相关文件 2. 修改GRUB的配置文件 3. 安装GRUB到/dev/sdb1分区的启动扇区中Linux GRUB加密方法 启动选项按 e 进入编辑模式，通过命令grub-md5-crypt 模式： 1. 给每个启动菜单加密 2. 给GRUB菜单整体加密 字符界面调整分比率 [文章](http://c.biancheng.net/view/1037.html)Linux内核模块管理(查看、添加、删除) 模块：动态可加载内核模块，有独立功能的程序，可被单独编译，但不能独立运行 安装模块的方法： 1. 在编译内核时，手工调整内核模块功能，加入所需的模块 2. 下载厂商发布的新硬件的驱动模块，或下载驱动程序，在编译 内核模块保存位置与模块保存文件 内核模块保存： /lib/modules/内核版本/kernel/目录中 depmod 选项 -a：扫描所有模块 -A: 扫描新模块，有新模块，更新moudles.dep 文件 -n：扫描结果不写入modules.dep 文件，直接输出到屏幕 内核模块的查看： lsmod 命令指定结果： Module：模块名 Size：模块大小 Used by：模块是否被其他模块调用 内核模块的添加与删除： modprobe 选项 模块名 -l：列出所有模块的文件名，依赖modules.dep文件 -f：强制加载模块 -r：删除模块Linux NTFS文件系统安装 方法有三： 一. 重新编译内核 二. 下载编译内核 三. 第三方插件 NTFS-3G 二. 1.下载内核 2.解压内核 3.生成内核编译所需的.config文件 4.编译模块 5.模块安装 三： 1.下载NTFS-3G插件 2.安装NTFS-3G插件 Linux单用户模块(修改密码、运行级别)方法 如何进入单用户模式： 开机、e 进入GRUB kernel、e 进入编辑界面，然后输入 空格 single，代表启动单用户模式 单用户模式常见错误修复： root密码: 单用户模式、 passwd root 修改系统默认运行级别： 直接修改配置文件/etc/inittab. 系统的默认运行级别只能使用3或5光盘修复模式使用方法： [光盘修复](http://c.biancheng.net/view/1042.html)Linux系统安全性分析 [密码安全](http://c.biancheng.net/uploads/allimg/181024/2-1Q024111633X7.jpg) 系统服务管理服务是后台运行的应用程序，提供本地系统或网络的功能，Service，Daemon：守护神、守护进程 守护进程：为了实现服务、功能的进程，是服务在后台运行的真实进程 系统服务及分类 [服务分类](http://c.biancheng.net/uploads/allimg/181024/2-1Q02413195AP.jpg) 软件安装方式：1. RPM包 2. 源码包 服务分为两种： 独立的服务：可自动启动，不依赖管理服务，如 Nginx服务、FTP服务等 基于Xinetd的服务：依靠管理服务来调用，管理服务是xinetd服务，是系统的超级守护进程，作用：管理不能独立启动的服务，当有客户端请求时，先请求xinetd服务，由xinetd服务去唤醒相对应的服务。查询已安装的服务与区分服务 RPM包默认安装到系统默认位置，可被服务管理命令(service、chkconfig)识别 chkconfig –list 服务名 // 管理RPM包默认安装服务的自启动命令，列出所有服务的自启动状态 Linux端口及查询方法 协议： 面向连接的可靠的TCP协议(Transmission Control Protocol,传输控制协议) 面向无连接的不可靠的UDP协议(User Datagram Protocol, 用户数据报协议) 查询系统中已启动的服务： netstat 选项 -a： 列出系统中所有网络连接，包括：网络服务、监听的网络服务、Socket套接字 -t： 列出TCP 数据 -u： 列出UDP 数据 -l： 列出正在监听的网络服务(不包含已连接的网络服务) -n： 用端口号来显示而不用服务名 -p： 列出该服务的进程ID(PID) 执行结果字段解析： Proto： 数据包的协议 Revc-Q：收到的数据已在本地接受缓冲 Send-Q：对方没有收到的数据包数量 Local Address：本地IP：端口，通过端口知道本机开启的服务 Foreign Address：远程主机：端口， State： 连接状态，已建立连接(ESTABLISED)和监听(LISTEN) PID/Program name: 进程ID和进程命令 Socket套接字的解析： Proto：协议，一般是Unix RefCnt： 连接到此Socket的进程数量 Flags：连接标识 Type： Socket访问类型 State：状态 Listening：监听 Connected：已建立连接 l-Node：程序文件的i节点号 Path：Socket程序的路径、或者相关数据的输出路径 独立服务的启动管理(RPM包的启动与自启动) 两种方式： 1. 使用/etc/init.d/ 目录中的启动脚本来启动独立的服务 /etc/init.d/独立服务名 start|stop|status|restart|… start：启动服务 stop ：停止服务 status：服务状态 restart：重启服务 2. 使用service命令来启动独立的服务 service 只是一个脚本，调用/etc/init.d/ 中的启动脚本来启动独立服务 service 独立服务名 start|stop|restart|… –status-all :列出所有独立服务的启动状态独立服务的自启动管理 三种方式： 1. 使用chkconfig服务自启动管理命令 chkconfig –list // 查询自启动状态 chkconfig –list | grep nginx chkconfig [–level 运行级别][独立服务名][on|off] –level：设定在哪个运行级别中开机自启动(on)，关闭自启动(off) chkconfig –level 2345 nginx on // 修改2345这4个级别为启用 /etc/init.d/nginx status // 查看服务状态 2. 修改 /etc/rc.d/rc.local 文件，设置服务自启动 修改 rc.local 文件，添加服务的启动命令，注：/etc/rc.d/rc.local 和 /etc/rc.local 文件时软连接，修改哪个都可以，这个文件中的命令会在启动时调用 vi /etc/rc.d/rc.local /etc/rc.d/init.d/nginx start # 在文件中加入nginx的启动命令 好处： 1. 集中管理 2. 服务启动唯一性，不管哪种方式都通过 /etc/rc.d/rc.local 文件实现 3. 使用ntsysv 命令管理自启动 ntsysv：调用窗口模式管理服务的自启动 ntsysv [–level 运行级别] ntsysv –level 234 # 设定234级别的服务自启动 Linux基于xinetd服务的管理方法 基于xinetd服务的启动 xinetd 服务的配置文件保存在 /etc/xinetd.d/ 目录中 telnet： /etc/xinetd.d/telnet 如果要启动telnet服务，只需把 /etc/xinetd.d/telnet 文件中的disable=yes 改为 disable=no ，disable:代表取消 基于xinetd服务的自启动 1. 使用chkconfig 命令管理自启动 chkconfig 服务名 on|off 2. 使用ntsysv命令管理自启动 Linux源码包服务管理(启动与自启动) 源码包服务的启动管理： /usr/local/apache2/bin/apachectl start|stop|restart|status|… 源码包服务的自启动管理： vim /etc/rc.d/rc.local // 修改自启动文件 touch /var/lock/subsys/local /usr/local/apache2/bin/apachectl start # 加入源码包服务的标准启动命令 让源码包服务被服务管理命令识别： 1. 卸载RPM包默认安装的apache服务 yum -y remove httpd 2. 安装源码包的apache服务，并启动 /usr/local/apache2/bin/apachectl start netst -tlun | grep 80 3. 让源码包安装的apache服务能被service命令管理启动 ln -s /usr/local/apache2/bin/apachectl /etc/init.d/apache # 把源码包的启动脚本连接到 /etc/init.d/目录中，能被service命令管理 4. 让源码包安装的apache服务能被chkconfig命令管理自启动 vi /etc/init.d/apache # 修改源码包安装的apache服务的启动脚本，此文件是软连接，实际修改的是源码包的启动脚本 chkconfig: 运行级别 启动顺序 关闭顺序 chkconfig –add apache chkconfig –list | grep apache 5. 让ntsysv命令可以管理源码包安装的apache服务 把服务的启动脚本链接到/etc/init.d/目录中，在启动脚本中加入： #chkconfig:运行级别 启动顺序 关闭 #description:说明 然后使用： chkconfig –add 服务名 chkconfig 选项服务名 -add： 把服务加入chkconfig命令的管理中 -del： 把服务从chkconfig命令的管理中删除 chkconfig -del|httpd Linux常见服务类被及功能 acpid： 电源管理接口 anacron： 系统的定时任务，是cron的子系统 alsasound： alsa声卡驱动 apmd： 电源管理模块 atd：指定系统在特定时间执行某个任务，只能执行一次 auditd：审核子系统 autofs：让服务器可自动挂载网络中其服务器的共享数据，挂载NFS服务 avahi-daemon：avahi是zeroconf协议的实现 bluetooth：蓝牙设备支持 capi：仅对ISND设备用户有用 chargen-dgram：使用UDP协议的chargen server，类远程打字功能 chargen-stream： 同上 cpuspeed：调整CPU频率 crond：系统定时任务 cvs：版本控制系统 … More 常见服务 Linux 命令行快捷键Tab：补全 Ctrl + c ： 中断命令或进程 Ctrl + z ： 同 &amp; ，将程序送到后台 Ctrl + d ： 退出终端 Ctrl + l ： 清空终端 Ctrl + a ： 光标移到行首 Ctrl + e ： 光标移到行尾 Ctrl + u ： 擦除整行命令 Ctrl + k ： 擦除所在未到行尾 Ctrl + y ： 粘贴擦除的命令 Ctrl + p ： 查看上一个命令，可看历史命令 Ctrl + n ： 下一个命令 Ctrl + h ： 擦除前面一个字符 Ctrl + r ： 搜索历史命令 Ctrl + 左右键： 在单词间跳转 Ctrl + t ： 交换光标所在处的两个字符的位置 esc + b ： 移到单词的开头 esc + f ： 移到单词的结尾 esc + w ： 删除光标前的字符 esc + t ： 颠倒光标所在处相邻字符位置 Ctrl + x + u ： 按Ctrl 同时按 x u，撤销操作 Bang(!)命令： !! ： 执行上一条命令 ^foo^bar ： 把上一条命令的foo替换为bar，并执行 !wget ： 执行最近的以 wget 开头的命令 !wget:p ： 仅打印最近的以wget开头的命令，但不执行 !$ ： 上一条命令的最后一个参数 !* ： 上一条命令的所有参数 !*p ： 执行上一条命令的所有参数 ^abc ： 删除上一条命令中的abc !-n ： 执行前 n 条命令， eg：!-3 执行前3条命令]]></content>
      <categories>
        <category>Linux</category>
        <category>Ubuntu</category>
        <category>Centos</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP]]></title>
    <url>%2F2019%2F08%2F09%2FPHP-Note%2F</url>
    <content type="text"><![CDATA[iFaithFreedom TODO ListPHP基础PHP进阶PHP高阶More…]]></content>
      <categories>
        <category>PHP</category>
        <category>Laravel</category>
        <category>ThinkPHP</category>
        <category>Yii</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim]]></title>
    <url>%2F2019%2F08%2F09%2FVim-Note%2F</url>
    <content type="text"><![CDATA[iFaithFreedom 6 种模式普通模式 插入模式 可视模式 选择模式 命令行模式 Ex模式 12345678910111213141516171819202122232425262728293031323334- 普通模式dd ndd djdGdggdb dw- 插入模式i I aAxXsS- 可视模式与普通模式相似- 选择模式Ctrl + vShift + v- 命令行模式: ：执行命令/ ：搜索? ：搜索! ：过滤命令- Ex模式与命令行模式相似，在使用 :visual 命令离开Ex模式前，可一次执行多条命令 文件操作1234567filename = x.x-r x.x: -R x.x: + x.x: +n x.x:+ /pattern x.x:-c command x.x 编辑操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162i: 光标所在处插入I: 所在行的第一个非空格符处开始插入o: 光标所在行的下一行输入新的一行O: 光标所在行的上一行输入新的一行a: 光标所在的下一个字符处开始输入A: 光标所在行的最后一个字符处开始输入r: 取代光标所在的那个一字符一次R: 取代光标所在的文字，直到按下 ESC为止查找文本/abc: /^abc:/abc$:?abc:n:N:替换文本r:R::s/x/x1/g::x1,x2s/y1/y2/g::g/x1/x2/g删除文本x: 向后删除一个字符 X: 向前删除一个字符 nx：连续向后删除n个字符dd: 删除光标所在的一整行ndd: 删除光标所在的向下n行dG: 删除光标所在到最后一行的所有数据d$: 删除光标所在处到最后一个字符d0: 删除光标所在处到该行的最前面一个字符D: 删除光标末尾的字符:x1,x2dp: 粘贴被删除的文本内容复制文本p: 粘贴通过复制下的行数和字符P: 会增加行数yy: 复制光标所在的那一行nyy: 复制光标所在的向下n行y1G: 复制光标所在行的第一行的所有数据y0: 复制光标所在的那个字符到该行行首的所有数据y$: 复制光标所在的那个字符到该行行尾的所有数据yw: J: 将光标所在行与下一行的数据结合成同一行c: 重复删除多个数据u: 复原前一个动作Ctrl+r: 重做上一个动作保存退出:wq 保存并退出:wq! 强制保存并退出:q 离开vim:q! 强制退出不保存:w 将文本保存:w! 若文件为只读时，强制写入该档案。但取决于权限:w xxx.xx: 将编辑的数据保存成另一个档案，类似于另存:x! :n1,n2 w filename : 将n1到n2的内容存储成filename这个档案ZZ: 文件没有改动，则不保存离开，若改动，则保存后离开:! command: 暂时离开vim到指令模式下执行命令 方向键1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950h : 向左 H : 屏幕上方那一行的第一个字符j : 向下 M : 屏幕中央那一行的第一个字符k : 向上 L : 屏幕下方...l : 向右 G : 移到档案的最后一行Ctrl + f : 屏幕向下一页Ctrl + b : 屏幕向上一页Ctrl + d : 屏幕向下移动半页Ctrl + u : 屏幕向上移动半页+ : 光标移动到非空格符的下一行- ： 光标移动到非空格符的上一行n&lt;space&gt; : n 表示数字，按下数字再按空格键光标以单词位单位移动w|W : b|B :e|E :nw|nW :nb|nB :光标移动至行首或行尾0 | ^ : 光标移动到行首$ : 光标移动到行尾n$ : 光标移动到指定字符fx :Fx :光标移动到指定行gg : 移到档案第一行G : 移到档案最后一行nG : 移动到档案的第n行:n : 光标向下移动n行光标移动到匹配的括号处% : 将光标先定位到 &quot;&#123;&quot; ,然后再使用 &quot; % &quot; 命令，可定位到 &quot; &#125; &quot; 批量注释和自定义注释快捷键s/^/#/g :eg: :1,10s/^/#/g :取消连续行注释:1,10s/^#//g ::map 快捷键 执行命令 Vim map Vim]]></content>
      <categories>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git]]></title>
    <url>%2F2019%2F08%2F09%2FGit-Note%2F</url>
    <content type="text"><![CDATA[iFaithFreedom Git建Git仓库两种场景： 1. 把已有的项目代码纳入Git管理cd 项目代码所在的文件夹git init 2. 新建的项目直接用Git管理cd 某个文件夹git init your_project # 会在当前路径下创建和项目名称同名的文件夹cd your_project Git 分离头指针在没有绑定分支的情况下，git status 会显示 HEAD， 后面需要 git branch xxx head_id 如果没有保存，会被当作垃圾清理掉HEAD branchgit checkout -b xxx yyy // 基于yyy 创建 xxx 分支 HEAD 可脱离分支，独立存在git diff // 比较两个commit 的不同 git diff HEAD HEAD^ | HEAD～n 查看不同提交的指定文件的差异git diff 分支1 分支2 -- 文件 // 比较不同分支的差异 git diff 分支指针1 分支指针2 -- 文件 // 用分支比较文件的差异正确删除文件的方法git rm xxx // 删除xxx 文件开发中临时加塞了紧急任务的处理方法git stash // 把现在做的工作任务存放到不影响接下来要做的工作环境中去 git stash list // 查看所有的stash 任务的列表 git status git stash apply // 弹出最新的stash， 不保留stash 的任务 git stash pop // 弹出最新的stash 工作，存放起来的任务还在指定不需要Git管理的文件.gitignore // 文件中添加不需要被提交的文件类型将Git仓库备份到本地git clone --bare // 不在工作区的仓库 哑协议： git clone --bare 本地仓库.git 新建仓库name.git添加公钥到Github SSH and GPG keys在Github 创建个人仓库把本地仓库同步到Githubgit remote add xxx git@github.com:aspire_8/xxx.git // 新增远程Github仓库 git remote remove xxx // 删除远程Github仓库 git remote rename oldName newName // 更改远程Github仓库的名称 git push xxx -all // 提交本地所有分支到远端一般出错的情况在推送前，需要先 拉取 远程仓库到本地 git pull // 拉取远程到本地并且合并，等同于 git fetch + git merge git fetch // 仅仅把远端的拉到本地 git merge 远端分支/本地分支(master) // 合并分支把不相干的两个分支合并git merge --allow-unrelater-histories 远端仓库/本地仓库不同人修改了同文件的不同区域的处理方案git push不同人修改了同文件的同一区域的处理方案global: git pull vim xxx.xx git push local : git pull vim xxx.xx git push 会出错，local没办法提交，解决方案 vim xxx.xx // 把修改的同一地方，删除其中一个人的修改，删除git的提示信息 git status -&gt; git commit -am &apos;解决冲突&apos; -&gt; git push同时变更了文件名和文件内容的处理方案global 在更改同一文件名和内容之后 local 在本地修改文件内容， git pull 的时候，git会弹出界面提示修改的信息，同时也会在被更改文件中，添加local修改的内容 把同一文件改成不同文件名的处理方案global: 修改xxx.xx 为 xxxa.xx，local: 修改 xxx.xx 为 xxb.xx global: git push local: git pull , git rm xxx.xx, git rm xxa.xx, git add xxb.xx, git commit -m &apos;delete xxx.xx xxa.xx&apos; git push禁止向集成分支执行push -f 操作git push -f 示例: git log --oneline // 查看历史日志 git reset --hard commitID // 在本地使用reset 恢复到 任意一个commit的历史，如果使用 -f 提交的话，远程仓库所有被提交的commit之前的改动都会被删除掉，很危险！！！ 禁止向集成分支执行变更历史的操作123@Author : Hale Lv@Created Time : 2019-08-31 19:27:26@Description : GitGit 简介最先进的分布式版本控制系统 安装 Git Linux： Centos: yum install -y git Ununtu: apt install -y git 配置： git config --global user.name &apos;Hale&apos; git config --global user.email &apos;Aspire_8@163.com&apos; 创建版本库 创建仓库文件夹： mkdir Git cd Git 初始化仓库：git init // 初始化仓库，把这个目录变成Git可管理的仓库 添加文件到仓库： git add xxx.xx 编写提交信息： git commit -m &apos;xxxxx&apos;版本版本回退： 查看仓库当前的状态：git status 比较文件修改的不同：git diff xxx.xx 查看历史记录： git log git log --pretty=oneline // 简化输出的日子信息 回退到上一个版本： git reset --hard HEAD^|Commit_ID Git命令历史： git reflog 工作区和暂存区 工作区： 管理修改 如新建一个文件：readme.txt git add readme.txt vim readme.txt 修改readme.txt 文件 git commit -m &apos;add readme.txt&apos; git status 比较工作和版本库文件的区别： git diff HEAD --readme.txt 撤销修改 git status 把readme.txt在工作去的修改全部撤销 git checkout -- file git checkout -- readme.txt git add readme.txt git status 把暂存区的修改撤销掉，从新放回工作区： git reset HEAD readme.txt git status 丢弃工作区的修改： git checkout -- readme.txt 删除文件 git add readme.txt git commit -m &apos;add readme.txt&apos; rm readme.txt git status git rm readme.txt git commit -m &apos;remove readme.txt&apos; 把误删的文件回复到最新版本: git checkout -- readme.txt远程仓库ssh-keygen -t rsa -C &apos;aspire_8@163.com&apos; cat ~/.ssh/id_ras.pub 复制公钥到github SSH-KEY 添加远程库 git remote add origin git@github.com:i-china/2048.git git remote add origin git@github.com:i-china/1024.git 推送本地库所有内容到远程库 git push -u origin master // 把当前分支master推送到远程 git push origin master git push 从远程库克隆 git clone git@github.com:i-china/4096.git分支管理 创建与合并分支 git checkout -b dev // 创建dev分支，并切换到dev分支 = git branch dev =+ git ckekout dev 查看当前分支 git branch git checkout master 把dev分支的工作成果合并到master分支： git merge dev 删除分支 git branch -d dev Switch 创建并切换到新的dev分支： git switch -c dev 直接切换到已有master分支： git switch master 解决冲突 创建新的分支 dev git checkout -b new 编写readme.txt内容 git add readme.txt 切换到master分支 git checkout master 编写readme.txt内容 git add readme.txt 把各自修改合并起来 git merge dev 此时会报冲突 git status 查看readme.txt 文件内容 Git 用 &lt;&lt;&lt;&lt;&lt; ===== &gt;&gt;&gt;&gt;&gt; 标记不同分支的内容，修改保存即可 git add readme.txt git log 删除dev分支 git branch -d dev 查看分支合并图 git log --graph 分支管理策略 git checkout -b dev git add readme.txt git checkout master git merge --no-off -m &apos;merge with no-off&apos; dev git log Bug 分支 git status git stash git checkout master git checkout -b issue-dev git add readme.txt git checkout master git merge --no-off -m &apos;merged bug fix dev&apos; issue-dev git checkout dev git status git stash list git stash apply | git stash pop git stash list 复制一个特定的提交到当前分支 git branch git cherry-pick commit_id Feature 分支 git checkout -b work git add readme.txt git commit -m &apos;add readme.txt&apos; git checkout dev 删除work 分支 git branch -d work 强行删除 git branch -D work 多人协作 git remote git remote -v git push origin master git push origin dev 抓取分支 git clone git@github.com:i-china/2048.git git branch git checkout -b dev origin/dev git add readme.txt git push origin dev git pul git branch --set-upstream-to=origin/dev dev git pull git commit -m &apos;fix dev readme.txt&apos; git push origin dev Rebase git log --graph --pretty=oneline --abbrev-commit git push origin master git pull git staus git log --graph --pretty=oneline --abbrev-commit git rebase git log --graph --pretty=oneline --abbrev-commit git push origin master git log --graph --pretty=oneline --abbrev-commit 标签管理 创建标签： git branch git checkout master git tar v1.0 git tag git log --pretty=oneline --abbrev-commit git tag v0.9 &lt;commit_id&gt; git tag git show v0.9 git tag -a v1.0 -m &apos;version 1.0 released&apos; &lt;commit_id&gt; git show v1.0 操作标签 删除标签： git tag -d v1.0 git push origin v1.0 git push origin --tags 删除本地标签： git tag -d v0.9 删除一个远程标签 git push origin :refs/tags/v0.9使用码云git remote add origin git@gitee.com:aspire_8/2048.git git remote -v git remote rm origin git remote add github git@github.com:i-china/2048.git git remote -v git remote rm origin git remote add gitee git@gitee.com:aspire_8/4096.git git remote -v git push origin master git push gitee master自定义Git git config --global color.ui true 忽略特殊文件 .gitignore *.xx git add remade.xx git add -f readme.xx git check-ignore -v readme.xx 配置别名 git config --global alias.st status git config --global alias.ci commit git config --global alias.br branch git config --global alias.unstage &apos;reset HEAD&apos; git config --global alias.last &apos;log-l&apos; 把配置别名放在一个文件中，方便管理 cat ~/.git/config vim ~/.git/config [alias] last = log -1 co = checkout ci = commit br = branch st = status [user] name = Hale email = Aspire_8@163.com 搭建Git服务器 apt install git adduser git 收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个。 git init --bare git.git chown -R git:git git.git git clone git@server:/srv/git.git [Git Cheat Sheet](https://gitee.com/liaoxuefeng/learn-java/raw/master/teach/git-cheatsheet.pdf)]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生活日记]]></title>
    <url>%2F2019%2F08%2F08%2FLife-Note%2F</url>
    <content type="text"><![CDATA[Hale's Life 记： 七夕节，回家做晚饭，吃完饭大概八点多，躺了一会，出去散了个步，回到家十点半，洗了个澡，十一点。然后闲着无聊，开始着手部署博客项目。到现在是8.8号凌晨 两点多。阿哈，真累！ 以后要养成记笔记的习惯，哈哈，不然学会的东西很快就会忘记的额～！]]></content>
      <categories>
        <category>Life</category>
        <category>Year</category>
        <category>Month</category>
        <category>Day</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
</search>
