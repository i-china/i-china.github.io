<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>iFaithFreedom</title>
  
  <subtitle>文能提笔安天下，武能上马定乾坤</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-03T13:22:14.669Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>&lt;center&gt; Hale Lv &lt;/center&gt;</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis</title>
    <link href="http://yoursite.com/2019/09/03/Redis-Note/"/>
    <id>http://yoursite.com/2019/09/03/Redis-Note/</id>
    <published>2019-09-03T13:20:43.000Z</published>
    <updated>2019-09-03T13:22:14.669Z</updated>
    
    <content type="html"><![CDATA[<center> iFaithFreedom </center><a id="more"></a><h3 id="TODO-LIST"><a href="#TODO-LIST" class="headerlink" title="TODO LIST"></a>TODO LIST</h3><p>Redis</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Author : Hale Lv</span><br><span class="line">@Created Time : 2019-09-02 21:45:06</span><br><span class="line">@Description :</span><br></pre></td></tr></table></figure><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><pre><code>Redis 具备一定持久层的功能，也可作为一种缓存工具，作为持久层，存储的数据是半结构化的，即在读入内存中有更少的规则，读入速度更快Redis成为NoSQL工具的原因：    1. 响应快速    2. 支持6中数据类型        字符串、哈希结构、列表、集合、可排序集合、基数    3. 操作都是原子的        所有redis的操作都是原子的    4. MultiUtility 工具        可以在如缓存、消息传递队列中使用Redis支持发布+订阅的消息模式</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;center&gt; iFaithFreedom &lt;/center&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Socket</title>
    <link href="http://yoursite.com/2019/08/29/Socket-Note/"/>
    <id>http://yoursite.com/2019/08/29/Socket-Note/</id>
    <published>2019-08-29T13:58:04.000Z</published>
    <updated>2019-09-02T13:30:15.057Z</updated>
    
    <content type="html"><![CDATA[<center> iFaithFreedom </center><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Author : Hale Lv</span><br><span class="line">@Created Time : 2019-08-29 21:26:32</span><br><span class="line">@Description :</span><br></pre></td></tr></table></figure><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><pre><code>socket： 套接字，通信技术就是两台联网的计算机之间交换数据的技术。    原意是插座，是计算机之间进行通信的一种约定或一种方式。 通过socket，计算机可接收、可发送数据        典型应用：web服务器和浏览器：浏览器获取用户输入的URL，向服务器发起请求，服务器分析接收到的URL，将对应的网页内容返回给浏览器，浏览器再经过解析和渲染，将文字、图片、视频元素呈现给用户    为了表示和区分已经打开的文件，Linux给每个文件分配一个ID整数，被称为：文件描述符File Descriptor如：        0： 输入文件 stdin，键盘    1:    输出文件 stdout ，显示器        网络连接也是一个文件，也有文件描述符            socket() 创建网络连接，打开一个网络文件，返回值即文件描述符。有文件描述符，即可使用普通的文件操作函数来传输数据，如：                read() ：读取从远程计算机传来的数据                write()：向远程计算机写入数据    Windows 系统中的socket         Windows：文件句柄                Liunx ： 文件描述符</code></pre><h3 id="套接字的类型，socket的类型"><a href="#套接字的类型，socket的类型" class="headerlink" title="套接字的类型，socket的类型"></a>套接字的类型，socket的类型</h3><pre><code>    有很多如：DARPA Internet 地址： Internet套接字、 本地节点的路径名：Unix套接字，CCITT X.25地址：X.25套接字等。    Internet 套接字：最常用、具有代表性    Internet套接字的数据传输方式：        1. 流格式套接字 SOCK_STREAM            流格式套接字：Stream Sockets 也叫&quot;面向连接的套接字&quot;，使用SOCK_STREAM 表示            SOCK_STREAM： 是一种可靠、双向的通信流数据。可准确无误到达另一台计算机，可损坏或丢失、可重新发送            SOCK_STREAM 的特征：                1. 数据在传输过程中不会消失                2. 数据是按照顺序传输的                3. 数据的发送和接收不是同步的。也成 不存在数据边界                使用TCP协议 The Transmission Control Protocol，传输控制协议，TCP控制数据按照顺序到达并且没有错误                IP Internet Protocol 网络协议，控制数据如何从源头到达目的地，即路由        2. 数据报格式套接字 SOCK_DGRAM            数据报格式套接字 Datagram Sockets 也叫 无连接的套接字，使用SOCK_DGRAM表示                只管传输数据，不做数据校验，如损坏或丢失，不补救，无法重传。            SOCK_DGRAM 的特征：                1. 强调快速传输而非传输顺序                2. 传输的数据肯跟丢失或损坏                3. 限制每次传输的数据大小                4. 数据的发送和接收是同步的，存在数据边界            SCOK_DGRAM：是一种不可靠、不按传序传递的、以追求速度为目的的套接字                使用UDP协议 User Datagram Protocol 用户数据报协议面向连接和无连接的套接字    流格式套接字Stream Sockets： 面向连接的套接字，基于TCP协议    数据报格式套接字 Datagram Sockets： 无连接的套接字，基于UDP协议        无连接的套接字            每个数据包可选择不同的路径            每个数据包之间是独立的        面向连接的套接字            路径是由路由器维护的，所有路由器都要存储该路径的信息    优缺点：        无连接套接字传输效率高，不可靠、丢失数据报、捣乱数据        有连接套接字可靠、传输效率低，耗费资源    有连接的套接字TCP：HTTP、FTP等    无连接的套接字UDP：DNS、即时聊天工具等</code></pre><h3 id="OSI-网络七层模型"><a href="#OSI-网络七层模型" class="headerlink" title="OSI 网络七层模型"></a>OSI 网络七层模型</h3><pre><code>    OSI模型:Open System Interconnection： 开发式系统互联        七层：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层        TCP/Ip 模型： 网络接口层、网络层、传输层、应用层            网络接口：针对不同物理网络的连接形式的协议，如：Ethernet、FDDI、ATM            网络层：负责数据的传输，路径及地址选择，常用协议：IP ARP(地址解析协议)            传输层：确认数据传输及进行纠错处理，常用协议：TCP、UDP(用户数据报协议)            应用层：各种服务及应用程序通过该层利用网络，常用协议：HTTP、FTP、SMTP(简单邮件传输协议)等            发送数据包时，程序或软件是通过应用层访问网络，产生的数据会一层一层往下传输，到最后的王略接口层，通过网线发送到网上，每传一层，协议增加一层包装，比原始数据多了四层包装。            接收数据包时：从网络接口层一层一层网上传，每传一层就拆开一层包装，到最后的应用层，最原始的数据。            socket：在传输层的基础上，使用TCP/IP协议，不能访问网页，访问网页需要HTTP协议        计算机通信的原则：            1. 同一层次进行通信，            2. 功能必须相同            3. 数据只能逐层传输，不能跃层            4. 可使用下层提供的服务，并向上层提供服务TCP/IP协议族    协议： Protocol 是网络通信过程中的约定或合同，双方必须都遵守才能正常收发数据。 协议是一种规范，通信双方需使用同一协议才能通信，    TCP/IP模型包含 TCP、IP、UDP、Telnet、FTP、SMTP等    TCP/UDP:![SOCKET](http://c.biancheng.net/uploads/allimg/190126/1-1Z126104435N0.gif)开放式系统 Open System    以多个标准为依据设计的系统称为开放式系统</code></pre><h4 id="IP、MAC和端口号-网络通信中确认身份信息的三要素"><a href="#IP、MAC和端口号-网络通信中确认身份信息的三要素" class="headerlink" title="IP、MAC和端口号 - 网络通信中确认身份信息的三要素"></a>IP、MAC和端口号 - 网络通信中确认身份信息的三要素</h4><pre><code>IP地址    是 Internet Protocol Address ，网际协议地址Mac地址     是 Media Access Control Address , 媒体访问控制地址，称为局域网地址LAN Address，以太网地址 Ethernet Address 或 物理地址Physical Address端口号    Port Number 为每个网路程序分配一个独一无二的端口号    是一个虚拟的、逻辑上的概念</code></pre><h3 id="Linux-下的Socket-演示程序"><a href="#Linux-下的Socket-演示程序" class="headerlink" title="Linux 下的Socket 演示程序"></a>Linux 下的Socket 演示程序</h3><pre><code>服务器端代码server.cpp:    #include &lt;stdio.h&gt;    #include &lt;string.h&gt;    #include &lt;stdlib.h&gt;    ...    int main() {        int serv_sock = socket(AF_INET,SOCK_STREAM,IPPROPT_TCP);        struct sockaddr_in serv_addr;    }...[SOCKET CPP](http://c.biancheng.net/view/2128.html)</code></pre><h3 id="WSAStartup-函数以及DLL的加载"><a href="#WSAStartup-函数以及DLL的加载" class="headerlink" title="WSAStartup() 函数以及DLL的加载"></a>WSAStartup() 函数以及DLL的加载</h3><pre><code>[More](http://c.biancheng.net/view/2130.html)</code></pre><h3 id="Socket-函数用法：创建套接字"><a href="#Socket-函数用法：创建套接字" class="headerlink" title="Socket() 函数用法：创建套接字"></a>Socket() 函数用法：创建套接字</h3><pre><code>Linux 下的Socket函数使用&lt;sys/socket.h&gt; 头文件中socket函数创建套接字，原型为：int socket(int af, int type, int protocol);    1. af: 地址族 Address Family， IP地址类型，常用AF_INET：表示IPv4地址 和 AF_INET6：表示IPv6地址，    2. type 为数据传输方式/套接字类型，常用： SOCK_STREAM 流格式套接字/面向连接套接字 和 SOCK_DGRAM 数据套接字/无连接的套接字    3. protocol 表示传输协议，常用： IPPROTO_TCP 和 IPPROTO_UDPTCP：    int tcp_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);UDP:    int udp_socket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);将 protocol的值设为0， 系统可自动推演出使用的协议：    int tcp_socket = socekt(AF_INET, SOCK_STREAM, 0)    // TCP    int udp_socket = socket(AF_INET, SOCK_DGRAM,  0)    // UDPbind() 和 connect()函数：绑定套接字并建立连接    使用 bind函数将套接字与特定的IP地址和端口绑定起来，    bind 函数原型：        int bind(int sock, struct sockaddr * addr, socklen_t addrlen);    //linux        int bind(SOCKET sock, const struct sockaddr * addr, int addrlen);    // windows        [More](http://c.biancheng.net/view/2344.html)listen accept : 让套接字进入监听状态并响应客户端请求    listen 函数：让套接字进入被监听状态，原型：        int listen(int sock, int backlog);    //linux        int listen(SOCKET sock, int backlog);    // windows            sock: 进入监听状态的套接字， backlog： 请求队列的最大长度[More](http://c.biancheng.net/view/2345.html)</code></pre><h4 id="send-recv-和write-read-发送数据和接收数据"><a href="#send-recv-和write-read-发送数据和接收数据" class="headerlink" title="send()/recv()和write()/read(): 发送数据和接收数据"></a>send()/recv()和write()/read(): 发送数据和接收数据</h4><pre><code>Linux 下数据的接收和发送    [More](http://c.biancheng.net/view/2346.html)        </code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Author : Hale Lv</span><br><span class="line">@Created Time : 2019-09-02 09:45:17</span><br><span class="line">@Description :</span><br></pre></td></tr></table></figure><h2 id="图解TCP数据报结构以及三次握手"><a href="#图解TCP数据报结构以及三次握手" class="headerlink" title="图解TCP数据报结构以及三次握手"></a>图解TCP数据报结构以及三次握手</h2><pre><code>TCP： Transmission Control Protocol，传输控制协议。 一种面向连接的、可靠的、基于字节流的通信协议，数据在传输前要建立连接，完毕后要断开连接客户端在收发数据前要使用connect 函数和服务器建立连接，建立连接的目的是保证IP地址、端口、物理链路等正确无误，为数据的传输开辟通道TCP建立连接时要传输三个数据包，俗称：三次握手 Three-way Handshaking ：    [Shake 1]套接字A： &quot;你好，套接字B，我这里有数据包传给你，建立连接吧&quot;    [Shake 2]套接字B：&quot;好的，这边已经准备就绪&quot;    [Shake 3]套接字C：&quot;谢谢你受理我的请求&quot;    TCP三次握手:![三次握手](http://c.biancheng.net/uploads/allimg/190219/1155315343-0.jpg)    图片中带阴影的字段说明：        1. 序号： Seq： Sequence Number ： 序号占32位，用来识别从计算机A发送到计算机B的数据包的序号，计算机发送数据时对此进行标记        2. 确认号：Ack：Acknowledge Number： 确认号占32位， 客户端和服务器端都可以发送， Ack=Seq+1        3. 标志位： 每个标志位占用1Bit， 共有6个，分别为：URG、ACK、PSH、RST、SYN、FIN，具体含义：            URG： 紧急指针urgent pointer 有效            ACK： 确认序号有效            PSH： 接收方应该尽快将这个报文交给应用层            RST： 重置连接            SYN： 建立一个连接            FIN： 断开一个连接            Seq 是 Sequence 的缩写，表示序列； Ack 是 Acknowledeg 缩写，表示确认； SYN 是 Synchronous 的缩写， 愿意是 同步的， 表示建立同步连接； FIN是Finish的缩写，表示完成    连接的建立(三次握手)        使用Connect 建立连接        Three-hand: ![Hands](http://c.biancheng.net/uploads/allimg/190219/1155312401-1.jpg &quot;Three-Hands&quot;)        客户端调用socket 函数创建套接字后，因没建立连接，所以套接字处于CLOSED状态，服务器调用listen函数后，套接字进入LISTEN状态，开始监听客户端请求        客户端开始发起请求：            1. 当客户端调用connect 函数后，TCP协议会组建一个数据包，并设置SYN标志位，表示该数据包用来建立同步连接的，同时生成一个随机数字1000， 填充 序号Seq 字段，表示该数据包的序号。完成这些工作，开始想服务器端发送数据包，客户端进入SYN-SEND状态            2. 服务器端收到数据包，检测到已经设置了SYN标志位， 检测到是客户端发来的建立连接的请求包，服务器也组建一个数据包， 并设置SYN和ACK标志位，SYN表示该数据包用来建立连接，ACK用来确认收到刚才客户端发送的数据包            服务器生成一个随机数2000，填充 序号 Seq 字段，2000 和客户端数据包没有关系            服务器将数据包发出，进入SYN-RECV状态            3. 客户端收到数据包，检测到已经设置 SYN 和ACK 标志位， 检测到服务器发来的 确认包， 客户端检测 确认号 Ack 字段，看值是否为1000+1，如是说明连接成功            客户端将数据包发出，进入ESTABLISED状态，表示连接已经成功建立            4. 服务器端收到数据包，检测到已经设置ACk标志位，知道是客户端发来的 确认包，服务器会检测 确认号Ack字段， 看值是否为2000+1，如是说明连接建立成功，服务器进入ESTABLISED状态            至此，客户端和服务器都进入ESTABLISED状态，连接建立成功，接下可收发数据    最后的说明：        三次握手的关键是要确认对方收到了自己的数据包，目标就是通过 确认号 Ack 字段实现的，计算机会记录下自己发送的数据包序号Seq，待收到对方的数据包后，检测 确认号Ack字段，看Ack = Seq + 1 是否成立， 如成立说明对方正确收到了自己的数据包</code></pre><h3 id="TCP数据的传输过程"><a href="#TCP数据的传输过程" class="headerlink" title="TCP数据的传输过程"></a>TCP数据的传输过程</h3><pre><code>Ack 号  = Seq号 + 传递的字节数 + 1重传超时事件 RTO ， Retransmission Time Out重传次数</code></pre><h3 id="TCP四次握手断开连接"><a href="#TCP四次握手断开连接" class="headerlink" title="TCP四次握手断开连接"></a>TCP四次握手断开连接</h3><pre><code>[More](http://c.biancheng.net/view/2353.html)</code></pre><h4 id="shotdown-函数：-优雅地断开TCP连接"><a href="#shotdown-函数：-优雅地断开TCP连接" class="headerlink" title="shotdown 函数： 优雅地断开TCP连接"></a>shotdown 函数： 优雅地断开TCP连接</h4><pre><code>[More](http://c.biancheng.net/view/2354.html)</code></pre><h3 id="Socket-实现文件传输"><a href="#Socket-实现文件传输" class="headerlink" title="Socket 实现文件传输"></a>Socket 实现文件传输</h3><pre><code>Client 从Server 下载一个文件并保存到本地需注意：    1. 文件大小不确定该，调用一次write /send 函数不能完成文件内容的发送，接收数据也同样    解决方案： 可使用while 循环：        int nCount;        while(nCount = fread(buffer, 1, BUF_SIZE, fp)) &gt; 0 {            send(sock, buffer, nCount, 0);        }            // Client        int nCount;        while((nCount = recv(clntSock, buffer, BUF_SIZE, 0)) &gt; 0 ) {            fwrite(buffer, nCount, 1, fp);        }         [More](http://c.biancheng.net/view/2355.html)</code></pre><h3 id="网络数据的大小端问题"><a href="#网络数据的大小端问题" class="headerlink" title="网络数据的大小端问题"></a>网络数据的大小端问题</h3><pre><code>        大端序和小端序        网络字节序转换函数gethostbyname: 通过域名获取IP地址    通过域名获取IP地址    [More](http://c.biancheng.net/view/2359.html)</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;center&gt; iFaithFreedom &lt;/center&gt;
    
    </summary>
    
      <category term="Socket" scheme="http://yoursite.com/categories/Socket/"/>
    
    
      <category term="Socket" scheme="http://yoursite.com/tags/Socket/"/>
    
  </entry>
  
  <entry>
    <title>Mac</title>
    <link href="http://yoursite.com/2019/08/26/Mac-Note/"/>
    <id>http://yoursite.com/2019/08/26/Mac-Note/</id>
    <published>2019-08-26T14:58:31.000Z</published>
    <updated>2019-08-26T15:02:01.076Z</updated>
    
    <content type="html"><![CDATA[<center> Hale's Mac </center><a id="more"></a><p>Mac 开发相关</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt; Hale&#39;s Mac &lt;/center&gt;
    
    </summary>
    
    
      <category term="Mac" scheme="http://yoursite.com/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="http://yoursite.com/2019/08/16/Docker-Note/"/>
    <id>http://yoursite.com/2019/08/16/Docker-Note/</id>
    <published>2019-08-16T13:34:17.000Z</published>
    <updated>2019-08-16T14:01:13.537Z</updated>
    
    <content type="html"><![CDATA[<center> iFaithFreedom </center><a id="more"></a><h3 id="Docker-基础"><a href="#Docker-基础" class="headerlink" title="Docker 基础"></a>Docker 基础</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">install </span><br><span class="line"></span><br><span class="line">windwos: Control Panel  -&gt; open: Hyper-V 和  容器</span><br><span class="line">[Docker.exe](https://www.docker.com/products/docker-desktop)</span><br><span class="line">Mac os : </span><br><span class="line">[Docker.dmg](https://www.docker.com/products/docker-desktop)</span><br><span class="line">Linux  :</span><br><span class="line">wget -qO- https://get.docker.com/ | sh</span><br><span class="line">usermod -aG docker your-user</span><br><span class="line">Windows Server :</span><br><span class="line">Install-Module DockerProvider -Force</span><br><span class="line">Install-Package Docker -ProviderName DockerProvider -Force</span><br><span class="line"></span><br><span class="line">Update Docker </span><br><span class="line">apt update</span><br><span class="line">apt remove docker docker-engine docker-ce docker.io -y</span><br><span class="line">wget -qO- https://get.docker.com/ | sh</span><br><span class="line">systemctl enable docker// 设置开机启动</span><br><span class="line">systemctl is-enabled docker//检测是否开机启动</span><br><span class="line"></span><br><span class="line">Docker Storage Driver: 存储驱动</span><br><span class="line">/etc/docker/daemon.json:&#123;&quot;storage-driver&quot;:&quot;overlay2&quot;&#125;</span><br><span class="line">docker system info//检查docker当前的存储驱动类型</span><br></pre></td></tr></table></figure><h4 id="运维角度看Docker"><a href="#运维角度看Docker" class="headerlink" title="运维角度看Docker"></a>运维角度看Docker</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br><span class="line">镜像：docker image ls </span><br><span class="line">容器：docker container run -it ubuntu:latest /bin/bash// -it 交互模式</span><br><span class="line">ps -ef//查看全部进程</span><br><span class="line">docker container ls// 系统内全部处于运行状态的容器</span><br><span class="line">docker container exec// 将shell连接到一个运行中的容器终端</span><br><span class="line">docker container exec -it &lt;options&gt; &lt;container-name or container-id&gt; &lt;command/app&gt;</span><br><span class="line">Ctrl + PQ// 退出容器</span><br><span class="line">docker container stop &lt;container-name or container-id&gt;// 停止容器</span><br><span class="line">docker container rm &lt;container-name or container-id&gt;// 删除容器</span><br><span class="line">docker container ls -a//列出所有容器 包括已删除的</span><br></pre></td></tr></table></figure><h4 id="开发角度看Docker"><a href="#开发角度看Docker" class="headerlink" title="开发角度看Docker"></a>开发角度看Docker</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">clone web应用代码cd xxx  -&gt;  ls -l -&gt; cat Dockfile </span><br><span class="line">-&gt; docker image build// 根据Dockerfile中的指令来创建新的镜像</span><br><span class="line">-&gt; docker image build -t xxx:latet .</span><br><span class="line"></span><br><span class="line">Docker 引擎 engine</span><br><span class="line">[总体逻辑](http://c.biancheng.net/uploads/allimg/190416/4-1Z416140U0537.gif)</span><br><span class="line">组成： Docker Client、 Docker daemon、 Contained 、runc </span><br><span class="line">[引擎架构](http://c.biancheng.net/uploads/allimg/190416/4-1Z41614102M63.gif)</span><br><span class="line">启动一个新的容器</span><br><span class="line">docker container run --name ctr1 -it alpine:latest sh</span><br><span class="line">[启动过程](http://c.biancheng.net/uploads/allimg/190416/4-1Z4161413112O.gif)</span><br><span class="line">daemon 作用</span><br><span class="line">镜像管理、镜像构建、REST API、身份验证、安全、核心网络以及编排</span><br><span class="line"></span><br><span class="line">Docker镜像</span><br><span class="line">docker container run</span><br><span class="line">docker service create//从某个镜像启动一个或多个容器</span><br><span class="line">拉取镜像</span><br><span class="line">docker image pull xxx:latest// xxx 为镜像名 latest 为版本</span><br><span class="line">docker image ls// 检查docker主机本地仓库是否包含镜像</span><br><span class="line">镜像仓库服务 Image Registry </span><br><span class="line">镜像命名和标签</span><br><span class="line">拉取镜像：docker image pull &lt;repository&gt;:&lt;tag&gt;</span><br><span class="line">docker image pull ubuntu:latest// 从官方ubuntu库拉取标签为latest的镜像</span><br><span class="line">拉取某组织的镜像: docker image pull microsoft/powershell:nanoserver</span><br><span class="line">为镜像打多个标签</span><br><span class="line">docker image pull -a nigelpoulton/tu-demo</span><br><span class="line">返回镜像列表内容</span><br><span class="line">docker image ls --filter dangling=true//返回没有标签的镜像(悬虚镜像)，显示为 &lt;none&gt;:&lt;none&gt;</span><br><span class="line">移除全部的悬虚镜像: docker image prune</span><br><span class="line">过滤器：dangding: 返回悬虚镜像(true), 非悬虚镜像(false)</span><br><span class="line">before :需要镜像名称或者id，返回在之前被创建的全部镜像</span><br><span class="line">since :类似before，返回指定镜像之后创建的全部镜像</span><br><span class="line">label :根据标注(label)的名称或者值，进行过滤 </span><br><span class="line">docker image ls --filter=reference=&quot;*.latest&quot;</span><br><span class="line">docker image ls --format &quot;&#123;&#123;.Size&#125;&#125;&quot;//通过Go模板对输出内容格式化</span><br><span class="line">docker image ls --format &quot;&#123;&#123;.Repository&#125;&#125;:&#123;&#123;.Tag&#125;&#125;:&#123;&#123;.Size&#125;&#125;&quot;</span><br><span class="line"></span><br><span class="line">搜索Docker Hub </span><br><span class="line">docker search xxx// xxx 为 仓库名称</span><br><span class="line">docker search xxx --filter &quot;is-official=true&quot;// 返回官方镜像</span><br><span class="line">docker search xxx --filter &quot;is-automated=true&quot;//显示自动创建的仓库</span><br><span class="line"></span><br><span class="line">镜像和分层</span><br><span class="line">Docker 镜像由一些 松耦合 的只读镜像层组成</span><br><span class="line">查看镜像分层： docker image inspect xxx:latest</span><br><span class="line">查看镜像的构建历史记录： docker history </span><br><span class="line">[镜像层](http://c.biancheng.net/uploads/allimg/190416/4-1Z416164115364.gif)</span><br><span class="line">共享镜像层</span><br><span class="line">docker image pull -a xxx/xxx</span><br><span class="line">本地产看镜像摘要：docker image ls --digests xxx</span><br><span class="line">在docker主机删除镜像：docker image rm xxx:latest</span><br><span class="line">多层架构的镜像</span><br><span class="line">[Multi-architecture Image](http://c.biancheng.net/uploads/allimg/190416/4-1Z416164446156.gif)</span><br><span class="line">删除本地镜像： docker image rmcontainer-id</span><br><span class="line">获取本地全部镜像:  docker image ls -q </span><br><span class="line">删除本地全部镜像:  docker image rm $(docker image ls -q) -f </span><br><span class="line"></span><br><span class="line">Docker 镜像常用命令</span><br><span class="line">docker image pull//下载镜像</span><br><span class="line">docker image pull xxx:xxx//下载指定镜像</span><br><span class="line">docker image ls//列出全部镜像</span><br><span class="line">docker image inspect//列出镜像层数数据和元数据</span><br><span class="line">docker image rm//删除镜像</span><br><span class="line">docker image rm xxx:xxx//删除指定镜像</span><br><span class="line"></span><br><span class="line">Docker 容器</span><br><span class="line">docker container run//启动容器</span><br><span class="line">docker container run &lt;image&gt; &lt;app&gt;// 指定启动所需的镜像及要运行的应用</span><br><span class="line">docker container run xxx:xxx sleep 10// shell连接到容器 10s 的时间</span><br><span class="line">docker container stop//手动停止容器运行</span><br><span class="line">docker container start//再次启动该容器</span><br><span class="line">docker container rm// 删除容器</span><br><span class="line"></span><br><span class="line">容器和虚拟机</span><br><span class="line">[](http://c.biancheng.net/uploads/allimg/190417/4-1Z41G01336346.gif)</span><br><span class="line"></span><br><span class="line">检擦Docker daemon</span><br><span class="line">docker version</span><br><span class="line">如果server 部分有错，需要 usermod -aG docker &lt;user&gt; 添加到本地docker 组</span><br><span class="line">检查docker daemon状态</span><br><span class="line">service docker status </span><br><span class="line">systemctl is-active docker </span><br><span class="line"></span><br><span class="line">启动一个简单容器</span><br><span class="line">docker container run </span><br><span class="line">docker container run &lt;options&gt; &lt;im- age&gt;:&lt;tag&gt; &lt;app&gt;</span><br><span class="line">docekr 默认非TLS网络端口为 2375 ， TLS端口为 2376</span><br><span class="line"></span><br><span class="line">容器进程：ps -ef </span><br><span class="line"></span><br><span class="line">查看正在运行的容器列表</span><br><span class="line">docker container ls </span><br><span class="line"></span><br><span class="line">启动容器后，重新连接到Docker</span><br><span class="line">docker container exec -it &lt;container-name or container-id&gt; bash </span><br><span class="line"></span><br><span class="line">停止容器</span><br><span class="line">docker container stop &lt;container-id or container-name&gt;</span><br><span class="line"></span><br><span class="line">删除容器</span><br><span class="line">docker container rm &lt;container-id&gt;</span><br><span class="line"></span><br><span class="line">容器生命周期</span><br><span class="line">docker container run --name percy -it xxx:xxx /bin/bash</span><br><span class="line">Ctrl - PQ 组合键退出当前容器</span><br><span class="line"></span><br><span class="line">优雅地停止容器</span><br><span class="line">docker container stop// 向容器内的PID 1进程发送 SIGTERM 信号，优雅结束10s时间</span><br><span class="line"></span><br><span class="line">没有预警停止容器</span><br><span class="line">docker container stop &lt;container&gt; -f</span><br><span class="line">docker container rm &lt;container&gt; -f// -f 不会发送 SIGTERM，直接发出 SIGKILL </span><br><span class="line"></span><br><span class="line">利用重启策略进行容器的自我修复</span><br><span class="line">容器支持的重启策略： always  unless-stopped  on-failed </span><br><span class="line">docker container run --name xxx -it --restart always xx sh</span><br><span class="line">exit</span><br><span class="line">docker container ls </span><br><span class="line">1. 创建两容器</span><br><span class="line">docker container run -d --name always --restart always alpine sleep 1d </span><br><span class="line">docker container run -d --name unless-stopped --restart unless-stopped alpine sleep 1d </span><br><span class="line">docker container ls </span><br><span class="line">2. 停止两容器</span><br><span class="line">docker container stop always unless-stopped</span><br><span class="line">docker container ls</span><br><span class="line">3. 重启 Docker </span><br><span class="line">systemctl restart docker</span><br><span class="line">4. 检查两状态</span><br><span class="line">docker container ls -a </span><br><span class="line">结论：always 重启了，unless-stopped 没有重启</span><br></pre></td></tr></table></figure><h4 id="Web服务器示例"><a href="#Web服务器示例" class="headerlink" title="Web服务器示例"></a>Web服务器示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">docker container run -d --name webserver -p 80:8080 nigelpoulton/pluralsight -docker -ci//-d后台模式-p 80:8080 端口映射 将Docker主机的80端口映射到容器内的8080端口</span><br><span class="line">docker container stopdocker container pausedocker container startdocker container rm </span><br><span class="line"></span><br><span class="line">查看容器详情</span><br><span class="line">docker container inspect </span><br><span class="line">快速清理</span><br><span class="line">$()</span><br><span class="line">rm $(docker image ls -q)|($docker container ls -aq)</span><br><span class="line">docker container rm</span><br><span class="line"></span><br><span class="line">Docker容器常用命令</span><br><span class="line">docker container run//启动新容器</span><br><span class="line">docker container ls//列出在运行(UP)， -a: 列出停止的(Exited)</span><br><span class="line">docker container exec//连接该容器 -it &lt;container-name or container-id&gt; bash </span><br><span class="line">docker container stop//停止运行中的容器</span><br><span class="line">docker container start//重启停止(Exited)状态的容器 &lt;container-id or contaienr -name&gt;</span><br><span class="line">docker container rm//删除停止运行的容器</span><br><span class="line">docker container inspect//显示容器配置细节和运行时信息 &lt;container-id or container-name&gt;</span><br><span class="line"></span><br><span class="line">Docker应用容器化(将应用程序部署到容器中)</span><br><span class="line">容器化：将应用整合到容器中并且运行起来的过程，能够简化应用的构建、部署和运行过程</span><br><span class="line">完整的应用容器化过程分为以下步骤</span><br><span class="line">1. 编写应用代码</span><br><span class="line">2. 创建一个Dockfile，包括应用的描述、依赖、及如何运行应用</span><br><span class="line">3. 对该Dockerfile 执行 docker image build 命令</span><br><span class="line">4. 等待Docker将应用程序构建到Docker镜像中</span><br><span class="line">[步骤](http://c.biancheng.net/uploads/allimg/190417/4-1Z41G51T3502.gif)</span><br><span class="line"></span><br><span class="line">单体应用容器化</span><br><span class="line">步骤：</span><br><span class="line">1， 获取应用代码</span><br><span class="line">2.  分析 Dockfile</span><br><span class="line">3.  构建应用镜像</span><br><span class="line">4.  运行该应用</span><br><span class="line">5.  测试应用</span><br><span class="line">6.  容器应用化细节</span><br><span class="line">7.  生产环境中的多阶段构建</span><br><span class="line">8.  最佳实践</span><br><span class="line"></span><br><span class="line">登录到Docker Hub</span><br><span class="line">docker login// 登录到docker</span><br><span class="line">docker image push// 推送到docker</span><br><span class="line">docker image tag web:latest xxx/web:latest// 为镜像打标签</span><br></pre></td></tr></table></figure><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">docker image build// 读取Dockerfile，并将应用程序容器化</span><br><span class="line">Dockerfile 示例代码：</span><br><span class="line"># Linux x64</span><br><span class="line">FROM xxx</span><br><span class="line"></span><br><span class="line">LABEL maintainer=&quot;mr_hale@163.com&quot;</span><br><span class="line"></span><br><span class="line"># install Node and NPM </span><br><span class="line">RUN apk and --update nodejs nodejs-npm</span><br><span class="line"></span><br><span class="line"># Copy app to /src</span><br><span class="line">COPY ./src</span><br><span class="line"></span><br><span class="line">WORKDIR /src</span><br><span class="line"></span><br><span class="line"># Install dependencies </span><br><span class="line">RUN npm install </span><br><span class="line"></span><br><span class="line">EXPOSE 8080</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;node&quot;,&quot;./app.js&quot;]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">-t ： 为镜像打标签</span><br><span class="line">-f ： 指定Dockerfile 的路径和名称，指定位于任意路径下的任意名称的Dockerfile</span><br><span class="line">FROM ：用于指定要构建的镜像的基础镜像，通常是Dockerfile 中的第一条指令</span><br><span class="line">RUN ： 用于在镜像中执行命令，会创建新的镜像层，每个指令创建一个新的镜像层</span><br><span class="line">COPY ： 用于将文件作为一个新的层添加到镜像中，使用COPY指令将应用代码赋值到镜像中</span><br><span class="line">EXPOSE ： 记录应用所使用的网络端口</span><br><span class="line">ENTRYPOINT ： 指定镜像以容器方式启动后默认运行的程序</span><br><span class="line">LABEL ：</span><br><span class="line">ENV ：</span><br><span class="line">ONBUILD ：</span><br><span class="line">HEALTHCHECK ：</span><br><span class="line">CMD ：</span><br></pre></td></tr></table></figure><h3 id="Dockers-Compose"><a href="#Dockers-Compose" class="headerlink" title="Dockers Compose"></a>Dockers Compose</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">与Docker Stack类似，在Docker节点上，以单引擎模式(Single-Engine Mode)进行多容器应用的部署和管理</span><br><span class="line">如：一个间的示例应用可能有4个服务组成</span><br><span class="line">1. Web前端</span><br><span class="line">2. 订单管理</span><br><span class="line">3. 品类管理</span><br><span class="line">4. 后台数据库</span><br><span class="line">Compose 用来部署和管理繁多的服务</span><br><span class="line">使用：首先编写定义多容器(多服务)应用的YAML文件，然后由 docker-compose 命令处理，基于Docker引擎API完成应用的部署</span><br><span class="line"></span><br><span class="line">安装：</span><br><span class="line">使用curl下载二进制文件，然后 chmod 修改权限</span><br><span class="line">检验： docker-compose --version</span><br><span class="line">用 pip 安装 Docker Compose 的 python 包</span><br><span class="line"></span><br><span class="line">Docker Compose YML 配置文件及常用指令</span><br><span class="line">YAML 定义多服务的应用，是JSON的子集，可使用JSON定义</span><br><span class="line">默认使用文件名 docker-compose.yml, 也可使用-f参数指定具体文件</span><br><span class="line">示例：包含  web-fe 、 redis 的小型Flask应用</span><br><span class="line">能够对其访问者进行计数并将其保存到Redis的简单Web服务</span><br><span class="line">version: &quot;1.0&quot;</span><br><span class="line">services:</span><br><span class="line">web-fe:</span><br><span class="line">build:.</span><br><span class="line">command: python app.py</span><br><span class="line">ports:</span><br><span class="line">- taget: 5000</span><br><span class="line">published: 5000</span><br><span class="line">networks:</span><br><span class="line">- counter-net</span><br><span class="line">volumes:</span><br><span class="line">- type: volume</span><br><span class="line">source: counter-vol</span><br><span class="line">target: /code</span><br><span class="line">redis:</span><br><span class="line">image: &quot;redis:alpine&quot;</span><br><span class="line">networks:</span><br><span class="line">counter-net:</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">counter-net:</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">counter-vol:</span><br><span class="line"></span><br><span class="line">包含4个一级key： version、services、networks、volumes</span><br><span class="line">version: 指定版本</span><br><span class="line">services: 定义不同的应用服务，compose 会将每个服务部署到各自的容器中</span><br><span class="line">networks：指引docker创建新的网络，默认 创建 bridge 网络，也可以使用driver属性指定网络类型,允许独立的容器连接到该网络上</span><br><span class="line">networks:</span><br><span class="line">over-net:</span><br><span class="line">driver: overlay</span><br><span class="line">attachable: true</span><br><span class="line">volumes: 指定docker创建新的卷</span><br><span class="line"></span><br><span class="line">定义了两个Key：web-fe 、redis，因此Docker Compose部署两容器，一个包含web-fe，一个redis</span><br><span class="line">web-fe服务定义中，包含以下指令：</span><br><span class="line">1. build： 指定docker基于当前目录 (.) 下dockerfile来构建新景象，用于启动该服务的容器</span><br><span class="line">2. command： 指定docker在容器中执行名为 app.py 的Python脚本作主程序</span><br><span class="line">3. ports： 将容器内(-target)的5000端口映射到主机(published)的5000端口</span><br><span class="line">4. networks：是的docker将服务连接到指定的网络上</span><br><span class="line">5. volumes：将counter-vol卷(source:)挂载到容器内的 /code (target:)</span><br><span class="line">6. image： redis:alpine 是的docker基于redis:alpine 镜像启动一个独立的名为redis的人弄国企，镜像会从docker hub上拉取下来</span><br><span class="line">7. networks：配置redis容器连接到counter-net网络</span><br><span class="line"></span><br><span class="line">Docker-Compose 部署应用</span><br><span class="line">在项目目录中，检查文件是否存在</span><br><span class="line">app.py:应用程序代码 Flask应用</span><br><span class="line">docker-compose.yml: compose文件，定义了Docker如何部署应用</span><br><span class="line">Dockerfile:定义了如何构建web-fe服务所使用的镜像</span><br><span class="line">requirements.txt: 列出了应用所依赖的python包</span><br><span class="line"></span><br><span class="line">启动应用：</span><br><span class="line">docker-compose up &amp;</span><br><span class="line">docker-compose -f prod-equus-bass.yml up//基于名为 prod... 的compose文件部署应用</span><br><span class="line">docker-compose up -d// 没有-d 用 &amp; 将终端窗口返回</span><br><span class="line"></span><br><span class="line">FROM python:3.4-alpine &lt;&lt;  基础镜像</span><br><span class="line">ADD ./code   &lt;&lt;将app复制到镜像中</span><br><span class="line">WORKDIR /code   &lt;&lt;设置工作目录</span><br><span class="line">RUN pip install -r requirements.txt   &lt;&lt; 安装依赖</span><br><span class="line">CMD [&quot;python&quot;,&quot;app.py&quot;]  &lt;&lt; 设置默认启动命令</span><br><span class="line"></span><br><span class="line">若 .Services.redis 中指定了image: &quot;redis:alpine&quot;，会从docker hub拉取redis:alpine 镜像</span><br><span class="line">docker container ls</span><br><span class="line">docker network ls </span><br><span class="line">docker volume ls</span><br><span class="line"></span><br><span class="line">使用Docker-Compose 子命令</span><br><span class="line">docker-compose up -d//拉取和构建的镜像保存在系统中</span><br><span class="line">docker-compose ps//列出容器名称、command、状态、网络端口</span><br><span class="line">docker-compose top//列出各个服务(容器)内运行的进程</span><br><span class="line">docker-compose stop//停止应用，但不删除</span><br><span class="line">docker-compose rm//删除应用相关的容器和网络，但不删除卷和镜像</span><br><span class="line">docker-compose restart//重启应用</span><br><span class="line">docker-compose down//停止和关闭应用</span><br><span class="line"></span><br><span class="line">./code </span><br><span class="line">[Dockerfile and Compose file](http://c.biancheng.net/uploads/allimg/190417/4-1Z41GJ242b5.gif)</span><br></pre></td></tr></table></figure><h3 id="Docker-Swarm"><a href="#Docker-Swarm" class="headerlink" title="Docker Swarm"></a>Docker Swarm</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">集群管理工具，作用：把若干台Docker主句抽象为一个整体，通过一个入口统一管理各种Docker资源。 类似 Kubernetes，包含：企业级的Docker安全集群，微服务应用编排引擎</span><br><span class="line">默认内置： 分布式集群存储、加密网络、公用TLS、安全集群接入令牌、简化数字证书管理的PKI</span><br><span class="line">基于Docker引擎之上的独立产品</span><br><span class="line">一个Swarm由一个或多个Docker节点组成，通过可靠的网络相连。</span><br><span class="line">节点被配置为管理节点(Manager)和工作节点(Worker)， 管理节点负责集群控制面，进行诸如监控集群状态、分发任务至工作节点等操作。 工作节点接受来自管理节点的任务并执行</span><br><span class="line">[Swarm](http://c.biancheng.net/uploads/allimg/190418/4-1Z41Q045505Y.gif)</span><br><span class="line"></span><br><span class="line">集群搭建：</span><br><span class="line">[Swarm](http://c.biancheng.net/uploads/allimg/190418/4-1Z41Q24Z2332.gif)</span><br><span class="line">每个节点装 Docker，并能够与Swarm的其他节点通信</span><br><span class="line">防火墙开放以下端口：</span><br><span class="line">2377/tcp:用于客户端与Swarm进行安全通信</span><br><span class="line">7946/tcp 与 7946/udp: 用于控制面gossip分发</span><br><span class="line">4789/udp: 用于基于VXLAN的覆盖网络</span><br><span class="line"></span><br><span class="line">大体流程：初始化第一个管理节点 -&gt; 加入额外的管理节点 -&gt; 加入工作节点 -&gt; 完成</span><br><span class="line"></span><br><span class="line">初始化一个全新的Swarm：</span><br><span class="line">[Swarm](http://c.biancheng.net/uploads/allimg/190418/4-1Z41Q25041I0.gif)</span><br><span class="line">在单引擎模式下的Docker 主机执行 docker swarm init 切换到swarm模式</span><br><span class="line">接入额外的管理节点，并切换为Swarm模式</span><br><span class="line">docker swarm init --advertise-addr 10.0.0.1:2377 --listen-addr 10.0.0.1:2377</span><br><span class="line">docker swarm init// 初始化并设置为第一个管理节点，开始swarm模式</span><br><span class="line">--advertise-addr// 指定其他节点用来连接到当前管理节点的IP和端口，可选</span><br><span class="line">--listen-addr// 用于承载Swarm流量的IP和端口</span><br><span class="line">docker node ls// 列出Swarm 节点</span><br><span class="line">docker swarm join-token// 获取添加新的工作节点和管理节点到Swarm的命令和Token</span><br><span class="line">docker swarm join-token worker</span><br><span class="line">docker swarm join-token manager </span><br><span class="line">docker swarm join --token SWMTKN-1-0uahebax...ca... 10.0.0.1:2377 --advertise-addr 10.0.0.4:2377 --listen-addr 10.0.0.4:2377</span><br><span class="line"></span><br><span class="line">Swarm 管理器高可用性(HA)</span><br><span class="line">[Swarm HA](http://c.biancheng.net/uploads/allimg/190418/4-1Z41Q25541296.gif)</span><br><span class="line">[详细文章：](http://c.biancheng.net/view/3178.html)</span><br><span class="line"></span><br><span class="line">内置的Swarm 安全机制</span><br><span class="line"></span><br><span class="line">锁定Swarm</span><br><span class="line">启用锁：docker swarm init --autolock</span><br><span class="line">解锁  ：docker swarm init --unlock</span><br><span class="line"></span><br><span class="line">Docker Swarm 服务的部署及操作</span><br><span class="line">docker service create// 创建一个新的服务</span><br><span class="line">docker service create --name web-fe -p 8080:8080 --replicas 5 xxx/xxx </span><br><span class="line">与 docker container run 相似，--name：将其命名为 web-fa -p：映射端口</span><br><span class="line">查看服务：</span><br><span class="line">docker service ls </span><br><span class="line">查看服务副本列表及个副本的状态：</span><br><span class="line">docker service ps &lt;service-name or serviceid&gt;</span><br><span class="line">查看服务详细信息：</span><br><span class="line">docker service inspect --pretty xxx// --pretty 易于阅读的格式</span><br><span class="line"></span><br><span class="line">副本服务 VS  全局服务：</span><br><span class="line">副本模式：服务的默认复制模式(Replication Mode) 是副本模式(replicated)</span><br><span class="line">全局模式：global </span><br><span class="line">docker service create --mode global </span><br><span class="line">服务的扩缩容：</span><br><span class="line">大流量情况下： </span><br><span class="line">docker service scale web-fa=10// 对web-fa服务扩容，将服务副本由5个增加到10个</span><br><span class="line">检查操作是否成功：</span><br><span class="line">docker service ls </span><br><span class="line">显示服务副本在各个节点上是均衡分布：</span><br><span class="line">dockers service ps </span><br><span class="line">减少副本树：</span><br><span class="line">docker service scale web-fa=5// 从10个降为5个</span><br><span class="line">删除服务：</span><br><span class="line">docker service rm web-fa </span><br><span class="line">docker service ls </span><br><span class="line">滚动升级：</span><br><span class="line">docker network create -d overlay uber-net// 创建网络并将服务接入网络</span><br><span class="line">[](http://c.biancheng.net/uploads/allimg/190418/4-1Z41Q4221H59.gif)</span><br><span class="line">docker network ls// 查看网络是否创建成功</span><br><span class="line"></span><br><span class="line">docker service create --name uber-svc --network uber-net -p 80:80 --replicas 12 xxxx/xxx </span><br><span class="line">docker service create --name uber-svc --network uber-net -publish published=80,target=80,mode=host --replicas 12 xxx/xxx</span><br><span class="line">docker service update// 更新运行中的服务</span><br><span class="line">docker service ps</span><br><span class="line">docker inspect --pretty</span><br><span class="line"></span><br><span class="line">Docker Swarm 服务日志及相关配置</span><br><span class="line">docker service log//查看服务的日志</span><br><span class="line">节点默认配置服务是 json-file 日志驱动，还有 journald(仅限systemctl的linux主机)、syslog、splunk、gelf</span><br><span class="line">json-file和journald 可用logs命令</span><br><span class="line">docker service logs &lt;service-name&gt;</span><br><span class="line">第三方日志驱动：</span><br><span class="line">&#123;</span><br><span class="line">&quot;log-driver&quot;:&quot;syslog&quot;</span><br><span class="line">&#125;</span><br><span class="line">docker service create --logdrive --log-opts// 强制某服务使用一个不同的日志驱动，会覆盖 daemon.json的配置</span><br><span class="line">--follow ：进行跟踪</span><br><span class="line">--tail :显示最近的日志</span><br><span class="line">--details ： 获取额外细节</span><br></pre></td></tr></table></figure><h5 id="Docker-Swarm-汇总"><a href="#Docker-Swarm-汇总" class="headerlink" title="Docker Swarm 汇总"></a>Docker Swarm 汇总</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker swarm init:创建新的Swarm，成为第一管理节点</span><br><span class="line">docker swarm join-token: 加入管理节点和工作节点到现有Swarm</span><br><span class="line">docker swarm join-token manager: 获取新增管理节点 </span><br><span class="line">docker swarm join-token worker:  获取新增工作节点</span><br><span class="line">docker node ls:列出Swarm中的所有节点及相关信息</span><br><span class="line">docker service create: 创建一个新服务</span><br><span class="line">docker service ls: 列出Swarm中运行的服务，如服务状态、副本等基本信息</span><br><span class="line">docker service ps &lt;service&gt;: 列出某个服务副本的信息</span><br><span class="line">docker service inspect: 获取关于服务的详细信息，--pretty 仅显示重要信息</span><br><span class="line">docker service scale: 对服务副本个数进行增减</span><br><span class="line">docker service update: 对运行中的服务属性进行变更</span><br><span class="line">docker service logs: 查看服务的日志</span><br><span class="line">docker serivce rm: 从Swarm中删除某服务，不做确认会删除服务的所有副本</span><br></pre></td></tr></table></figure><h3 id="Dockerfile-1"><a href="#Dockerfile-1" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">docker image build// 读取Dockerfile，并将应用程序容器化</span><br><span class="line">Dockerfile 示例代码：</span><br><span class="line"># Linux x64</span><br><span class="line">FROM xxx</span><br><span class="line"></span><br><span class="line">LABEL maintainer=&quot;mr_hale@163.com&quot;</span><br><span class="line"></span><br><span class="line"># install Node and NPM </span><br><span class="line">RUN apk and --update nodejs nodejs-npm</span><br><span class="line"></span><br><span class="line"># Copy app to /src</span><br><span class="line">COPY ./src</span><br><span class="line"></span><br><span class="line">WORKDIR /src</span><br><span class="line"></span><br><span class="line"># Install dependencies </span><br><span class="line">RUN npm install </span><br><span class="line"></span><br><span class="line">EXPOSE 8080</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;node&quot;,&quot;./app.js&quot;]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">-t ： 为镜像打标签</span><br><span class="line">-f ： 指定Dockerfile 的路径和名称，指定位于任意路径下的任意名称的Dockerfile</span><br><span class="line">FROM ：用于指定要构建的镜像的基础镜像，通常是Dockerfile 中的第一条指令</span><br><span class="line">RUN ： 用于在镜像中执行命令，会创建新的镜像层，每个指令创建一个新的镜像层</span><br><span class="line">COPY ： 用于将文件作为一个新的层添加到镜像中，使用COPY指令将应用代码赋值到镜像中</span><br><span class="line">EXPOSE ： 记录应用所使用的网络端口</span><br><span class="line">ENTRYPOINT ： 指定镜像以容器方式启动后默认运行的程序</span><br><span class="line">LABEL ：</span><br><span class="line">ENV ：</span><br><span class="line">ONBUILD ：</span><br><span class="line">HEALTHCHECK ：</span><br><span class="line">CMD ：</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;center&gt; iFaithFreedom &lt;/center&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Laravel</title>
    <link href="http://yoursite.com/2019/08/16/Laravel-Note/"/>
    <id>http://yoursite.com/2019/08/16/Laravel-Note/</id>
    <published>2019-08-16T13:30:48.000Z</published>
    <updated>2019-08-16T13:51:17.455Z</updated>
    
    <content type="html"><![CDATA[<center> iFaithFreedom </center><a id="more"></a><h3 id="composer的安装和使用"><a href="#composer的安装和使用" class="headerlink" title="composer的安装和使用"></a>composer的安装和使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; php -r &quot;copy(&apos;https://getcomposer.org/installer&apos;, &apos;composer-setup.php&apos;);&quot;</span><br><span class="line">&gt;&gt; php composer-setup.php</span><br><span class="line">&gt;&gt; mv composer.phar /usr/local/bin/composer</span><br><span class="line">&gt;&gt; composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/</span><br><span class="line">&gt;&gt; 取消配置： composer config -g --unset repos.packagist</span><br><span class="line">&gt;&gt; composer install</span><br><span class="line">&gt;&gt; composer search xxx</span><br><span class="line">&gt;&gt; composer selfupdate</span><br><span class="line">&gt;&gt; composer show | composer show xxx </span><br><span class="line">&gt;&gt; curl -sS https://getcomposer.org/installer | php </span><br><span class="line">&gt;&gt; mv composer.phar /usr/local/bin/composer</span><br><span class="line">&gt;&gt; composer require xxx/xxx</span><br><span class="line">&gt;&gt; composer remove xxx/xxx | xxx </span><br><span class="line">&gt;&gt;  composer.json </span><br><span class="line">&#123;</span><br><span class="line">&quot;require&quot;: &#123;</span><br><span class="line">&quot;xxx/xxx&quot;:&quot;1.0.*@beta&quot;,</span><br><span class="line">&quot;xxx/xxx&quot;:&quot;@dev&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Laravel-安装"><a href="#Laravel-安装" class="headerlink" title="Laravel 安装"></a>Laravel 安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Laravel install Tool:composer global require &quot;laravel/install&quot;</span><br><span class="line">添加laravel 到系统环境变量： </span><br><span class="line">export PATH=“root/.config/composer/vendor/bin:$PATH</span><br><span class="line">$HOME/.composer/vendor/bin  主要让系统找到laravel的可执行文件</span><br><span class="line">laravel new xxx</span><br><span class="line">composer install laravel:</span><br><span class="line">composer create-project --prefer-dist laravel/laravel xxx &quot;5.5.*&quot;</span><br><span class="line"></span><br><span class="line">Web 服务器配置：</span><br><span class="line">Nginx:</span><br><span class="line">location / &#123;</span><br><span class="line">try_files $uri $uri/ /index.php?$query_string;</span><br><span class="line">&#125;</span><br><span class="line">具体看微信图片收藏中的配置信息</span><br><span class="line"></span><br><span class="line">php artisan serve</span><br><span class="line">php artisan --version | php artisan -V</span><br><span class="line">php artisan down | up</span><br><span class="line"></span><br><span class="line">// 设置时区</span><br><span class="line">在 app.php 中</span><br><span class="line">&apos;timezone&apos; =&gt; &apos;Asia/Shanghai&apos;;</span><br><span class="line">&apos;timezone&apos; =&gt; &apos;PRC&apos;;</span><br><span class="line"></span><br><span class="line">初始化完成后，修改.env配置文件，配置数据库等</span><br><span class="line">exec: php artisan migrate:install// 检测数据是否迁移成功</span><br></pre></td></tr></table></figure><h1 id="文章模块"><a href="#文章模块" class="headerlink" title="文章模块"></a>文章模块</h1><p>路由:  路由 模板<br>表设计: 表设计 模型</p><h2 id="页面逻辑：-文章列表-添加文章-编辑文章-删除文章-文章详情"><a href="#页面逻辑：-文章列表-添加文章-编辑文章-删除文章-文章详情" class="headerlink" title="页面逻辑： 文章列表 添加文章 编辑文章 删除文章 文章详情"></a>页面逻辑： 文章列表 添加文章 编辑文章 删除文章 文章详情</h2><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- HTTP 方法：</span><br><span class="line">Route::get($uri,$callback);</span><br><span class="line">get | post | put | patch | delete | options | any | macth </span><br><span class="line"></span><br><span class="line">- 路由参数</span><br><span class="line">Route::get(&apos;uri1&apos;/&#123;param1&#125;/uri2/&#123;param2&#125;&apos;,function($param1,$param2)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;)-&gt;where(&apos;param&apos;,&apos;[a-zA-z0-9]+&apos;);</span><br><span class="line"></span><br><span class="line">- 路由分组</span><br><span class="line">Route::group([&apos;prefix&apos; =&gt; &apos;xxx&apos;],function()&#123;</span><br><span class="line">Route:;get(&apos;xxx&apos;,function()&#123;</span><br><span class="line">xxx</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Route::middleware([&apos;xxx&apos;,&apos;xxxx&apos;]) -&gt; group(function()&#123;</span><br><span class="line">Route::get(&apos;x&apos;,function()&#123;</span><br><span class="line">...</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="模型绑定"><a href="#模型绑定" class="headerlink" title="模型绑定"></a>模型绑定</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Route::get(&apos;api/users/&#123;user&#125;&apos;,function(\App\User $user)&#123;</span><br><span class="line">return $user -&gt; email;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="创建控制器，路由"><a href="#创建控制器，路由" class="headerlink" title="创建控制器，路由"></a>创建控制器，路由</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">php artisan make:controller PostController </span><br><span class="line">Route: </span><br><span class="line">文章列表</span><br><span class="line">Route:;get(&apos;/posts&apos;,&apos;\App\Http\Controllers\PostController@index&apos;);</span><br><span class="line">创建文章</span><br><span class="line">Route:;get(&apos;/posts/create&apos;,&apos;\App\Http\Controllers\PostController@create&apos;);</span><br><span class="line">Route:;post(&apos;/posts&apos;,&apos;\App\Http\Controllers\PostController@store&apos;);</span><br><span class="line">文章详情页</span><br><span class="line">Route:;post(&apos;/posts/&#123;post&#125;&apos;,&apos;\App\Http\Controllers\PostController@show&apos;);</span><br><span class="line">编辑文章</span><br><span class="line">Route:;get(&apos;/posts/&#123;post&#125;/edit&apos;,&apos;\App\Http\Controllers\PostController@edit&apos;);</span><br><span class="line">Route:;put(&apos;/posts/&#123;post&#125;&apos;,&apos;\App\Http\Controllers\PostController@update&apos;);</span><br><span class="line">删除文章</span><br><span class="line">Route:;get(&apos;/posts/&#123;post&#125;/delete&apos;,&apos;\App\Http\Controllers\PostController@delete&apos;);</span><br><span class="line">-- 控制器</span><br><span class="line">Controller:</span><br><span class="line">namespace \App\Http\Controllers;</span><br><span class="line">use Illuminate\Http\Request;</span><br><span class="line">class PostController exntends Controller &#123;</span><br><span class="line">public function xxx()&#123;...  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h3><p>创建文章    编辑文章    文章列表    文章详情</p><h4 id="在控制器进行页面渲染："><a href="#在控制器进行页面渲染：" class="headerlink" title="在控制器进行页面渲染："></a>在控制器进行页面渲染：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Extends Controller:</span><br><span class="line">public function  index()&#123;</span><br><span class="line">$arrs = [</span><br><span class="line">[&apos;title&apos; =&gt; &apos;totle ...&apos;], [&apos;title&apos; =&gt; &apos;titles ...&apos;], [&apos;ok&apos; =&gt; &apos;okoko&apos;],</span><br><span class="line">];</span><br><span class="line">return view(&apos;post/index&apos;,[&apos;arrs&apos; =&gt; $arr]);  // 指 post文件夹下的index.blade.php 页面</span><br><span class="line">&#125;</span><br><span class="line">-- 传递参数</span><br><span class="line">$tit = &apos;a tit&apos;;</span><br><span class="line">view(&apos;post/index&apos;,[&apos;title&apos; =&gt; &apos;text&apos;,&apos;isTrue&apos; =&gt; false,&apos;arrs&apos; =&gt; $arrs] );</span><br><span class="line">view(&apos;post/index&apos;,compact(&apos;tit&apos;,&apos;arrs&apos;));   view(&apos;post/index&apos;,compact(&apos;arrs&apos;));</span><br></pre></td></tr></table></figure><p>– Blade模板</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">模板语法：&#123;&#123; &#125;&#125;   @if@foreach </span><br><span class="line">参数传递： </span><br><span class="line">继承模板：extends/section/yield/content</span><br><span class="line">引入视图：include </span><br><span class="line"></span><br><span class="line">-- index.blade.php </span><br><span class="line">&#123;&#123;$title&#125;&#125;// 解析控制器中传递的变量值</span><br><span class="line">@if($isTrue == true)</span><br><span class="line">Message </span><br><span class="line">@endif</span><br><span class="line">@foreach($arrs as $arr)</span><br><span class="line">&#123;&#123;$arr&#125;&#125;</span><br><span class="line">@endforeach</span><br><span class="line"></span><br><span class="line">- 文章模块页面模板调整</span><br><span class="line">提取 layout</span><br><span class="line">提取 footer</span><br><span class="line">提取 nav</span><br><span class="line"></span><br><span class="line">layout/main.blade.php</span><br><span class="line">公用头部</span><br><span class="line">@yield(&apos;content&apos;)</span><br><span class="line">公用尾部</span><br><span class="line"></span><br><span class="line">单独拆解</span><br><span class="line">layout/footer.blade.php</span><br><span class="line">footer 的页面内容</span><br><span class="line">layout/nav.blade.php</span><br><span class="line">nav 的页面内容</span><br><span class="line"></span><br><span class="line">模板集成与包含</span><br><span class="line">post/index.blade.php</span><br><span class="line">@extends(&apos;layout.main&apos;)</span><br><span class="line">@section(&apos;content&apos;)</span><br><span class="line">@include(&apos;layout.nav&apos;)</span><br><span class="line">index 中的页面内容</span><br><span class="line">@include(layout.footer)</span><br><span class="line">@endsection</span><br></pre></td></tr></table></figure><h3 id="文章模块数据表"><a href="#文章模块数据表" class="headerlink" title="文章模块数据表"></a>文章模块数据表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">使用 migrate 创建数据表</span><br><span class="line">外键 user_id</span><br><span class="line">时间 created_at/updated_at</span><br><span class="line">migration： 数据库同步迁移</span><br><span class="line">php artisan make:migration create_posts_table// 格式：create_ 数据表名_table </span><br><span class="line">在创建好的create_posts_table.php中</span><br><span class="line">pubic function up()&#123;// 创建表用crate  更新表用 table</span><br><span class="line">Scheme::create(&apos;posts&apos;,function(Blueprint $table)&#123;// 创建表</span><br><span class="line">$table -&gt; increment(&apos;id&apos;);</span><br><span class="line">$table -&gt; string(&apos;title&apos;,100) -&gt; default(&apos;&apos;);</span><br><span class="line">$table -&gt; text(&apos;content&apos;);</span><br><span class="line">$table -&gt; integer(&apos;user_id&apos;) -&gt; default(0);</span><br><span class="line">$table -&gt; timestamps();</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">public function down()&#123;</span><br><span class="line">Scheme::dropIfExists(&apos;posts&apos;);// 删除表</span><br><span class="line">&#125;</span><br><span class="line">// 如果报错 SQL max key length 767 bytes，就需要在 app\Providers 文件的boot() 方法中添加 一下代码</span><br><span class="line">public function boot()&#123;</span><br><span class="line">Schema::defaultStringLength(191);// 191 = 797 / 4 </span><br><span class="line">&#125;</span><br><span class="line">php artisan migrate// 完成数据表的迁移</span><br><span class="line">数据库的回滚</span><br><span class="line">php artisan migrate:rollback</span><br></pre></td></tr></table></figure><h4 id="表名-posts"><a href="#表名-posts" class="headerlink" title="表名 posts"></a>表名 posts</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ORM:</span><br><span class="line">创建posts 的模型:</span><br><span class="line">php artisan make:model Post</span><br><span class="line"></span><br><span class="line">tinker 的使用:</span><br><span class="line">php artisan think</span><br><span class="line">基本的增删改查</span><br><span class="line">增加:</span><br><span class="line">$post = new \App\Post();</span><br><span class="line">$post -&gt; title = &apos;title text&apos;;</span><br><span class="line">$post -&gt; content = &apos;content text&apos;;</span><br><span class="line">$post -&gt; save();</span><br><span class="line">查找：</span><br><span class="line">\App\Post::find(3);</span><br><span class="line">\App\Post::where(&apos;title&apos;,&apos;titel text&apos;) -&gt; get() | -&gt; first();</span><br><span class="line">更新：</span><br><span class="line">$post = \App\Post::find(3);</span><br><span class="line">$post -&gt; title = &apos;new title text&apos;;</span><br><span class="line">删除:</span><br><span class="line">$post = \App\Post::find(3);</span><br><span class="line">$post -&gt; delete();</span><br></pre></td></tr></table></figure><h3 id="文章列表逻辑"><a href="#文章列表逻辑" class="headerlink" title="文章列表逻辑"></a>文章列表逻辑</h3><h4 id="模型查找-页面渲染-时间格式-数据填充-字符截断-分页"><a href="#模型查找-页面渲染-时间格式-数据填充-字符截断-分页" class="headerlink" title="模型查找  页面渲染  时间格式   数据填充   字符截断    分页"></a>模型查找  页面渲染  时间格式   数据填充   字符截断    分页</h4><p>在列表控制器中实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">PostController.php</span><br><span class="line">use \App\Post;</span><br><span class="line">public function index()&#123;</span><br><span class="line">$posts = Post::orderBy(&apos;created_at&apos;,&apos;desc&apos;) -&gt; get();// 模型查找</span><br><span class="line">return view(&apos;posts/index&apos;,compact(&apos;posts&apos;));// 页面渲染</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">接着在模板中修改页面渲染：</span><br><span class="line">如果传递过来的是数组：</span><br><span class="line">@foreach($arrs as $arr)</span><br><span class="line">&#123;&#123;$arr[&apos;title&apos;]&#125;&#125;</span><br><span class="line">@endforeach</span><br><span class="line">如果传递过来的是对象</span><br><span class="line">@foreach($posts as $post)</span><br><span class="line">&#123;&#123;$post -&gt; title&#125;&#125;//post 的 title 属性和其他属性</span><br><span class="line">&#123;&#123;$post -&gt; created_at&#125;&#125; | &#123;&#123;$pos -&gt; id&#125;&#125; | &#123;&#123;$post -&gt; content&#125;&#125; | &#123;&#123;$post -&gt; updated_at&#125;&#125;</span><br><span class="line">@endforeach</span><br><span class="line"></span><br><span class="line">时间格式渲染：</span><br><span class="line">&#123;&#123;$post -&gt; created_at -&gt; toFormattedDateString()&#125;&#125;// 格式化时间</span><br><span class="line"></span><br><span class="line">数据填充：</span><br><span class="line">在 database\factories\ModelFactory.php 文件中设置以下代码</span><br><span class="line">$factory -&gt; define(App\Post::class,function(Faker\Generator $faker)&#123;</span><br><span class="line">return [</span><br><span class="line">&apos;title&apos; =&gt; $faker -&gt; sentence(6);// 6个单词</span><br><span class="line">&apos;content&apos; =&gt; $faker -&gt; paragraph(10);// 10个句子</span><br><span class="line">];</span><br><span class="line">&#125;);</span><br><span class="line">php artisan tinker</span><br><span class="line">: factory(App\Post::class,20) -&gt; create();//生成  make-&gt; (); //演示</span><br><span class="line"></span><br><span class="line">分页：</span><br><span class="line">控制器PostController  index() </span><br><span class="line">$posts = Post::orderBy(&apos;created_at&apos;,&apos;desc&apos;) -&gt; paginate(n);// n 一个页面显示的数量</span><br><span class="line">模板 view/post/index.blade.php</span><br><span class="line">&#123;&#123;$posts -&gt; links()&#125;&#125;</span><br><span class="line"></span><br><span class="line">字符截取：</span><br><span class="line">&#123;&#123;str__limit($post -&gt; content,&apos;100&apos;,&apos;...&apos;)&#125;&#125;    // str__limit() 100：显示的数量 ... 显示文本</span><br></pre></td></tr></table></figure><h3 id="文章添加逻辑"><a href="#文章添加逻辑" class="headerlink" title="文章添加逻辑"></a>文章添加逻辑</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">控制器</span><br><span class="line">模板 form 中传递的参数名和数据库字段名保持一致</span><br><span class="line">文章列表  详情页面  创建页面  创建逻辑  编辑页面 编辑逻辑</span><br><span class="line">控制器对应的方法中在接收传递数据的内容调试时使用 dd(\Request::all()); == dd(request()); // dd(request(&apos;title&apos;));     dd = dump and die </span><br><span class="line"></span><br><span class="line">CSRF</span><br><span class="line">在模板页面需要设置 csrf_token() 字段</span><br><span class="line">&lt;input type=&apos;hidden&apos; name=&apos;_token&apos; value=&quot;&#123;&#123;csrf_token()&#125;&#125;&quot;&gt;  == &#123;&#123;csrf_field()&#125;&#125;</span><br><span class="line"></span><br><span class="line">保存model</span><br><span class="line">1. 第一种方式</span><br><span class="line">$post = new Post();</span><br><span class="line">$post -&gt; title = request(&apos;title&apos;);// 通过request 获取title数据</span><br><span class="line">$post -&gt; content = request(&apos;content&apos;);// 通过request 获取content数据</span><br><span class="line">$post -&gt; save();// 通过 save() 进行保存</span><br><span class="line">2. 第二种方式</span><br><span class="line">$params = [&apos;title&apos; =&gt; request(&apos;title&apos;), &apos;content&apos; =&gt; request(&apos;content&apos;)];</span><br><span class="line">Post::create($params);</span><br><span class="line">3. 第三种方式是第二种方式的简写</span><br><span class="line">Post::create(request([&apos;title&apos;,&apos;content&apos;]))；</span><br><span class="line">如果报错，create方法需要在模型中设置相对应的规则</span><br><span class="line">app/Post.php</span><br><span class="line">class Post extends Model&#123;</span><br><span class="line">protected $guarded = [];// 不可以注入数据的字段为空的话，所有数据都可以注入</span><br><span class="line">protected $fillable = [&apos;title&apos;,&apos;content&apos;];// 可以注入数据的字段</span><br><span class="line">&#125;</span><br><span class="line">此处可以把$guarded $fillable 提取到新的model 类文件中, post.php 集成新的model类就可以简写很多代码</span><br><span class="line"></span><br><span class="line">验证和错误提示</span><br><span class="line">控制器做数据的验证：</span><br><span class="line">public function store()&#123;</span><br><span class="line">// 验证</span><br><span class="line">$this -&gt; validate(request()[</span><br><span class="line">&apos;title&apos; =&gt; &apos;required|string|max:100|min:5&apos;,</span><br><span class="line">&apos;content&apos; =&gt; &apos;required|string|min:10&apos;</span><br><span class="line">]);</span><br><span class="line">&#125;</span><br><span class="line">// 逻辑</span><br><span class="line">$post = Post::create(request([&apos;title&apos;,&apos;content&apos;]));</span><br><span class="line">// 渲染</span><br><span class="line">return redirect(&apos;/posts&apos;);</span><br><span class="line">视图层做错误的提示：</span><br><span class="line">@if(count($errors) &gt; 0)</span><br><span class="line">@foreach($errors as $error)</span><br><span class="line">&#123;&#123;$error&#125;&#125;</span><br><span class="line">@endforeach</span><br><span class="line">@endif</span><br><span class="line"></span><br><span class="line">错误提示本地化</span><br><span class="line">resources/lang/zh/复制 en中的文件到zh中，中文汉化放到validation.php中， 在config/app.php 中修改 locale en 为 zh</span><br></pre></td></tr></table></figure><h3 id="富文本编辑器的使用"><a href="#富文本编辑器的使用" class="headerlink" title="富文本编辑器的使用"></a>富文本编辑器的使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">下载wangEdit2 js 和其他的</span><br><span class="line">模板中对标签的格式化</span><br><span class="line">&#123;!! str_limit($post -&gt; content),&apos;100&apos;,&apos;...&apos; !!&#125;</span><br><span class="line">图片上传</span><br><span class="line">设置 路由</span><br><span class="line">Route::post(&apos;/posts/image/upload&apos;,&apos;\App\Http\PostController@imageUpload&apos;);</span><br><span class="line">控制器</span><br><span class="line">这一部分不是最重要的，暂时不细研究</span><br></pre></td></tr></table></figure><h4 id="文章编辑逻辑"><a href="#文章编辑逻辑" class="headerlink" title="文章编辑逻辑"></a>文章编辑逻辑</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">路由：</span><br><span class="line">Route::get(&apos;/posts/&#123;post&#125;/edit&apos;,&apos;\App\Http\PostController@edit&apos;);// 传递 post 模型绑定</span><br><span class="line">控制器:</span><br><span class="line">如果路由中有传递 模型绑定，那么控制器也需要在相对应的方法中注入模型参数 </span><br><span class="line">public function edit(Post $post)&#123;</span><br><span class="line">return view(&apos;/posts/edit&apos;,compact(&apos;posts&apos;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CSRF 视图层：</span><br><span class="line">&#123;&#123; method_field(&apos;PUT&apos;) &#125;&#125;// 视图层</span><br><span class="line">&#123;&#123; csrf_field() &#125;&#125;</span><br><span class="line">&#123;&#123; $posts -&gt; title &#125;&#125;//</span><br><span class="line">&#123;&#123; $posts -&gt; content &#125;&#125;</span><br><span class="line"></span><br><span class="line">更新 Model:</span><br><span class="line">路由:</span><br><span class="line">Route::put(&apos;/posts/&#123;post&#125;/&apos;,&apos;\App\Http\PostController@update&apos;);</span><br><span class="line">控制器 PostController:</span><br><span class="line">public function update(Post $post)&#123;</span><br><span class="line">// 验证</span><br><span class="line">$this -&gt; validate(requset()[</span><br><span class="line">&apos;title&apos; =&gt; &apos;required|string|max:100|min:5&apos;,</span><br><span class="line">&apos;content&apos; =&gt; &apos;required|string|min:10&apos;</span><br><span class="line">]);</span><br><span class="line">// 逻辑</span><br><span class="line">$post -&gt; title = request(&apos;title&apos;);</span><br><span class="line">$post -&gt; content = request(&apos;content&apos;);</span><br><span class="line">$post -&gt; save();</span><br><span class="line">// 渲染</span><br><span class="line">return redirect(&apos;/posts/&#123;$post -&gt; id&#125;&apos;);</span><br><span class="line">&#125;</span><br><span class="line">视图层：</span><br><span class="line">错误提示代码提取到 layout/error.blade.php</span><br><span class="line">edit.blade.php</span><br><span class="line">@extends(&apos;layout.main&apos;)</span><br><span class="line">@section(&apos;content&apos;)</span><br><span class="line">some html code ... </span><br><span class="line">@include(&apos;layout.error&apos;)</span><br><span class="line">@endsection</span><br><span class="line"></span><br><span class="line">删除文章：</span><br><span class="line">路由: </span><br><span class="line">Route::get(&apos;/posts/&#123;post&#125;&apos;,&apos;\App\Http\PostController@delete&apos;);</span><br><span class="line">控制器:</span><br><span class="line">public function delete(Post $post)&#123;</span><br><span class="line">// TODO: 用户的权限认证</span><br><span class="line">$post -&gt; delete();</span><br><span class="line">return redirect(&apos;/posts&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;center&gt; iFaithFreedom &lt;/center&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
      <category term="Laravel" scheme="http://yoursite.com/categories/PHP/Laravel/"/>
    
    
      <category term="Laravel" scheme="http://yoursite.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>Error</title>
    <link href="http://yoursite.com/2019/08/14/Error-Note/"/>
    <id>http://yoursite.com/2019/08/14/Error-Note/</id>
    <published>2019-08-14T15:15:56.000Z</published>
    <updated>2019-08-14T15:18:29.034Z</updated>
    
    <content type="html"><![CDATA[<center> 积累工作中常见错误</center><a id="more"></a><h3 id="TODO-List"><a href="#TODO-List" class="headerlink" title="TODO List"></a>TODO List</h3><ul><li>积累错误</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;center&gt; 积累工作中常见错误&lt;/center&gt;
    
    </summary>
    
      <category term="Error" scheme="http://yoursite.com/categories/Error/"/>
    
    
      <category term="Error" scheme="http://yoursite.com/tags/Error/"/>
    
  </entry>
  
  <entry>
    <title>Design</title>
    <link href="http://yoursite.com/2019/08/14/Design-Note/"/>
    <id>http://yoursite.com/2019/08/14/Design-Note/</id>
    <published>2019-08-14T15:04:45.000Z</published>
    <updated>2019-08-15T12:39:00.235Z</updated>
    
    <content type="html"><![CDATA[<center> 设计模式 </center><a id="more"></a><h3 id="TODO-设计模式"><a href="#TODO-设计模式" class="headerlink" title="TODO: 设计模式"></a>TODO: 设计模式</h3><h2 id="创造型设计模式"><a href="#创造型设计模式" class="headerlink" title="创造型设计模式"></a>创造型设计模式</h2><ul><li>简单工厂</li><li>工厂方法</li><li>抽象工厂</li><li>构建器</li><li>原型</li><li>单例</li></ul><h2 id="结构型设计模式"><a href="#结构型设计模式" class="headerlink" title="结构型设计模式"></a>结构型设计模式</h2><ul><li>适配器</li><li>桥梁</li><li>组合</li><li>装饰</li><li>门面</li><li>享元</li><li>代理</li></ul><h2 id="行为型设计模式"><a href="#行为型设计模式" class="headerlink" title="行为型设计模式"></a>行为型设计模式</h2><ul><li>责任链</li><li>命令行</li><li>迭代器</li><li>中介者</li><li>备忘录</li><li>观察者</li><li>访问者</li><li>策略</li><li>状态</li><li>模版方法</li></ul><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>创造型        结构型        行为型    </p><h2 id="创造型设计模式-1"><a href="#创造型设计模式-1" class="headerlink" title="创造型设计模式"></a>创造型设计模式</h2><ul><li><p>简单工厂：</p><pre><code>只是为客户端生成一个实例，而不会向客户端公开任何实例化逻辑工厂时用户创建其他对象的对象，正式工厂是一种函数或方法，它从一些方法调用返回变化的原型或类的对象，这被假定为&quot;新&quot;</code></pre><p>  程序化示例：<br>  首先，定义一个门界面和实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">interface Door &#123;</span><br><span class="line">public function getWidth(): float;</span><br><span class="line">public function getHeight(): float;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">clas WoodenDoor implements Door &#123;</span><br><span class="line">protected $width;</span><br><span class="line">protected $height;</span><br><span class="line"></span><br><span class="line">public function __construct(float $width, float $height) &#123;</span><br><span class="line">$this -&gt; width = $width;</span><br><span class="line">$this -&gt; height = $height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function getWidth(): float &#123;</span><br><span class="line">return $this -&gt; width;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function getHeight(): float &#123;</span><br><span class="line">return $this -&gt; height;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  我们有我们的门工厂、门，并返回它</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class DoorFactory &#123;</span><br><span class="line">public static function makeDoor($width, $height): Door &#123;</span><br><span class="line">return new WoodenDoor($width, $height);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  然后它可以用作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Make me a door of 300 x 300</span><br><span class="line">$door = DoorFactory::makeDoor(300,300);</span><br><span class="line"></span><br><span class="line">echo &apos;Width: &apos; . $door -&gt; getWidth();</span><br><span class="line">echo &apos;Height: &apos;. $door -&gt; getHeight();</span><br><span class="line"></span><br><span class="line">// Make me a door of 100 x 100</span><br><span class="line">$door2 = DoorFactory::makeDoor(100,100);</span><br></pre></td></tr></table></figure></li></ul><p>用处：当创建一个对象不仅仅是一些分配而且涉及一些逻辑时，将它放在专用工厂中，而不是在任何地方重复相同的代码时有意义的</p><ul><li><p>工厂方法<br>  提供了一种将实例化逻辑委托给子类的方法<br>  处理创建对象的问题，无需指定将要创建的对象的确切类。在接口中指定并由子类实现，或者在基类中实现并可选地由派生类覆盖，而不是通过调用构造函数<br>  程序化示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">interface Interviewer &#123;</span><br><span class="line">public function askQuestions();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Developer implements Interviewer &#123;</span><br><span class="line">public function askQuestions() &#123;</span><br><span class="line">echo &apos;Factory Design Patterns &apos;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CommunityExecutive implements Interviewer &#123;</span><br><span class="line">public function askQuestions() &#123;</span><br><span class="line">echo &apos;Asking about community building &apos;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  创造 HiringManager</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">abstract class HiringManager &#123;</span><br><span class="line">// Factory method</span><br><span class="line">abstract protected function makeInterviewer(): Interviewer;</span><br><span class="line"></span><br><span class="line">public function takeInterview() &#123;</span><br><span class="line">$interviewer = $this -&gt; makeInterviewer();</span><br><span class="line">$interviewer -&gt; askQuestions();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>任何子类可以延长并提供所需的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class DevelopmentManager extends HiringManager &#123;</span><br><span class="line">protected function makeInterviewer(): Interviewer &#123;</span><br><span class="line">return new Developer();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MarketingManager extends HiringManager &#123;</span><br><span class="line">protected function makeInterviewer(): Interviewer &#123;</span><br><span class="line">return new CommunityExecutive();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$devManager = new DevelopmentManager();</span><br><span class="line">$devManager -&gt; takeInterview();// Output: Asking about design patterns </span><br><span class="line"></span><br><span class="line">$marketingManager = new MarketingManager();</span><br><span class="line">$marketingManager -&gt; takeInterview();// Output : Asking about community building</span><br></pre></td></tr></table></figure><p>用处：<br>    在类中有一些通用处理但在运行时动态决定所需的子类时用，当客户端不知道他需要什么样子的子类时</p><ul><li>抽象工厂<br>  将个人 相关\依赖工厂组在一起而不指定其具体类别的工厂<br>  提供了一种封装一组具有共同主题但没有指定具体类的单个工厂的方法<br>  程序化示例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">interface Door &#123;</span><br><span class="line">public function getDescription();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class WooderDoor implements Door &#123;</span><br><span class="line">public function getDescription() &#123;</span><br><span class="line">echo &apos;I am a wooden door&apos;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class IronDoor implements Door &#123;</span><br><span class="line">public function getDescription() &#123;</span><br><span class="line">echo &apos;I am an iron door&apos;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>为每种门类型都配备一些装配专家</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">interface DoorFittingExpert &#123;</span><br><span class="line">public function getDescription();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Weler implements DoorFittingExpert &#123;</span><br><span class="line">public function getDescription() &#123;</span><br><span class="line">echo &apos;i can only fit iron doors &apos;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Carpenter implements DoorFittingExpert &#123;</span><br><span class="line">public function getDescription() &#123;</span><br><span class="line">echo &apos;I can only fit wooden doors &apos;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有抽象工厂，制作相关对象的家庭，即木门工厂将创建一个木门和木门配件，门专家</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">interface DoorFactory &#123;</span><br><span class="line">public function makeDoor(): Door;</span><br><span class="line">public function makeFittingExpert(): DoorFittingExpert;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Wooden factory to return carpenter and wooden door </span><br><span class="line">class WoodenDoorFactory implements DoorFactory &#123;</span><br><span class="line">public function makeDoor(): Door &#123;</span><br><span class="line">return new WoodenDoor();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function makeFittingExpert(): DoorFittingExpert &#123;</span><br><span class="line">return new Carpenter();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Iron Door factory to get iron door and the relevant fitting expert </span><br><span class="line">class IronDoorFactory implements DoorFactory &#123;</span><br><span class="line">public function makeDoor(): Door &#123;</span><br><span class="line">return new IronDoor();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function makeFittingExpert(): DoorFittingExpert &#123;</span><br><span class="line">return new Welder();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Iron d</span><br></pre></td></tr></table></figure><p>可用作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$woodenFactory = new WoodenDoorFactory();</span><br><span class="line"></span><br><span class="line">$door = $woodenFactory -&gt; makeDoor();</span><br><span class="line">$expert = $woodenFactory -&gt; makeFittingExpert();</span><br><span class="line"></span><br><span class="line">$door -&gt; getDescription(); // Output: i am a wooden door</span><br><span class="line">$expert -&gt; getDescription();</span><br><span class="line"></span><br><span class="line">// Same for Iron Factory </span><br><span class="line">$ironFactory = new IronDoorFactory();</span><br><span class="line"></span><br><span class="line">$door = $ironFactory -&gt; makeDoor();</span><br><span class="line">$expert = $ironFactory -&gt; makeFittingExpert();</span><br><span class="line"></span><br><span class="line">$door -&gt; getDescription();</span><br><span class="line">$expert -&gt; getDescription();</span><br></pre></td></tr></table></figure><p>木门工厂疯转 各种函数<br>用法： 当存在互相关联的依赖关系时，涉及非简单的创建逻辑</p><ul><li>构建器<br>  允许创建不同风格的对象，同时避免构造函数污染，当有几种风格的物体时很有用，或在创建对象时设计很多步骤<br>  目的：找到伸缩构造器反模式的解决方案<br>  程序化示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Burger &#123;</span><br><span class="line">protected $size;</span><br><span class="line"></span><br><span class="line">protected $cheese = false;</span><br><span class="line">protected $pepperoni = false;</span><br><span class="line">protected $lettuce = false;</span><br><span class="line">protected $tomato = false;</span><br><span class="line"></span><br><span class="line">public function __construct(BurgerBuilder $builder) &#123;</span><br><span class="line">$this -&gt; size = $builder -&gt; size;</span><br><span class="line">$this -&gt; cheese = $builder -&gt; cheese;</span><br><span class="line">$this -&gt; pepperoni = $builder -&gt; pepperoni;</span><br><span class="line">$this -&gt; lettuce = $builder -&gt; lettuce;</span><br><span class="line">$this -&gt; tomato = $builder -&gt; tomato;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>然后有建设者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class BurgerBuilder &#123;</span><br><span class="line">public $size;</span><br><span class="line"></span><br><span class="line">public $cheese = false;</span><br><span class="line">public $pepperoni = false;</span><br><span class="line">public $lettuce = false;</span><br><span class="line">public $tomato = false;</span><br><span class="line"></span><br><span class="line">public function __construct(int $size) &#123;</span><br><span class="line">$this -&gt; size = $size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function addPepperoni() &#123;</span><br><span class="line">$this -&gt; pepperoni = true;</span><br><span class="line">return $this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function addLettuce() &#123;</span><br><span class="line">$this -&gt; lettuce = true;</span><br><span class="line">return $this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function addCheese() &#123;</span><br><span class="line">$this -&gt; cheese = true;</span><br><span class="line">return $this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function addTomato() &#123;</span><br><span class="line">$this -&gt; tomato = true;</span><br><span class="line">return $this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function build(): Burger &#123;</span><br><span class="line">return new Burger($this);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$burger = (new BurgerBuilder(14)) </span><br><span class="line">-&gt; addPepperoni()</span><br><span class="line">-&gt; addLettuce()</span><br><span class="line">-&gt; addTomato()</span><br><span class="line">-&gt; build();</span><br></pre></td></tr></table></figure><p>用处：<br>    当可能存在几种类型的对象并避免构造函数伸缩时，与工厂模式区别在于：当创建时一步过程时，将使用工厂模式，而当创建是多步骤过程时，将使用构造器模式</p><ul><li>原型<br>  通过克隆基于现有对象创建对象, 允许创建现有对象的副本并进行修改，而不是从头开始创建对象并进行设置<br>  程序化示例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Sheep &#123;</span><br><span class="line">protected $name;</span><br><span class="line">protected $category;</span><br><span class="line"></span><br><span class="line">public function __construct(string $name, string $category = &apos;Mountain Sheep&apos;) &#123;</span><br><span class="line">$this -&gt; name = $name;</span><br><span class="line">$this -&gt; category = $category;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function setName(string $name) &#123;</span><br><span class="line">$this -&gt; name = $name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function getName() &#123;</span><br><span class="line">return $this -&gt; name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function setCategory(string $category) &#123;</span><br><span class="line">$this -&gt; category = $category;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function getCategory() &#123;</span><br><span class="line">return $this -&gt; category;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$original = new Sheep(&apos;Hale&apos;);</span><br><span class="line">echo $original -&gt; getName(); // Hale</span><br><span class="line">echo $original -&gt; getCategory() // Mountain Sheep</span><br><span class="line"></span><br><span class="line">// Clone and Modify what is required</span><br><span class="line">$cloned = clone $original;</span><br><span class="line">$cloned -&gt; setName(&apos;Lv&apos;);</span><br><span class="line">echo $cloned -&gt; getName(); // Lv</span><br><span class="line">echo $cloned -&gt; getCategory();// Mountain Sheep</span><br></pre></td></tr></table></figure><p>可用魔术方法 __clone() 来修改克隆方法<br>用处： 当需要一个与现有对象类似的对象时，或者与克隆相比，创建的成本会很高</p><ul><li>单例<br>  确保只创建特定类的一个对象<br>  程序化示例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">final Class President &#123;</span><br><span class="line">private static $instance;</span><br><span class="line"></span><br><span class="line">private function __construct() &#123;</span><br><span class="line">// Hide the constructor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static function getInstance(): President &#123;</span><br><span class="line">if(!self::$instance) &#123;</span><br><span class="line">self::$instance = new self();</span><br><span class="line">&#125;</span><br><span class="line">return self::$instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private function __clone() &#123;</span><br><span class="line">// Disable cloning</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private function __wakeup() &#123;</span><br><span class="line">// Disable unserialize</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$president1 = President::getInstance();</span><br><span class="line">$president2 = President::getInstance();</span><br><span class="line"></span><br><span class="line">var_dump($president1 === $president2);// true</span><br></pre></td></tr></table></figure><h3 id="结构型设计模式-1"><a href="#结构型设计模式-1" class="headerlink" title="结构型设计模式"></a>结构型设计模式</h3><p>适配器     桥梁     组合     装饰     门面     享元     代理</p><p>适配器：<br>    在适配器中包装其他不兼容的对象，以使其与另一个类兼容。 允许将现有类的接口用作另一个接口，通常用于使现有类与其他类一起工作而无需修改其源代码<br>    程序化示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">interface Lion &#123;</span><br><span class="line">public function roar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class AfricanLion implements Lion &#123;</span><br><span class="line">public function roar()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class AsianLion implements Lion &#123;</span><br><span class="line">public function roar()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现任何Lion接口可以进行搜索</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Hunter &#123;</span><br><span class="line">public function hunt(Lion $lion) &#123;</span><br><span class="line">$lion -&gt; roar();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Wilddog &#123;</span><br><span class="line">public function bark() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Adapter around wild dog to make it compatible with our game </span><br><span class="line">class WildDogAdapter implements Lion &#123;</span><br><span class="line">protected $dog;</span><br><span class="line">public function __construct(WildDog $dog) &#123;</span><br><span class="line">$this -&gt; dog = $dog;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$wildDog = new WildDog();</span><br><span class="line">$wildDogAdapter = new WildDogAdapter($wildDog);</span><br><span class="line"></span><br><span class="line">$hunter = new Hunter();</span><br><span class="line">$hunter -&gt; hunt($wildDogAdapter);</span><br></pre></td></tr></table></figure><p>桥梁模式<br>    优先于集成的组合,实现细节从层次结构推送到具有单独层次结构的另一个对象<br>    程序化示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">interface WebPage &#123;</span><br><span class="line">public function __construct(Theme $theme);</span><br><span class="line">public function getContent();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class About implements WebPage &#123;</span><br><span class="line">protected $theme;</span><br><span class="line"></span><br><span class="line">public function __construct(Theme $theme) &#123;</span><br><span class="line">$this -&gt; theme = $theme;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function getContent() &#123;</span><br><span class="line">return &apos;About page in&apos; . $this -&gt; theme -&gt; getColor();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Careers implements WebPage &#123;</span><br><span class="line">protected $theme;</span><br><span class="line"></span><br><span class="line">public function __construct(Theme $theme) &#123;</span><br><span class="line">$this -&gt; theme = $theme;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function getContent() &#123;</span><br><span class="line">return &apos;Careers page in &apos; . $this -&gt; theme -&gt; getColor();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">interface Theme &#123;</span><br><span class="line">public function getColor();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DarkTheme implements Theme &#123;</span><br><span class="line">public function getColor() &#123;</span><br><span class="line">return &apos;Dark Black&apos;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class LightTheme implements Theme &#123;</span><br><span class="line">public function getColor() &#123;</span><br><span class="line">return &apos;Off white&apos;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class AquaTheme implements Theme &#123;</span><br><span class="line">public function getColor() &#123;</span><br><span class="line">return &apos;Light theme&apos;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$darkTheme = new DarkTheme();</span><br><span class="line"></span><br><span class="line">$about = new About($darkTheme);</span><br><span class="line">$careers = new Careers($darkTheme);</span><br><span class="line"></span><br><span class="line">echo $about -&gt; getContent(); // about page in dark black</span><br><span class="line">echo $careers -&gt; getContent();//Careers page in Dark Black</span><br></pre></td></tr></table></figure><p>组合模式<br>    复合模式允许客户以统一的方式处理单个对象<br>    程序化示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">interface Employee &#123;</span><br><span class="line">public function __construct(string $name , float $salary);</span><br><span class="line">public function getName(): string;</span><br><span class="line">public function setSalary(float $salary);</span><br><span class="line">public function getSalary(): flaot;</span><br><span class="line">public function getRoles(): array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Developer implements Employee &#123;</span><br><span class="line">protected $salary;</span><br><span class="line">protected $name;</span><br><span class="line">protected $roles;</span><br><span class="line"></span><br><span class="line">public function __construct(string $name, float $salary) &#123;</span><br><span class="line">$this -&gt; name = $name;</span><br><span class="line">$this -&gt; salary = $salary;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function getName(): string &#123;</span><br><span class="line">return $this -&gt; name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function setSalary(float $salary) &#123;</span><br><span class="line">$this -&gt; salary = $salary;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function getSalary(): float &#123;</span><br><span class="line">return $this -&gt; salary;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function getRoles(): array &#123;</span><br><span class="line">return $this -&gt; roles;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Organization &#123;</span><br><span class="line">protected $employees;</span><br><span class="line"></span><br><span class="line">public function addEmployee(Employee $employee) &#123;</span><br><span class="line">$this -&gt; employees[] = $employee;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function getNetSalaries(): float &#123;</span><br><span class="line">$netSalary = 0;</span><br><span class="line"></span><br><span class="line">foreach($this -&gt; employees as $emploess) &#123;</span><br><span class="line">$netSalary += $employee -&gt; getSalary();</span><br><span class="line">&#125;</span><br><span class="line">return $netSalary;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$john = new Developer(&apos;John Doe&apos;, 12000);</span><br><span class="line">$hale = new Designer(&apos;Hale Lv&apos;, 15000);</span><br><span class="line"></span><br><span class="line">// Add them to organization()</span><br><span class="line">$organization = new Organization();</span><br><span class="line">$organization -&gt; addEmployee($john);</span><br><span class="line">$organization -&gt; addEmployee($hale);</span><br><span class="line"></span><br><span class="line">echo &apos;Net Salaries: &apos; . $organization -&gt; getNetSalaries();// Net Salaries : 27000</span><br></pre></td></tr></table></figure><p>装饰模式<br>    通过将对象包装在装饰器类的对象中来动态更改对象在运动时的行为<br>    程序化示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface Coffee &#123;</span><br><span class="line">public function getCost();</span><br><span class="line">public function getDescription();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SimpleCoffee implements Coffee  &#123;</span><br><span class="line">public function getCost() &#123;</span><br><span class="line">return 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function getDescription() &#123;</span><br><span class="line">return &apos;Simple Coffee&apos;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class MilkCoffee implements Coffee &#123;</span><br><span class="line">protected $coffee;</span><br><span class="line"></span><br><span class="line">public function __constrcut(Coffee $coffee) &#123;</span><br><span class="line">$this -&gt; coffee = $coffee;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function getCost() &#123;</span><br><span class="line">return $this -&gt; coffee -&gt; getCost + 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function getDescription() &#123;</span><br><span class="line">return $this -&gt; coffee -&gt; getDescription() . &apos; Milk &apos;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class WhipCoffee implements Coffee &#123;</span><br><span class="line">protected $coffee;</span><br><span class="line"></span><br><span class="line">public function __construct(Coffee $coffee) &#123;</span><br><span class="line">$this -&gt; coffee = $coffee;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function getCost() &#123;</span><br><span class="line">return $this -&gt; coffee -&gt; getCost() + 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function getDescription() &#123;</span><br><span class="line">return $this -&gt; coffee -&gt; getDescription() . &apos;whip&apos;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class VanlillaCoffee implements Coffee &#123;</span><br><span class="line">protected $coffee;</span><br><span class="line"></span><br><span class="line">public function __constrcut(Coffee $coffee) &#123;</span><br><span class="line">$this -&gt; coffee = $coffee;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function getCost() &#123;</span><br><span class="line">return $this -&gt; coffee = getCost() + 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function getDescription() &#123;</span><br><span class="line">return $this -. coffee -&gt; getDescription(). &apos; Valilla&apos;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$someCoffee = new SimpleCoffee();</span><br><span class="line">echo $someCoffee -&gt; getCost(); </span><br><span class="line">echo $someCoffee -&gt; getDescription();</span><br><span class="line"></span><br><span class="line">$someCoffee = new MilkCoffee($someCoffee);</span><br><span class="line">echo $someCoffee -&gt; getCost();</span><br><span class="line">echo $someCoffee -&gt; getDescription();</span><br><span class="line"></span><br><span class="line">$someCoffee = new WhipCoffee($someCoffee);</span><br><span class="line">echo $someCoffee -&gt; getCost();</span><br><span class="line">echo $someCoffee -&gt; getDescription();</span><br><span class="line"></span><br><span class="line">$someCoffee = new VanillaCoffee($someCoffee);</span><br><span class="line">echo $someCoffee -&gt; getCost();</span><br><span class="line">echo $someCoffee -&gt; getDescription();</span><br></pre></td></tr></table></figure><h3 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h3><pre><code>Facade 模式为复杂的子系统提供了简化的界面外观是一个对象，它为更大的代码提供了简化的接口，如类库程序化示例</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Computer &#123;</span><br><span class="line">public function getElectricShock() &#123;</span><br><span class="line">echo &apos;CDB&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function makeSound() &#123;</span><br><span class="line">echo &apos;Liunx&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function showLoadingScreen() &#123;</span><br><span class="line">echo &apos;Loding ... &apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function bam() &#123;</span><br><span class="line">echo &apos;Ready to be used !&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function closeEverything() &#123;</span><br><span class="line">echo &apos;Biu biu biu ... !&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function sooth() &#123;</span><br><span class="line">echo &apos;zzzzz&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function pullCurrent() &#123;</span><br><span class="line">echo &apos;Hahaha!&apos;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class ComputerFacade &#123;</span><br><span class="line">protected $computer;</span><br><span class="line"></span><br><span class="line">pulic function __construct(Computer $computer) &#123;</span><br><span class="line">$this -&gt; computer = $computer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function turnOn() &#123;</span><br><span class="line">$this -&gt; computer -&gt; getElectricShock();</span><br><span class="line">$this -&gt; computer -&gt; makeSound();</span><br><span class="line">$this -&gt; computer -&gt; showLoadingScreen();</span><br><span class="line">$this -&gt; computer -&gt; bam();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function turnOff() &#123;</span><br><span class="line">$this -&gt; computer -&gt; closeEverything();</span><br><span class="line">$this -&gt; computer -&gt; pullCurrent();</span><br><span class="line">$this -&gt; computer -&gt; sooth();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$computer = new ComputerFacade(new Computer());</span><br><span class="line">$computer -&gt; turnOn();</span><br><span class="line">$computer -&gt; turnOff();</span><br></pre></td></tr></table></figure><p>享元模式<br>    通过尽可能多地与类似对象共享来最小化内存使用或计算开销<br>    程序示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class KarakTea &#123;&#125;</span><br><span class="line"></span><br><span class="line">class TeaMaker &#123;</span><br><span class="line">protected $availableTea = [];</span><br><span class="line"></span><br><span class="line">public function make($preference) &#123;</span><br><span class="line">if(empty($this -&gt; availableTea[$preference])) &#123;</span><br><span class="line">$this -&gt; availableTea[$preference] = new KarakTea();</span><br><span class="line">&#125;</span><br><span class="line">return $this -&gt; availableTea[$preference];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class TeaShop &#123;</span><br><span class="line">protected $orders;</span><br><span class="line">protected $teaMaker;</span><br><span class="line"></span><br><span class="line">public function __construct(TeaMaker $teaMaker) &#123;</span><br><span class="line">$this -&gt; teaMaker = $teaMaker;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function takeOrder(string $teaType, int $table) &#123;</span><br><span class="line">$this -&gt; orders[$table] = $this -&gt; teaMaker -&gt; make(teaType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function serve() &#123;</span><br><span class="line">foreach($this -&gt; orders as $table =&gt; $tea) &#123;</span><br><span class="line">echo &apos;Serving tea to table &apos; . $table;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$teaMaker = new TeaMaker();</span><br><span class="line">$shop = new TeaShop($teaMaker);</span><br><span class="line"></span><br><span class="line">$shop -&gt; takeOrder(&apos;Less Sugar&apos;);</span><br><span class="line">$shop -&gt; takeOrder(&apos;More Milk&apos;);</span><br><span class="line">$shop -&gt; takeOrder(&apos;Without Sugar&apos;, 5);</span><br><span class="line"></span><br><span class="line">$shop -&gt; serve();</span><br></pre></td></tr></table></figure><p>代理模式<br>    类表示另一个类的功能<br>    程序化示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface Door &#123;</span><br><span class="line">public function open();</span><br><span class="line">public function close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class LabDoor implements Door &#123;</span><br><span class="line">public function open() &#123;</span><br><span class="line">echo &apos;Opening lab door&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function close() &#123;</span><br><span class="line">echo &apos;Closing the lab door&apos;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class SecuredDoor &#123;</span><br><span class="line">protected $door;</span><br><span class="line"></span><br><span class="line">public function __constrcut(Door $door) &#123;</span><br><span class="line">$this -&gt; door = $door;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function open($password) &#123;</span><br><span class="line">if($this -&gt; authenticate($password)) &#123;</span><br><span class="line">$this -&gt; door -&gt; open();</span><br><span class="line">&#125;else &#123;</span><br><span class="line">echo &apos;Big no! &apos;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function authenticate($password) &#123;</span><br><span class="line">return $password === &apos;$ecr@t&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function close() &#123;</span><br><span class="line">$this -&gt; door -&gt; close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$door = new SecureDoor(new LabDoor());</span><br><span class="line">$door -&gt; open(&apos;invalid&apos;);</span><br><span class="line"></span><br><span class="line">$door -&gt; open(&apos;$ecr@t&apos;);</span><br><span class="line">$door -&gt; close();</span><br></pre></td></tr></table></figure><h3 id="行为型设计模式-1"><a href="#行为型设计模式-1" class="headerlink" title="行为型设计模式"></a>行为型设计模式</h3><p>责任链    命令行    迭代器    中介者    备忘录    观察者    访问者    策略    状态    模板</p><p>责任链<br>    构建一系列对象,请求从一端进入并继续从一个对象到另一个对象，直到找到合适的处理程序<br>    程序示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">abstract class Account &#123;</span><br><span class="line">protected $successor;</span><br><span class="line">protected $balance;</span><br><span class="line"></span><br><span class="line">public function setNext(Account $account) &#123;</span><br><span class="line">$this -&gt; succcessor = $account;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function par(float $amountToPay) &#123;</span><br><span class="line">if($this -&gt; canPay($amountToPay)) &#123;</span><br><span class="line">echo sprintf(&apos;Paid %s using %s &apos; . PHP_EOL, $amountToPay, get_called_class());</span><br><span class="line">&#125;else if($this -&gt; successor) &#123;</span><br><span class="line">echo sprintf(&apos;Cannot pay using %s. Proceeding..&apos; .PHP_EOL, get_called_class());</span><br><span class="line">$this -&gt; successor -&gt; pay($amountToPay);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">throw new Exception(&apos;None of the accounts have enough balance&apos;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function canPay($amount): bool &#123;</span><br><span class="line">return $this -&gt; balance &gt;= $amount;// 原文是 &gt;= ,感觉应该是 =</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Bank extends Account &#123;</span><br><span class="line">protected $balance;</span><br><span class="line"></span><br><span class="line">public function __construct(float $balance) &#123;</span><br><span class="line">$this -&gt; balance = $balance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Bitcoin extends Account &#123;</span><br><span class="line">protected $balance;</span><br><span class="line"></span><br><span class="line">public function __constrcut(flaot $balance) &#123;</span><br><span class="line">$this -&gt; balance = $balance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$bank = new Bank(100);</span><br><span class="line">$paypal = new Paypal(200);</span><br><span class="line">$bitcoin = new Bitcoin(300);</span><br><span class="line"></span><br><span class="line">$bank -&gt; setNext($paypal);</span><br><span class="line">$paypal -&gt; setNext($bitcoin);</span><br><span class="line"></span><br><span class="line">$bank -&gt; pay(259);</span><br></pre></td></tr></table></figure><p>命令行<br>    将操作封装在对象中，提供将客户与接收器分离的方法. 对象用于封装执行动作或稍后触发事件所需的所有信息，此信息包括方法名称，拥有该方法的对象以及方法参数的值。<br>    程序化示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Bulb &#123;</span><br><span class="line">public function trunOn() &#123;</span><br><span class="line">echo &apos;Buld has been lit&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function turnOff() &#123;</span><br><span class="line">echo &apos;Darkness !&apos;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">interface Command &#123;</span><br><span class="line">public function execute();</span><br><span class="line">public function undo();</span><br><span class="line">public function redo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TurnOn implements Command &#123;</span><br><span class="line">protected $bulb;</span><br><span class="line"></span><br><span class="line">public function __construct(Bulb $bulb) &#123;</span><br><span class="line">$this -&gt; bulb = $bulb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function execute() &#123;</span><br><span class="line">$this -&gt; bulb -&gt; turnOn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function undo() &#123;</span><br><span class="line">$this -&gt; bulb -&gt; turnOff();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function redo() &#123;</span><br><span class="line">$this -&gt; execute();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TurnOff implements Command &#123;</span><br><span class="line">protected $bulb;</span><br><span class="line"></span><br><span class="line">public function __constrcut(Bulb $bulb) &#123;</span><br><span class="line">$this -&gt; bulb = $bulb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function execute() &#123;</span><br><span class="line">$this -&gt; bulb -&gt; turnOff();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function undo() &#123;</span><br><span class="line">$this -&gt; bulb -&gt; turnOn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function redo() &#123;</span><br><span class="line">$this -&gt; execute();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class RemoteControl &#123;</span><br><span class="line">public function submit(Command $command) &#123;</span><br><span class="line">$command -&gt; execute();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$bulb = new Bulb();</span><br><span class="line"></span><br><span class="line">$turnOn = new TurnOn($bulb);</span><br><span class="line">$turnOff = new TurnOff($bulb);</span><br><span class="line"></span><br><span class="line">$remote = new RemoteControl();</span><br><span class="line">$remote -&gt; submit($turnOn);</span><br><span class="line">$remote -&gt; submit($turnOff);</span><br></pre></td></tr></table></figure><p>迭代器<br>    提供了一种访问对象元素而不是暴露底层表示的方法<br>    用于遍历容器并访问容器的元素,将算法与容器分离，因算法是特定于容器，so 不能解耦<br>    程序化示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class RadioStation &#123;</span><br><span class="line">protected $frequency;</span><br><span class="line"></span><br><span class="line">public function __construct(float $frequency) &#123;</span><br><span class="line">$this -&gt; frequency = $frequency;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function getFrequency(): float &#123;</span><br><span class="line">return $this -&gt; frequency;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">use Countable;</span><br><span class="line">use Iterator;</span><br><span class="line"></span><br><span class="line">class StationList implements Countable, Iterator &#123;</span><br><span class="line">protected $stations = [];</span><br><span class="line">protected $counter = [];</span><br><span class="line"></span><br><span class="line">public function addStation(RadioStation $station) &#123;</span><br><span class="line">$this -&gt; stations[] = $station;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function removeStation(RadioStation $toRemove) &#123;</span><br><span class="line">$toRemoveFrequency = $toRemove -&gt; getFrequency();</span><br><span class="line">$this -&gt; stations = array_filter($this -&gt; stations, function(RadioStation $station) use ($toRemoveFrequency) &#123;</span><br><span class="line">return $station -&gt; getFrequency() !== $toRemoveFrequency;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function count(): int &#123;</span><br><span class="line">return count($this -&gt; stations);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function current(): RadioStation &#123;</span><br><span class="line">return $this -&gt; stations[$this -&gt; counter];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function key() &#123;</span><br><span class="line">return $this -&gt; counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function next()&#123;</span><br><span class="line">$this -&gt; counter++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function rewind() &#123;</span><br><span class="line">$this -&gt; counter = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function valid(): bool &#123;</span><br><span class="line">return isset($this -&gt; stations[$this -&gt; counter]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$stationList = new StationList();</span><br><span class="line"></span><br><span class="line">$stationList -&gt; addStation(new RadioStation(89));</span><br><span class="line">$stationList -&gt; addStation(new RadioStation(90));</span><br><span class="line">$stationList -&gt; addStation(new RadioStation(100));</span><br><span class="line">$stationList -&gt; addStation(new RadioStation(120.3));</span><br><span class="line"></span><br><span class="line">foreach($stationList as $station) &#123;</span><br><span class="line">echo $station -&gt; getFrequency() . PHP_EOL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$stationList -&gt; removeStation(new RadioStation(89));</span><br></pre></td></tr></table></figure><p>中介者<br>    添加第三方对象控制两个对象之间的交互,减少彼此通信的类之间的耦合，不需要了解彼此的实施。 中介模式定义了一个对象，该对象封装了一组对象的交互方式，可以改变程序的运行行为。<br>    程序化示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">interface ChatRoomMediator &#123;</span><br><span class="line">public function showMessage(User $user, string $message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CharRoom implements CharRoomMediator &#123;</span><br><span class="line">public function showMessage(User $user, string $message) &#123;</span><br><span class="line">$time = date(&apos;M d, y H:i&apos;);</span><br><span class="line">$sender = $user -&gt; getName();</span><br><span class="line"></span><br><span class="line">echo $time . &apos;[&apos; . $sender .&apos;]:&apos; . $message;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">protected $name;</span><br><span class="line">protected $charMediator;</span><br><span class="line"></span><br><span class="line">public function __constrcut(string $name, ChatRoomMediator $chatMediator) &#123;</span><br><span class="line">$this -&gt; name = $name;</span><br><span class="line">$this -&gt; chatMediator = $chatMediator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function getName() &#123;</span><br><span class="line">return $this -&gt; name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function send($message) &#123;</span><br><span class="line">$this -&gt; chatMediator -&gt; showMessage($this, $message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$mediator = new ChatRoom();</span><br><span class="line"></span><br><span class="line">$hale = new User(&apos;Hale Lv &apos;, $mediator);</span><br><span class="line">$judy = new User(&apos;Judy &apos;, $mediator);</span><br><span class="line"></span><br><span class="line">$hale -&gt; send(&apos;Hi there!&apos;);</span><br><span class="line">$judy -&gt; send(&apos;Hey!!!&apos;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;center&gt; 设计模式 &lt;/center&gt;
    
    </summary>
    
    
      <category term="Design" scheme="http://yoursite.com/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>NoSQL</title>
    <link href="http://yoursite.com/2019/08/11/NoSQL-Note/"/>
    <id>http://yoursite.com/2019/08/11/NoSQL-Note/</id>
    <published>2019-08-11T05:05:07.000Z</published>
    <updated>2019-08-11T06:36:42.943Z</updated>
    
    <content type="html"><![CDATA[<center> NoSQL </center><a id="more"></a><h3 id="TODO-List"><a href="#TODO-List" class="headerlink" title="TODO List"></a>TODO List</h3><p>Redis</p><p>Memcached</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt; NoSQL &lt;/center&gt;
    
    </summary>
    
      <category term="NoSQL" scheme="http://yoursite.com/categories/NoSQL/"/>
    
      <category term="Redis" scheme="http://yoursite.com/categories/NoSQL/Redis/"/>
    
      <category term="Memcached" scheme="http://yoursite.com/categories/NoSQL/Redis/Memcached/"/>
    
    
      <category term="NoSQL" scheme="http://yoursite.com/tags/NoSQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="http://yoursite.com/2019/08/11/MySQL-Note/"/>
    <id>http://yoursite.com/2019/08/11/MySQL-Note/</id>
    <published>2019-08-11T05:00:23.000Z</published>
    <updated>2019-09-03T13:20:20.235Z</updated>
    
    <content type="html"><![CDATA[<center> MySQL </center><a id="more"></a><h3 id="TODO-LIST"><a href="#TODO-LIST" class="headerlink" title="TODO LIST"></a>TODO LIST</h3><p>基本语法<br>常见用法<br>集群<br>缓存<br>主从复制<br>双主热备<br>分库分表<br>分布式架构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">创建表：</span><br><span class="line">create table tb [if not exists] _name(</span><br><span class="line">`id` int(10) auto_incrementl,</span><br><span class="line">`name` varchar(20) not null default &apos;&apos;,</span><br><span class="line">`user_id` int(10) default 1,</span><br><span class="line">`salary` float unique,</span><br><span class="line">`create_at` time,</span><br><span class="line">primary key(id,user_id),</span><br><span class="line">contraint fk_name foreign key (field) references other_tb(id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">主键约束： primary key</span><br><span class="line">外键约束： foreign key</span><br><span class="line">非空约束： not null</span><br><span class="line">唯一性约束：unique</span><br><span class="line">默认约束：default value</span><br><span class="line">自动增加： auto__increment</span><br><span class="line"></span><br><span class="line">查看表：</span><br><span class="line">describe</span><br><span class="line">describe tb_name / desc tb_name;</span><br><span class="line"></span><br><span class="line">查看表结构：</span><br><span class="line">show create table tb_name \G</span><br><span class="line"></span><br><span class="line">查看警告信息：</span><br><span class="line">show warnings;</span><br><span class="line"></span><br><span class="line">修改数据表: </span><br><span class="line"></span><br><span class="line">修改表名：</span><br><span class="line">alter table tb_oldName rename tb_newName;</span><br><span class="line"></span><br><span class="line">修改自增ID值</span><br><span class="line">alter table tb_name auto_increment = 1</span><br><span class="line"></span><br><span class="line">修改字段的数据类型：</span><br><span class="line">alter table tb_name modify id int(11);</span><br><span class="line"></span><br><span class="line">修改字段名：</span><br><span class="line">alter table tb_name change tb_old_field  tb_new_field int(10);</span><br><span class="line"></span><br><span class="line">添加字段：</span><br><span class="line">alter table tb_7 add name varchar(100) [first|after id];</span><br><span class="line"></span><br><span class="line">删除字段：</span><br><span class="line">alter table tb_7 drop fieldName;</span><br><span class="line"></span><br><span class="line">修改字段的排列位置：</span><br><span class="line">alter table tb_7 modify name varchar(30) [first|after] id;</span><br><span class="line"></span><br><span class="line">修改表的存储引擎：</span><br><span class="line">alter table tb_7 engine = myisam;</span><br><span class="line"></span><br><span class="line">删除表的外键约束：</span><br><span class="line">alter table tb_7 drop foreign key FK_Name;</span><br><span class="line"></span><br><span class="line">删除数据表:</span><br><span class="line">drop table [if exists] tb_name;</span><br><span class="line"></span><br><span class="line">删除没有被关联的表:</span><br><span class="line">drop table tb_name;</span><br><span class="line">删除被其他表关联的表的主表：</span><br><span class="line">全部删除：删除会破坏表的参照完整性，先删除与之关联的子表，再删除父表，这样会删除两个表中的数据。</span><br><span class="line">单独删除：如果保存子表，只需将关联表的外键约束条件取消，然后删除父表</span><br><span class="line"></span><br><span class="line">alter table tb_name drop foreign key FK_Name;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">数据类型:</span><br><span class="line">整数类型:</span><br><span class="line">tinyintsmallintmediumintint(integer)bigint</span><br><span class="line"></span><br><span class="line">浮点类型:</span><br><span class="line">浮点类型：floatdouble</span><br><span class="line">定点类型：decimal</span><br><span class="line"></span><br><span class="line">字符串类型：</span><br><span class="line">charvarcharbinaryvarbinaryblobtextenumset</span><br><span class="line"></span><br><span class="line">二进制类型：</span><br><span class="line">bitbinaryvarbinarytinyblobblobmediumbloblongblob</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运算符：</span><br><span class="line">算数运算：</span><br><span class="line">+- * /</span><br><span class="line">比较运算:结果为 0，1 或者 null</span><br><span class="line">=&lt;=&gt;  &lt;&gt;(!=)&lt;= &gt;=   &gt;is nullit not null</span><br><span class="line">least  greatestbetweenandisnullinnot in  </span><br><span class="line">likeregexp</span><br><span class="line">逻辑运算：</span><br><span class="line">falsenull</span><br><span class="line">notnull </span><br><span class="line">and&amp;&amp;</span><br><span class="line">or|| </span><br><span class="line">xor</span><br><span class="line">位操作运算：</span><br><span class="line">|&amp;异或：^&lt;&lt;&gt;&gt;取反：~</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">函数：</span><br><span class="line"></span><br><span class="line">数学函数：</span><br><span class="line">绝对值函数： abc()</span><br><span class="line">平方根函数|求余函数： mod(x,y)</span><br><span class="line">获取整数函数： ceil(x), ceiling(x) , floor(x)</span><br><span class="line">随机整数函数： rand()rand(x)</span><br><span class="line">四舍五入函数： round(x), round(x,y), truncate(x,y)</span><br><span class="line">符号函数：sign(x)</span><br><span class="line">幂运算函数： pow(x,y), power(x,y), exp(x)</span><br><span class="line">对数运算函数： log(x) , log10(x)</span><br><span class="line">角度与弧度相互转换的函数： radians(x), degrees(x)</span><br><span class="line">正弦函数： sin(x)， 反弦函数: asin(x)</span><br><span class="line">余弦函数： cos(x),  反余弦函数： acos(x)</span><br><span class="line">正切函数、反正切函数、余切函数</span><br><span class="line"></span><br><span class="line">字符串函数：</span><br><span class="line">计算长度的函数： length(), char_length()</span><br><span class="line">合并字符串的函数： concat(str,str1...),concat_ws(str,str1...)</span><br><span class="line">替换字符串的函数： insert(str1, x ,len,str2)</span><br><span class="line">大小写转换函数： lower(),upper()</span><br><span class="line">获取指定长度的字符串的函数： left(s,n), right(s,n)</span><br><span class="line">填充字符串的函数： lpad(str1,len,str2), rpad(str1,len,str2)</span><br><span class="line">删除空格的函数： ltrim(s), rtrim(s), trim(s)</span><br><span class="line">删除指定字符串的函数： trim(str1 from s)</span><br><span class="line">重复生成字符串的函数： repeat(s,n)</span><br><span class="line">比较字符串大小的函数：strcmp(str,str1)</span><br><span class="line">获取字串的函数： substring(s,n,len),mid(s,n,len)</span><br><span class="line">匹配字串开始位置的函数： locate(&apos;s&apos;,&apos;str&apos;); position(&apos;s&apos; in &apos;str&apos;); instr(&apos;str&apos;,&apos;s&apos;);</span><br><span class="line">字符串逆序的函数： reverse(s)</span><br><span class="line">返回指定位置的字符串的函数：</span><br><span class="line">返回指定字符串位置的函数： field(s,s1,s2)</span><br><span class="line">返回字串位置的函数： find_in_set(s1,s2)</span><br><span class="line">选取字符串的函数： make_set(x,s1,s2...)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">日期和时间函数：</span><br><span class="line">当前日期和时间的函数：curdate(), current_date(), curdate()</span><br><span class="line">时间函数获取系统当前时间：curtime(), current_time(), curtime() </span><br><span class="line">获取当前系统日期和时间： current_timestamp(), localtime(), now(), sysdate()</span><br><span class="line">Unix时间戳函数：unix_timestamp()</span><br><span class="line">将UNIX时间戳转为普通格式时间： from_unixtime(&apos;1232131&apos;)</span><br><span class="line">返回UTC日期的函数和返回UTC时间的函数：utc_date(), utc_time(),</span><br><span class="line">返回月份的函数： month(date), monthname(date)</span><br><span class="line">获取日期的函数： dayname(d)， dayofweek(d), weekday(d)</span><br><span class="line">获取天数的函数： dayofyear(d), dayofmonth(d) </span><br><span class="line">获取年份、季度、小时、分钟、秒钟的函数：year(),quarter(), minute(), second()</span><br><span class="line">获取日期的指定值的函数：  extract(type from d)</span><br><span class="line">时间和秒钟转换的函数：time_to_sec(), sec_to_time(), </span><br><span class="line">计算日期和时间的函数：date_add(), adddate(), date_sub(), subdate(), addtime(), datediff(),subtime(), </span><br><span class="line">将日期和时间格式化的函数：date_format(), time_format(), get_format(), </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">条件判断函数：</span><br><span class="line">if(expr,v,v1)</span><br><span class="line">ifnull(v1,v2)</span><br><span class="line">case, case value when, case when</span><br><span class="line"></span><br><span class="line">系统信息函数:</span><br><span class="line">获取版本号、连接数、数据库名的函数：select version(), connect_id(), show processlist() select database(), select schema()</span><br><span class="line">获取用户名的函数：select user() | current_user() | system_user()</span><br><span class="line">获取字符串的字符集和排序方式的函数：charset(&apos;abc&apos;), charset(convert(&apos;abc&apos; using latin1), charset(version))</span><br><span class="line">获取最后一个自动生成的ID值的函数：select last_insert_id() </span><br><span class="line"></span><br><span class="line">加密函数：</span><br><span class="line">password(str)</span><br><span class="line">md5(str)</span><br><span class="line">加密函数：encode(str,pswd_str)</span><br><span class="line">解密函数：decode(crypt_str,pswd_str)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">其他函数：</span><br><span class="line">格式化函数：format()</span><br><span class="line">不同进制的数字进行转换的函数：conv() </span><br><span class="line">IP地址与数字相互转换的函数：inet_aton(), inet_ntoa()</span><br><span class="line">加锁函数和解锁函数：select get_lock(), is_used_lock(), is_free_lock(), release_lock()</span><br><span class="line">重复执行指定操作的函数：denchmark() </span><br><span class="line">改变字符集的函数：convert() </span><br><span class="line">改变数据类型的函数：cast(), convert()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">查询语句：</span><br><span class="line">基本查询：</span><br><span class="line">select &#123; *  | &#125; [from table_name  [ where &lt;&gt;] [group by &lt;&gt;] [ having &lt;&gt; ] [ order by &lt;&gt; ] [ limit [&lt;&gt;,] &lt;row count&gt;]  ]</span><br><span class="line">select filed,field1...fieldN from [table | view] where [&lt;condition&gt;]</span><br><span class="line">单表查询：</span><br><span class="line">查询所有字段：select * from table;</span><br><span class="line">查询指定字段：select filed,field1... from table;</span><br><span class="line">查询指定记录：select filed,filed1... from table where condition;</span><br><span class="line">带 IN 关键字的查询：select filed,filed1... from table where filed in (a,z) order by field;</span><br><span class="line">带 Between and 的范围查询：select filed from table where filed between a and z;</span><br><span class="line">带 Like 的字符匹配查询：select filed from table where filed like &apos;%&apos;</span><br><span class="line">% 匹配任意长度的字符，     _ 下划线只能匹配任意一个字符</span><br><span class="line">查询空值：select filed from table where filed is null | is not null </span><br><span class="line">带 And 的多条件查询：select field, field1 from table where filed &gt; condition and filed &gt; condition;</span><br><span class="line">带 Or 的多条件查询：select field, filed1 from table where field = condition or filed1 = condition;</span><br><span class="line">查询结果不重复：select distinct field from table;</span><br><span class="line">对查询结果排序：select field,filed1 from table order by field | desc | asc </span><br><span class="line">分组查询：</span><br><span class="line">gourp by field having condition</span><br><span class="line">创建分组，使用having过滤分组， 在group by 字句中使用with rollup， 多字段分组  group by 和order by 一起使用</span><br><span class="line">select filed,filed1 from table gourp by filed having count(filed1) &gt; condition;&lt;F8&gt;&lt;F9&gt;</span><br><span class="line">select filed,field1 from table gourp by filed with rollup;</span><br><span class="line">用Limit 限制查询结果的数量：select * from table limit n | n,m;</span><br><span class="line"></span><br><span class="line">集合函数查询：</span><br><span class="line">count(),sum()avg()max()min()</span><br><span class="line">连接查询：</span><br><span class="line">内连接：inner join </span><br><span class="line">select tb_1.field from table where tb_2.filed = tb_1.id;</span><br><span class="line">外连接：left join, right join</span><br><span class="line">复合条件连接查询：</span><br><span class="line">子查询：</span><br><span class="line">子查询：</span><br><span class="line">合并查询：</span><br><span class="line">为表和字段取别名：</span><br><span class="line">正则表达式查询：</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Author : Hale Lv</span><br><span class="line">@Created Time : 2019-09-02 12:43:57</span><br><span class="line">@Description :</span><br></pre></td></tr></table></figure><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><pre><code>存储方式    计算机数据Data 的存储一般以 硬盘 为数据存储空间资源，从而保证计算机内的数据能够保持保存，对于数据的处理，一般采用数据库相关的技术进行处理，从而保证数据处理的高效性数据库    是数据管理的有效技术，是由一批数据构成的有序集合，这些数据存放在结构化的数据表里，数据表之间相互关联，反映客观事物的本质联系，有效帮助组织或企业科学管理各类信息资源数据    是数据库中存储的基本对象，是按一定顺序排列组合的物理符号，数据有多种表现形式，可是数字、文字、图像、音频、视频等，可经过数字化存入计算机数据库 是 数据 的集合，具有同一的结构形式存放于统一的存储介质内，是多种应用数据的继承，并可悲各个应用程序共享</code></pre><h4 id="数据库的存储结构"><a href="#数据库的存储结构" class="headerlink" title="数据库的存储结构"></a>数据库的存储结构</h4><pre><code>是指数据库中的物理数据和逻辑数据的表示形式、物理和逻辑数据关系映射方式的描述。可使用两种形式描述客观现实的数据。物理数据和逻辑数据之间的转换通过数据库管理系统实现。物理数据描述    是指数据在存储设备上的存储方式，实际存放在存储设备上的数据。根据物理记录存储位置，可分为有序存储和无需存储</code></pre><h6 id="物理数据包括："><a href="#物理数据包括：" class="headerlink" title="物理数据包括："></a>物理数据包括：</h6><pre><code>1. 位 bit ： 二进制的一个单位称为位 ，位只能取 1 或 02. 字节 byte ： 8个位称为一个字节，可存放对应的ASCII码的一个字符3. 字 word ： 若干个字节组成一个字，一个字所含的二进制的位数称为字长，计算计算机的字长是不同的，可是0、16、24、32位等4. 块 block ： 内存储器和外存储器交换信息的最小单位，称为物理块或物理记录，每块大小为 256字节、512字节、1024字节等5. 卷 volume ： 一台输入输出设备所能装载的全部有用信息，如；磁带机的一盘磁带即为一卷，磁盘设备的一个盘组也是一卷。6. 无序存储 unordered ： 数据记录按照插入的顺序进行存储</code></pre><h6 id="逻辑数据描述"><a href="#逻辑数据描述" class="headerlink" title="逻辑数据描述"></a>逻辑数据描述</h6><pre><code>指用户或程序员用于操作的数据形式，是一种抽象的概念，是对客观现实世界的反映和记录，也可称为 逻辑记录逻辑数据包含两个层次，一个层次是对客观现实信息世界的描述，另一个层次是对数据库管理系统中数据的描述对客观信息世界的描述包括：    1. 实体 entity ： 客观现实存在的东西用实体来描述，可是具体的、有型的，也可是抽象的、无形的对象，如： 一本书是一个有形对象，另一个是无形对象    2. 实体集 entities ： 特征完全相同的同类实体的集合称为实体集，如一个图书馆所有书籍是一个实体集。    3. 属性 attribute ： 实体的特性称为属性，每个属性都有一个值域。可以是整数类型、浮点数类型、字符类型、日期类型等    4. 标识符 identifier ： 能够唯一地标识每个实体的属性或属性集，如 书的书号属性是实体书的标识符。    关系型数据库管理系统介绍；        1. 数据项 data item ： 也称字段field ，标记实体属性的命名的最小信息单位，命名采用属性的描述性名称        2. 元组 tuple ： 也称 记录 record ，数据项的集合称为 元组，一个元组表示一个具体的实体        3. 关系 relation ： 同一类元组所在的集合称为关系，适用于描述实体集，包括一个实体集的所有元组        4. 键码 key ： 能够唯一标识关系中每个元组的数据项或数据项的组合称为关系的键码</code></pre><h3 id="数据库涉及的技术"><a href="#数据库涉及的技术" class="headerlink" title="数据库涉及的技术"></a>数据库涉及的技术</h3><pre><code>数据库系统    Database Management System ，DBMS 是位于操作系统与用户之间的额一种操纵和管理数据库的软件，按照一定的数据模型科学地组织和存储数据，同时可提供数据高效地获取和维护    DBMS 主要功能概括：        1. 数据定义功能：                数据定义语言 Data Definition Language， DDL：用户通过它可方便对数据库中的数据对象进行定义            数据操纵功能 Data Manipulation Language ，DML： 实现对数据库的基本操作，如：查询、插入、删除和修改等            数据库的运行管理： 数据库在建立、运用和维护时由数据库管理系统统一管理、统一控制、保证数据的安全性、完整性、多用户对数据的并发使用及发生故障后的系统恢复，如；                1. 数据的完整性检查功能保证用户输入的数据应该满足相应的约束条件                2. 安全保护功能保证只有赋予权限的用户才能访问数据库中的数据                3. 并发控制能力使多个用户可在同一时刻并发地访问数据库的数据                4. 故障恢复功能使数据库运行出现故障时可进行数据恢复，保证数据库可靠运行            提供方便、有效地存储数据库信息的接口和工具                编程语言与数据库之间的接口进行数据库应用程序的开发。 数据库管理员Database Administrator， DBA 通过提供的工具对数据进行管理            数据库的建立和维护功能                数据库输出话数据的输入、转换功能，数据库的转储、恢复功能，数据库的重组织功能和性能监控、分析功能等                数据库系统是指计算机系统中引入数据库后的系统，一个完整的数据库系统Database System ，DBS 一般由数据库、数据库管理系统、应用开发工具、应用系统、数据库管理员和用户组成。</code></pre><h3 id="SQL语言"><a href="#SQL语言" class="headerlink" title="SQL语言"></a>SQL语言</h3><pre><code>通过结构化查询语言 Structed Query Language， SQL来实现，是各种数据库交互方式的基础SQL是一种数据库查询和程序设计语言，用户存取数据以及查询、更新和管理关系数据库系统    优点：    1. 一体化 ： SQL 集数据定义、数据操作和数据控制一体，可完成数据库中的全部工作    2. 使用方式灵活： 两种使用方式，直接命令交互方式使用；也可嵌入使用，嵌入C、C++等    3. 非过程化： 只提操作要求，不必描述操作步骤    4. 语言简洁： 语法简单、好学好用。包含94个单词、6个核心功能动词数据库访问技术    包括： ODBC、DAO、OLE DB 和ADO        ODBC ： Open Database Connectivity，开放数据库互连，建立了一组规范，提供了一组对数据库访问的标准API(应用程序编程接口)        DAO ： Data Access Object ， 数据访问对象，是基于一个数据库对象集合的访问技术，独立于DBMS进行数据库的访问        OLE DB ： Object Linking and Embedding Database，对象连接与嵌入。开放数据库连接通性 ODBC 的结构化查询语言SQL的能力，具有面向其他非SQL数据类型的通路，是一组读写数据的方法，对象主要包括数据源对象、阶段对象、命令对象和行组对象        ADO ： ActiveX Data Objects，是一个用于存取数据源的COM组件，提供编程语言和统一数据访问方式OLE DB 的一个中间层，允许编写访问数据的代码而不用关心数据库是如何实现过得，只关心到数据库的连接</code></pre><h3 id="数据库的优势"><a href="#数据库的优势" class="headerlink" title="数据库的优势"></a>数据库的优势</h3><pre><code>具有以下系统特性：    1. 使用C和C++编写，可移植性    2. 支持Linux 、Mac OS、Windows 等多种操作系统    3. 多种编程语言：C、C++、Python、PHP、Java、等    4. 支持多线程，充分利用CPU资源    5. 优化的SQL查询算法，有效提高查询速度    6. 作为一个单独的应用程序在客户端服务器网络环境中，也可作为一个库嵌入其他的软件中    7. 提供多语言支，编码： GB2312、BIG5等    8. 提供TCP/IP、ODBC 和 JDBC 等多种数据库连接途径    9. 提供用于管理、检查、优化数据库操作的管理工具    10. 支持大型的数据库，可处理拥有上千万条记录的大型数据库    11. 支持多种存储引擎MySQL 版本及版本号    如 mysql-5.7.20        5 ：是主版本号        7 ： 是发行级别        20： 在此发行系列的版本号新特性：    1. 随机root密码    2. 自定义test 数据库    3. 默认SSL加密    4. 密码过期策略    5. 用户锁    6. 全面支持JSON    7. 支持两类生成列 generated column    8. 引入系统库 sys schema    具体看官网新版本的更新内容</code></pre><h3 id="MySQL-客户端和服务器端工具集"><a href="#MySQL-客户端和服务器端工具集" class="headerlink" title="MySQL 客户端和服务器端工具集"></a>MySQL 客户端和服务器端工具集</h3><pre><code>    MySQL 服务器端：        1. mysqld ：SQL后台程序。必须运行，客户端才能连接服务器来访问数据库        2. mysqld_safe ： 服务器启动脚本，mysqld_safe 来启动 mysqld 服务器，mysqld_safe 增加了安全性，如出现错误，重启服务器向错误日志写入运行时间信息        3. mysql.server ： 服务器启动脚本，用于使用包含特定级别的、运行启动服务器脚本的、运行目录的系统，调用mysqld_safe 启动mysql服务器        4. mysqld_multi ：服务器启动脚本，可启动或停止系统安装的多个服务器        5. mysamchk ： 用来描述、检查、优化和维护MyISAM表的使用工具        6. mysql.server ： 服务器启动脚本        7. mysqlbug ： MySQL 缺陷报告脚本，可用来向MySQL邮件系统发送缺陷报告        8. mysql_install_db ： 使用默认权限创建 MySQL授予权表，首次安装mysql时执行一次    MySQL 客户端：        1. myisampack ：压缩MyISAM 表产生更小的制度表的一个工具        2. mysql ：交互输入SQL语句或从文件批处理模式执行他们的命令行工具        3. mysqlaccess ： 检查访问主机名、用户名和额数据库组合的权限的脚本        4. mysqladmin ： 执行管理操作的客户程序，如创建、删除、重载授权表、将表刷新到硬盘以及重新打开日志文件。 还可用来检查索引版本、进程及服务器的版本信息        5. mysqlbinlog ： 从二进制日志读取语句的工具，在二进制日志文件中包含执行过的语句，可帮助系统从奔溃中恢复        6. mysqlcheck ： 检查、修复、分析、优化表的表维护客户程序        7. mysqldump ： 将MySQL数据库转储到一个文件        8. mysqlhotcopy ： 当服务器在运行时，快速备份 MyISAM 或ISAM表的工具        9. mysql import ： 使用LOAD DATA INFILE 将文本文件导入相应的额客户程序        10. mysqlshow ： 显示数据库、表、列及索引相关信息的客户程序        11. perror ： 显示系统或MySQL错误代码含义的工具MySQL 免安装版配置    [免安装版](http://c.biancheng.net/view/2412.html)</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Author : Hale Lv</span><br><span class="line">@Created Time : 2019-09-02 14:29:19</span><br><span class="line">@Description :</span><br></pre></td></tr></table></figure><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><pre><code>数据库可看作是一个专门存储数据对象的容器，这里的数据对象包括表、视图、触发器、存储过程等，表是最基本的数据对象，在创建数据对象前，先要创建数据库创建数据库： CREATE DATABASE     CREATE DATABASE [IF NOT EXISTS] &lt;数据库名&gt; [[DEFAULT] CHARSET SET &lt;字符集名&gt;] [[DEFAULT] COLLATE &lt;校对规则名&gt;]；    [] 是可选的，语法说明：        - &lt;数据库名&gt; ： 创建数据库的名称，不区分大小写        - IF NOT EXISTS : 在创建数据库之前进行判断，该数据库不存在时执行此操作        - [DEFAULT] CHARSET SET : 指定数据库的默认字符集        - [DEFAULT] COLLATE : 指定字符集的默认校对规则    MYSQL 的字符集 CHARSET 和校对规则 COLLATION 两个不同概念： 字符集用来定义MYSQL存储字符串的方式，校对规则定义了比较字符串的方式，解决排序和字符分组的问题    创建MYSQL数据库的语句：        CREATE DATABASE test_db；        MYSQL 不允许在同一系统创建两个相同名称的数据库        CREATE DATABASE IF NOT EXISTS test_db； // 避免出现已存在错误提示    创建MySQL数据库时指定字符集和校对规则        创建test_db_char ，指定默认字符集为utf8， 默认校对规则为 utf8_chinese_ci        CREATE DATABASE IF NOT EXISTS test_db_char            DEFAULT CHARACTER SET utf8            DEFAULT COLLATE utf8_chinese_ci;    使用SHOW CREATE DATABASE查看 test_db_char 数据库的定义声明</code></pre><h3 id="MySQL查看或显示数据库（SHOW-DATABASES语句）"><a href="#MySQL查看或显示数据库（SHOW-DATABASES语句）" class="headerlink" title="MySQL查看或显示数据库（SHOW DATABASES语句）"></a>MySQL查看或显示数据库（SHOW DATABASES语句）</h3><pre><code>SHOW DATABASES [LIKE &apos;数据库名&apos;];    1. LIKE 从句，可选，用于匹配数据库名    2. 数据库名由 &apos;&apos; 包围1. 查看所有数据库    SHOW DATABASES2. 创建并查看数据库    CREATE DATABASE test_db；    SHOW DATABASE;3. 使用LIKE 语句    SHOW DATABASES LIKE &apos;test_db&apos;;    SHOW DATABASES LIKE &apos;%test%&apos;    SHOW DATABASES LIKE &apos;db%&apos;    SHOW DATABASES LIKE &apos;%db&apos;</code></pre><h3 id="MYSQL-修改数据库：-ALTER-DATABASE"><a href="#MYSQL-修改数据库：-ALTER-DATABASE" class="headerlink" title="MYSQL 修改数据库： ALTER DATABASE"></a>MYSQL 修改数据库： ALTER DATABASE</h3><pre><code>修改数据库，使用 ALTER DATABASE 或 ALTER SCHEMA 语句修改数据库语法：    ALTER DATABASES [数据库米ing] { [DEFAULT] CHARACTER SET &lt;字符集名&gt; [DEFAULT] COLLATE &lt;校对规则名&gt; }        1. ALTER DATABASES 更改数据库的全局特性，存储在db.opt 文件中        2. 需要获取ALTER 权限        3. 数据库名可忽略， 对应默认数据库        4. CHARCTER SET 子句用于更改默认的数据库字符集修改数据库字符集    SHOW CREATE DATABASE test_db；    CREATE DATABASE test_db DEFAULT CHARACTER SET gb2312 DEFAULT COLLATE gb2312_chinese_ci;</code></pre><h3 id="删除数据库-DROP-DATABASES"><a href="#删除数据库-DROP-DATABASES" class="headerlink" title="删除数据库 DROP DATABASES"></a>删除数据库 DROP DATABASES</h3><pre><code>DROP DATABASE | DROP SCHEMADROP DATABASE [IF EXISTS] &lt;数据库名&gt;    1. 数据库名： 指定要删除的数据库名    2. IF EXISTS ： 防止当前数据库不存在时发生错误    3. DROP DATABASE ： 删除数据库中的所有表哥并同时删除数据库    不能删除 information_schema 和 mysql的两个系统数据库，否则不能工作MYSQL删除数据库：    DROP DATABASE test_db；    DROP DATABASE IF NOT EXISTS test_db；</code></pre><h3 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h3><pre><code>USE 用来完成一个数据库到另一个数据库的跳转USE &lt;数据库名&gt;</code></pre><h3 id="存储引擎详解"><a href="#存储引擎详解" class="headerlink" title="存储引擎详解"></a>存储引擎详解</h3><pre><code>存储引擎    是数据库底层软件组件，使用数据引擎进行创建、查询、更新和删除数据操作    InnoDb 事务型数据库的首选引擎， 支持事物安全表ACID，支持行锁定和外键    MyISAM 基于ISAM的存储引擎，拥有较高的插入、查询速度，不支持事物    可对每一个表使用不同的存储引擎    支持的存储引擎有：        InnoDB、MyISAM、Memory、Merge、Archive、Federated、CSV、Blackhole等</code></pre><h4 id="使用-SHOW-ENGINES，查看系统支持的引擎类型"><a href="#使用-SHOW-ENGINES，查看系统支持的引擎类型" class="headerlink" title="使用 SHOW ENGINES，查看系统支持的引擎类型"></a>使用 SHOW ENGINES，查看系统支持的引擎类型</h4><h3 id="如何选择MYSQL存储引擎"><a href="#如何选择MYSQL存储引擎" class="headerlink" title="如何选择MYSQL存储引擎"></a>如何选择MYSQL存储引擎</h3><pre><code>    功能                MyISAM        MEMORY        INNODB        ARCHIVE  存储限制                256TB        RAM            64TB        NONE  支持事物                No            No            Yes            No支持全文索引            Yes            No            No            No支持树索引                Yes            Yes            Yes            No支持哈希索引            No            Yes            No            No支持数据缓存            No            N/A            Yes            No支持外键                No            No            Yes            No选择MYSQL存储引擎的原则：    1. 如要提交、回滚、恢复的事物安全ACID能力，并要求实现并发控制，选择InnoDB    2. 插入和查询记录，选择MyISAM    3. 临时存放数据，数据量不大， 不需要较高的数据安全性，可将数据保存在内存的MEMORY引擎中    4. 如只有 INSET 和SELECT ，选择 ARCHIVE引擎，支持高并发的插入操作，适合存储归档数据，如记录日志信息可使用Archive    一个数据库中可使用不同的引擎以满足各种性能和实际需求</code></pre><h4 id="MYSQL-默认存储引擎"><a href="#MYSQL-默认存储引擎" class="headerlink" title="MYSQL 默认存储引擎"></a>MYSQL 默认存储引擎</h4><pre><code>使用下面语句修改数据库临时的默认存储引擎：    SET default_storage_engine = &lt;存储引擎名&gt;        SET default_storage_engine = MyISAM;    重启MYSQL客户端，默认存储引擎是 InnoDB</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Author : Hale Lv</span><br><span class="line">@Created Time : 2019-09-02 16:12:27</span><br><span class="line">@Description :</span><br></pre></td></tr></table></figure><h2 id="常见数据类型"><a href="#常见数据类型" class="headerlink" title="常见数据类型"></a>常见数据类型</h2><pre><code>1. 整数类型    INTYINT、 SMALLINT、 MEDIUMINT、 INT、 BIGINT、 浮点数类型 FLOAT 和 DOUBLE，定点树类型 DECIMAL 2. 日期/时间类型    YEAR、 TIME、 DATE、 DATETIME 和 TIMESTAMP3. 字符串类型    CHAR、 VARCHAR、 BINARY、 VARBINARY、 BLOG、 TEXT、 ENUM、 SET等4. 二进制类型    BIT、 BINARY、 VARBINARY、 TINYBLOB、 BLOB、 MEDIUMBLOB、 LONGBLOB</code></pre><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><pre><code>属性字段可以添加AUTO_INCREMENT 自增约束条件    类型名称            说明            存储需求    TINYINT            很小的整数            1个字节 | 0～255    SMALLINT        小的整数            2个字节    | 0～65535     MEDIUMINT        中等大小的整数        3个字节    | 0～16777215    INT|INTEGHR        普通大小的整数        4个字节    | 0～4294967295    BININT            大整数                8个字节    | 0～18446744074709551615</code></pre><h3 id="小数类型-FLOAT、DOUBLE、-DECIMAL"><a href="#小数类型-FLOAT、DOUBLE、-DECIMAL" class="headerlink" title="小数类型 FLOAT、DOUBLE、 DECIMAL"></a>小数类型 FLOAT、DOUBLE、 DECIMAL</h3><pre><code>    单精度浮点数 FLOAT， 双精度浮点数 DOUBLE， 定点类型： DECIMAL    浮点类型和定点类型都可用 M、D表示，M为精度，表示总共的位数， D为标度，表示小数的位数    类型名称            说明            存储需求    FLOAT            单精度浮点数        4个字节    DOUBLE            双精度浮点数        8个字节    DECIMAL(M,D), DEC  压缩的严格定点数    M+2个字节定点数以字符串形式存储，对精度要求比较高的时候，使用DECIMAL的类型，避免做浮点数比较</code></pre><h3 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h3><pre><code>每一个类型都有合法的取值范围，当指定确定不合法的值时，系统将 零 值插入数据表中类型名称        日期格式            日期范围                存储需求YEAR            YYYY                1901～2155                1个字节TIME            HH:MM:SS                                    3个字节DATE            YYYY-MM-DD                                    3个字节DATETIME        YYYY-MM-DD HH:MM:SS                            8个字节TIMESTAMP        YYYY-MM-DD HH:MM:SS                            4个字节[More](http://c.biancheng.net/view/2425.html)</code></pre><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><pre><code>字符串类型中，括号中的M表示可为其指定长度类型名称                说明                    存储需求CHAR(M)VARCHAR(M)TINYTEXTTEXTMEDIUMTEXTLONGTEXTENUMSET[More](http://c.biancheng.net/view/2426.html)</code></pre><h3 id="二进制类型"><a href="#二进制类型" class="headerlink" title="二进制类型"></a>二进制类型</h3><pre><code>类型名称            说明                存储需求BIT(M)BINARY(M)VARBINARY(M)BLOB(M)MEDIUMBLOB(M)LONGBLOB(M)[More](http://c.biancheng.net/view/2428.html)</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Author : Hale Lv</span><br><span class="line">@Created Time : 2019-09-02 16:39:36</span><br><span class="line">@Description :</span><br></pre></td></tr></table></figure><h2 id="MYSQL-数据表增删改查"><a href="#MYSQL-数据表增删改查" class="headerlink" title="MYSQL 数据表增删改查"></a>MYSQL 数据表增删改查</h2><h3 id="创建数据表-CREATE-TABLE"><a href="#创建数据表-CREATE-TABLE" class="headerlink" title="创建数据表 CREATE TABLE"></a>创建数据表 CREATE TABLE</h3><pre><code>在已经创建的数据库中创建新表    CREATE TABLE  &lt;表名&gt; ([表定义选项][表选项][分区选项]);    主要由表创建定义 create-definition、 表选项 table-options 和 分区选项 partition-options 组成        1. CREATE TABLE ： 用于创建给定名称的表，必须拥有表CREATE 的权限        2. 表名： 指定要创建表的名称        3. 表定义选项： 表创建定义，由列名col_name、列的定义 column_definition 以及空值说明、完整性约束或表索引组成        4. 默认的情况，表被创建到当前的数据库中</code></pre><h4 id="在指定数据库中创建表"><a href="#在指定数据库中创建表" class="headerlink" title="在指定数据库中创建表"></a>在指定数据库中创建表</h4><pre><code>使用 USE 数据库名 指定操作的数据库    USE 数据库名    CREATE TABLE 数据表名 (        ...    )查看表结构：    DESC  | DESCRIBE  TABLE     SHOW CREATE TABLE    各个字段的含义：        1. NULL ：表示该列可存储NULL值        2. Key ： 该列是否已编制索引，PRI：该列是表主键的一部分， UNI：UNIQUE索引的一部分， MUL：列中某个定植允许出现多次        3. Default ： 表示该列是否有默认值，如有，值是多少        4. Extra ： 可获取的与给定列有关的附加信息，如 AUTO_INCREMENT等结合：    SHOW CREATE TABLE &lt;TABLE_NAME&gt;\G;    SHOW CREATE TABLE tb_name \G    CREATE TABLE `tb_name` (        `id` int(11) DEFAULT NULL,        `name` varchar(100) DEFAULT NULL,        `salary` float DEFAULT NULL    )ENGINE=InnoDB DEFAULT CHARSET=gb2312</code></pre><h3 id="MySQl-修改数据表-ALTER-TABLE"><a href="#MySQl-修改数据表-ALTER-TABLE" class="headerlink" title="MySQl 修改数据表 ALTER TABLE"></a>MySQl 修改数据表 ALTER TABLE</h3><pre><code>修改表指修改数据库中已经存在的数据表的结构。使用 ALTER TABLE 修改。修改表的操作有：修改表名、修改字段数据类型或字段名、增加和删除字段、修改字段的排列位置、更改表的存储引擎、删除表的外键约束等    ALTER TABLE &lt;表名&gt; [修改选项]        选项：            {                ADD COLUMN &lt;列名&gt; &lt;类型&gt;    |                CHANGE COLUMN &lt;旧列名&gt; &lt;新列名&gt; &lt;新列类型&gt;    |                ALTER COLUMN &lt;列名&gt; { SET DEFAULT &lt;默认值&gt; | DROP DEFAULT }    |                MODIFY COLUMN &lt;列名&gt; &lt;类型&gt;    |                DROP COLUMN &lt;列名&gt;    |                RENAME TO &lt;新表名&gt;            }添加字段    ALTER  TABLE  &lt;表名&gt; ADD &lt;新字段名&gt; &lt;数据类型&gt;  [约束调教] [FIRST|AFTER 已存在的字段名];        新字段名为要添加的字段的名称修改字段数据类型    修改字段的数据类型即把字段的数据类型转换成另一种数据类型    ALTER TABLE &lt;表明&gt; MODIFY &lt;字段名&gt; &lt;数据类型&gt;删除字段    ALTER TABLE &lt;表名&gt; DROP &lt;字段名&gt;;修改字段名称    ALTER TABLE  &lt;表名&gt;  CHANGE  &lt;旧字段名&gt;  &lt;新字段名&gt; &lt;新数据类型&gt;;        :CHANGE 可只修改数据类型，实现和MODIFY同样的效果，将SQL中的新字段名 和 旧字段名设置为相同的名称，只改变 数据类型修改表名    ALTER TABLE &lt;旧表名&gt; RENAME &lt;TO&gt; &lt;新表名&gt;;        :TO 为可选参数</code></pre><h3 id="删除数据表-DROP-TABLE"><a href="#删除数据表-DROP-TABLE" class="headerlink" title="删除数据表 DROP TABLE"></a>删除数据表 DROP TABLE</h3><pre><code>DROP TABLE [IF EXISTS] &lt;表名&gt; [, &lt;表名1&gt; , &lt;表名2&gt; ] ...    1. 表名： 被删除的表名，可同时删除多个表    2. 表被删除时，所有表数据和表定义会被取消    3. 表被删除时，权限不会自动被删除    4. IF EXISTS 在删除前判断删除的表是否存在删除表    DROP TABLE test_tb;</code></pre><h3 id="MYSQL-INSERT-：-插入数据"><a href="#MYSQL-INSERT-：-插入数据" class="headerlink" title="MYSQL INSERT ： 插入数据"></a>MYSQL INSERT ： 插入数据</h3><pre><code>有两种语法：    1. INSERT ... VALUES 语句        INSERT INTO &lt;表名&gt; [ &lt;列名1&gt; [,...&lt;列名n&gt;]] VALUES (值1) [...,(值n)];            ： 表名 ：指定被操作的表名            ： 列名： 指定需要插入数据的列名，如向表中所有列插入数据，可省略列名            ： VALUES 或 VALUE 子句： 要插入的数据清单顺序要和列的顺序相对应    2. INSERT ... SET 语句        INSERT INTO &lt;表名&gt; SET &lt;列名&gt; = &lt;值1&gt;, &lt;列名2&gt; = &lt;值2&gt;, ...        ：INSERT 。。。VALUES 可向表中插入一行或多行数据    ：INSERT。。 VALUES 可指定插入行中每列的值，也可指定部分列的值    ：INSERT。。。SELECT 可向表中插入其他表的数据    ：INSERT 。。。SET可向表中插入部分列的值    ：INSERT。。。VALUES可一次插入多条数据使用INSERT INTO 。。。FROM 语句复制表数据</code></pre><h3 id="MYSQL-UPDATE-：-修改数据-更新数据"><a href="#MYSQL-UPDATE-：-修改数据-更新数据" class="headerlink" title="MYSQL UPDATE ： 修改数据|更新数据"></a>MYSQL UPDATE ： 修改数据|更新数据</h3><pre><code>UPDATE &lt;表名&gt; SET 字段1=值 1 [，字段 2 = 值 2.。。] [ WHERE 子句] [ORDER BY 子句] [LIMIT 子句]    ： 表名： 指定要更新的表名称    ： SET 子句： 指定表中要修改的列名以及其值    ： WHERE 子句： 限定表中要修改的行，如不指定，修改所有行    ： ORDER BY： 限定表中的行被修改的次序    ： LIMIT 子句： 限定被修改的行数</code></pre><h3 id="MYSQL-DELETE-：-删除数据"><a href="#MYSQL-DELETE-：-删除数据" class="headerlink" title="MYSQL DELETE ： 删除数据"></a>MYSQL DELETE ： 删除数据</h3><pre><code>DELETE FORM &lt;表名&gt; [WHERE 子句] [ORDER BY 子句] [LIMIT 子句]    ： 表名； 指定要删除的表名    ： ORDER BY ： 按照子句中指定的顺序进行删除    ： WHERE 子句： 为删除操作限定删除条件，如省略，则删除素有行    ： LIMIT 子句： 被删除行的最大值不使用WHERE条件的时候，将删除所有数据</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Author : Hale Lv</span><br><span class="line">@Created Time : 2019-09-03 09:14:58</span><br><span class="line">@Description :</span><br></pre></td></tr></table></figure><h2 id="MYSQL-主键-PRIMARY-KEY"><a href="#MYSQL-主键-PRIMARY-KEY" class="headerlink" title="MYSQL 主键 PRIMARY KEY"></a>MYSQL 主键 PRIMARY KEY</h2><pre><code>主键PRIMARY KEY 完整称呼为： 主键约束。 是一个列或列的组合，其值能唯一地标识表中的每一行， 这样的一列或多列成为表的主键，可强制表的实体完整性选取设置主键约束的字段    需遵守的规则：        1. 每个表只能定义一个主键        2. 主键值必须是唯一标识表中的每一行，不能为NULL，即表中不能存在两行数据有相同的主键值        3. 一个列名只能在复合主键列表中出现一次        4. 复合主键不能包含不必要的多余列。 在创建表时设置主键约束    &lt;字段名&gt; &lt;数据类型&gt; PRIMARY KEY [默认值]    在定义完所有列之后，指定主键的语法格式：        [CONSTRAINT] &lt;约束名&gt; | PRIMARY KEY [字段名]在创建表时设置复合主键    PRIMARY KEY [字段1，字段2，。。。字段n]在修改表时添加主键约束    ALTER TABLE &lt;数据表名&gt; ADD PRIMARY KEY(&lt;列名&gt;);</code></pre><h3 id="MYSQL-外键约束-FOREIGN-KEY"><a href="#MYSQL-外键约束-FOREIGN-KEY" class="headerlink" title="MYSQL 外键约束 FOREIGN KEY"></a>MYSQL 外键约束 FOREIGN KEY</h3><pre><code>外键约束用来在 两个表之间建立连接，可是一列或多列， 一个表可有一个或多个外键外键对应的参照完整性，一个表的外键可是空值，如不为空，则每个外键的值必须等于另一个表中主键的某个值作用：保持数据的一致性、完整性，如部门表 tb_dept 的主键是 id， 员工表 tb_emp中有一个键 deptID 与 这个 id 关联    主表(父表)： 对于两个具有关联关系的表而言，相关联字段中主键所在的表就是主表    从表(子表)： 对于两个具有关联关系的表而言，相关联字段中外键所在的表就是从表选取设置MYSQL外键约束的字段    定义外键，需遵守的规则：        1. 父表存在与数据库中，或是当前正在创建的表，父表与子表是同一个表，这样的表称为 自参照表， 结构称为 自参照完整性        2. 必须为父表定义主键        3. 主键不能包含空值，允许外键中出现空值        4. 在父表的表名后指定列名或列名的组合，这个列或列名的组合必须是父表的主键或候选键        5. 外键中列的树木必须和父表的主键中列的数目相同        6. 外键中列的数据类型必须和父表主键中对应的数据类型相同在创建表时设置外键约束    在数据表中是创建外键使用 FOREIGN KEY 关键字        [CONSTRAINT &lt;外键名&gt;] FOREIGN KEY 字段名 [,字段名2,...] REFERENCES &lt;主表名&gt; 主键列1 [, 主键列2,...]        :外键名 为定义的外键约束的名称，不能有相同名称的外键；字段名表示子表需要添加外键约束的字段列； 主表名即被子表外键所依赖的表的名称；主键列表示主表中定义的主键列或列组合在修改表时添加外键约束    ALTER TABLE &lt;数据表名&gt; ADD CONSTRAINT &lt;索引名&gt; FOREIGN KEY(列名) REFERENCES &lt;主键名&gt; (&lt;列名&gt;);删除外键约束    删除外键，解除主表和从表间的关联关系    ALTER TABLE &lt;表名&gt; DROP FOREIGN KEY &lt;外键约束名&gt;;</code></pre><h3 id="MYSQL-唯一约束-UNIQUE-KEY"><a href="#MYSQL-唯一约束-UNIQUE-KEY" class="headerlink" title="MYSQL 唯一约束 UNIQUE KEY"></a>MYSQL 唯一约束 UNIQUE KEY</h3><pre><code>要求该列唯一，允许为空，但只能出现一个空值，唯一约束可确保一列或几列不出现重复值在创建表时设置唯一约束    &lt;字段名&gt; &lt;数据类型&gt; UNIQUEUNIQUE 和 PRIMARY KEY 的区别： 一个表可有多个字段声明为UNIQUE，但只能有一个PRIMARY KEY 声明；声明为PAIMARY KEY的列不允许有空值，UNIQUE的字段允许空值的存在在修改表时添加唯一约束    ALTER TABLE &lt;数据表名&gt; ADD CONSTRAINT &lt;唯一约束名&gt; UNIQUE(&lt;列名&gt;);删除唯一约束    ALTER TABLE &lt;表名&gt; DROP INDEX &lt;唯一约束名&gt;;</code></pre><h3 id="MYSQL检查约束-CHECK"><a href="#MYSQL检查约束-CHECK" class="headerlink" title="MYSQL检查约束 CHECK"></a>MYSQL检查约束 CHECK</h3><pre><code>选取设置检查约束的字段    CHECK &lt;表达式&gt;        ：表达式指SQL，用于指定需要检查的限定条件    若将CHECK约束子句置于某个列的定义之后，这种约束称为基于列的CHECK 约束    在更新表数据的时候，系统检查更新后的数据行是否满足CHECK约束中的限定条件在创建表时设置检查约束    CHECK (&lt;检查约束&gt;)在修改表时添加检查约束    ALTER TABLE tb_emp ADD CONSTRAINT &lt;检查约束名&gt; CHECK(&lt;检查约束&gt;)删除检查约束        ALTER TABLE &lt;数据表名&gt; DROP CONSTRAINT &lt;检查约束名&gt;;</code></pre><h3 id="默认值-DEFAULT"><a href="#默认值-DEFAULT" class="headerlink" title="默认值 DEFAULT"></a>默认值 DEFAULT</h3><pre><code>完整称呼为： 默认值约束 DEFAULT Constraint，默认值约束用来指定某列的默认值在创建表时设置默认值约束    &lt;字段名&gt; &lt;数据类型&gt; DEFAULT &lt;默认值&gt;;在修改表时添加默认值约束    ALTER TABLE &lt;数据表名&gt; CHANGE COLUMN &lt;字段名&gt; &lt;数据类型&gt; DEFAULT &lt;默认值&gt;;删除默认值约束    ALTER TABLE &lt;数据表名&gt; CHANGE COLUMN &lt;字段名&gt; &lt;字段名&gt; &lt;数据类型&gt; DEFAULT NULL;</code></pre><h3 id="MYSQL-非空约束-NOT-NULL"><a href="#MYSQL-非空约束-NOT-NULL" class="headerlink" title="MYSQL 非空约束 NOT NULL"></a>MYSQL 非空约束 NOT NULL</h3><pre><code>可通过 CREATE TABLE 或 ALTER TABLE 实现，在表中某个列的定义后加上关键字 NOT NULL 作为限定词，来约束该列的取值不能为空在创建表时设置非空约束    &lt;字段名&gt; &lt;数据类型&gt; NOT NULL;在修改表时添加非空约束    ALTER TABLE &lt;数据表名&gt; CHANGE COLUMN &lt;字段名&gt; &lt;字段名&gt; &lt;数据类型&gt; NOT NULL;删除非空约束    ALTER TABLE &lt;数据表名&gt; CHANGE COLUMN &lt;字段名&gt; &lt;字段名&gt; &lt;数据类型&gt; NOT NULL;</code></pre><h3 id="MYSQL-查看表中的约束"><a href="#MYSQL-查看表中的约束" class="headerlink" title="MYSQL 查看表中的约束"></a>MYSQL 查看表中的约束</h3><pre><code>使用 SHOW  CREATE TABLE 查看表约束SHOW CREATE TABLE &lt;数据表名&gt;;</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Author : Hale Lv</span><br><span class="line">@Created Time : 2019-09-03 10:50:13</span><br><span class="line">@Description :</span><br></pre></td></tr></table></figure><h2 id="MYSQL-查询数据表"><a href="#MYSQL-查询数据表" class="headerlink" title="MYSQL 查询数据表"></a>MYSQL 查询数据表</h2><pre><code>指从一张表的数据中查询所需要的数据，主要有查询所有字段、查询指定字段、查询指定记录、查询空值、多条件的查询、对查询结果进行排序等MySQL SELECT 基本语法    SELECT { * | &lt;字段列名&gt;}    [                FROM &lt;表1&gt; , &lt;表2&gt; ...        [            WHERE &lt;表达式&gt;            [ GROUP By &lt;group by definition&gt;                [                    HAVING &lt;expression&gt; [{&lt;operator&gt; &lt;expression&gt;}...]                ]                [                    ORDER BY &lt;order by definition&gt;                ]                [                     LIMIT [&lt;offset&gt;,] &lt;row count&gt;                ]            ]        ]    ]        1. { * | &lt;字段列名&gt; } 包含星号通配符的字段列表，表示查询的字段，字段列至少包含一个字段名称，如要查询多个，要用逗号隔开        2. FROM &lt;表1&gt;,&lt;表2&gt;...， 表1，2表示查询数据的来源，可单个可多个        3. WHERE 子句是可选项，将限定查询行必须满足的查询条件        4. GROUP BY &lt;字段&gt; ，该子句告诉MYSQL，如何显示查询出来的数据，并按照指定的字段分组        5. [ ORDER BY &lt;字段&gt; ], 该子句告诉MYSQL 按顺序显示查询出来的数据，升序ASC 降序DESC        6. [LIMIT[&lt;offset&gt;,]&lt;row count&gt;] ,每次西芹是查询出来的数据条数    使用 *  查询表中的全部内容        使用星号 * 通配符查询所有字段            SELECT * FROM 表名;    查询表中指定的字段        SELECT &lt;列名&gt; FROM &lt;表名&gt;;        SELECT &lt;字段名1&gt;, &lt;字段名2&gt;, &lt;字段名n&gt; FROM &lt;表名&gt;;</code></pre><h3 id="MYSQL-DISTINCT-：-去重，过滤重复数据"><a href="#MYSQL-DISTINCT-：-去重，过滤重复数据" class="headerlink" title="MYSQL DISTINCT ： 去重，过滤重复数据"></a>MYSQL DISTINCT ： 去重，过滤重复数据</h3><pre><code>SELECT DISTINCT &lt;字段名&gt; FROM &lt;表名&gt;;</code></pre><h3 id="MYSQL-AS-设置别名"><a href="#MYSQL-AS-设置别名" class="headerlink" title="MYSQL AS :设置别名"></a>MYSQL AS :设置别名</h3><pre><code>&lt;表名&gt; [AS] &lt;别名&gt;;    : 表名： 数据中存储的数据表的名称    ：别名： 查询时指定的表的新名称    ： AS ：可选参数    为表取别名时，保证不能与数据库中的其他表的名称冲突    显示的列名称很长或名称不直观，可指定列的别名，替换名字或表达式&lt;列名&gt; [AS] &lt;列别名&gt;    ： 列名 ： 为表中字段定义的名称    ： 列别名： 字段新的名称    ： AS ： 可选参数</code></pre><h3 id="MYSQL-LIMIT-：-限制查询结果的记录条数"><a href="#MYSQL-LIMIT-：-限制查询结果的记录条数" class="headerlink" title="MYSQL LIMIT ： 限制查询结果的记录条数"></a>MYSQL LIMIT ： 限制查询结果的记录条数</h3><pre><code>返回第一行或前几行，用 MYSQL LIMIT 子句&lt;LIMIT&gt; [ &lt;位置偏移量&gt;, ] &lt;行数&gt;LIMIT接受一个或两个数字参数，参数必须是一个整数常量，如给定两个，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目第一个参数 位置偏移量 指示 MYSQL 从哪行开始显示，如不指定，从表中的第一条记录开始，第二个参数 行数 指示 返回的记录条数如指定返回记录的开始位置，则返回结果为从 位置偏移量 参数开始的指定行数， 行数 参数指定返回的记录条数返回第一行时，位置偏移量为0， 因此， LIMIT 1，1 返回第2行，而不是1行</code></pre><h3 id="MYSQL-ORDER-BY-：-对查询结果进行排序"><a href="#MYSQL-ORDER-BY-：-对查询结果进行排序" class="headerlink" title="MYSQL ORDER BY ： 对查询结果进行排序"></a>MYSQL ORDER BY ： 对查询结果进行排序</h3><pre><code>ORDER BY 子句主要将结果集中的数据按照一定的顺序进行排序ORDER BY { &lt;列名&gt; | &lt;表达式&gt; | &lt;位置&gt; } [ASC | DESC]    ： 列名： 指定用于排序的列， 可指定多个列，列名之间用逗号隔开    ： 表达式 指定用于排序的表达式    ： 位置： 用于排序的列在SELECT 语句结果集中的额位置，通常是一个正整数    ： ASC|DESC ： ASC表示 升序 DESC 表示 降序ORDER BY 注意：    1. ORDER BY 子句中可以包含子查询    2. 当排序的值中存在空值时，将该空值作为最小值来对待    3. 指定多个列进行排序时，按照从左到右依次进行排序    4. 如没有进行排序，根据插入到数据表中的顺序显示</code></pre><h3 id="MYSQL-WHERE-：-条件查询"><a href="#MYSQL-WHERE-：-条件查询" class="headerlink" title="MYSQL WHERE ： 条件查询"></a>MYSQL WHERE ： 条件查询</h3><pre><code>使用 WHERE 子句指定查询条件，从FROM子句的中间结果选取适当的数据行，达到过滤的效果WHERE &lt;查询条件&gt;  { &lt;判定运算1&gt; , &lt;判定运算2&gt;,...}    判定结果取值为： TRUE 、FALSE、UNKNOWN    分类：        1. &lt;表达式1&gt; {=|&lt;|&lt;=|&gt;|&gt;=|&lt;==&gt;|&lt;&gt;|! = } &lt;表达式2&gt;        2. &lt;表达式2&gt; [NOT] LIKE  &lt;表达式2&gt;        3. &lt;表达式1&gt; [NOT][REGEXP|RLIKE] &lt;表达式2&gt;        4. &lt;表达式1&gt; [NOT] BETWEEN &lt;表达式2&gt; AND &lt;表达式3&gt;        5. &lt;表达式1&gt; IS [NOT] NULL单一条件的查询语句    查询一个指定列的具体值多条件的查询语句    使用AND操作符限定只有满足所有查询条件的记录才会被返回使用LIKE的模糊查询    &lt;表达式1&gt; {NOT} LIKE &lt;表达式2&gt;        一种模式匹配，使用运算符LIKE设置过滤条件，使用通配符进行匹配运算，而不是判断是否相等进行比较        匹配运算对象可以是 CHAR、 VARCHAR、TEXT、DATETIME等数据类型，返回结果是TRUE 或FALSE    MYSQL支持的通配符：        1. 百分号 % 是一种通配符，可表示任何字符串，字符串可出现任意次            需注意：                默认不区分大小写， 如要区分大小写，需更换字符集的校对规则                百分号不匹配空值                百分号可代表搜索模式中给定位置的0个、1个或多个字符                在搜索模式的最后附加一个百分号        2. 下划线 _    通配符，只匹配单个字符，不是多个，也不是0个字符日期字段作为条件的查询语句    以日期字段作为条件，使用比较运算符设置查询条件，也可使用 BETWEEN AND 运算符查询某个范围内的值</code></pre><h3 id="MYSQL-常用运算符"><a href="#MYSQL-常用运算符" class="headerlink" title="MYSQL 常用运算符"></a>MYSQL 常用运算符</h3><pre><code>MYSQL支持的4种运算符：    1.  算术运算法： 加、减、乘、除    2， 比较运算符：大于、小于、等于、不等于等等    3.  逻辑运算符： 与、或、非、异或等，返回值为布尔值    4.  位运算符 ： 按位与、按位或、按位取反、按位异或、按位左移、按位右移等，位运算必须将数据转换为二进制[More](http://c.biancheng.net/view/2561.html)</code></pre><h2 id="MYSQL-INNER-JOIN-：内连接查询"><a href="#MYSQL-INNER-JOIN-：内连接查询" class="headerlink" title="MYSQL INNER JOIN ：内连接查询"></a>MYSQL INNER JOIN ：内连接查询</h2><pre><code>内连接是通过查询中设置连接条件的方式， 移除查询结果集中某些数据行的交叉连接，利用条件表达式来消除交叉连接的某些数据行使用 INNER JOIN 连接两张表，使用 ON 子句来设置连接条件，如没有条件， INNER JOIN 和 CROSS JOIN 是等同的，可互换。SELECT &lt;列名1,列名2,...&gt; FROM &lt;表名1&gt; INNER JOIN &lt;表名2&gt; [ON子句]    ： 列名1，列名2，。。。： 需要检索的列名    ： 表名1 表名2  ： 进行内连接的两张表的表名    内连接是系统默认的表连接，在FROM子句后可省略INNER关键字，使用内连接，FROM子句中的额ON子句可用来设置连接表的条件    在FROM子句中可在多个表之间连续使用INNER JOIN或JOIN，可同时实现多个表的内连接</code></pre><h3 id="MYSQL-LEFT-RIGHT-JOIN-：-外连接查询"><a href="#MYSQL-LEFT-RIGHT-JOIN-：-外连接查询" class="headerlink" title="MYSQL LEFT / RIGHT JOIN ： 外连接查询"></a>MYSQL LEFT / RIGHT JOIN ： 外连接查询</h3><pre><code>内连接是在交叉连接的结果集上返回满足条件的记录； 而外查询先将连接的表分为基表和参考表，再以基表为依据返回满足和不满足条件的记录外连接注重两张表之间的关系，按照表的顺序，可分为 左外连接 和 右外连接左外连接称为 左连接，  在 FROM 子句中使用 LEFT OUTER JOIN 或 LEFT JOIN，用于接收该关键字左表即基表的所有行，这些行与该关键字右表即参考表中的行进行匹配，左表中的每一行及右表中的符合条件的行左外连接的结果集中，除匹配行外，还包活左表中有但右表中不匹配的行，从右表中选择的行的值被设置为NULL， 即左外连接的结果集汇中的NULL值表示右表中没有找到与左表享福的记录右外连接称为 右连接，在FROM子句中使用RIGHT OUTER JOIN或RIGHT JOIN， 与左外连接相反，右表中有左表中不匹配的行，从左表中选择的值设置为NULL</code></pre><h3 id="MYSQL-子查询"><a href="#MYSQL-子查询" class="headerlink" title="MYSQL 子查询"></a>MYSQL 子查询</h3><pre><code>子查询是指一个查询语句嵌套另一个查询语句内部的查询，在SELECT 子句中先计算子查询，子查询结果作为外层另一个查询的过滤条件，查询可基于一个表或多个表子查询中常用的操作符有 ANY(SOME) 、ALL、IN、EXISTS子查询可添加到 SELECT、UPDATE、DELETE中，可进行多层嵌套，子查询可使用比较运算符，如&lt;,&lt;=,&gt; =&gt; ,!=等</code></pre><h4 id="子查询中常用的运算符"><a href="#子查询中常用的运算符" class="headerlink" title="子查询中常用的运算符"></a>子查询中常用的运算符</h4><pre><code>1. IN 子查询    判断一个给定值是否存在于子查询的结果集中        &lt;表达式&gt; [NOT] IN &lt;子查询&gt;            ： 表达式： 用于指定表达式，当表达式与子查询返回的结果集中的某个值相等时，返回TRUE，如使用关键值 NOT， 返回的值正好相反            ： 子查询： 用于指定子查询，只能返回一列数据，可使用SELECT语句实现查询的多层嵌套2. 比较运算符子查询    用于对表达式的值和子查询返回的值进行比较运算        &lt;表达式&gt; { = | &lt; | &gt; | &gt;= | &lt;= | &lt;=&gt; | != }    { ALL | SOME | ANY } &lt;子查询&gt;3. EXISTS 子查询    用于判断子查询的结果集是否为空，        EXISTS &lt;子查询&gt;[More](http://c.biancheng.net/view/2566.html)</code></pre><h2 id="MYSQL-GROUP-BY-：-分组查询"><a href="#MYSQL-GROUP-BY-：-分组查询" class="headerlink" title="MYSQL GROUP BY ： 分组查询"></a>MYSQL GROUP BY ： 分组查询</h2><pre><code>将结果集中的数据行根据选择列的值进行逻辑分组，能汇总表内容的子集，实现对每个组而不是整个结果集进行整合GROUP BY { &lt;列名&gt; | &lt;表达式&gt; | &lt;位置&gt; } [ ASC | DESC ]    ：列名： 指定用于分组的列，可指定多个列    ： 表达式： 指定用于分组的表达式，通常与聚合函数一起使用    ： 位置： 用于分组的选择列在SELECT 语句结果集中的位置，是一个整数    ： ASC | DESC ： 必须位于对应的列名、表达式、列的位置之后    需注意：        1. 可包含任意数目的列，可对分组进行嵌套，为数据分组提供更细致的控制        2. 每个列都必须是检索列或有效的表达式，不能是聚合函数        3. SELECT语句中的每个列都必须是GROUP BY 子句中给出        4. 用于分组的列中包含有NULL值，则NULL将作为一个单独的分组返回，如列中存在多个NULL值， 则将这些NULL值所在行分为一组</code></pre><h3 id="MYSQL-HAVING-：-指定过滤条件"><a href="#MYSQL-HAVING-：-指定过滤条件" class="headerlink" title="MYSQL HAVING ： 指定过滤条件"></a>MYSQL HAVING ： 指定过滤条件</h3><pre><code>在结果集中规定包含哪些分组和排除哪些分组    HAVING &lt;条件&gt;    HAVING 和 WHERE 子句相似，HAVING子句支持WHERE子句中素有的操作符和语法，差异：        1. WHERE 子句主要过滤数据行， HAVING子句用于过滤分组，集HAVING子句基于分组的聚合值而不是特定行的值来过滤数据，主要过滤分组        2. WHERE子句不可以包含聚合函数，HAVING子句的条件可包含聚合函数        3. HAVING子句是在数据分组后进行过滤， WHERE子句会在数据分组前进行过滤，WHERE子句排除的行不包含在分组中，会影响HAVING子句基于这些值过滤的分组</code></pre><h3 id="MYSQL-REGEXP-正则表达式查询"><a href="#MYSQL-REGEXP-正则表达式查询" class="headerlink" title="MYSQL REGEXP : 正则表达式查询"></a>MYSQL REGEXP : 正则表达式查询</h3><pre><code>    用来被检索或替换符合某个模式的文本内容，根据指定的匹配模式匹配文中符合要求的特殊字符串    REGEXP操作符常用的匹配列表    ^ ： 匹配文本的开始字符     $ ： 结束字符    . ： 任何单个字符    * ： 0个或者 多个在它前面的字符    + ： 1次个或多次    &lt;字符串&gt; ：匹配包含指定字符的文本     [字符集合] ： 字符集合中的一个字符    [^]    ： 不在括号中的任何字符    {n,} ： 匹配前面的字符串至少n次    {n,m} ： 至少n次，至多m次查询以特定字符或字符串开头的记录    字符 ^ 匹配以特定字符或字符串开头的文本查询以特定字符或字符串结尾的记录    字符 $ </code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Author : Hale Lv</span><br><span class="line">@Created Time : 2019-09-03 15:21:40</span><br><span class="line">@Description :</span><br></pre></td></tr></table></figure><h2 id="MYSQL-视图"><a href="#MYSQL-视图" class="headerlink" title="MYSQL 视图"></a>MYSQL 视图</h2><pre><code>视图是一个虚拟表，内容由查询定义。同真实表一样， 视图包含一系列带有名称的列和行数据，但视图不是数据库真实存储的数据表视图是一个、多个表或者视图中导出的表， 包含一系列带有名称的数据列和若干条数据行视图和数据库的区别：    1. 视图不是数据库中真实的表，而是一张虚拟表，其结构和数据是建立在对数据中真实表的查询基础上的    2. 存储在数据库中的查询操作SQL语句定义了视图的内容，列数据和行数据来自于视图查询所引用的实际表， 引用视图时动态生成这些数据    3. 视图没有实际的物理记录，不是以数据集的形式存储在数据库中，对应的数据实际上是存储在视图所引用的真实表中    4. 视图是数据的窗口，而表是内容。表是实际数据的存放单位， 视图是以不同的显示方式展示数据，数据源是实际表    5. 视图是查看数据表的一种方法，可查询数据表中某些字段构成的数据    6. 视图的建立和删除只影响视图本身，不影响对应的基本表视图的优点：    1. 定制用户数据，聚集特定的数据    2. 简化数据操作    3. 提高基表数据的安全性    4. 共享所需数据    5. 更改数据格式    6. 重用SQL语句使用视图注意的点：    1. 创建视图需要足够的权限    2. 数目没有限制    3. 可以嵌套，即从其他视图中检索数据的查询来创建视图    4. 视图可以和表一起使用    5. 视图不包含数据，必须执行查询中所需的任何一个检索操作。 </code></pre><h3 id="创建视图-CREATE-VIEW"><a href="#创建视图-CREATE-VIEW" class="headerlink" title="创建视图 CREATE VIEW"></a>创建视图 CREATE VIEW</h3><pre><code>CREATE VIEW &lt;视图名&gt; AS &lt;SELECT语句&gt;    ：视图名 ： 指定视图的名称，必须唯一    ：SELECT语句： 指定创建视图的SELECT语句，可用于查询多个基础表或源视图存在的限制：    1. 权限问题，基础表和其他视图的相关权限    2. SELECT 语句不能引用系统或用户变量    3. SELECT语句不能包含FROM子句汇中的子查询    4. SELECT 语句不能引用预处理语句参数创建基于单表的视图    在单个数据表上创建视图创建基于多表的视图    在两个以上的表中创建视图查询视图    应用方面：        使用视图重新格式化检索出的数据        使用视图简化复杂的表连接        使用视图过滤数据                DESCRIBE 视图名；</code></pre><h3 id="修改视图-ALTER-VIEW"><a href="#修改视图-ALTER-VIEW" class="headerlink" title="修改视图 ALTER VIEW"></a>修改视图 ALTER VIEW</h3><pre><code>ALTER VIEW &lt;视图名&gt; AS &lt;SELECT语句&gt;    ：视图名： 指定视图名称，必须唯一    ： SELECT 语句： 指定创建视图的SELECT语句，可用于查询多个基础比或源视图修改视图名称    将视图删除，创建视图，命名为新视图</code></pre><h3 id="删除视图-DROP-VIEW"><a href="#删除视图-DROP-VIEW" class="headerlink" title="删除视图 DROP VIEW"></a>删除视图 DROP VIEW</h3><pre><code>DROP VIEW &lt;视图名1&gt; [,&lt;视图名2&gt;,...]    : 视图名：指定要删除的视图名， DROP VIEW可一次删除多个视图</code></pre><h2 id="MYSQL-自定义函数-CREATE-FUNCTION"><a href="#MYSQL-自定义函数-CREATE-FUNCTION" class="headerlink" title="MYSQL 自定义函数 CREATE FUNCTION"></a>MYSQL 自定义函数 CREATE FUNCTION</h2><pre><code>自定义函数于存储过程之间的区别：    1. 不能拥有输出参数，因为自定义函数自身就是输出参数，存储过程可以拥有输出参数    2. 必须包含一条RETURN 语句， 不允许包含于存储过程中    3. 可直接对自定义函数进行调用而不需要使用CALL 语句， 而对存储过程的调用需使用CALL语句创建并使用自定义函数    CREATE FUCTION &lt;函数名&gt; </code></pre>]]></content>
    
    <summary type="html">
    
      &lt;center&gt; MySQL &lt;/center&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Hexo</title>
    <link href="http://yoursite.com/2019/08/11/Hexo-Note/"/>
    <id>http://yoursite.com/2019/08/11/Hexo-Note/</id>
    <published>2019-08-11T02:59:43.000Z</published>
    <updated>2019-08-11T06:34:10.082Z</updated>
    
    <content type="html"><![CDATA[<center> Hexo 基础和语法 </center><a id="more"></a> <p><code>npm install -g hexo-cli</code><br><code>hexo init &lt;Folder&gt;</code><br><code>npm install</code><br><code>vim package.json</code><br><code>hexo new [layout] &lt;title&gt;</code><br><code>hexo generate = hexo g</code><br><code>hexo publish [layout] &lt;filename&gt;</code><br><code>hexo server -p xxxx -s --static -l --log</code><br><code>hexo deploy = hexo d</code><br><code>hexo render &lt;file1&gt; [file2] ... -o --output</code><br><code>hexo migrate</code><br><code>hexo clean = hexo c</code><br><code>hexo list &lt;type&gt;</code><br><code>hexo version</code><br><code>hexo --safe</code><br><code>hexo --debug</code><br><code>hexo --silent</code><br><code>hexo --config custom.yml</code><br><code>hexo --draft</code><br><code>hexo --cwd /path/to/cwd</code></p><p><code>npm install hexo-migrator-rss --save</code><br><code>hexo migrate rss &lt;source&gt;</code><br><code>npm install hexo-migrator-wordpress --save</code><br><code>hexo migrate wordpress &lt;source&gt;</code>  </p><h3 id="Write"><a href="#Write" class="headerlink" title="Write"></a>Write</h3><p><code>hexo new [layout] &lt;title&gt;</code><br><code>layout:  post &gt; source/_posts    page  &gt; source     draft     &gt; source/_drafts</code><br><code>hexo new photo &quot;TEXT&quot;</code>  </p><h3 id="Front-Matter"><a href="#Front-Matter" class="headerlink" title="Front-Matter"></a>Front-Matter</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">title: TEXT</span><br><span class="line">date: DATE</span><br><span class="line">updated: UPDATE_TIME</span><br><span class="line">comments: true</span><br><span class="line">tags: TEXT</span><br><span class="line">categories: TEXT</span><br><span class="line">permalink: url</span><br><span class="line">keywords: TEXT</span><br><span class="line">copyright: true   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Tag Plugins</span><br><span class="line"></span><br><span class="line">引用块</span><br><span class="line">&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125; </span><br><span class="line">content </span><br><span class="line">&#123;% endblockquote %&#125; </span><br><span class="line"></span><br><span class="line">代码块</span><br><span class="line">&#123;% codeblock [title] [lang:language] [url] [link text] %&#125;</span><br><span class="line">code snippet</span><br><span class="line">&#123;% endcodeblock %&#125; </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">反引号代码块</span><br><span class="line"></span><br><span class="line">&#123;% pullquote [class] %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endpullquote %&#125;</span><br></pre></td></tr></table></figure><h3 id="SERVER"><a href="#SERVER" class="headerlink" title="SERVER"></a>SERVER</h3><p><code>npm install hexo-server --save</code><br><code>hexo server -p 5000</code><br><code>hexo server -s</code><br><code>hexo server -i 192.168.1.1</code> </p><h3 id="MADE-FILES"><a href="#MADE-FILES" class="headerlink" title="MADE FILES"></a>MADE FILES</h3><p><code>hexo generate</code><br><code>hexo generate --watch</code><br><code>hexo generate --deploy</code><br><code>hexo deploy --generate</code><br><code>hexo g -d</code><br><code>hexo d -g</code> </p><h3 id="DEPLOY"><a href="#DEPLOY" class="headerlink" title="DEPLOY"></a>DEPLOY</h3><p><code>npm install hexo-deploy-git --save</code><br><code>hexo deploy</code><br><code>deploy:     type: git    repo: &lt;repository url&gt;    branch: [branch_name]    message: [message]</code></p><h3 id="SFTP"><a href="#SFTP" class="headerlink" title="SFTP"></a>SFTP</h3><p><code>npm install hexo-deployed0-sftp --save</code><br><code>vim _config.ymldeploy:    type: sftp    host: &lt;host&gt;    user: &lt;user&gt;    pass: &lt;password&gt;     remotePath: [remote path]    port: [port]    privateKey: [path/to/privateKey]    passphrase: [passphrase]    agent: [path/to/agent/socket]</code></p><h3 id="PERMALINKS"><a href="#PERMALINKS" class="headerlink" title="PERMALINKS"></a>PERMALINKS</h3><p><code>vim _config.ymlpermalink_defaults:     lang: en|zh-Hans</code></p><h3 id="THEME"><a href="#THEME" class="headerlink" title="THEME"></a>THEME</h3><p><code>git clone git@github.com/&lt;username&gt;/xxx.git theme/xxxcd xxxnpm install</code></p><h3 id="TEMPLATE"><a href="#TEMPLATE" class="headerlink" title="TEMPLATE"></a>TEMPLATE</h3><p><code>index          首页post        文章page        分页    archive        归档category    分类tag        标签</code></p><h3 id="具体看官方API"><a href="#具体看官方API" class="headerlink" title="具体看官方API"></a>具体看官方API</h3><p><a href="https://hexo.io/zh-cn/docs/" title="HEXO_DOC" target="_blank" rel="noopener">HEXO-DOC</a></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt; Hexo 基础和语法 &lt;/center&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript</title>
    <link href="http://yoursite.com/2019/08/11/JavaScript-Note/"/>
    <id>http://yoursite.com/2019/08/11/JavaScript-Note/</id>
    <published>2019-08-11T02:28:14.000Z</published>
    <updated>2019-08-26T14:57:09.613Z</updated>
    
    <content type="html"><![CDATA[<center> iFaithFreeom </center><a id="more"></a><p>JavaScript</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt; iFaithFreeom &lt;/center&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
      <category term="JQuery" scheme="http://yoursite.com/categories/JavaScript/JQuery/"/>
    
      <category term="Vue" scheme="http://yoursite.com/categories/JavaScript/JQuery/Vue/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Nginx</title>
    <link href="http://yoursite.com/2019/08/11/Nginx-Note/"/>
    <id>http://yoursite.com/2019/08/11/Nginx-Note/</id>
    <published>2019-08-11T02:14:23.000Z</published>
    <updated>2019-08-12T14:28:20.815Z</updated>
    
    <content type="html"><![CDATA[<center> iFaithFreedom </center><a id="more"></a> <h3 id="TODO-LIST"><a href="#TODO-LIST" class="headerlink" title="TODO LIST"></a>TODO LIST</h3><p>基本语法<br>常见用法<br>虚拟主机<br>反向代理<br>缓存<br>负载均衡</p><h3 id="配置文件由指令与指令块构成"><a href="#配置文件由指令与指令块构成" class="headerlink" title="配置文件由指令与指令块构成"></a>配置文件由指令与指令块构成</h3><p><a href="http://www.nginx.cn/doc/" target="_blank" rel="noopener">Nginx_DOC</a><br>每条指令以 ； 分号结尾，指令与参数间以空格符号分隔<br>指令块以 {} 大括号将多条指令组织在一起<br>include 语句允许组合多个配置文件以提升可维护性<br>使用# 符号添加注释，提高可读性<br>使用 $ 符号使用变量<br>部分指令的参数支持正则表达式<br>配置参数： 时间的单位<br>s: seconds    m: minutes    h:hours     d:days  w:weeks   M:months,30 days   y:years,365 days<br>           空间的单位<br>bytes    k/K: kilobytes        m/M: megabytes        g/G: gigabytes<br>eg:  </p><figure class="highlight"><figcaption><span>&#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">includemime.types;</span><br><span class="line">upstream xxx &#123;</span><br><span class="line">server 127.0.0.1:8000;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">listen 443 http2;</span><br><span class="line"># Nginx Config syntax</span><br><span class="line">limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;</span><br><span class="line">location ~* \.(gif|jpg|jpeg)$ &#123;</span><br><span class="line">proxy_cache my_cache;</span><br><span class="line">expires 3m;proxy_cache_key $host$uri$is_args$args;</span><br><span class="line">proxy_cache_valid 200 304 302 1d;</span><br><span class="line">proxy_pass http://xxx.xxx;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重载，热部署，日志切割"><a href="#重载，热部署，日志切割" class="headerlink" title="重载，热部署，日志切割"></a>重载，热部署，日志切割</h3><p>Nginx 命令行：<br>格式： nginx -s reload<br>帮助： -？ -h<br>使用指定的配置文件： -c<br>指定配置指令： -g<br>指定运行目录： -p<br>发送信号： -s    ：    立刻停止服务： stop        优雅的停止：quit    重载配置文件： reload   重新开始记录日志文件 reopen<br>测试配置文件是否有语法错误： -t        -T<br>打印nginx的版本信息、编译信息等： -v    -V</p><p>重载： nginx -s reload<br>热部署：nginx 版本升级， 编译安装， kill -USR2 nginxID(ps -ef | grep nginx), kill -WINCH ID(进程号)<br>日志切割：xxx.lg(日志文件) nginx -s reopen </p><h3 id="Nginx-配置静态资源Web服务器"><a href="#Nginx-配置静态资源Web服务器" class="headerlink" title="Nginx 配置静态资源Web服务器"></a>Nginx 配置静态资源Web服务器</h3><p>http {<br>    include        mime.types;<br>    #default_type    application/octet-stream;<br>    log_format        main        ‘$remote_addr - $remote_user [$time_local] “$request”  ‘<br>                                ‘$status  $body_bytes_sent “$http_referer” ‘<br>                                ‘“$http_user_agent” “$http_x_forwarded_for”‘;<br><br>    client_max_body_size    60M;<br><br>    proxy_cache_path    /tmp/nginxcache    levels=1:2    keys_zone=my_cache:10m    max_size=10g inactive=60m use_temp_path=off;<br><br><br>    #access_log        logs/access.log        main;<br><br>    sendfile        on;<br>    #tcp_nopush        on;<br><br>    #keepalive_timeout    0;<br>    keepalive_timeout    65;<br><br>    gzip    on;<br>    gzip_min_lengt        1;<br>    gzip_comp_level        2;<br>    gzip_types            text/plain    application/x-javascript    text/css    application/xml        text/javascript        application/x-httpd-php        image/jpeg    image/gif    image/png;</p><p>}</p><p>server {<br>    listen 8080;<br>    server_name hale.dev;</p><pre><code>access_log  logs/hale.dev.log main;location / {    alias dirpath/;    #autoindex on;                        # 开启目录浏览功能    #set $limit_rate 1k;                # 限制访问速度 每秒传输1kb    #index  index.html  index.htm;}#error_page 404            /404.html;# redirect server error pages to the static page /50x.html #error_page        500    502    503    504        /50x.html;    </code></pre><p>}</p><h5 id="nginx-s-reload"><a href="#nginx-s-reload" class="headerlink" title="nginx -s reload"></a>nginx -s reload</h5><h3 id="Nginx-搭建缓存功能的反向代理服务"><a href="#Nginx-搭建缓存功能的反向代理服务" class="headerlink" title="Nginx 搭建缓存功能的反向代理服务"></a>Nginx 搭建缓存功能的反向代理服务</h3><p>openresty实现反向代理</p><p>include vhost/****.conf;<br>upstream local {<br>    server 127.0.0.1:8080;<br>}</p><p>server {<br>    server_name hale.dev;<br>    listen 80;</p><pre><code>location / {        proxy_set_header Host $host;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        #proxy_cache my_cache;            #proxy_cache_key $host$uri$is_args$args;        #proxy_cache_valid    200    304    302    1d;        proxy_pass    http://local;}</code></pre><p>}</p><h4 id="此处的配置详情可以在Nginx官网-ngx-http-proxy-module-中获取"><a href="#此处的配置详情可以在Nginx官网-ngx-http-proxy-module-中获取" class="headerlink" title="此处的配置详情可以在Nginx官网 ngx__http__proxy_module 中获取"></a>此处的配置详情可以在Nginx官网 ngx__http__proxy_module 中获取</h4><h3 id="GoAccess实现可视化并实时监控access日志"><a href="#GoAccess实现可视化并实时监控access日志" class="headerlink" title="GoAccess实现可视化并实时监控access日志"></a>GoAccess实现可视化并实时监控access日志</h3>]]></content>
    
    <summary type="html">
    
      &lt;center&gt; iFaithFreedom &lt;/center&gt;
    
    </summary>
    
      <category term="Nginx" scheme="http://yoursite.com/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>MarkDown</title>
    <link href="http://yoursite.com/2019/08/11/MarkDown-Note/"/>
    <id>http://yoursite.com/2019/08/11/MarkDown-Note/</id>
    <published>2019-08-11T02:06:00.000Z</published>
    <updated>2019-08-16T13:51:01.683Z</updated>
    
    <content type="html"><![CDATA[<center> MarkDown 基础、语法 </center><a id="more"></a> <ol><li><p>斜体、粗体<br> <code>*斜体*  _斜体 _</code><br> <code>**粗体**</code><br> <code>*** 加粗斜体 ***</code><br> <code>~~ 删除线 ~~</code></p></li><li><p>分级标题<br> <code>#    ##    ##    ###    ####    #####    ######</code></p></li><li><p>超链接<br> <code>TEXT[Your Message](https://i-china.github.io/)</code><br> <code>TExt[Your Text][https://i-china.win/ &quot;message&quot;]</code></p></li><li><p>锚点<br> <code>Goto[Redirect](#TEXT)</code></p></li><li><p>列表<br> <code>无序列表    *    +     -</code><br> <code>有序列表    1. Text        2. Text        3. Text ...</code><br> <code>代码缩进    *   TEXT    // * 后三空格</code><br> <code>列表引用    &gt; TEXT         &gt; TEXT</code></p></li><li><p>引用<br> <code>列表嵌套    &gt;&gt;&gt; TEXT     &gt;&gt; TEXT     &gt; TEXT</code><br> <code>其他要素    &gt; T1    &gt; T2    &gt; T3    &gt; T4 ...</code></p></li><li><p>插入图片<br> <code>TEXT:![TEXT](URL &quot;TEXT&quot;)</code></p></li><li><p>内容目录<br> <code>[TOC]</code></p></li><li><p>注脚<br> <code>TEXT[^1] TEXT[^2]  TEXT[^flag]</code><br> <code>[^1]: TEXT Comment   [^2]: TEXT Comment  [^flag]: TEXT FOR flag</code></p></li><li><p>公式<br><code>$ 表示行内公式    $E=mc^2$</code><br><code>$$ 整行公式     $$\sum_{i=1}^n a_i=0$$</code></p></li><li><p>流程图<br><code>st=&gt; start: START:&gt;url   e=&gt;end: TEXT:&gt;url op1=&gt;operation: text|past // 有些复杂，不经常用，先不写了</code> </p></li><li><p>表格<br><code>居左：:----        居中：:----:或者 -----         居右：:----:</code><br><code>TEXT|TEXT|TEXT</code><br><code>-|-|-|</code><br><code>TEXT|TEXT|TEXT</code><br><code>TEXT|TEXT|TEXT</code><br><code>-----------</code><br><code>TEXT|TEXT</code><br><code>-|-:</code><br><code>TEXT TEXT | TEXT/TEXT</code></p></li><li><p>分割线<br><code>* * *</code><br><code>***</code><br><code>*****</code><br><code>- - -</code><br><code>---------</code></p></li><li><p>代码<br><code></code>CODE()<code></code><br><code>```  #include&lt;stdio.h&gt; ```</code></p></li><li><p>换行<br><code>行后 加两空格</code></p></li><li><p>文本<br><code>&lt;center&gt; TEXT &lt;/center&gt;</code><br><code>&lt;left&gt; TEXT &lt;/left&gt;</code><br><code>&lt;right&gt; TEXT &lt;/right&gt;</code><br><code>&lt;u&gt; TEXT &lt;/u&gt;</code></p></li></ol><h5 id="备注：-有些不清楚，需要随用随查！"><a href="#备注：-有些不清楚，需要随用随查！" class="headerlink" title="备注： 有些不清楚，需要随用随查！"></a>备注： 有些不清楚，需要随用随查！</h5>]]></content>
    
    <summary type="html">
    
      &lt;center&gt; MarkDown 基础、语法 &lt;/center&gt;
    
    </summary>
    
      <category term="Markdown" scheme="http://yoursite.com/categories/Markdown/"/>
    
    
      <category term="MarkDown" scheme="http://yoursite.com/tags/MarkDown/"/>
    
  </entry>
  
  <entry>
    <title>Golang</title>
    <link href="http://yoursite.com/2019/08/09/Golang-Note/"/>
    <id>http://yoursite.com/2019/08/09/Golang-Note/</id>
    <published>2019-08-09T10:59:22.000Z</published>
    <updated>2019-08-11T07:03:52.959Z</updated>
    
    <content type="html"><![CDATA[<center> iFaithFreedom </center><a id="more"></a><h3 id="TODO-List"><a href="#TODO-List" class="headerlink" title="TODO List"></a>TODO List</h3>]]></content>
    
    <summary type="html">
    
      &lt;center&gt; iFaithFreedom &lt;/center&gt;
    
    </summary>
    
      <category term="Go" scheme="http://yoursite.com/categories/Go/"/>
    
    
      <category term="Golang" scheme="http://yoursite.com/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Python</title>
    <link href="http://yoursite.com/2019/08/09/Python-Note/"/>
    <id>http://yoursite.com/2019/08/09/Python-Note/</id>
    <published>2019-08-09T10:59:15.000Z</published>
    <updated>2019-08-29T13:02:42.021Z</updated>
    
    <content type="html"><![CDATA[<center> Python </center><a id="more"></a><h2 id="Python-编程基础"><a href="#Python-编程基础" class="headerlink" title="Python 编程基础"></a>Python 编程基础</h2><pre><code>[编译型和解释型](http://c.biancheng.net/uploads/allimg/190211/2-1Z2111G33L03.gif)领域：    Web应用开发：        通过mod_wsgi模块，apache可运行python的web程序，Python定义WSGI标准应用接口协调HTTP服务器与基于Python的Web程序之间的通信。Web框架：Django、TurboGears、web2py等    操作系统管理、自动化运维开发：        例：Ubunut的Ubiquity安装器、RedHat、Fedora的Anaconda安装器等    游戏开发：        支持更多的特性和数据类型，例：文明    编写服务器软件：        支持各种网络协议，可编写服务器软件及网络爬虫，例：第三方库Twisted    科学计算：        NumPy、SciPy、Matplotlip等3和2的区别：    print函数代替print语句    默认使用UTF-8编码    除法运算    异常    八进制字面量表示    不等于运算符    数据类型Python 2to3：自动将Python2.x代码转换为Pyhton3.x代码</code></pre><p>安装<br>    Linux 两种方式：<br>        1. 命令行安装<br>            apt update<br>            apt install python3.6<br>            unlink /usr/bin/python        //    取消旧python的映射<br>            ln -s /usr/bin/python3.6 /usr/bin/python        // python3环境的路径和版本要写正确<br>        2. 源码安装<br>            下载：    wget python3.6下载路径<br>            压缩：    tar -zxvf python3.6.tgz<br>            编译：    ./configure –prefix=/usr/local/    make    make install</p><h3 id="第一个python"><a href="#第一个python" class="headerlink" title="第一个python"></a>第一个python</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">代码编写</span><br><span class="line">两种方式：</span><br><span class="line">1. 在提示符 &gt;&gt;&gt; 直接输入： print(&quot;hello world&quot;)</span><br><span class="line">2. 文本编辑器编写并执行python程序</span><br><span class="line">vim hi.python</span><br><span class="line">print(&quot;hello world&quot;)</span><br><span class="line">python hi.python</span><br><span class="line"></span><br><span class="line">注释：</span><br><span class="line">单行注释： #  </span><br><span class="line">多行注释： 1. &apos;&apos;&apos;  xxx...xxx &apos;&apos;&apos;2. &quot;&quot;&quot; xxx...xxx &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">中文编码声明注释：</span><br><span class="line">1. # -*-coding:utf-8 -*-2. # coding=utf-8</span><br><span class="line"></span><br><span class="line">缩进规则：</span><br><span class="line">冒号(:)和代码缩进</span><br><span class="line"></span><br><span class="line">编码规范(PEP8)</span><br><span class="line">PEP: Python Enhancement Proposal, 8代表Pyton代码的样式指南</span><br><span class="line">1. 每个import语句只导入一个模块，避免导入多个</span><br><span class="line">2. 不在行为加分号，不将两条命令放一行</span><br><span class="line">3. 每行不超80字符，如超，用小括号连接</span><br><span class="line">4. 用空行增强可读性，顶级定义空两行，方法定义空一行</span><br><span class="line">5. 使用空格分隔 运算符、函数参数</span><br><span class="line"></span><br><span class="line">Python标识符命名规范</span><br><span class="line">1. 字符、下划线、数字，数字不开头</span><br><span class="line">2. 不与保留子相同</span><br><span class="line">3. 不包含空格、@、%、$等特殊字符</span><br><span class="line">4. 严格区分大小写</span><br><span class="line">5. 下划线开头有特殊意义</span><br><span class="line">单下划线： 不能直接访问的类属性，无法通过 from ... import * 的方式导入</span><br><span class="line">双下划线： 类的私有成员</span><br><span class="line">双下划线开头和结尾： 专用标识符</span><br><span class="line"></span><br><span class="line">关键字(保留子)</span><br><span class="line">查看方式：</span><br><span class="line">import keyword</span><br><span class="line">keyword.kwlist</span><br><span class="line"></span><br><span class="line">内置函数</span><br><span class="line">[内置函数](https://docs.python.org/zh-cn/3/library/functions.html)</span><br></pre></td></tr></table></figure><h2 id="变量类型和运算符"><a href="#变量类型和运算符" class="headerlink" title="变量类型和运算符"></a>变量类型和运算符</h2><p>数值类型(整形、浮点型、复数)<br>    整形：<br>        二进制：1 和 0 组成， 0b|0B<br>        八进制：0～7 ， 0o|0O<br>        十进制：普通的整数，不以0开头<br>        十六进制：0～9 + A～F， 0x|0X<br>    浮点型：<br>        十进制形式：eg：3.14<br>        科学计数：eg：2.3e2<br>    复数：<br>        虚部用j|J表示</p><p>字符串(长字符串、原始字符串)<br>    长字符串：<br>        三个引号：单引号、双引号<br>    原始字符串：<br>        需要’&#39;进行转义</p><p>bytes类型<br>    由多个字节组成，以字节为单位进行操作，只负责以字节(二进制格式)序列来记录数据<br>    将字符串转换为 bytes对象的三种方式：<br>        1. 如内容是ASCII，在字符串之前添加 b 构建字节串值<br>        2. 调用 bytes() 函数<br>        3. 调用字符串本身的 encode() 方法</p><p>bool布尔类型<br>    真：True ：1<br>    假：False：0 </p><p>len() 获取字符串长度或字节数<br>    len(string)： 字符串的字符|字符串长度|一个字符串占用的字节数， string 进行长度统计的字符串</p><p>input() 获取用户输入的字符串<br>    将用户输入的内容放到字符串中，返回一个字符串中</p><p>print() 高级用法<br>    同时输出多个变量： eg：print(value,…sep=’’,end=’\n’,file=sys.stdout,flush=False)</p><p>格式化字符串(格式化输出)<br>    对各种类型的数据进行格式化输出<br>        print()函数包含三部分：<br>            1. 格式化字符串，相当于字符串模版<br>            2. 固定使用” % “ 作为分隔符<br>            3. 对应的变量，多个用’()’括号括起来<br>    转换说明符：<br>        %d， %i ：    十进制的整数<br>        %o        ：    八进制的整数<br>        %x，%X    ：    十六进制整数<br>        %e        ：    科学计数的浮点数<br>        %E        ：    科学计数的浮点数<br>        %f，%F    ：    十进制的浮点数<br>        %g        ：    智能选择%f或%e格式<br>        %G        ：    智能选择%F或%E格式<br>        %c        ：    格式化字符及其ASCII码<br>        %r        ：    使用repr()将变量或表达式转换为字符串<br>        %s        ：    使用str()将变量或字符串转换为字符串</p><p>转义字符<br>    \            ：    一行未完，转到下一行继续写<br>    &#39;            ：    单引号<br>    &quot;            ：    双引号<br>    \0            ：    空<br>    \n            ：    换行符<br>    \r            ：    回车符<br>    \t            ：    水平制表符<br>    \a            ：    响铃<br>    \b            ：    退格<br>    \            ：    反斜线<br>    \0dd        ：    八进制数，dd代表字符，eg：\012代表换行<br>    \xhh        ：    十六进制数，hh代表字符，eg：\x0a 代表换行</p><p>数据类型转换<br>    int(x)        ：    将x转换为整数类型<br>    lloat(x)    ：    转为浮点型<br>    complex(real,[,imag])    ： 创建一个复数<br>    str(x)        ：    转为字符串<br>    repr(x)        ：    转为表达式字符串<br>    eval(x)        ：    计算字符串中有效python表达式，返回一个对象<br>    chr(x)        ：    将整数x转为一个字符<br>    ord(x)        ：    将字符x转为对应的整数值<br>    hex(x)        ：    将整数x转为十六进制字符串<br>    oct(x)        ：    整数x转为八进制字符串</p><p>算术运算符<br>    +    ：    加<br>    -    ：    减<br>    *    ：    乘<br>    /    :    除<br>    %    :    取余，返回除法的余数<br>    //    :    整除，返回商的整数部分<br>    **    :    幂，返回x的y次方    eg：2**4，    16</p><p>赋值运算符<br>    =    ： 基本赋值<br>    扩展后的赋值运算符：<br>        +=    ：    加赋值<br>        -=    ：    减赋值<br>        <em>=    ：    乘赋值<br>        /=    ：    除赋值<br>        %=    ：    取余赋值<br>        *</em>=    ：    幂赋值<br>        //=    ：    取整数赋值<br>        |=    ：    按位或赋值<br>        ^=    ：    按位与赋值<br>        &lt;&lt;=    ：    左移赋值<br>        &gt;&gt;=    ：    右移赋值</p><p>位运算符<br>    &amp;    ：    按位与<br>    |    ：    按位或<br>    ^    ：    按位异或<br>    ～    ：    按位取反<br>    &lt;&lt;    ：    按位左移<br>    &gt;&gt;    ：    按位右移<br>    <a href="http://c.biancheng.net/view/2184.html" target="_blank" rel="noopener">详细说明</a></p><p>比较运算符<br>    &gt;        ：    大于<br>    &gt;=        ：    大于等于<br>    &lt;        ：    小于<br>    &lt;=        ：    小于等于<br>    ==        ：    等于<br>    !=        ：    不等于<br>    is        ：    判断两个变量引用的对象是否相同，不同返回False<br>    is not    ：    判断两个变量引用的对象是否不相同，不同返回True<br>        比较运算符 == 和 is 的区别：<br>            == ： 比较两个变量的值是否相等。<br>            is ： 对比两个变量引用的是否是同一个对象    </p><p>逻辑运算符<br>    and        ：    与    两个都为True，为True，否则为False<br>    or        ：    或    一个为True，为True，两都为False，则为False<br>    not        ：    非    只需一个为True，则为False</p><p>三目运算符(三元)<br>    先对逻辑表达式求值，如果为True，则返回True_statements的值，如为False，则返回False_statements的值<br>        A = 5    B = 3<br>        st = “A大于B” if A &gt; B else “A小于B”</p><p>运算符优先级<br>    <a href="http://c.biancheng.net/view/2190.html" target="_blank" rel="noopener">优先级</a></p><h2 id="列表、元组、字典、集合"><a href="#列表、元组、字典、集合" class="headerlink" title="列表、元组、字典、集合"></a>列表、元组、字典、集合</h2><pre><code>内置的四种常用数据结构： 列表(list)、 元组(tuple)、 字典(dict)、 集合(set)列表和元组不同和相同：    相同：按顺序保存元素    不同：元组不可修改，列表可修改字典和集合的相同和不同：    相同：数据是无序的    不同：字典可用key-value形式保存数据</code></pre><p>序列<br>    序列：一块可存放多个值的连续内容空间，值按一定顺序排列，可通过值位置的编号(索引)访问他们<br>        序列包括：字符串、列表、元祖、集合、字典。    字典和集合不支持索引、切片、相加、相乘等操作<br>            字符串是一种常见的序列，可直接通过索引访问字符串内的字符<br>            索引值从0开始递增，支持索引值负数，从右向左计数<br>        序列切片：是访问序列中元素的另一种方法，可访问一定范围内的元素，通过切片，生成新的序列<br>            snmae[start ：end ：step]<br>                sname：表示序列的名称<br>                start：表示切片开始索引位置，默认为0，从开头进行切片<br>                end：  表示切片的结束位置，若不指定，默认为序列的长度<br>                step： 表示隔几个存储位置取一次元素<br>        序列相加：两种相同类型的序列使用 “ + “ 运算符做相加操作，但不去重<br>            相同类型：指 + 两侧都是序列类型，都为元组 或 都为字符串<br>        序列相乘：<br>            使用数字n乘以一个序列生成新的序列，eg : print(‘hi’ * 3)<br>        检查元素是否包含在序列中：使用 in 关键字<br>            value in sequence    ： value 要检查的元素，sequence 指定的序列<br>        序列相关的内置函数：<br>            len()            ：    计算序列的长度，即返回序列中包含多少个元素<br>            max()            ：    最大元素<br>            min()            ：    最小元素<br>            list()            ：    将序列转为列表<br>            str()            ：    将序列转为字符串<br>            sum()            ：    计算元素和<br>            sorted()        ：    对元素排序<br>            reversted()        ：    反向序列中的元素<br>            enumerate()        ：    将序列组合为一个索引序列，用在for循环中</p><h3 id="list列表"><a href="#list列表" class="headerlink" title="list列表"></a>list列表</h3><pre><code>python没有数组，有列表。 列表将所有元素放在一对中括号中[],相邻元素用逗号隔开，eg：[var1,var2,...varn]，个数不限，支持的数据类型即可。可以是：整数、实数、字符串、列表、元组、浮点数等    type([&apos;xxx&apos;,xxx,[xxx,&apos;xxx&apos;],xxx]) ：查看数据类型，数据类型为list，即为：列表创建列表    使用 = 运算符创建列表， 使用赋值运算符 = 直接将列表赋值给变量                listname = [element1, element2,... elementn]    使用list()函数创建列表：        list() 将 元组、区间等对象转换为 列表            a_tuple = (&apos;name&apos;,23)            a_list = list(a_tuple)    访问列表元素    通过列表的索引获取指定的元素 或 直接使用 print() 函数        list_str[n]        |        print(list_str)删除列表    使用 del 语句删除        del list_str    </code></pre><p>列表添加元素的三种方法<br>    1. append()：在列表的末尾追加元素，传递列表或元组，视为一个元素，直接添加到列表中，形成包含列表和元组<br>        list_str.append(obj)<br>    2. extend()：不将被追加的列表或元组当作一个整体，只追加列表中的元素<br>        list_str.extend(obj)<br>    3. insert()：在列表中间增加元素<br>        list_str.insert(index，obj)    ： index 将元素插入到列表中指定位置处的索引值，将插入的对象视为一个整体</p><p>列表删除元素的三种方法<br>    删除元素的三种场景：<br>        1. 根据元素位置的索引值，用del语句<br>        2. 元素的位置删除，用 list提供的remove 方法<br>        3. 删除所有元素，用list提供的clear方法<br>    删除元素的3中方法：<br>        1. 根据索引值删除元素,类删除列表，用del语句<br>            del list_str[n:m]<br>        2. 根据元素值删除元素<br>            remove 删除第一个和指定值相同的元素，如没有，则显示ValueError错误，删除前判断是否存在，长于count()方法组合使用<br>        3. 删除列表所有元素<br>            clear()    : 清空列表的所有元素<br>                    list_str.clear() </p><p>list列表修改元素<br>    列表的元素类变量，可对列表的元素赋值，即可修改列表的元素<br>        通过索引到列表元素赋值，可用正数索引，也可用负数索引<br>            list_str = list(rang(1,5))<br>            list_str[1:3] = [‘a’,’b’]<br>                可用步长</p><p>list常用方法(count、index、pop、reverse、sort)<br>    交互模式：查看列表包含的所有方法： dir(list)<br>    count()    ：统计列表中某个元素出现的次数<br>        listname.count(obj)<br>    index() ：定位某个元素在列表中出现的位置，即索引<br>        listname.index(obj,start,end)    : start、end：指定范围内搜索元素<br>    pop()    ：移除列表中指定索引处的元素，若不指定，默认移除列表中最后一个元素<br>        listname.pop(index)<br>    reverse() ：反转列表中的元素<br>        listname.reverse()<br>    sort() ：对列表元素进行排序<br>        listname.sort(key=None,reserse=False)<br>            key ： 指定每个元素提取用于比较的健，key=str.lower：不区分大小写<br>            reserse ：是否需要反转排序，默认False表示从小到大。True为从大到小排序</p><h3 id="tuple元组"><a href="#tuple元组" class="headerlink" title="tuple元组"></a>tuple元组</h3><pre><code>按特定顺序排序的元素，序列不可变。不可边的列表，保存不可变的内容，用()定义，用，逗号分隔。元组可存储整数、实数、字符串、列表、元组等任何类型的数据(&apos;xxx&apos;,[x,xx,&apos;xxx&apos;],(x,xx,xxx))创建元组    1. 使用 &quot;=&quot; 运算符直接创建元组        tupe_str = (x,xx,xxx)    2. 使用tuple()函数创建元组        tuple(data)            list_str = [x,&apos;xx&apos;,xxx]            tuple_str = tuple(list_str)访问元组元素    使用元组各元素的索引值获取        tuple_str[n]修改元组元素    元组不可改变序列，元素不可单独修改。    修改方法：        1. 对元组重新赋值：            tuple_str = (x,xx,&apos;xxx&apos;)            tuple_str = (&apos;x&apos;,&apos;xx&apos;,xxx)        2. 通过连接多个元组的方式向元组中添加新元素            tuple_str = (x,&apos;xx&apos;,xxx)            tuple_str + (&apos;y&apos;,yy,&apos;yyy&apos;)            元组连接的必须是元组，否则抛出：TypeError 错误删除元组    使用 del 语句删除：        tuple_str = (&apos;x&apos;,xx,&apos;xxx&apos;)        del(tuple_str)元组使用场景：    1. 元组作为很多内置函数和序列类型方法的返回值存在，使用某些函数或方法，如返回元组类型，对元组进行处理。    2. 元组比列表访问和处理速度更快，如 对指定元素访问，且不修改时，使用元组    3. 元组在映射(和集合的成员)中可做 健 使用，列表不行。 元组和列表的区别：    同属序列类型，按照顺序存放在一组数据，数据类型不受限制    数据修改：        列表可修改        元组不可修改    字节：元组比列表少16个字节        列表是动态的，存储指针指向对应的元素 占用8个字节，元素可变，需要额外存储已经分配的长度大小        元组，长度固定，存储元素不可变，存储空间是固定的。</code></pre><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><pre><code>dict ： 类列表，数据的集合，可变序列类型。无序可变序列，内容以 键值对 形式存放特征：    通过键来读取元素    任意数据类型的无需集合    可变的，可任意嵌套    键必须是唯一    键必须不可变创建字典    1. 花括号 { }        每个元素包含2部分： 键 : 值， 键和值用冒号分割，相邻元素用逗号分割，大括号{}包含        eg : dict_str = {&apos;name&apos;:&apos;hale&apos;,&apos;age&apos;:23}            同一字典 键值 必须唯一，键值可以是整数、字符串、元组    2. 通过 fromkeys() 创建字典        创建所有键值为空的字典        eg:    dict_str = dict.formkeys(list, value=None)            各个键对应的值为空None， 通常用初始化字典，设置value的默认值    3. 通过 dict() 映射函数创建字典        eg： dict_str = dict(one=1,tow=2,thre=2)             dict_str = [(&apos;one&apos;,1),(&apos;toe&apos;,2)]             dict_str = [[&apos;one&apos;,1],[&apos;tow&apos;,2]]             dict_str = ((&apos;one&apos;.1),(&apos;two&apos;,2))             dict_str = [&apos;one&apos;,&apos;two&apos;,&apos;three&apos;]访问字典    通过 键 访问对应的元素值。 但字典元素是无序的        eg： dict_str[&apos;one&apos;]             dict_str.get(key[,default])    // 通过 get 方法获取指定键的值                dict_str.get(&apos;two&apos;)            使用get() 方法，可为其设置默认值删除字典    使用 del 语句 删除字典        eg： del(dict_str)</code></pre><p>字典基本操作(添加、修改、删除键值对)<br>    字典无需<br>    操作字典的方法：<br>        1. 向现有字典添加键值对<br>        2. 修改现有字典中的键值对<br>        3. 删除指定键值对<br>        4. 判断是否存在指定键值对</p><pre><code>字典添加键值对    dict[key] = value        dict ： 表示字典名称        key  ： 要添加元素的键，不可重复        value： 要添加的值。支持的数据类型修改键值对    不是修改某一键值对的键和值，只修改值    如 新添加的元素的键已存在，替换原键对应的值删除键值对    del         eg：del dict_str[&apos;one&apos;]判断是否存在    使用 in 或者 not in 运算符        eg：&apos;one&apos; in dict_str        |        &apos;two&apos; not in dict_str</code></pre><p>字典方法攻略<br>    keys() 、values() 、 items()<br>        keys() ：返回字典中的所有键<br>            dict_str.keys()<br>        values() ： 返回字典中所有键对应的值<br>            dict_str.values()<br>        items() ： 返回字典中所有的键值对<br>            dict_str.items()<br>    返回数据的两个方法：<br>        list()    ： 将返回的数据转换为 列表<br>            list(dict_str.keys())<br>        利用多重赋值，李彤循环结构将键或值分别赋给不同的变量<br>            for k in dict_str.keys():<br>                print(k,end=’ ‘)<br>            for v in dict_str.values():<br>                …v<br>            for k,v in dict_str.items():<br>                print(‘key: ‘,k,’value: ‘,v)</p><pre><code>copy() 方法    返回一个具有相同键值对的新字典        dict_str.copy()            // copy 将字典 的数据 拷贝给 字典other            拷贝原理，有深、有浅。 copy为深拷贝update() 方法    使用一个字典所包含的键值对更新已有的字典        如果已存在的键值对，原value会被覆盖，如不存在，即添加pop() 方法    获取指定 key 对应的 value，并删除这个键值对        dict_stc.pop(&apos;key&apos;)popitem()    随机弹出字典中的一个键值对，弹出字典最后一个键值对，底层存储的最后一个键值对        dict_str.popitem()setdefault() 方法    根据 key 获取对应 value 的值，如获取的key在字典中不存在，会设置默认的value，然后返回该key对应的value        dict_str.setdefault(&apos;one&apos;,23)使用字典格式化字符串    在字符串模板中按 key 指定变量， 然后通过字典为字符串模板中的 key 设置值         字符串模板中使用key            people = &apos;name: %(name)s , price: %(price)0.2f, sex: %(sex)s&apos;            object = {&apos;name&apos;:&apos;Hale&apos;,&apos;price&apos;:23,&apos;sex&apos;:&apos;man&apos;}            print(people % object)</code></pre><p>Set 集合<br>    保存不重复的元素，集合中的元素是唯一的，set集合是无序的<br>    集合将所有元素放在一堆大括号中{}，元素用 ‘,’ 分割<br>        {key,key2,keyN}<br>        只能存储不可变的数据类型，即 整形、浮点型、字符串、元组。 不可以存储 列表、字典、集合。<br>    两种集合类型：<br>        1. set 类型的集合 ： 可做 添加、删除元素的操作<br>        2. frozenset 集合 ：    不可以</p><pre><code>创建set集合    2种方式：        1. 使用 {} 创建 ：直接将集合赋值给变量            set_str = {key,key1,keyn...}        2. set()函数创建            set_str = set(iteration)                iteration : 表示字符串、列表、元组、range对象等数据访问set集合元素    访问集合元素使用循环结构        for key in set_str:            print(key,end=&apos; &apos;)删除set集合    del()        del(set_str)集合常用操作：向集合中添加、删除元素。以及集合之间做交集、并集、差集等运算。</code></pre><p>set集合基本操作(添加、删除、交集、并集、差集)<br>    向set集合中添加元素<br>        set_str.add(element)<br>            只能是数字、字符串、元组或布尔类型，不能添加列表、字典、集合等可变数据<br>    从set集合删除元素<br>        set_str.remove(element)<br>            如删除不存在的，抛出 KeyError错误<br>                如不想提示KetError错误，可使用discard()方法</p><p>set集合做交集、并集、差集运算<br>    交集： &amp;    取两集合公共的元素        set1 &amp; set2<br>    并集： |    取两集合全部的元素        set1 | set2<br>    差集： -    取一个集合中另一集合没有的元素    set1 - set2<br>    对称差集： ^    取集合A和B中不属于A&amp;B的元素  set1 ^ set2</p><p>set集合方法<br>    dir(set)<br>        add、clear、copy、difference、difference_update、discard、intersection、intersection_update、isdisjoint、issubset、i是superset、pop、remove、symmetric_difference、symmetric_difference_update、union、update</p><p>frozenset 集合(set 集合不可变版本)<br>    特点：<br>        1. 当集合元素不需要改变时，使用frozenset代替set更安全<br>        2. API不需要改变时，必须用frozenset代替set。如 集合元素不可变，set只能包含frozenset<br>            s = set()<br>            f = frozenset(‘key’)<br>            s.add(f)</p><p>深入底层字典和集合<br>    字典和集合是进行过性能高度优化的数据结构<br>        字典和集合的工作原理：<br>            数据机构<br>                字典和集合的内部结构都是一张哈希表<br>                    对字典：表存储了哈希值(hash)、键和值<br>                    对集合：哈希表内只存储单一的元素<br>    哈希表插入数据<br>    哈希表查找数据<br>    哈希表删除元素</p><h2 id="字符串常用方法详解"><a href="#字符串常用方法详解" class="headerlink" title="字符串常用方法详解"></a>字符串常用方法详解</h2><pre><code>拼接字符串、截取字符串、格式化字符串</code></pre><h3 id="字符串拼接-拼接数字"><a href="#字符串拼接-拼接数字" class="headerlink" title="字符串拼接(+拼接数字)"></a>字符串拼接(+拼接数字)</h3><pre><code>使用加号 (+) 作为字符串的拼接运算符字符串拼接数字    先将数字转换为 字符串        数字转换为字符串： str()    repr()            直接拼接字符串和数字，会报错</code></pre><p>截取字符串(字符串切片)<br>    通过索引来操作字符：<br>        string[index]                // index 表示索引值，从0开始递增，最后一个为-1<br>    使用范围获取字符串的中间值：<br>        string[start: end: step]<br>            string : 要截取的字符串<br>            start : 要截取的第一个字符所在的索引，默认为0<br>            end ：要截取最后一个字符所在的索引。如不指定，默认字符串的长度<br>            step ：从start字符开始，step 距离获取一个字符，end索引出的字符。step默认值为1<br>                支持用 in 运算符判断是hi否包含某个子串</p><p>split() : 分割字符串<br>    将一个字符串按照指定的分隔符切分成多个子串，字串被保存在列表中，不包含分隔符<br>        str.split(sep,maxsplit)<br>                1. str：要分割的字符串<br>                2. set：指定分隔符，默认使用空字符分割<br>                3. maxsplit：可选参数，指定分割的次数，如不指定，次数不限</p><p>join() ：合并字符串<br>    将列表(或元组)中多个字符串采用固定的分隔符连接在一起<br>        join_str = str.join(iterable)<br>            1. join_str : 合并后生成的新字符串<br>            2. str ： 指定合并时的分隔符<br>            3. iterator： 做合并操作的源字符串数据，允许：列表、元组等</p><p>count() ：统计字符串出现的次数<br>    用于检索指定字符串在另一个字符中出现的次数，如检索的字符串不存在，返回 0，否则返回出现的次数<br>        str.count(sub[,start[,end]])<br>            1. str : 原字符串<br>            2. sub : 要检索的字符串<br>            3. start : 起始位置<br>            4. end : 终止位置</p><p>find() ：检测字符串中是否包含某字串<br>    检索字符串中是否包含目标字符串，如包含：出现第一次该字符串的索引，返回-1<br>        1. str：原字符串<br>        2. sub：目标字符串<br>        3. start： 起始位置，若不指定，默认从头开始索引<br>        4. end ：结束位置，若不指定，一直检索到结尾<br>    rfind() ：字符串从右边开始检索</p><p>index() ：检测字符串中是否包含某子串<br>    检索是否包含指定的字符串，若指定的字符串不存在，抛出异常<br>        str.index(sub[,start[,end]])<br>            1. str : 原字符串<br>            2. sub : 子字符串<br>            3. start : 起始位置，默认从头开始<br>            4. end : 结束位置，默认到结尾</p><p>startswith() 和 endswith<br>    startswith() ： 检索字符串是否以指定字符串开头，是返回True，反之False<br>        str.startswith(sub[,start[,end]])<br>            1. str ： 原字符串<br>            2. sub ： 要检索的字串<br>            3. start ：起始位置，默认从头开始<br>            4. end ： 结束索引<br>    end.swith(sub[,start[,end]]) : 是否以指定字符结尾，是返回True，反之Flase<br>        str.endswith(sub[,start[,end]])<br>            1. str : 原字符串<br>            2. sub : 检索的字符串<br>            3. start : 起始位置<br>            4. end : 结束位置</p><h3 id="字符串大小写转换的三种函数"><a href="#字符串大小写转换的三种函数" class="headerlink" title="字符串大小写转换的三种函数"></a>字符串大小写转换的三种函数</h3><pre><code>title()    : 将字符串中每个单词的首字符转为大写，其他转为小写    str.title()        str 要进行转换的字符串lower() : 将字符串所有大写字符转为小写    str.lower()upper() : 将字符串所有小写字母转为大写    str.upper()</code></pre><p>去除字符串中空格(删除指定字符)的3种方法<br>    去除字符串中的空格和特殊字符<br>        特殊字符： 制表符 \t、回车符 \r 、换行符 \n<br>    strip()     lstrip()     rstrip()<br>    1. strip()    :    删除字符串前后(左右两侧)的空格或特殊字符<br>        str.strip([chars])<br>            str : 原字符串<br>            chars ：指定要删除的字符，可同时指定多个，若不指定，默认为空格、制表符、回车符、换行符等特殊字符<br>    2. lstrip() :    删除字符左边的空格或特殊字符<br>        str.lstrip([chars])<br>    3. rstrip() :    删除字符右边的空格或特殊字符<br>        str.rstrip([chars])</p><p>format() 格式化输出<br>    str.format(args)<br>        str : 指定字符串显示样式<br>        args: 指定要进行格式化转换的项，如多项，逗号分割<br>            str 格式：<br>                { [index][:[fill] align] [sign] [#] [width] [.precision] [type] ]}<br>                    index :  指定 ；后边设置的格式要作用到args中第几个数据，索引值从0开始<br>                    fill : 指定空白处填充的字符<br>                    align : 指定数据的对齐方式<br>                        &lt; :    左对齐<br>                        &gt; : 右对齐<br>                        = : 右对齐，放在填充内容的最左侧，只对数字类型有效<br>                        ^ : 居中，和width参数一起使用<br>                    sign：<br>                        +    ：<br>                        -    ：<br>                        空格：<br>                        #    ：<br>                    width ：指定输出数据时所占的宽度<br>                    .precision : 指定保留的小数位数<br>                    type ：指定输出数据的具体类型<br>                        s    ： 字符串<br>                        d    ： 十进制整数<br>                        c    ： 将十进制整数自动转换为对应的Unicode字符<br>                        e|E    ： 转为科学技术后，再格式化输出<br>                        g|G    ： 自动再e|f E|F 中切换<br>                        b    ： 将十进制自动转换为二进制，再格式化<br>                        o    ： 转为八进制，再格式化<br>                        x|X    ： 转为十六进制<br>                        f|F    ： 转为浮点数<br>                        %    ： 显示百分比，默认小数点后6位</p><p>encode() 和 decode() 字符串编码转换<br>    2中常用字符串类型： str 、bytes。 str：Unicode 。 bytes：二进制数据。使用encode 和decode 进行转换<br>    encode() : 将str类型转换为bytes类型，成为 编码<br>        str.encode([encoding=”utf-8”][,errors=”strict”])<br>            str ：要进行转换的字符串<br>            encoding=”utf-8” : 采用的字符编码，默认位utf-8 中文：gb2312<br>            errors=”strict”     : 指定错误处理方法：<br>                    strict :    遇到非法字符就抛出异常<br>                    ignore :    忽略非法字符<br>                    replace:    用 “?” 替换非法字符<br>                    xmlcharrefreplace: 使用xml的字符引用</p><pre><code>decode() ： 将bytes类型的二进制数据转换为str类型，过程称为&quot;解码&quot;    bytes.decode([encoding=&quot;utf-8&quot;][,errors=&quot;strict&quot;])        bytes : 要进行转换的二进制数据        encoding=&quot;utf-8&quot;: 解码时采用的字符编码        errors=&quot;strict&quot;</code></pre><p>dir() 和 help() 帮助函数<br>    dir() : 列出指定类或模块名包含的全部内容，包括函数、方法、类、变量等<br>    help() : 查看某个函数或方法的帮助文档</p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><pre><code>两种基本流程控制结构： 分支结构、循环结构    分支结构： 实现根本条件来选择性地执行某段代码    循环结构： 实现根据循环条件重复执行某段代码    if语句：分支    while、for in 循环        break 和 continue 控制程序的循环结构</code></pre><h3 id="if条件语句可分3中形式："><a href="#if条件语句可分3中形式：" class="headerlink" title="if条件语句可分3中形式："></a>if条件语句可分3中形式：</h3><pre><code>    if、if else、 if elif else        if 表达式：            代码块        if 表达式：            代码块 1        else：            代码块 2        if 表达式 1：            代码块 1        elif 表达式 2：            代码块 2        elif 表达式 3：            代码块 3            ...        else :            代码块 nif 表达式真假值判断方法：    if 表达式的值 是 布尔值，要么是真 True，假为False    假 False： False、None、0、 &quot;&quot; 、()、[]、{}if else 语句用法规范    1. 代码块不要忘记缩进    2. if 代码块不要随意缩进    3. if 表达式不要遗忘冒号if 语句嵌套    if condition 1:        if condition 2:            code1        else:            code2if condition 1:    if condition 2:        code 1    else:         code 2else:    if condition 3:        code 3    else:        code 4pass 语句及作用    占位assert 断言函数及用法    对于对一个bool表达式进行断言，如为True，继续向下执行，否则引发 AssertionError错误    会让程序奔溃，测试、调试的辅助工具    eg： age = input(&apos;enter age&apos;)        age = int(age)        assert 30 &lt; age &lt; 100        print(&apos;your age at 30 ~ 100&apos;)</code></pre><h3 id="while-循环语句"><a href="#while-循环语句" class="headerlink" title="while 循环语句"></a>while 循环语句</h3><pre><code>如果条件condition为真，一直重复执行代码块while 条件表达式：    代码块    执行流程：判断条件表达式的值，如果为True 真，执行代码块语句，执行完毕，重新判断条件表达式的值是否为真，如为真，继续执行代码块，直到表达式的值为假False，才终止循环使用while循环遍历列表和元组    列表和元组有索引，通过while循环、列表和元组的索引来遍历列表和元组中的所有元素        eg： tuple_str = (&apos;name&apos;,&apos;age&apos;,&apos;sex&apos;)            i = 0            while(i &lt; len(tuple_str)):                print(tuple_str[i])                i += 1</code></pre><h3 id="for循环用法"><a href="#for循环用法" class="headerlink" title="for循环用法"></a>for循环用法</h3><pre><code>循环语句有2种，while 和for     用于遍历字符串、列表、元组、字典、集合等序列类型        for 迭代变量 in 字符串|列表|元组|字典|集合：            代码块        迭代变量：用来存放从序列类型变量中读取的元素，一般不再循环中对迭代变量赋值，代码块值具有相同缩进格式的多行代码。也称为循环体for 进行数值循环    如 0 ～100 的累加    r = 0;    for i in range(101):        r += i    print(r)range() : 生成一系列连续的整数，用于for循环中        range(start,end,step)            1. start : 计数的初始值，默认从0开始            2. end : 计数的计数值，不能省略            3. step : 指定步长，两个数之间的间隔，如省略，默认为1                for i in range(1,10,2):                    print(i,end=&apos; &apos;)for循环遍历列表和元组    列表或元组有几个元素，for循环的循环体就执行几次，迭代变量会依次被赋值为元素的值isinstance() 函数用于判断某个变量是否为指定类型的实例for 循环遍历字典    1. items()    ： 返回字典中所有key-value对的列表    2. keys()    ： 所有key的列表    3. values()    ： 所有value 的列表</code></pre><p>循环结构中else用法<br>    while 和 for循环，可都跟 else 代码块，作用：当循环条件为False，程序最先执行else代码块的代码<br>    for 循环可使用else代码块，当for把所有元素遍历一次后，会执行else代码块，</p><p>for 和while 循环嵌套<br>    for 和 while 可循环嵌套<br>        for i in range(1,10):<br>            j = 0<br>            while j &lt; 3:<br>                print(“i %d, j %d”,(i,j))<br>                j += 1<br>    循环可以两层或者更多层嵌套    </p><p>列表推导式for表达式<br>    利用range区间、元组、列表、字典、集合等数据类型，快速生成一个列表<br>    [表达式 for 迭代变量 in 可迭代对象 [if 条件表达式]]<br>        for 迭代变量 in 可迭代对象<br>            表达式</p><p>元组推导式<br>    利用range区间、元组、列表、字典、集合等，生成一个列表<br>    (表达式 for 迭代变量 in 可迭代对象[if 条件表达式])<br>    使用元组推导式获得新元组或新元组中的元素，有三种方式：<br>        1. 使用tuple()，直接将生成器对象转换为元组<br>            a = (x for x in range(1,10))<br>                print(tuple(a))<br>        2. 使用for循环遍历生成器对象，获得各个元素<br>            a = (x for x in range(1,10))<br>            for i in a:<br>                print(i,end=’ ‘)<br>            print(tuple(a))<br>        3. 使用 <strong>next</strong>() 方法遍历生成器对象，获得各个元素<br>            a = (x for x in range(3))<br>            print(a.<strong>next</strong>())<br>            a = tuple(a)<br>        无论是for循环遍历生成器对象，还是<strong>next</strong>()遍历，遍历后原生成器对象不复存</p><p>字典推导式<br>    使用字典推导式可以借助列表、元组、字典、集合以及range区间，快速生成复合需求的字典<br>        {表达式 for 迭代变量 in 可迭代对象 [if 条件表达式]}<br>            []    扩起来的可省略</p><p>集合推导式<br>    集合推导式可借助 列表、元组、字典、集合以及range区间，快速生成符合需求的集合<br>        {表达式 for 迭代变量 in 可迭代对象 [if 条件表达式]}<br>    集合推导式和字典推导式的区别：<br>        如果表达式以键值对(key:value)的形式，则是字典推导式，反之是集合推导式</p><p>zip函数用法<br>    可把两个列表 压缩 为一个zip对象(可迭代对象)，可使用一个循环并行遍历两个列表<br>        a = [‘a’,’c’,’dd’]<br>        b = [1,3,2]<br>        [x for x in zip(a,b)]<br>        zip函数压缩得到的可迭代对象所包含的元素是由原列表元素组成的元组</p><p>reversed 函数及用法<br>    反向遍历，可接收各种序列(元组、列表、区间等)，返回一个反序排列的法代器<br>        reversed()可对列表、元组进行反转</p><p>sorted函数及用法<br>    与reversed 函数类似，接收一个可迭代对象作为参数，返回一个对元素排序的列表<br>        不会改变传入的可迭代对象，而是返回新的、排序好的列表<br>            sorted 可传入一个 reverse 参数，也可传入一个 key 参数</p><p>2种强制离开循环体的方法：<br>    1. continue    ： 可跳过执行本次循环体中剩余的代码，转而执行下一次的循环<br>    2. break ： 完全终止当前循环</p><h2 id="函数和lambda表达式"><a href="#函数和lambda表达式" class="headerlink" title="函数和lambda表达式"></a>函数和lambda表达式</h2><h3 id="函数是执行特定任务的一段代码，通过一段代码定义成函数，并为该函数指定一个函数名，可多次调用。可代码复用"><a href="#函数是执行特定任务的一段代码，通过一段代码定义成函数，并为该函数指定一个函数名，可多次调用。可代码复用" class="headerlink" title="函数是执行特定任务的一段代码，通过一段代码定义成函数，并为该函数指定一个函数名，可多次调用。可代码复用"></a>函数是执行特定任务的一段代码，通过一段代码定义成函数，并为该函数指定一个函数名，可多次调用。可代码复用</h3><pre><code>lambda表达式：可作为表达式、函数参数或函数返回值，可让代码更简洁。函数(函数定义、函数调用)    函数定义需注意3点：        1. 函数需要几个关键的需要动态变化的数据，这些数据被定义成函数的参数        2. 函数需要传几个重要的数据(就是调用该函数的人希望得到的数据)，这些数据被定义成返回值。         3. 函数的内部实现过程。</code></pre><h3 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h3><pre><code>def 函数名(形参列表):    // 由零条到多条可执行语句组成的代码块    [return 返回值]        函数名：函数名是合法的标识符，单词的字符全小写，但此语单词用下划线分隔        形参列表：定义该函数可接收的参数。形参列表由多个形参名组成，多个用逗号隔开，定义函数指定了形参列表，就必须传入相应的参数值，谁调用函数谁负责为形参赋值。</code></pre><p>函数的调用<br>    调用函数就是执行函数<br>        函数名(形参值)<br>        函数名：是调用的函数的名称，形参值：指当初创建函数传入的各个形参的值。即创建函数有多少个形参，就传入多少个值，顺序必须和创建函数一致。函数名后的小括号不能省略。</p><p>为函数提供说明文档<br>    使用内置的 help()函数查看帮助文档。 很重要<br>        可为函数编写说明文档， 写在函数声明之后、函数体之前。<br>        可通过help()函数查看，也可通过函数的 <strong>doc</strong> 属性访问函数的说明文档<br>            def hi():<br>                ‘’’<br>                    这是说明文档的内容，输出 hi<br>                ‘’’<br>                print(‘hi’)<br>        使用help()函数查看该函数的说明文档<br>            help(hi)</p><h3 id="函数值传递和引用传递-包括形式参数和实际参数的区别"><a href="#函数值传递和引用传递-包括形式参数和实际参数的区别" class="headerlink" title="函数值传递和引用传递(包括形式参数和实际参数的区别)"></a>函数值传递和引用传递(包括形式参数和实际参数的区别)</h3><pre><code>函数参数作用：传递数据给函数，令其对接收的数据做具体的操作处理    形式参数(形参) 和 实际参数(实参)的区别：        形式参数：在定义函数时，函数名后面括号中的参数就是形式参数            def hi(name):                print(name)        实际参数：在调用函数时，函数名后面括号中的参数成为实际参数，函数的调用者给函数的参数。            name = &apos;hale&apos;            hi(name)函数参数的传递方式分为2种：值传递和引用(地址)传递    1. 值传递：参数类型不可变类型(字符串、数字、元组)    2. 引用(地址)传递： 实参类型为可变类型(列表、字典)    值传递和引用传递的区别：        函数参数进行值传递后，如形参的值改变，不影响实参的值。        函数参数进行引用传递后，若改变形参的值，实参的值也一同改变            def name(name):            name(&apos;hale&apos;)            def name(name):            name = [&apos;adam&apos;]</code></pre><h3 id="函数参数传递机制"><a href="#函数参数传递机制" class="headerlink" title="函数参数传递机制"></a>函数参数传递机制</h3><pre><code>1.值传递：实际是将实际参数值的副本(复制品)传入函数，本身不受影响    值传递会在主程序和swap函数分配两块栈区，用于保存局部变量，实际上在swap 函数战区产生了两个变量，并将主程序栈区的两个变量赋值给swap栈区的两个参数：即对swap函数的两个变量进行初始化。系统存在两个变量，只是存在于不同的栈区中。</code></pre><p>函数参数的引用传递<br>    如实际参数的数据类型是可变对象(列表、字典)，函数参数的传递方式将采用引用传递方式。但引用传递方式的底层实现，采用的依然是值传递的方式<br>    程序创建了一个字典对象，定义了一个引用变量，其实就是一个指针 指向字典对象， 此时内存中有两个东西：对象本身和只想该对象的引用变量，<br>    <a href="http://c.biancheng.net/view/2258.html" target="_blank" rel="noopener">具体内容点击</a></p><pre><code>结论：    1. 不管类型的参数，对参数直接使用 = 符号复制是没用的，使用 = 符号复制不能改变参数    2. 如函数修改数据，则通过把数据包装成列表、字典等可变对象，然后把列表、字典等对象作为参数传入函数，在函数中通过列表、字典的方法，可改变数据。</code></pre><p>python 位置参数<br>    也称 必备参数，指必须按照正确的顺序将实际参数传到函数中，调用函数时传入实际参数的数量和位置必须和定义函数保持一致。<br>    实参和形参数量必须一致<br>        如数量不一致抛出 TypeError异常<br>    实参和形参位置必须一致<br>        若不一致，会出现两中结果：<br>            1. 抛出 TypeError 异常<br>            2. 产生的结果和预期不符</p><p>函数关键字参数用法<br>    指使用形式参数的名字来确定输入的参数值，此方式指定函数参数，不需要位置一致，只需参数名正确即可！<br>        def obj(name,age):</p><pre><code>obj(age,name)</code></pre><h3 id="函数默认参数设置"><a href="#函数默认参数设置" class="headerlink" title="函数默认参数设置"></a>函数默认参数设置</h3><pre><code>在定义函数时，直接给形式参数指定默认值    def 函数名(...，形参名 = 默认值)：        代码块在调用函数时关键字参数必须位于位置参数的后面，在定义函数时指定了默认值的参数(关键字参数)必须在没有默认值的参数之后</code></pre><p>可变参数函数用法<br>    可变参数：不定长参数，传入函数中的实际参数是任意个数。主要形式：<br>        1. 可变参数：形参前添加一个 ‘ * ‘<br>            <em>parameter<br>                parameter 表示形参名，可接收任意多个实际参数，并放到一个元组中<br>            def kebian(name,</em>obj):<br>                for i in obj:<br>                    print(b)<br>            kebian(‘hale’,’judy’,’jally’)<br>            obj 参数可传入多个字符串作为参数值，本质就是一个元组，将参数的多个值集成一个元组<br>            可变的形参可处于形参列表的任意位置<br>        2. 可变参数：形参前添加两个 ‘ * ‘<br>            <strong>parameter<br>                parameter 表示形参名，可接任意多个以关键字参数赋值的实际参数，并放到一个字典中。<br>            def obj(name,age,sex, *height,</strong>weight):<br>                print(name,age,sex)<br>            obj(‘hale’,’jally’,’judy’,100,200,110,220)<br>                前三为普通参数，两个字符串收集成元组，最后两个关键字收集为字典</p><pre><code>逆向参数收集    指在程序已有列表、元组、字典等对象，把他们的元素 拆开 后传给函数的参数。需在传入的列表、元组参数前添加一个星号，在字典参数前添加两个星号        def obj(name,age):        objs = [&apos;hale&apos;,23]        obj(objs)    可变参数，如程序将一个元组传给参数，使用逆向收集        def obj(name,*ages):            print(name)            print(ages)        ages = (12,23,32)        obj(&apos;hale&apos;,*ages)</code></pre><p>return 函数返回值<br>    用def 创建函数时，可用return 指定返回的值，该返回值可是任意类型，但return在同意函数值可出现一次，只要执行，就会结束函数。<br>        return [返回值]<br>            指定返回值后，在调用函数时，将该函数赋值给一个变量，用变量保存函数的返回值，也可将函数作为其他函数的实际参数<br>        def name(names):<br>            pass<br>        def age(name(name)):<br>            pass</p><p>函数返回多个值的方法<br>    将多个值包装成列表后返回，也可直接返回多个值，自动将多个返回值封装成元组</p><p>函数递归<br>    在函数体内调用它本身，递归包含了一种隐式的循环。重复执行某段代码，<br>    递归调用，必须在某个时刻函数的返回值是确定的，否则死循环。 递归一定要向已知方向进行<br>        def fn(n):<br>            if n = 10:<br>                return 1<br>            elif n = 20:<br>                return 2<br>            else :<br>                return fn(n+2) - 2*fn(n + 1)</p><h3 id="变量作用域-全局和局部"><a href="#变量作用域-全局和局部" class="headerlink" title="变量作用域(全局和局部)"></a>变量作用域(全局和局部)</h3><pre><code>变量的有效范围：全局和局部    局部变量：指在函数内部定义并使用的变量，只在函数内部有效        在执行函数时，为该函数分配一块&quot;临时内存空间&quot;，所有局部变量保存在临时变量中，执行完后，释放内存空间，局部变量失效。离开此函数不能再访问，否则抛出NameError        def name():            i_name = &apos;Hale&apos;        name()    全局变量：指能作用于函数内部的变量，可在各个函数外部使用，也可在各函数内部使用        定义方式：            1. 在函数体外的变量，一定为全局变量：                i_name = &apos;Hale&apos;                def name():                    print(i_name)            2. 在函数体内定义使用 global 关键字对变量修饰，即为全局变量                def name():                    global your_name = &apos;Judy&apos;获取指定作用域范围中的变量    1. globals() : 该函数返回全局范围内所有变量组成的 变量字典    2. locals() : 返回当前局部范围内所有变量组成的 变量字典    3. vars(object) : 获取在制定对象范围内所有变量组成的 变量字典 如不传入 object 参数， vars 和 locals 作用完全相同globals 和 locals 的区别：    1. local 获取当前局部范围内所有变量组成的 变量字典， 如全局范围内(在函数外)调用locals 函数，获取全局范围内所有变量组成的 变量字典。 而 globals 无论在哪，获取的都是全局的变量字典    2. 一般，locals 和 globals 获取的 变量字典 只被访问，不被修改。实际上都可被修改，修改改变全局变量本身。 locals 获取的局部范围内的 变量字典 不会影响局部变量全局变量和局部变量的遮蔽现象    全局变量所有函数体内被访问，若函数体中定义了与全局变量同名的变量，会发生遮蔽。两种方式避免遮蔽：    1. 访问被遮蔽的全局变量， globals 函数来实现    2. 在函数中声明全局变量， 使用global 语句来声明全局变量</code></pre><p>局部函数及用法(包含 nonlocal 关键字)<br>    在函数体内定义函数，被放在函数体内的函数称为 局部函数<br>        默认情况下，局部函数对外隐藏，在封闭函数内有效，封闭函数返回局部函数，以便在其他作用域中使用局部函数<br>        局部函数内的变量会遮蔽他所在函数内的局部变量<br>        在函数体内声明的变量，赋值语句不是定义新的局部变量，而是访问他所在函数体内的局部变量。<br>        nonlocal 关键字， 可声明访问赋值语句只是访问该函数内的局部变量</p><h3 id="函数高级用法"><a href="#函数高级用法" class="headerlink" title="函数高级用法"></a>函数高级用法</h3><pre><code>函数本身是一个对象，即可用于赋值，也可用作其他函数的参数，还可作为其他函数的返回值使用函数变量    所有函数都是 function 对象，即可把函数本省赋值给变量，就像把整数、浮点数、列表、元组赋值给变量一样使用函数作为函数形参    若调用函数能动态传入 某些逻辑代码，就需要在函数中定义函数形参，即可在调用该函数时传入不同的函数作为参数使用函数作为返回值    使用函数作为其他函数的返回值</code></pre><h3 id="lambda-表达式及用法"><a href="#lambda-表达式及用法" class="headerlink" title="lambda 表达式及用法"></a>lambda 表达式及用法</h3><pre><code>使用 lambda 表达式代替局部函数    lambda [parameter_list] : 表达式        lambda 几个要点：            1. lambda 必须使用lambda 关键字定义            2. 在 lambda 关键字后、冒号左边的参数列表，可没有参数，也可有多个，多个用逗号隔开，冒号右边是该lambda表达式的返回值            本质：就是匿名的、单行函数体的函数                lambda x，y ：x + y                 --------------------                def add (x , y):                    return x + y    lambda 两个用途：        1. 单行函数： 使用lambda 可省去定义函数的过程，代码更简洁        2. 不需要多次复用的代码，lambda表达式使用完后立即释放，提高了性能</code></pre><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><pre><code>封装、继承、多态</code></pre><h3 id="面向对象：-一切皆对象"><a href="#面向对象：-一切皆对象" class="headerlink" title="面向对象： 一切皆对象"></a>面向对象： 一切皆对象</h3><pre><code>面向对象编程(Object-oriented Programming, OOP)，是一种封装代码的方法    代码封装：隐藏实现功能的具体代码，仅留接口    分为两部分描述：        1. 表面特征： 颜色、外观等        2. 行为：爬、运动        所有变量都是对象，    面向对象相关术语：        类： 即模版，可创建出多个具体实例。称为：类的实例化        对象： 创造出的实例，称为对象        属性： 类中所有变量 称为属性        方法： 类中所有函数 称为方法</code></pre><p>定义类<br>    类：仅充当图纸，根据图纸创造对象。 先定义、在创建类的实物对象，通过实例对象实现特定的功能。类名：每个单词首字母大写，单词与单词不能有分隔符<br>    创建类使用 class 关键字<br>        class 类名：<br>            N个类属性<br>            N个类方法</p><pre><code>__init__()类构造方法    用于创建对象使用，没创建一个类的实例对象时，会自动调用它。        def __init__(self,...):            代码块        可包含多个参数，但必须包含 self 此参数，必须作为第一个，类的构造方法至少要一个self参数，self 不需要手动传递参数,python自动给 self传值。        class Person {            &apos;&apos;&apos; commit &apos;&apos;&apos;            def __init__(self):                print(&apos;构造方法&apos;)        }</code></pre><h3 id="类对象的创建和使用"><a href="#类对象的创建和使用" class="headerlink" title="类对象的创建和使用"></a>类对象的创建和使用</h3><pre><code>class 语句只创建类，需手动创建类的对象，创建类对象的过程称为类的实例化    类名(参数)    class Person {        def __init__(self,name,age):            self.name = name            self.age = age    }    p = Person(&apos;Hale&apos;,23)类对象的使用    作用：        1. 操作对象的实例变量，即访问、修改实例对象的值，以及给对象添加、删除实例变量        2. 调用对象的方法。    类对象访问变量或方法        使用已创建好的对象访问类中的实例变量            对象名.变量名        使用类对象调用类中方法            对象名.方法名(参数)            对象与变量名及方法名 用 &apos; . &apos; 连接    给类对象动态添加变量        为已创建好的对象动态增加实例变量，只要为它的新变量赋值            xxx.yyy = [&apos;xxxx&apos;,&apos;xxxx&apos;]        删除变量：            del xxx.yyy    给类对象动态添加方法        如果希望动态增加的方法能自动绑定到第一个参数，可借助于types模块下的MethodType 进行包装self 用法    python 类方法中的self 参数相当于 C++中的 this 指针    同一个类可产生多个对象，当某个对象调用类方法时，该对象会把自身的引用作为第一个参数自动传给该方法，python自动绑定类方法的第一个参数指向调用该方法的对象，即解释器知道操作哪个对象的方法    对构造方法，self 参数 代表 该 构造方法 正在初始化的对象    class Obj {        def __ini__(self):            pass        def __name(self):            pass        def __jump(self):            self.name()    }        当self参数作为对象的默认引用时，可访问self参数，也可当成实例方法的返回值        class ReturnSelf {            def obj(self):                if hasattr(self,&apos;age&apos;):                    self.age += 1                else:                     self.age = 1                return self        }        rs = ReturnSelf()        // 实例化</code></pre><p>类变量和实例变量(类属性和实例属性)<br>    类中定义的属性和方法，在外部，无法调用。 可把类看做独立的作用域，称为 类命名空间，类属性定义在类命令空间内的变量<br>        类属性 可分为： 类属性也称类变量，和 实例属性也称实例变量<br>        类变量： 指定义在类中，但在各个类方法外的变量，类变量的特点是：所有类的实例化和对象都可共享类变量的值，即类变量可在所有实例化对象中作为公用资源<br>            类变量推荐直接用类名访问，也可用对象名访问<br>                改变类变量的值会作用于该类所有的实例化对象</p><p>实例变量(实例属性)<br>    指：定义在类的方法中的属性，特点：只作用于调用方法的对象<br>        实例变量只能通过对象名访问，无法通过类名直接访问<br>            class Obj {<br>                name = ‘hale’<br>                age = 23<br>                def change(self,name,age):<br>                    self.name = name<br>                    self.age = age<br>            }<br>            one = Obj()<br>            one.change(‘judy’,24)<br>            print(one.name,one.age)            //    Judy 24<br>            print(Obj.name,Obj.age)            //    Hale 23</p><p>实例方法、静态方法和类方法详解<br>    分为： 类方法、实例方法、静态方法</p><pre><code>类实例方法    实例方法： 至少需要包含一个self参数，用于绑定调用此方法的实例对象，可用类对象、也可用类名调用        p = Person{}        p.say(&apos;xxx&apos;)        Person.say(person,&apos;xxx&apos;)类方法    类方法： 至少包含一个参数，名为： cls， 自动将类本身绑定给 cls 参数， cls命名不规定，可随意命名    类方法需要使用 @classmethod 修饰        class Obj:            # @classmethod 修饰的方法是类方法            @classmethod             def name(cls):                print(&apos;Class Method:&apos;,cls)        如没有 @classmethod ，会将 name方法认定为 实例方法，而不是类方法类静态方法    静态方法和函数唯一区别： 静态方法定义在类空间，而函数定义在程序所在的空间中    静态方法没有类似 self cls 特殊的参数，因此不会对包含的参数做任何类或对象的绑定。此方法中无法调用任何类和对象的属性和方法，其和类关系不大    静态方法使用 @staticmethod 修饰        class Obj:            @staticmethod            def name(p):                print(&apos;static Method&apos;, p)    静态方法的调用：可用类名，也可用类对象        Obj.name(&apos;Class Name&apos;)        o = Obj()        b.name(&apos;Class Object&apos;)</code></pre><p>类调用实例方法<br>    # 定义全局空间的foo函数<br>    def foo():<br>        pass<br>    # 全局空间的bar变量<br>    bar = 20<br>    class Obj:<br>        # 定义Obj空间的bar变量<br>        def foo():<br>            pass<br>        bar = 200<br>    # 调用Obj空间的函数和变量<br>    foo()<br>    Obj.foo()</p><p>总结： python类可调用实例方法，使用类调用实例方法，不会自动为方法的第一个参数self绑定参数值，程序必须显式为参数self传参，称为：未绑定方法</p><p>property 函数：定义属性<br>    属性名 = property(fget=NOne, fset=None, fdel=None, doc=None)<br>        fget：制定获取该属性值的类方法， fset：指定设置该属性值的方法， fdel：指定删除该属性值的方法，doc： 提供说明此函数的作用<br>        类似property 函数合成的属性被称为计算属性，并不存储任何状态，值通过某种算法得到，当程序对该值赋值时，被赋的值也会被存储到其他实例变量中</p><p>@parperty 装饰器<br>    既保护类的封装特性，又可以用 对象.属性 操作类属性，除了 property 函数，还提供 @property 装饰器，可直接通过方法名来访问方法，<br>    @preperty<br>    def 方法名(self)<br>        代码块<br>    要想实现修改 xx 属性的值，还为xx属性添加 setter方法，可用 setter装饰器<br>        @方法名.setter<br>        def 方法名(self,value):<br>            代码块<br>    可用 deleter 装饰器 删除指定属性<br>        @方法名.deleter<br>        def 方法名(self):<br>            代码块</p><p>@函数装饰器及用法<br>    内置的函数装饰器：    @staticmethod    @classmethod    @property<br>    自定义函数装饰器：<br>        1. 将被修饰的函数(函数B) 作为参数传给 @ 符号引用的函数(函数A)<br>        2. 将函数B替换(装饰) 成第一步的返回值</p><h3 id="封装机制及实现方法"><a href="#封装机制及实现方法" class="headerlink" title="封装机制及实现方法"></a>封装机制及实现方法</h3><pre><code>目的：    隐藏类的实现细节    使用预定义方法访问，可加入控制逻辑，限制对属性的不合理访问    进行数据检查，保证完整性    便于修改，提高可维护性实现封装的两方面：    1. 将对象的属性和实现细节隐藏起来，不可直接访问    2. 暴露方法，对属性安全访问和操作定义：    类的成员命名以双下划线开头，就能隐藏    class User:        def __hide(self):            pass        def getname(self):            return self.__name</code></pre><h3 id="继承机制及作用"><a href="#继承机制及作用" class="headerlink" title="继承机制及作用"></a>继承机制及作用</h3><pre><code>实现继承的类称为 子类， 被继承的类称为 父类，也叫 基类、超类子类继承父来的语法：在定义类时，将多个父类放在子类后的圆括号内    class 类名(父类1，父类2,...):        类定义部分Python是多继承机制，一个类可继承多个父类    object 类是所有类的父类，直接父类、间接父类    子类是对父类的扩展，子类是一种特殊的父类    从子类的角度看，子类扩展(extend)类父类，从父类的角度看，父类派生出(derive)出子类，    class Fruit:        def name(self):            pass    class Animal:        def name(self):    class Obj(Fruit,Animal):        pass</code></pre><p>父类方法重写<br>    子类与父类同名的方法为方法重写(Override)，也叫方法覆盖<br>    使用未绑定方法调用被重写的方法</p><p>super()函数：调用父类的构造方法<br>    子类继承父类的构造方法，如子类有多个直接父类，优先选择最前面父类的构造方法<br>    如果子类重写了父类的构造方法，子类的构造方法必须调用父类的构造方法<br>        子类调用父类构造方法的2种方式：<br>            1. 使用未绑定，构造方法是实例方法，可通过此方式来调用<br>            2. 使用super()函数调用父类的构造方法<br>                当子类继承多个父类时，super()只调用第一个父类的构造方法，其他父类构造方法只能使用 未绑定 的方式调用</p><p><strong>slots(两侧得都有两下划线)</strong>: 限制类实例动态添加属性和方法<br>    <strong>slots</strong> 属性的值是一个元组，该元组的所有元素列出了该类的实例允许动态添加的所有属性名和方法名</p><p>type(): 动态创建类<br>    type 可指定三个参数：<br>        1. 参数一： 创建的类名<br>        2. 参数二： 该类继承的父类集合，使用元组指定多个父类<br>        3. 参数三： 该字典对象为该类绑定的类变量和方法</p><p>MetaClass 元类<br>    创建类的来，即创建类后，再由类来创建实例进行应用，使用元类可在创建类时动态修改类定义<br>    定义元类： 类名以MetaClass 结尾，元类需要定义并实现 <em>new</em>()方法，一定要有返回值<br>        <strong>new</strong>()方法作用： 使用class定义新类时，如指定了元类，<strong>new</strong>方法会被自动执行</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><pre><code>同一变量完全可在不同的时间应用不同的对象，当同一变量在调用同一方法，可呈现多种行为    class Bird:        def move(self,filed):            print(&apos;bird %s&apos; % filed)    class Dog:        def move(self,filed):            print(&apos;dog %s&apos; % field)    b = Bird()    b.move(&apos;sky&apos;)    d = Dog()    d.move(&apos;road&apos;)</code></pre><p>枚举类定义和使用<br>    定义方式：<br>        1. 使用Enum 列出多个枚举值来创建枚举类<br>        2. 通过继承Enum 基类来派生枚举类<br>        import enum<br>        s = enum.Enum(‘name’,(‘hale’,’judy’,’jally’))<br>    可通过枚举类变量名或枚举值来访问指定枚举对象<br>    <strong>members</strong> 属性，返回一个dict字典，包含了该枚举的所有实例，遍历 <strong>members</strong>属性访问枚举的所有实例</p><pre><code>枚举构造器    可定义构造器，为枚举定义构造器后，在定义枚举实例时，必须为构造器参数设置值</code></pre><h2 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h2><h3 id="异常机制主要依赖try、except、else、finally、raise-五个关键字"><a href="#异常机制主要依赖try、except、else、finally、raise-五个关键字" class="headerlink" title="异常机制主要依赖try、except、else、finally、raise 五个关键字"></a>异常机制主要依赖try、except、else、finally、raise 五个关键字</h3><pre><code>    1. try 关键字后的代码块简称 try块，放置 引发异常的代码    2. 在except 后对应的是异常类型和一个代码块，表明该 except 块处理这种类型的daimakaui        3. 多个except 后放一个 else 块，程序不出现异常还是执行 else 块    4. finally 块用于回收在 try 打开的无力资源，异常机制保证 finally 块总被执行    5. raise 用于引发实际的异常，可单独作为语句使用，引发具体异常对象常见异常类型    语法错误 和 运行时错误        语法错误：            解析代码是出现的错误，报出 SyntaxError 语法错误        运行时错误：            逻辑错误    常见异常类型        AssertionError ： 当assert 关键字后的条件为假时，程序停止并抛出此异常        AttributeError ： 试图访问的对象属性不存在时，抛出        IndexError       ： 索引超出序列范围        KeyError       ： 字典中查找一个不存在的关键字时        NameError       ： 尝试访问一个未声明的变量时        TypeError       ： 不同类型数据之间的无效操作        ZeroDivisionError ： 除法运算中除数为 0 引发此异常</code></pre><h3 id="异常处理机制-1"><a href="#异常处理机制-1" class="headerlink" title="异常处理机制"></a>异常处理机制</h3><p>try except 异常处理<br>    try:<br>        可能产生异常的代码块<br>    except ([Error1,Error2,…]) [as e]:        // ErrorN 表明处理异常的具体类型<br>        处理异常的代码块1<br>    except ([Error3,Error4,…]) [as e]:        // as e 表示将异常类型赋值给变量 e<br>        处理异常的代码块2<br>    执行流程：<br>        1. 先执行 try 中的代码块，如出现异常，自动生成异常对象，提交给Python解释器，称为引发异常<br>        2. 解释器收到异常，寻找处理该异常对象的except块，如找到合适的except块，则把异常对象交给except块，如找不到，则终止。<br>            try:<br>                name = input(‘Enter name’)<br>            except (ValueError, ArithmeticError):<br>                print(‘error’)<br>            except :<br>                print(‘no error’)<br>    访问异常信息<br>        通过except块添加 as e 来访问异常对象的相关信息，当解释器决定调用某个except块来处理该异常对象时，会将异常对象赋值给except 块后的异常变量<br>        异常对象包含的属性和方法：<br>            args ： 返回异常的错误编号和描述字符串<br>            errno ： 返回异常的错误编号<br>            strerror ： 返回异常的描述字符串<br>            with_traceback() ： 处理异常的传播轨迹信息</p><pre><code>异常类的继承体系    异常类派生于 BaseException，    [继承关系](http://c.biancheng.net/uploads/allimg/190215/2-1Z2151H054Q0.gif)    BaseException 主要子类是 Exception，不管是系统的异常类，还是用户自定义的异常类，都应该从Exception派生        1. 如发生数值类型错误，则调用ValueError 对应的except块处理该异常        2. 如发生逻辑错误： 2/0，则调用ArthmeticError 对应的except块处理该异常        3. 如运行时发生其他异常，异常对象是Exception类或其他子类的实例，则调用Exception对应的except块处理该异常        注： 先捕获小异常，再捕获大异常。</code></pre><p>try except else 异常处理结构<br>    作用：指定当try块中没有发现异常时要执行的代码，若try中发现异常，则else块中的语句不会执行<br>        try:<br>            r = 20 / int(input(‘enter num’))<br>        except ValueError:<br>            pass<br>        except ArithmeticError:<br>            pass<br>        else:<br>            print(‘no error’)</p><p>try except finally : 资源回收<br>    完整异常处理语法结构：<br>        try:<br>            xxx<br>        except SubException as e:<br>            xxx<br>        except SubException as e:<br>            xxx<br>        else:<br>            xxx<br>        finally:<br>            xxx<br>        在异常处理语法结构中，只有try块是必须的<br>            1. 如没有try块，就没有except 和 finally 块<br>            2. except 和 finally 块可选，可同时出现，也可出现其一<br>            3. 可有多个except块，但捕获父类异常的except块位于捕获子类异常的后面<br>            4. 不能只有try块，没有except  finally块<br>            5. 多个except 位于try块后，finally块位于所有except块之后<br>        不要在finally块中使用如return 或 raise 等导致方法终止的语句，若在finally中使用return 或 raise 语句，会导致 try 块、except、中的return、raise语句失效</p><h3 id="raise-用法"><a href="#raise-用法" class="headerlink" title="raise 用法"></a>raise 用法</h3><pre><code>    如需自行引发异常，则使用raise语句        raise [exceptionName [(reason)]]    raise 语句三种用法        1. raise： 单独一个raise。 引发当前上下文中捕获的异常，如在except中，引发 RuntimeError异常        2. raise异常类名称： 指定异常类的默认实例        3. raise异常类名称： 引发指定异常的同时，附带异常的描述信息raise 不需要参数    class Demo:        def __init__(self,init_price):            self.init_price = init_price        def bid(self,bid_price):            try:                xxx            except Exception as e:                xxx                raise except 和 raise 同时使用    实现通过多个方法协作处理同一个异常，可在except中结合raise语句来完成        try:            xx        except Exception as e:            raise AuctionException(&apos;error message by self&apos;)            raise AuctionException(e)        对异常的处理分为两个部分：            1. 应用后台需要通过日志来记录异常发生的详细情况            2. 根据异常向应用使用者传达某种提示    用户自定义异常对原始异常进行包装        raise AuctionException(e)        被称为： 异常包装或异常转译自定义异常类    自定义异常需继承Exception 基类 或Exception的子类，    class AuctionException(Exception):        pass</code></pre><h3 id="sys-exc-info-获取异常信息"><a href="#sys-exc-info-获取异常信息" class="headerlink" title="sys.exc_info(): 获取异常信息"></a>sys.exc_info(): 获取异常信息</h3><pre><code>捕获异常的2种方式获得更多的异常信息：    1. 使用 sys 模块中的 exc_info 方法    2. 使用 traceback 模块中的相关函数两个方法返回异常全部信息：exc_info 和 last_traceback         exc_info ： 将当前的异常信息以元组的形式返回，该元组包含三个元素， type、value、traceback                type： 异常类型的名称                value： 捕获到的异常实例                traceback： 是一个traceback 对象                    try:                        pass                    except:                        print(sys.exc_info())</code></pre><h3 id="traceback模块：-获取异常信息"><a href="#traceback模块：-获取异常信息" class="headerlink" title="traceback模块： 获取异常信息"></a>traceback模块： 获取异常信息</h3><pre><code>使用traceback 模块查看异常传播轨迹，现将traceback模块引入，提供两个方法：    1. traceback.print_exec() ： 将异常传播轨迹信息输出到控制台或指定文件中    2. format_exc()    ： 将异常传播轨迹信息转换为 字符串print_exception(etype,value,tb[,limit[,file]])    三个参数用于分别指定异常的信息：        etype ： 指定异常类型        value ： 指定异常值        tb ： 指定异常的traceback 信息print_exc([limit[,file]])    print_exc 自动处理except块所捕获的异常，涉及两个参数        1. limit ： 限制显式异常传播的层数        2. file  ： 指定将异常传播轨迹信息输出到指定文件中，如不指定该参数，默认输出到控制台        import traceback        def xxx():            raise SelfException(&apos;by self&apos;)        try:            xxx()        except:                traceback.print_exec(file=open(&apos;log.txt&apos;,&apos;a&apos;))</code></pre><h3 id="自定义异常类及用法"><a href="#自定义异常类及用法" class="headerlink" title="自定义异常类及用法"></a>自定义异常类及用法</h3><pre><code>自定义一个异常类，通常应继承自 Exception类，直接继承Exception。也可继承自从Exception 继承而来的类，间接继承Exception[异常继承图](http://c.biancheng.net/uploads/allimg/190819/2-1ZQ9154321244.gif)</code></pre><p>异常机制使用细节<br>    成功的异常处理4个小目标<br>        1. 使程序代码混乱最小化<br>        2. 捕获并保留诊断信息<br>        3. 通知合适的人员<br>        4. 采用合适的方式结束异常活动<br>    不要过度使用异常<br>        1. 把异常和普通错误混淆<br>        2. 使用异常处理代替流程控制<br>        3. 不要使用过于庞大的try块<br>        4. 不要忽略捕获到的异常</p><p>assert 调试程序<br>    assert 条件表达式 [,描述信息]<br>        assert 语句作用： 当条件表示式为真时，什么也不做，如果为假，则assert抛出 AssertionError异常<br>            age = input(‘enter age’)<br>            name = input(‘enter name’)<br>            assert 20 &lt; age &lt; 100 , ‘age at 20 ~ 100’<br>    assert 可与  try except 异常处理语句配合使用<br>        try:<br>            age = input(‘enter age’)<br>            assert 20 &lt; age &lt; 100 , ‘age at 20 ~ 100’<br>        except AssertionError as e:<br>            print(‘age is error’)</p><h2 id="类特殊成员-属性和方法"><a href="#类特殊成员-属性和方法" class="headerlink" title="类特殊成员(属性和方法"></a>类特殊成员(属性和方法</h2><h3 id="特殊：-方法名、属性名前后添加双下划线。-可重写或调用方法来实现特殊的功能"><a href="#特殊：-方法名、属性名前后添加双下划线。-可重写或调用方法来实现特殊的功能" class="headerlink" title="特殊： 方法名、属性名前后添加双下划线。 可重写或调用方法来实现特殊的功能"></a>特殊： 方法名、属性名前后添加双下划线。 可重写或调用方法来实现特殊的功能</h3><pre><code>如： 构造方法： __init__ ，通过重写类中的此方法实现自己的初始化逻辑__repr__()方法 ： 显式属性__del__方法：    销毁对象__dir__用法 ： 列出对象的所有属性(方法)名__dict__属性： 查看对象内部所有属性名和属性值组成的字典setattr() , getattr() , hasattr()issubclass , isinstance ： 检查类型__call____getitem__ , __setitem__ , __delitem__ , __len__, __contains____iter__ , __reversed__ ：实现迭代器生成器详解__repr__()方法： 显式属性    class xxx:        def __init__(self,xx,xxx):            self.xx = xx            self.xxx = xxx    x = xxx(&apos;xx&apos;,&apos;xxx&apos;)__repr__(): 所有的类都是object类的子类，所以所有的对象都具有 __repr__()方法    此方法：用于实现： 当程序直接打印该对象时，系统输出该对象的 自我描述 信息，用来告诉外界该对象具有的状态信息    此方法返回该对象实现类的 &quot;类名+object at + 内存地址&quot;，如    class obj:            def __init__(self,xx,xxx):                self.xx = xxx                self.xxx = xxx            def __repr__(self):                return &quot;self.xx&quot; + self.xx + \                    ,&quot;self.xxx&quot; + self.xxx     x = obj(&apos;xx&apos;,&apos;xxx&apos;)重写__repr__() 总是返回该对象的所有令人感兴趣的信息所组成的字符串，如下格式的字符串    类名 [field1 = 值1， filed1 = 值2 ,...]__del__方法： 销毁对象    与 __init__() 方法对象， __init__() 方法用于初始化对象，  __del__() 方法用于销毁python对象，在任何对象被系统收回之时，会自动调用该对象的 __del__() 方法如不需要一个对象时，必须把对象占用的内存空间释放，称为垃圾回收(GC, Garbage Collector)    Python 采用自动引用计数(ARC) 方式来回收对象所占用的空间    当对象被垃圾回收时，自动调用该对象的 __del__方法，当对象的引用计数变为0时，对象才会被回收    class Obj:        del __init__(self,xx):            self.xx = xx        def __del__(self):            pass    o = Obj(&apos;xx&apos;)    x = o    del x若父类提供 __del__()方法，则系统重写 __del__() 方法时必须显式调用父类的 __del__()方法，保证合理回收父类实例的部分属性__dir__用法：列出对象的所有属性(方法)名    用于列出该对象内部的所有属性包活方法名，该方法将会返回包含所有属性方法名的序列    当程序对某个对象执行 dir 函数时，将该对象的__dir__() 方法返回值进行排序，然后包装成 列表    class obj:        def __init__(self,xxx):            self.xxx = xxx        def info():            pass     x = obj    print(x.__dir__())        不仅输出对对象定义的xxx 、info属性和方法，还有系统内置的属性和方法，如 __repr__, __del__方法__dict__属性： 查看对象内部所有属性名和属性值组成的字典    即可看对象的所有内部状态，也可通过字典语法来访问或修改指定属性的值        class obj:            def __init__(self,xxx):                self.xxx = xxx        x = obj        print(x.__dict__)        print(x.__dict__(xxx))</code></pre><h3 id="setattr-getattr-hasattr-函数用法"><a href="#setattr-getattr-hasattr-函数用法" class="headerlink" title="setattr(), getattr(), hasattr() 函数用法"></a>setattr(), getattr(), hasattr() 函数用法</h3><pre><code>动态检测对象是否包含某些属性或方法相关的函数：    1. hasattr(obj,name) : 检查obj对象是否包含名为 name 的属性或方法    2. getattr(object,name[,default]) : 获取object对象中名为 name 的属性的属性值    3. setattr(obj,name,value,/) : 将obj对象的 name 属性设为 value        class obj:            def __init__(self,xx,xxx):                self.xx = xx                self.xxx = xxx            def info():                pass        x = obj        print(hasattr(x,&apos;xxx&apos;))        // True        print(getattr(x,&apos;xxx&apos;))        // True        setattr(x,&apos;xx&apos;,&apos;yy&apos;)        print(x.xx)setattr() 可改变 对象的属性值，若对象设置的属性不存在，可添加属性</code></pre><h3 id="issubclass-和-isinstance-函数-：-检查类型"><a href="#issubclass-和-isinstance-函数-：-检查类型" class="headerlink" title="issubclass 和 isinstance 函数 ： 检查类型"></a>issubclass 和 isinstance 函数 ： 检查类型</h3><pre><code>issubclass(cls, clsss_or_tuple) : 检查cls是否为后一个类或元组包含的多个类中任意类的子类isinstance(obj, class_or_tuple) : 检查obj是否为后一个类或元组包含的多个类中任意类的对象区别：    issubclass 第一个参数是类名，判断是否为子类    isinstance 第一个是变量，判断是否为该类或子类的实例                             第二参数都可使用 元组__base__属性 ： 通过该属性可查看该类的所有直接父类，该属性返回所有直接父类组成的元组    class x:        pass    class xx:        pass    class xxx(x,xx):        pass    print(x.__base__)    print(xx.__base__)__subclasses__()方法 ： 查看该类的所有直接子类，返回该类的所有组成的列表    print(x.__subclasses__()__call__方法    hasattr 函数判断指定属性或方法是否存在，  __call__属性： 进一步判断该属性或方法是否可调用    class x:        def __init__(self,xx,xxx):            self.xx = xx            self.xxx = xxx        def ValidLogin(self):            pass    x = x(&apos;xx&apos;,&apos;xxx&apos;)    print(x.xx,&apos;__call__&apos;)    print(x.xxx,&apos;__call__&apos;)__getitem__ , __setitem__ , __delitem__ , __len__ , __contains__     序列的特征 可包含多个元素，相关的特殊方法：        __len__(self)    ： 返回值决定序列中元素的个数        __getitem__(self,key) ： 获取指定索引对应的元素，key是整数值或slice对象，会引发 KeyError异常        __contains__(self,item) ： 判断序列是否包含指定元素        __setitem__(self,key,value) ： 指定设置索引对应的元素，key 是整数值或slice对象，否则引发 KeyError异常        __delitem__(self,key) ： 删除指定索引对应的元素    def xx(key):        if not isinstace(key,int) : raise TypeError(&apos;must int&apos;)        if key &lt; 0 : raise IndexError(&apos;is ini&apos;)    class xxx:        def __init__(self):            self.__changed = {}            self.deleted = []        def __len__(self):            pass        def __getitem__(self,key):            pass        def __setitem__(self,key,value):            pass        def __delitem(self,key):            pass</code></pre><h3 id="iter-和-reversed-：实现迭代器"><a href="#iter-和-reversed-：实现迭代器" class="headerlink" title="iter 和 reversed ：实现迭代器"></a><strong>iter</strong> 和 <strong>reversed</strong> ：实现迭代器</h3><pre><code>for循环遍历列表、元组和字典等对象都是可迭代的，都属于迭代器实现迭代器，需实现两个方法：    1. __iter__(self) : 该方法返回一个迭代器，必须包含一个 __next__() 方法，返回迭代器的下一个元素    2. __reversed__(self) : 为内奸的reversed 反转函数提供支持，对指定迭代器执行反转时class  x:    def __init__(self,len):        self.first = 0        self.sec = 1        self.__len = len    def __next__(self):        if self.__len == 0:            raise StopIteration            self.first, self.sec = self.sec, self.first + self.sec            self.__len -= 1            return self.first    def __iter__(self):        return self</code></pre><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><pre><code>生成器与迭代器的区别在于： 迭代器通常是先定义一个迭代器类，通过创建实例来创建迭代器。 生成器：先定义一个包含 yield 语句的函数，然后通过调用该函数来创建生成器创建生成器    创建生成器的步骤：        1. 定义一个包含 yield 语句的函数        2. 调用第一步创建的函数得到生成器            def xxx(val,step):                xx = 0                 for i in range(val):                    xx += i * step                    yield xx        yield xx 语句的作用：            1. 每次返回一个值，类return 语句            2. 冻结执行，每次执行到yield 语句时会被暂停</code></pre><h3 id="两种方式创建生成器："><a href="#两种方式创建生成器：" class="headerlink" title="两种方式创建生成器："></a>两种方式创建生成器：</h3><pre><code>    1. 使用 for 循环的生成器推导式    2. 调用带 yield 语句的生成器函数生成器的方法：    1. 外部程序通过 send 方法发送数据    2. 生成器函数使用 yield 语句接收收据生成器两个常用方法：    1. close ：用于停止生成器    2. throw ：用于在生成器内部(yield语句内) 引发一个异常</code></pre><h2 id="模块和包"><a href="#模块和包" class="headerlink" title="模块和包"></a>模块和包</h2><h3 id="常用-sys、OS-、-traceback-三个模块"><a href="#常用-sys、OS-、-traceback-三个模块" class="headerlink" title="常用 sys、OS 、 traceback 三个模块"></a>常用 sys、OS 、 traceback 三个模块</h3><pre><code>模块化编程    模块： Modules， 模块就是Python程序，        代码的可重复性体现在，编写好模块后，需用到该模块中的某个功能(由变量、函数、类实现)，无需重复性工作，直接导入该模块即可使用该功能    封装特性的结构：        1. 容器： 例 列表、元组、字符串、字典等，都是对数据的封装        2. 函数： 对Python代码的封装        3. 类： 对方法和属性的封装，对函数和数据的封装    语法格式：        模块名.函数</code></pre><h3 id="导入模块：-import"><a href="#导入模块：-import" class="headerlink" title="导入模块： import"></a>导入模块： import</h3><pre><code>    1. import 模块名1 [as 别名] , 模块名2 [as 别名2],... :         导入指定模块中的所有成员(变量、函数、类等)。 当使用模块中的成员时，需要该模块名(或别名)作为前缀    2. from 模块名 import 成员名1 [as 别名1], 成员名2 [as 别名2] ,... :        只会导入模块中指定的成员，非全部成员，使用该成员时，无需任何前缀，直接使用成员名或别名        第二种from 模块名 import * ： 可导入指定模块中的所有成员import 模块名 as 别名    1. 导入整个模块： import sys    2. 导入整个模块，指定别名： import sys as s    3. 导入多个模块： import sys，os    4. 导入多个模块，同时指定别名： import sys as s, os as ofrom 模块名 import 成员名 as 别名    1. 导入模块的成员 ： from sys import argv    2. 导入模块成员，指定别名 ： from sys import argv as v    3. 导入模块成员，一次导入多个成员 ： from sys import argv ， winver    4. 导入多个模块，指定别名 ： from sys import argv as v， winver as w    不推荐使用 from import 导入模块所有成员</code></pre><h3 id="自定义模块"><a href="#自定义模块" class="headerlink" title="自定义模块"></a>自定义模块</h3><pre><code>    模块文件的文件名是它的模块名，如 xxx.py 的模块名就是 xxx自定义模块编写测试代码    如直接运行模块文件，程序会执行该模块的函数，如其他程序导入该模块，不应该执行该模块的函数    要实现这个效果，需借助 python 内置的 __name__ 变量，当直接运行模块时， name 变量的值为 __main__; 而将模块被导入其他程序并运行该程序，处于模块中 __name__ 变量的值就编程类模块名。 如希望函数只有在直接运行模块文件时才执行，则可增加判断，即只有当 __name__ == &apos;__main__&apos; 时才调用函数__name__ == &apos;__main__&apos; :    __name__ :内置的系统变量，用于标识所在模块的模块名，    作用： 确保只有单独运行该模块时，此表达式才成立，才可以进入此判断语法，执行其中的测试代码，反之，如只是作为模块导入到其他程序文件中， 则此表达式不成立，若运行，不执行判断语句汇中的代码</code></pre><h3 id="导入模块的三种方式"><a href="#导入模块的三种方式" class="headerlink" title="导入模块的三种方式"></a>导入模块的三种方式</h3><pre><code>当时用import 语句导入模块后，会按顺序查找指定的模块文件    1. 当前目录，即当前执行的程序程序文件所在目录下查找    2. 到Pythonpath 环境变量下的每个目录下查找    3. 到python 默认的安装目录下查找自定义的模块：    1. 向sys.path 中临时添加模块文件存储位置的完整路径    2. 将模块放在sys.path 变量中已包含的模块加载路径中    3. 设置系统环境变量导入模块方式一： 临时添加模块完整路径导入模块方式二： 将模块保存到指定位置导入模块方式三： 设置环境变量    linux 设置环境变量：            vim ~/.bash_profile             PATHONPATH=.:/pythondir/python_module            export PYTHONPATH</code></pre><h3 id="导入模块的本质"><a href="#导入模块的本质" class="headerlink" title="导入模块的本质"></a>导入模块的本质</h3><pre><code>    将xxx.py 中的全部代码加载到内存并执行，然后将整个模块内容赋值给与模块同名的变量，该变量的类型是module，而在该模块中定义的所有程序单元都相当于该module对象的成员    导入同一模块多次，只执行一次__all__ 变量    将变量的值设置为一个列表，只有该列表中的成员才会被暴露出来        def xx():            pass        def xxx():            pass        __all__ = [&apos;xx&apos;,&apos;xxx&apos;]    意义：为模块定义开放的公公接口，只有 __all__变量列出的成员，    如使用模块内__all__ 列表之外的成员，两种解决方法        1. import 模块名  导入模块， 通过模块名前缀来调用模块内的成员        2. from 模块名 import 成员 ，导入指定成员包： 存放多个模块的文件夹    包：就是文件夹，必须存在名为 &quot;__init__.py&quot; 的文件        每个包的目录下必须建立一个 __init__.py 的模块，可为空模块        作用： 将目录当成包来处理</code></pre><h3 id="创建包，导入包"><a href="#创建包，导入包" class="headerlink" title="创建包，导入包"></a>创建包，导入包</h3><pre><code>    包的创建步骤：        1. 创建文件夹，名称为该包的包名        2. 文件夹内创建名为 __init__.py 的文件，    包的导入：        1. import 包名[.模块名[as 别名]]            import xx.xxx        2. from 包名 import 模块名 [as 别名]            from xx import xxx        3. from 包名.模块名 import 成员名 [as 别名]            from xx.xxx import xxxx__init__.py    导入包等同于导入包中的__init__.py文件，可在此文件中编写功能代码。 包作用是包含多个模块，因此此文件作用是导入该包内的其他模块查看模块(变量、函数、类)方法    2种方式：        1. dir()            dir(xxx)        2. __all__            xxx.__all____doc__属性：查看文档    help(string.capwords)    print(string.capwords.__doc__)__file__属性：查看模块的源文件路径    import string            string.__file__第三方模块(库)下载和安装(通过pip命令)    pip install | uninstall | list  模块名</code></pre><h2 id="常见模块"><a href="#常见模块" class="headerlink" title="常见模块"></a>常见模块</h2><pre><code>日期、时间、正则表达式、JSON支持、容器等sys 模块用法    和解释器关系密切的标准库，帮助访问和解释器联系密切的变量和函数    import sys    [e for e in dir(sys) if not e.startswith(&apos;__&apos;)]        // 双下划线 没有 __all__变量</code></pre><h3 id="sys模块包含全部成员-包括变量、函数等"><a href="#sys模块包含全部成员-包括变量、函数等" class="headerlink" title="sys模块包含全部成员 包括变量、函数等"></a>sys模块包含全部成员 包括变量、函数等</h3><pre><code>    sys成员：        sys.argv ： 获取运行python 程序的命令行参数        sys.path ： 一个字符串列表，每个字符串都是一个目录名，使用import导入模块时，解释器从这些目录中查找指定的模块        sys.exit() ： 引发SystemExit 异常退出程序        sys.modules ： 返回模块名和载入模块对应关系的字典        sys.platform ： 是字符串，标识解释器运行平台名称，即操作系统名称        sys.stdin、sys.stdout、sys.stderr ： 类文件流对象，表示 标准输入、输出、错误        sys.flags ： 只读属性返回运行py命令时指定的旗标        sys.getrefcount(object) ： 返回指定对象的引用计数，当objet对象引用计数为0，系统会回收该对象        sys.getfilesystemencoding(object) ： 返回系统中保存文件所用的字符集        sys.getrecursionlimit() ： 返回当前支持的递归深度        sys.getswitchinterval()    ： 返回解释器中线程切换的时间间隔，通过setswitchinterval 函数改变        sys.implementation ： 返回当前py解释器的实现        sys.maxsize ： 返回整数支持的最大值，32: 2**31 -1  64: 2**63-1         sys.executable ： 返回解释器在从磁盘的存放路径        sys.byteorder ： 显示本地字节序的指示符        sys.copyright ： 返回与解释器有关的版权信息        sys.version ： 返回解释器版本的版本信息        sys.winver ： 返回解释器的主版本号sys获取运行参数：    sys 模块的argv 属性可获取运行py程序的命令行参数，argv是一个列表        python argv xx.py &quot;xxx&quot;动态修改模块加载路径：    import sys    sys.path.append(&apos;E:\xxx&apos;)</code></pre><h3 id="os-模块及用法"><a href="#os-模块及用法" class="headerlink" title="os 模块及用法"></a>os 模块及用法</h3><pre><code>    代表程序所在的操作系统，用于获取程序运行所在操作系统的相关信息    import os     os.__all__ ： 查看该模块所包含的全部变量和函数        os.name ：返回依赖模块操作系统的名称，如 posix、nt、java等        os.environ ： 所有环境变量组的字典        os.sep ： 路径分隔符        os.fsencode(filename) ： 对类路径 path-like 的文件名进行编码        os.fsdecode(filename) ： 对类路径 path-like 的文件名解码        os.PathLie ： 是类，代表 类路径对象        os.getenv(key,default=None) ： 指定环境变量的值        os.getlogin() ： 系统登录用户名。 os.getuid、os.getgroups、os.getgid 等函数，获取用户 ID 、用户组、组ID        os.getpid() ： 进程ID        os.getppid() ： 进程的父ID        os.putenv(key,value) ： 设置环境变量        os.cpu_count() ： 系统的CPU数量        os.pathsep ： 系统上多条路径之间的分隔符。如 ； ：        os.linesep ： 系统的换行符        os.urandom(size) ： 加密使用、最多由N个字节组成的bytes对象    os 进程管理函数：        os.system(command) ： 运行操作系统上的指定命令        os.abor() ： 生成一个SIGABRT 信号给当前进程，UNIX上默认生成内核转储；windows 退出返回3        os.execl(path,arg0,arg1,...) ： 一系列功能类似的函数，如： os.execle、os.execlp等        os.forkpty() ： fork 一个子进程        os.kill(pid, sig) ： 将sig 信号发送到pid对应的过程，用于结束进程        os.killpg(pgid,sig) ： 发送到 pgid 对应的进程组        os.popen(cmd, mode=&apos;r&apos;,buffering=-1) ： 向cmd命令打开读写管道，buffering村冲参数，返回文件对象用于读写字符串，而不是字节        os.startfile(path,operation) ： 对指定文件使用关联工具执行operation对应的操作random 模块及用法    查看该模块所包含的全部变量和函数： import random   random.__all__    random 模块常用函数：        random.seed(a=None,version=2) ： 指定种子来初始化伪随机数生成器        random.randrange(start,stop[,step]) ： 返回从start开始到stop结束，步长为 step的随机数        random.randin(a,b) ： 生成一个范围为 a &lt;= N &lt;= b 的随机数        random.choice(seq) ： 从seq 中随机抽取一个元素，如为空，抛 IndexError异常        random.choices(seq,weights=None,cum_weights=None,k=1) ： 从seq 抽元素，weigths指定被抽取的权重        random.shuffle(x[,random]) ： 对 x 序列执行洗牌 随机排序 操作        random.sample(population,k) ： 从population序列中随机抽取k个独立元素        random.random() ： 生成从包含0.0 到不包含1.0之间的随机浮点数        random.uniform(a,b) ： 生成一个范围 a ～ b 的随机数        random.expovariate(lambd) ： 生成呈指数分布的随机数，lambda 参数</code></pre><h3 id="time-模块"><a href="#time-模块" class="headerlink" title="time 模块"></a>time 模块</h3><pre><code>查看time模块包含的全部属性和函数    import time    time.__all__        |  [e for e in dir(time) if not e.startswith(&apos;__&apos;)]        time.struct_time ： 代表一个时间对象，包含9个属性            tm_year 年            tm_mon 月    | tm_mday 日    | tm_hour 时    | tm_min 分            tm.sec 秒    | tm_wday 周    | tm_yday 一年内第几天 | tm_isdst 夏令时    time 函数：        time.asctime([t]) ： 将时间元组或struct_time转换为时间字符串        time.ctime([secs]) ： 以秒数的时间转换时间字符串        time.gmtime([secs])    ： 将秒数的时间转为 struct_time 对象        time.localtime([secs]) ：         time.mktime(t)        time.perf_counter()        time.process_time()        time.sleep(secs)        time.strftime(format[,t])        time.time()        time.timezone        time.tzname        [详细点击](http://c.biancheng.net/view/2420.html)</code></pre><h3 id="json-模块"><a href="#json-模块" class="headerlink" title="json 模块"></a>json 模块</h3><pre><code>JSON： JavaScript Object Notation ，即javascript对象符号，数据交换格式两种数据结构：        1. 由 key-value 对组成的数据结构    2. 有序集合， 在python中对应于列表使用JSON语法创建对象：    object = {            xxx:xxxx,        // 字符串用双引号包含            yyy:yyyy,    }JSON创建数组：    arr = [value1,value2,...]JSON for Python    JSON 类型转换 Python 类型        对象(object)                字典(dict)        数组(array)                    列表(list)        字符串(string)                字符串(str)            整数(number(int))            整数(int)                true                        True        false                        False        null                        None    Python类型转换为 JSON类型        字典(dict)                        对象(object)        列表(list)和元组(tuple)            数组(array)        字符串(str)                        字符串(string)        整形、浮点型、派生的枚举        数值型(number)        True                            true        False                            false        None                            null 查看模块所有属性和函数： import json -&gt; json.__all__常用函数和类的功能：    json.dump(obj,fp,*,skipkeys=False...)    // 将obj对象转换成json字符串输出到fp流中    json.dumps(obj,*,skipkeys=False,...)    // 将obj对象转换为JSON字符串，并返回该JSON字符串    json.load(fp,*,cls=NONE,object_hook=None,...)    // 从fp流读取JSON字符串，将其恢复成JSON对象， fp支持write()方法的类文件对象    json.loads(s,fp,*,encoding=None,cls=None,object_hook=None,...)    // 将JSON字符串s恢复为JSON对象</code></pre><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="Regular-Expression-描述一种字符串匹配的模式，检查一个字符串是否含有某个子串，也可从字符串中提取匹配的子串，或对字符串中匹配的子串执行替换操作，可用来开发数据抓取、网络爬虫等"><a href="#Regular-Expression-描述一种字符串匹配的模式，检查一个字符串是否含有某个子串，也可从字符串中提取匹配的子串，或对字符串中匹配的子串执行替换操作，可用来开发数据抓取、网络爬虫等" class="headerlink" title="Regular Expression 描述一种字符串匹配的模式，检查一个字符串是否含有某个子串，也可从字符串中提取匹配的子串，或对字符串中匹配的子串执行替换操作，可用来开发数据抓取、网络爬虫等"></a>Regular Expression 描述一种字符串匹配的模式，检查一个字符串是否含有某个子串，也可从字符串中提取匹配的子串，或对字符串中匹配的子串执行替换操作，可用来开发数据抓取、网络爬虫等</h3><pre><code>查看该模块所包含的属性和函数： import re -&gt; re.__all__函数作用：    re.complie(pattern, flags=0) : 将正则表达式字符串编译成 _sre.SRE_Pattern 对象， 该对象代表正则表达式编译之后在内存中的对象，可缓存并复用正则表达式字符串，如多次使用同一正则表达式字符串，则可先编译它。        pattern ： 所编译的正则表达式字符串， flags ： 匹配旗标，    re.match(pattern , string, flags=0) : 从字符串开始位置匹配正则表达式，如匹配不成功，match 函数返回None，        pattern ： 正则表达式。 string ：匹配的字符串。 flags ： 正则表达式的匹配旗标。    re.search(pattern, string, flags=0) : 扫描整个字符串，返回字符串中第一处匹配pattern的匹配对象，        pattern ： 正则表达式。 string ：被匹配的字符串。 flags ： 匹配旗标    re.findall(pattern, string, flags=0) :  扫描整个字符串，返回字符串中所有匹配pattern的子串组成的列表。         pattern ： 正则表达式。 string ：被匹配的字符串。 flags ： 匹配旗标    re.finditer(pattern, string, flags=0) ： 扫描整个字符串，返回字符串所有匹配pattern 的子串组成的迭代器。        pattern ： 正则表达式。 string ：被匹配的字符串。 flags ： 匹配旗标findall、finditer 、search 的区别： search 只返回字符串中第一处匹配pattern的子串，findall和finditer 返回字符串中所有匹配pattern的子串    re.fullmatch(pattern,string, flags=0) ：要求整个字符串匹配 pattern，如匹配返回包含匹配信息的 _sre.SRE_Match对象，否则 None    re.sub(pattern,repl,string,count=0,flags=0) ：将string字符串中所有匹配pattern的内容替换成repl            repl ： 被替换的字符串，可是函数， count 控制替换的次数。        import re        date = &apos;2019-08-22&apos;        print(re.sub(r&apos;-&apos;,&apos;/&apos;,date))            r&apos;-&apos; ：是原始字符串， r ： 代表原始字符串，通过原始字符串，避免对字符串中的特殊字符转译                r&apos;(?P&lt;lang&gt;\w+)&apos; : 正则表达式用圆括号表达式创建一个组， &apos;?P&apos; 为该组起名为 lang ， \w+ 是正则表达式的内容，代表一个或多个任意字符，    re.split(pattern,string, maxsplit=0, flags=0) ： 使用pattern对string进行分割，返回分割得到的多个子串组成的列表，maxsplit 参数控制分割的次数    re.purge() : 清楚正则表达式缓存    re.escape(pattern) ：对模式中除ASCII字符、数值、下划线之外的其他字符转义    re模块中的Match 对象是match 、search方法的返回值，包含了详细的正则表达式匹配信息，包含匹配的位置、子串    sre.SRE_Match 对象包含如下方法或属性：        match.group([group1,...]) : 获取该匹配对象中指定组所匹配的字符串        match.__getitem__(g) ： match.group(g)的简化写法。        match.groups(default=None) : 返回match对象中所有组所匹配的字符串组成的元组        match,groupdict(default=None) ：返回match对象中所有组所匹配的字符串组成的字典        match.start([group]) ：获取该匹配对象中指定组所匹配的字符串的开始位置        match.end([group]) ：获取结束位置        match,span([group]) ：获取开始和结束位置，相当于同时返回 start 和 end方法的返回值        match.pos : 该属性返回传给正则表达式对象的search , match等方法的pos参数        match.lastindex : 返回最后一个匹配的捕获组的整数索引，如没有，则返回None        match.lastgroup : 返回最后一个匹配的捕获组的名字，如没有，则返回None        match.re : 返回执行正则表达式匹配时所用的正则表达式        match.string : 返回执行正则表达式时所用的字符串</code></pre><h2 id="set-和-frozenset-集合操作"><a href="#set-和-frozenset-集合操作" class="headerlink" title="set 和 frozenset 集合操作"></a>set 和 frozenset 集合操作</h2><h3 id="set-集合是可变容器，可改变容器中的元素，-frozenset集合，是set的不可变版本，他的元素不可变"><a href="#set-集合是可变容器，可改变容器中的元素，-frozenset集合，是set的不可变版本，他的元素不可变" class="headerlink" title="set 集合是可变容器，可改变容器中的元素， frozenset集合，是set的不可变版本，他的元素不可变"></a>set 集合是可变容器，可改变容器中的元素， frozenset集合，是set的不可变版本，他的元素不可变</h3><pre><code>set集合：    两个特征：        1. set 不记录元素的添加顺序        2. 元素不允许重复        [e for e in dir(set) if not e.startswith(&apos;__&apos;)]    add添加 、 remove 删除元素、discard 删除元素、clear 清空     remove 和 discard 区别： remove 报KeyError异常。discard 不报set 支持的运算符：    &lt;= : 相当于调用 issubset() 方法，判断前面的set集合是否为后面set集合的子集合    &gt;= ：调用issuperset 方法，判断是否为后面set集合的父集合    - ： 调用difference ，前面的set集合减去后面的set集合的元素    &amp; ： 调用intersection，获取两个set集合的交集    ^ ： 计算两个集合异或的结果，即两个集合的并集减去交集的元素</code></pre><h3 id="frozenset-集合"><a href="#frozenset-集合" class="headerlink" title="frozenset 集合"></a>frozenset 集合</h3><pre><code>是set的不可变版本，set集合中不改变集合本身的方法，fronzenset 都支持作用：    1. 当集合元素不需要改变时，使用frozenset 代替 set更安全    2. 当某些api需要不可变对象时，必须用frozenset代替set</code></pre><h3 id="queue-双端队列-模块"><a href="#queue-双端队列-模块" class="headerlink" title="queue (双端队列) 模块"></a>queue (双端队列) 模块</h3><pre><code>栈：一种特殊的线性表，允许一端进行插入、删除操作。这个端为栈定(top),另一端为栈底(botton)从栈顶插入一个元素称为： 进栈， 压入栈。 push 从栈顶删除一个元素称为： 出栈， 弹出栈。 pop栈，陷入栈的元素位于栈底，上面元素出栈后，栈底的元素才能出栈。 栈 是一种 后进先出(LIFO)的线性表 队列是一种特殊的线性表，只允许在表的前段(font) 删除，在后端(rear) 插入。 插入的操作的端为 队尾， 删除操作的端为 队头    队列：元素是从队列的rear 端进。 队列是一种 先进先出FIFO 的线性表。 双端队列deque 代表特殊的队列， 在两端同时进行插入、删除操作，deque 即可为队列使用，也可为 栈 使用deque 位于 collections 包下，[e for e in dir(collections.deque)if not e.startswith(&apos;__&apos;)]    from collections import deque    双端队列的特征， deque 的左边 left 相当于 它的队头front， 右边right 相当于它的队列尾rear        append 和 appendleft ：在deque的右边或左边添加元素， 即在默认队列尾添加元素        pop 和 popleft ：在deque的右边或左边弹出元素，默认在队列尾弹出元素        extend 和 extendleft ： 在deque的右边或左边添加多个元素，默认在队列尾添加多个元素    deque 中clear 方法用于清空队列，insert 方法是线性表的方法，指定位置插入元素    deque 中 rotate 方法。将队列的队尾元素移动到队头，使之首位相连</code></pre><h3 id="heapq-堆操作"><a href="#heapq-堆操作" class="headerlink" title="heapq 堆操作"></a>heapq 堆操作</h3><pre><code>    小顶堆的任意子树是小顶堆，大顶堆的任意子树是大顶堆    import heapq    -&gt; heapq.__all__    函数功能：        heappush(heap,item) ： 将item元素加入堆        heappop(heap) : 将堆中最小元素弹出        heapify(heap) : 将堆属性应用到列表上        headpreplace(heap,x) : 将堆中最小元素弹出，并将元素x入堆        merge(*iterables, key=None, reverse=False) ： 将多个有序的堆合并为一个大的有序堆，然后输出        headppushpop(heap,item) ： 将item入堆，然后弹出并返回堆中最小的元素        nlargest(n,iterable,key=None) ： 返回队中最大的n个元素        nsmallest(n,iterable,key=None) : 返回堆中最小的n个元素ChainMap    使用链的方式将多个 dict 链在一起，允许程序可直接获取任意一个dict所包含的key对应的value    ChainMap 相当于把多个dict合并为一个大的dict，</code></pre><h3 id="Counter-类"><a href="#Counter-类" class="headerlink" title="Counter 类"></a>Counter 类</h3><pre><code>    可自动统计容器中个元素出现的次数    本质是一个特殊的dict，key是所包含的元素，value记录key出现的次数     Counter 继承了dict， 提供三个常用的方法：        1. elements ： 返回该counter 所包含的全部元素组成的迭代器        2. most_common([n]) ：返回Counter 中出现最多的n个元素        3. subtract([iterable-or-mapping]) ： 计算counter 的减法，计算减去之后各元素出现的次数    可把Counter对象转换为 set集合、list列表、dict字典等，可对Counter执行 加、减、交、并运：        加： 将两个Counter对象中各Key 出现的次数相加，保留为正的元素        减： 相减，保留出现次数为正的元素        并： 出现key且各key对应的次数的最小数        求正： 只保留出现次数为0 或正数的key-value对        求负： 保留次数为负的 key-value 对，将次数改为正数defaultdict ：    是dict 的子类，与dict 的区别： 根据不存在的key访问dict中对应的value，会引发KeyError异常，defaultdict则提供default_factory属性， 指定的函数为不存在的key来生成value</code></pre><h3 id="namedtuple-工厂函数功能"><a href="#namedtuple-工厂函数功能" class="headerlink" title="namedtuple 工厂函数功能"></a>namedtuple 工厂函数功能</h3><pre><code>    可创建一个tuple类的子类，为tuple的每个元素指定字段名，可根据字段名访问namedtuple的各元素，根据索引来访问namedtuple的各元素        namedtuple(typename,field_names, * , verbose=False, rename=False,module=None)            typename : 指定所创建的tuple子类的类名，等于用户定义一个新类            field_names ： 字符串序列，使用单个字符串代表所有字段名，用空格、逗号隔开            rename ： 如参数为True， 无效字段名会被自动替换为位置名            verbose ： 参数为True， 当子类被创建后，该类定义会被立即打印出来            module ： 自定义类的__module__属性将被设为该参数值        Python 为命名元组提供的方法和属性：            _make(iterable) ：类方法，根据序列或可迭代对象创建命名元组对象            _asdict() : 将当前命名元组对象转换为OrderdDict 字典            _replace(**kwargs) ： 替换命名元组中一个或多个字段的值            _source ： 返回定义该命名元组的源代码            _fileds ： 返回该命名元组中所有字段组成的元组OrderdDict用法：    是dict的子类，可 维护 添加 key-value 对的顺序， 先添加key-value对排的前面，后添加的key-value对排的后面    两个方法：        1. popitem(last=True) ： 弹出并返回最左边的最后加入的key-value对，将last参数设为False，则弹出并返回最左边最先加入的key-value对        2. move_to_end(key,last=True) : 将指定的key-value对移动到最右边最后加入，将last改为False，则将指定的key-value对移动到最左右最先加入</code></pre><h3 id="itertools模块：生成迭代器"><a href="#itertools模块：生成迭代器" class="headerlink" title="itertools模块：生成迭代器"></a>itertools模块：生成迭代器</h3><pre><code>先导入 import itertools 模块， [e for e dir(itertools) if not e.startswith(&apos;__&apos;)]三个生成无限迭代器的函数：    1. count(start,[step]) ：生成start、start+step、start+2*step,...的迭代器，step默认为1。 count(10) 生成的迭代器包含： 10，11，12，13，14.。。    2. cycle(p) : 对序列p生成无限循环p0，p1.。。的迭代器。cycle(&apos;ABCD&apos;) 包含：A,B,C,D,A,B,C,D,...    3. repeat(elem [,n]) ： 生成无限个 elem元素重复的迭代器. repeat(10,3) ：10，10，10，在itertools 模块中常用的迭代器函数：        accumulate(p,[func]) ： 生成根据序列p元素累加的迭代器        chain(p,q,...) : 将多个序列里的元素 链 在一起生成新的序列        compress(data,selectros) ： 根据selectors序列的值对data序列的元素进行过滤        dropwhile(pred,seq) : 使用pred函数对seq序列进行过滤，如计算为False，保留该元素到序列结束的全部元素        takewhile(pred,seq) ：使用pred函数对seq进行过滤，去掉从该元素序列结束的全部元素        filterfalse(pred,seq)：使用pred函数对seq序列进行过滤，保留seq中使用pred计算为True的元素        islice(seq,[start,]stop[,step]) ：类似于slice，返回seq[start:stop:step]的结果        starmap(func,seq)：使用func对seq每个元素进行计算，结果为新的序列元素        zip_longest(p,q,...) ：将p、q序列中元素按索引合并成元组，元组作为新序列的元素在itertools 模块中生成序列排列的工具函数：        product(p,q,...[repeat = 1])：用序列p、q，。。。进行排序组合，相当于嵌套循环组合        permutations(p[,r]) ：从序列p中取出r个元素组成排序，将排序得到的元组作为新迭代器的元素        combinations(p,r) ：从序列p中取出r个元素组成全组合，元素不重复，将组合得到的元组作为新迭代器的元素        combinations with_replacement(p,r)：从序列p中取出r个元素组成全组合，元素可重复，将组合得到的元组作为新迭代器的元素</code></pre><h3 id="functools-模块："><a href="#functools-模块：" class="headerlink" title="functools 模块："></a>functools 模块：</h3><pre><code>包含函数装饰器和便捷的功能函数， import functools     常用函数装饰器和功能函数：        functools.cmp_to_key(func) ：将老式的比较函数(func)转换为关键字函数(key function) py3不支持        @function.lru        [更多](http://c.biancheng.net/view/2443.html)</code></pre><h2 id="Tkinter-GUI图形洁面开发"><a href="#Tkinter-GUI图形洁面开发" class="headerlink" title="Tkinter (GUI图形洁面开发)"></a>Tkinter (GUI图形洁面开发)</h2><h3 id="GUI-：Graphics-User-Interface-图形用户界面。三要素：输入数据、处理数据、输出数据"><a href="#GUI-：Graphics-User-Interface-图形用户界面。三要素：输入数据、处理数据、输出数据" class="headerlink" title="GUI ：Graphics User Interface 图形用户界面。三要素：输入数据、处理数据、输出数据"></a>GUI ：Graphics User Interface 图形用户界面。三要素：输入数据、处理数据、输出数据</h3><pre><code>常用库：    wxPython ： 跨平台GUI工具集    PyQt ： 是Py和Qt库的融合    PyGTK ： 基于老版本GTK+2的库提供绑定，借助于底层GTK+2提供的可视化元素和组件    Pywin32 ： 允许像VC使用Py开发win32应用    Kivy ： 开源库，使用同源代码创建的程序跨平台    Flexx ： 纯Py工具包，创建图形化界面程序，支持使用web技术进行界面渲染</code></pre><h3 id="Tkinet-GUI-编程组件及用法"><a href="#Tkinet-GUI-编程组件及用法" class="headerlink" title="Tkinet GUI 编程组件及用法"></a>Tkinet GUI 编程组件及用法</h3><pre><code>    学习GUI步骤为三步：        1. 包含的组件        2. 容器及容器对组件布局的方法        3. 掌握各组件的用法        [Tkinter GUI 关系](http://c.biancheng.net/view/2451.html)    Tkinter的GUI组件有两个根父类，直接继承object类        1. Misc ： 所有组件的根父类        2. Wm ： 提供窗口管理器通行的功能函数    BaseWidget ： 所有组件的基类，派生类：Widget ，通用GUI组件，Tkinter 是所有GUI组件都是Widget的子类    各GUI组件的功能        Toplevel：        顶层            容器类        Button ：        按钮            按钮组件        Canvas ：        画布            绘图功能        Checkbutton：    复选框            可勾选的复选框        Entry  ：        单行输入框        用户可输入容内        Frame ：        容器            装载其他GUI组件        Label ：        标签            显示不可编辑的文本或图标        LabelFrame ：    容器            容器组件，支持添加标题        Listbox ：        列表框            列出多个选项，供用户选择        Menu    ：        菜单            菜单组件        Menubutton ：    菜单按钮        包含菜单的按钮 包括下拉式、层叠式        OptionMenu ：    菜单按钮        Menubutton的子类        Message ：        消息框            类标签，显示多行文本，Lable代替，废弃        PanedWindow：    分区窗口        该容器可划分为多个区域        Radiobutton    ：    单选钮            单选按钮        Scale ：        滑动条            可设置起始值和结束值，显示当前精准值        Spinbox ：        微调选择器        可通过组件向上、向下选择不同的值        Scrollbar ：    滚动条            用于为组件(文本域、画布、列表框、文本框)提供滚动        Text ：            多行文本框        显示多行文本    initWidgets 方法实现的代码：        1.创建 GUI 组件        2.添加 GUI 组件        3.配置 GUI 组件    配置GUI组件的2种方法：        1. 以关键字参数的方式配置        2. 以字典语法进行配置    [GUI通用选项](http://c.biancheng.net/view/2451.html)TKinter Pack 布局管理器    [常用选项及功能]()    anchor : 空间大于组件所需求的大小，决定被放置在容器的位置    expand : 指定当容器增大时是否拉伸组件    fill :    组件是否沿水平或垂直方向填充    ipadx :    指定组件在 x 方向上的内部留白    ipady : 在 y 方向上内部留白    padx :  在x方向上与其他组件的间距    pady :    在y方向上的间距    side :  设置组件的添加位置Tkinter Grid 布局管理器    Grid 把组件空间分解为一个网格进行维护    Tkinter Grid 常用选项        column ： 指定将组件放哪列        columnspan : 指定组件横跨多少列        row ：指定放入哪行        sticky ：类 pack方法的anchor选项</code></pre><h3 id="Tkinter-Place-布局管理器"><a href="#Tkinter-Place-布局管理器" class="headerlink" title="Tkinter Place 布局管理器"></a>Tkinter Place 布局管理器</h3><pre><code>    绝对布局 ： 要求程序显式指定每个组件的绝对位置或相对其他组件的位置    常用选项：        x            指定组件的X坐标， x 为 0 代表最左边        y            Y 坐标                        最右边        relx        组件的X坐标        rely        组件的Y坐标        width        组件的宽度        height        组件的高度        relwidth    组件的宽度        relheight    组件的高度        bordermode    设置组件的宽度、高度Tkinter Command 和 Bind 事件处理    command 绑定事件处理方法：        可通过command 来绑定，可绑函数或方法，单击时，触发绑定的函数或方法    bind 绑定事件处理方法：        无法为具体事件绑定事件处理方法        无法获取事件相关信息    bind()方法： 可为 任意 事件绑定事件处理方法        Tkinter 支持的鼠标、键盘事件Tkinter ttk组件及用法    是Tinkter 包下的模块，界面美化、包装Tkinter Variable类用法    支持GUI组件与变量进行双向绑定，        1. 如改变变量的值，GUI组件的显示内容或值也改变        2. 当GUI组件的内容改变时，值也改变    Tinkter 不能讲组件和普通变量进行绑定，只能和tkinter 包下的Variable类的子类进行绑定    1. StringVar() :    包装str值的变量    2. IntVar() :        整形值的变量    3. DoubleVar() ：    浮点值的变量    4. BooleanVar() :  包装bool值的变量</code></pre><h3 id="Tkinter-compound-选项使用方法"><a href="#Tkinter-compound-选项使用方法" class="headerlink" title="Tkinter compound 选项使用方法"></a>Tkinter compound 选项使用方法</h3><pre><code>如使组件同时显示文本和图片，可通过 compound 选型进行控制    属性值：        1. None ： 图片覆盖文字        2. LEFT 常量： 图片在左，文本在右        3. RIGHT 变量： 图片在右，文本在左        4. TOP 常量： 图片在上， 文本在下        5. BOTTON 常量： 图片在底，文本在上        6. CENTER 常量： 文本在图片上方</code></pre><h3 id="Tkinter-Entry-和-Text-控件用法"><a href="#Tkinter-Entry-和-Text-控件用法" class="headerlink" title="Tkinter Entry 和 Text 控件用法"></a>Tkinter Entry 和 Text 控件用法</h3><pre><code>    可接收用户输入的输入框组件，区别： Entry ： 单行。 Text： 多行Tkinter Radiobutton 和 Checkbutton 用法    单选按钮，可绑定一个方法或函数。 将多个Radiobutton 编为一组，将多个Radiobutton绑定到同一个变量，当其中一个单选按钮被选中时，该变量随之改变。Tkinter Listbox 和 Combobox 控件用法    列表框，通过列表框选择一个列表项。        创建 Listbox 的步骤：            1. 创建Listbox 对象，设置listbox的选择模式            2. 调用listbox的insert(self,index,*elements)添加选项Tkinter Spinbox 控件    通过两个小箭头调整该组件内的值Tkinter Scale 和 LabeledScale用法    代表一个滑动条，为滑动设置最大最小值    Scale 组件选项：        from ： 最大值        to ： 最小值        resolution ： 滑动时的步长        lable ： 设置标签内容        length ： 设置轨道的长度        width ： 轨道的宽度        troughcolor ： 背景色        sliderlength ： 长度        sliderrelief ： 立体样式        showvalue ： 是否显示当前值        orient ： 设置方向        digits ： 设置有效数字位数        variable ： 与变量进行绑定        command ： 为该Scale 组件绑定事件处理，函数或方法Tinkter LabelFrame 用法    是Frame容器改进版，为容器添加标签，可为普通文字标签，也可为GUI组件为标签    对标签进行定制：        1. labelwidget ： 将任意GUI组件作为标签        2. labelanchor ： 设置标签位置</code></pre><h3 id="Tkinter-Panedwindow-控件"><a href="#Tkinter-Panedwindow-控件" class="headerlink" title="Tkinter Panedwindow 控件"></a>Tkinter Panedwindow 控件</h3><pre><code>    管理窗口布局的容器，允许添加多个子组件，并为每个子组件划分一个区域，可用鼠标移动分隔线改变各子组件的大小    操作Panedwindow 容器中子组件的方法：        1. add(self,child,**kw) : 添加一个子组件        2. insert(self,pos,child,**kw) : 在pos 位置插入一个子组件        3. remove(self,child) ： 删除一个子组件，所在区域也删除 Tkinter OptionMenu控件    构建带菜单的按钮，可在按钮的四个方向上展开，通过direction选项控制        __init__(self,master,variable ,value,*values, **kwargs)            1. variable ； 指定该按钮上的菜单与哪个变量绑定            2. Value ： 默认选择菜单中的哪一项            3. values ： 将收集为此参数传入的多个值，为每个值创建一个菜单项            4. kwargs ： 为 OptinoMenu配置选项Tkinter 对话框创建及使用    1. 对话框依赖类似于顶级窗口，创建时需指定master属性    2. 对话框有非模式noo-modal和模式modal，某个模块对话框被打开，位于它依赖的窗口之上。    Tkinter 在 simpledialog 和dialog 模式下分别提供了 SimpleDialog 类和 Dialog 类，可作为普通对话框使用        使用simpledialog 和dialog 创建对话框可指定：            1. title： 标题            2. text ：内容            3. button： 按钮            4. default：默认第几个按钮得到焦点            5. cancel： 指定对话框上角的X按钮关闭对话框Tkinter 自定义对话框    自定义通过继承Toplevel 实现：        1. 继承Toplevel 实现自定义对话框需要为对话框指定 master        2. 调用Toplevel 的grab_set 方法 把对话框变为模式对话框，否则为非模式对话框</code></pre><h4 id="Tkinter-输入对话框"><a href="#Tkinter-输入对话框" class="headerlink" title="Tkinter 输入对话框"></a>Tkinter 输入对话框</h4><pre><code>工具函数：    1. askinteger ； 生成一个让用户输入正数的对话框    2. askfloat ： 输入浮点数的对话框    3. askstring ： 输入字符串的对话框</code></pre><h4 id="Tkinter-文件对话框创建和使用"><a href="#Tkinter-文件对话框创建和使用" class="headerlink" title="Tkinter 文件对话框创建和使用"></a>Tkinter 文件对话框创建和使用</h4><pre><code>    直接返回用户选择文件的输入/输出流：        1. askiopenfile ： 打开单个文件的对话框        2. askopenfiles ： 打开多个文件的对话框        3. askopenfilename ： 打开单个文件的对话框，返回选择文件的文件路径        4. askopenfilenames ： 多个文件的对话框        5. asksavesfile ： 生成保存文件的对话框        6. asksaveasfilename ： 保存文件的对话框，返回所选择文件的文件路径        7. askdirectory ： 生成打开目录的对话框    生成打开文件的对话框工具函数：        1. defaulttextension ： 指定默认扩展名        2. filetypes ： 查看的文件类型        3. initaldir ： 初始化打开的目录        4. parent ： 指定该对话框的属主窗口        5. title ： 对话框的标题        6. multiple ： 允许多选Tkinter askcolor 颜色选择对话框    函数选项：            1. parent ： 属主窗口        2. title ： 标题        3. color ： 颜色</code></pre><h4 id="Tkinter-消息框"><a href="#Tkinter-消息框" class="headerlink" title="Tkinter 消息框"></a>Tkinter 消息框</h4><pre><code>    选项按钮        1. icon  ： 定制图标        2. type ： 定制按钮的选项    showinfo 函数： 默认生成的消息框的图标是感叹号Tkinter Menu 菜单 窗口菜单和右键菜单    添加菜单项的方法：        1. add_command() : 添加菜单项        2. add_checbutton(): 复选框        3. add_radiobutton(): 单选按钮        4. add_separator() : 菜单分隔条    添加菜单的三个方法选项：            1. label ： 指定菜单项的文本        2. command ： 指定绑定的事件处理方法        3. image ： 指定菜单项的图标        4. compound ： 图标位于文字的哪个方位    Menu窗口菜单：        创建菜单后，将菜单设为窗口的menu选项即可            add_command 为file_menu 添加多个菜单项            add_cascade 再次为file_menu添加子菜单            add_radiobutton 添加多个单选菜单项    Menu 右键菜单：        先创建菜单，为目标组件的右键菜单绑定处理函数, 点击右键，调用菜单post 方法即可</code></pre><h3 id="Tkinter-Canvas-画布完全攻略"><a href="#Tkinter-Canvas-画布完全攻略" class="headerlink" title="Tkinter Canvas 画布完全攻略"></a>Tkinter Canvas 画布完全攻略</h3><pre><code>    绘制直线、矩形、椭圆等图形，提供create_rectangle 方法绘制和 create_oval 绘制椭圆，绘制方法：        create_arc ： 绘制弧        create_bitmap ： 位图        create_image ： 图片        create_polygon ： 多边形        create_line ： 直线        create_text ： 文本        creat_window ： 绘制组件            绘制指定的选项：                    fill ： 填充颜色                outline ： 边框颜色                width ： 边框宽度                dash ： 边框虚线                stipple ： 位图平铺填充                start ： 开始角度                extend ： 绘制弧的角度                style ： 绘制弧样式                arrow ： 是否有箭头                arrowshape ： 箭头样式                joinstyle ： 连接点的风格                anchor ： 绘制文字                justify ： 文本对齐方式Tkinter Canvas tag_bind ：指定图形项绑定事件处理函数或方法    tag_bind 方法： 用于为指定图形项绑定事件处理函数或方法，可用于响应用户动作Tkinter Canvas 绘制动画    小球转动； 循环显示多张转动的小球图片    小球移动： 改变小球的坐标程序</code></pre><h2 id="文件操作I-O"><a href="#文件操作I-O" class="headerlink" title="文件操作I/O"></a>文件操作I/O</h2><h3 id="文件基本操作"><a href="#文件基本操作" class="headerlink" title="文件基本操作"></a>文件基本操作</h3><pre><code>常见操作： 创建、删除、修改权限、读取、写入等    1. 删除、修改权限：作用于文件本身，属于系统级操作    2. 写入、读取： 文件常用操作，作用于文本的内容，属于应用级操作文件操作实现函数：    1. 打开文件： open 函数，返回文本对象    2. 对已打开的文件做读/写操作，读写，使用 read 、readline readlines 函数，写入：write 函数    3. 关闭文件： close </code></pre><h3 id="open-函数：打开指定文件"><a href="#open-函数：打开指定文件" class="headerlink" title="open 函数：打开指定文件"></a>open 函数：打开指定文件</h3><pre><code>如要操作文件，需创建或者打开指定的文件，并创建一个文件对象，内置的 open 函数    file = open(file_name [, mode [, buffering]])         file: 表示要创建的文件对象        file_mode ： 要创建或打开文件的文件名称，需用引号扩起来，注意路径        mode ： 可选参数；指定文件的打开模式，如不写，默认只读r        buffing ： 指定对文件做读写操作，是否使用缓存区</code></pre><h3 id="open-函数文件打开模式："><a href="#open-函数文件打开模式：" class="headerlink" title="open 函数文件打开模式："></a>open 函数文件打开模式：</h3><pre><code>            r ： 只读，指针在开头            rb ： 二进制格式，只读模式，指针位于开头，用于打开非文本文件，如图片            r+ ： 从头读取文件内容，从开头写入新的内容，新内容覆盖原有内容            rb+ ： 二进制格式读写模式打开，针对非文本文件，如音频文件            w ： 只读，清空文件原有内容            wb ：二进制格式、只读模式，音频文件            w+ ： 读写， 清空原有内容            wb+ ： 二进制格式、读写模式，非文本            a ：追加模式，只写权限，如文件不存在，则创建新文件            a+ ： 读写，指针位于末尾，如不存在，则新建            ab+ ： 二进制模式，追加模式，读写权限[读写操作](http://c.biancheng.net/uploads/allimg/190228/2-1Z22QI61c59.gif)    open 打开文件时，默认GBK编码，指定打开文件的编码格式；         file = open(&apos;xx.txt&apos;,encoding=&quot;utf-8&quot;)</code></pre><h3 id="open-是否需要缓冲区"><a href="#open-是否需要缓冲区" class="headerlink" title="open()是否需要缓冲区"></a>open()是否需要缓冲区</h3><pre><code>    一般建议打开缓冲，open函数，第三个参数是0或False，是不带缓冲的，若是1或True，则带缓冲open 文件对象常用属性：    file.closed ： 判断是否关闭    file.mode ： 返回访问模式    file.name ： 返回文件名以文件格式和二进制格式打开文件的区别：    相同点： 都是以二进制格式打开文件    不同点： 对文件中换行符的处理不同        Win： \r\n  转换为 \n         Unix/Linux ： 默认换行符是 \n        推荐使用 b 打开二进制文件</code></pre><h3 id="read-函数：-按字节、字符读取文件"><a href="#read-函数：-按字节、字符读取文件" class="headerlink" title="read 函数： 按字节、字符读取文件"></a>read 函数： 按字节、字符读取文件</h3><pre><code>        read 读取文件是字节、字符的区别： 取决于open函数打开文件时，是否使用 b 模式，如使用 b ，读取的是 字节， 如不是 b ，则是 字符        file.read([size])    read 抛出UnicodeDecodeErorr 异常的解决方案：        文本的额字符集和操作系统的字符集不匹配，解决方案：            1. 使用二进制模式读取， 然后用bytes 的decode 方法恢复为字符串            2. 采用 codecs 模块的open函数打开文件时指定字符集readline 和 readlines ： 按行读取文件    readline ： 读取一行内容 。 readlines ： 读取文件内的所有行         readline ：             file.readline([size])                file 为打开的文件对象， size 可选参数，指定读取每一行，一次最多读取的字符数，模式使用 r 或 r+ 读写        readlines ：            file.readlines() : file 为文件打开对象， 模式使用r 或 r+    write 和 writelines ： 向文件中写入数据        file.write(string) :向文件中写入指定内容。 file。write(string)        writefiles() 函数：             将字符串列表写入文件中。 向文件中写入多行数据时，不自动给各行添加换行符</code></pre><h3 id="close-：-关闭文件"><a href="#close-：-关闭文件" class="headerlink" title="close ： 关闭文件"></a>close ： 关闭文件</h3><pre><code>        flie.close()            关闭使用open函数打开的文件                如不在关闭文件的前提下将数据写入到文件中，使用文件对象提供的flush 函数seek 和 tell 函数    tell ：判断文件指针当前所处的位置    seek ：用于移动文件指针到文件的指定位置        file.tell()        file.seek(offset[, whence])            file : 文件对象            whence ： 指定文件指针要放置的位置，0 开头，1当前位置，2文件尾            offset ： 相对于whence位置文件指针的偏移量</code></pre><h3 id="with-as-用法"><a href="#with-as-用法" class="headerlink" title="with  as 用法"></a>with  as 用法</h3><pre><code>使用with as 语句操作上下文管理器 context manager，自动分配并且释放资源    with 表达式 [as target]:        代码块即使没有关闭文件，修改文件内容的操作也能成功</code></pre><h3 id="上下文管理器，-python-with-as-底层原理"><a href="#上下文管理器，-python-with-as-底层原理" class="headerlink" title="上下文管理器， python with as 底层原理"></a>上下文管理器， python with as 底层原理</h3><pre><code>    包含 __enter__() 和  __exit__() 方法的对象是上下文管理器，上下文管理器必须实现一下两个方法：        1. __enter__(self): 进入上下文管理器自动调用的方法，会在with as 执行前执行，返回值被赋值给 as 子句后的变量，可返回多个值，在as子句后可指定多个变量，必须用 () 括起来        2. __exit__(self,exc_typ`e,exc_value,exc_traceback ) ： 退出上下文管理器自动调用的方法，在with as 代码执行后执行，如with as 因异常终止，程序自动调用该方法，使用 sys.exc_info 得到的异常信息将作为调用该方法的参数    构建上下文管理器，实现的2种方式：        1. 基于类的上下文管理器            只要类实现 __enter__()  __exit__ 这两个方法，就可使用with as来管理， 通过 __exit__ 方法的参数，可判断with 代码块执行是否遇到了异常，        2. 基于生成器的上下文管理器            使用基于生成器的上下文管理器时，不需要定义 __enter__() 和 __exit__()方法，但必须添加 装饰器 @contextmanager         基于类的上下文管理器灵活，适用于大型的系统开发        基于生成器的上下文管理器更方便、简洁、适用于小型程序            切记： 用__exit__() 或是 finally 块中释放资源fileinput模块：逐行读取多个文件    把多个输入流合并在一起        fileinput.input (files = &quot;filename1,filenamex,...&quot;,inplace=False,backup=&quot;,bufsize=0,mode=&apos;r&apos;,openhook=None&quot;)            files ：多个文件的路径列表            inplace ： 指定是否将标准输出的结果写回到文件，默认值为 False            backup ： 指定备份文件的扩展名            bufsize ： 指定缓存区的大小，默认0            mode ： 打开文件的格式，默认 r            openhook ： 控制文件的打开方式，如编码格式    fileinput 模块常用函数        fileinput.filename() ：返回读取文件的文件名        fileinput.fileno() ：返回文件描述        fileinput.lineno() ：返回读取的行号        fileinput.filelineno() ：返回读取的行在文件中的行号        fileinput.isfirstline() ： 读取的行在文件中是否为第一行        fileinput.isstdin() ： 是否从sys.stdin 读取        fileinput.nextfile() ： 关闭当前文件，开始读取下一个文件        fileinput.close() ： 关闭fileinput对象linecache模块：随机读取文件指定行    从源文件随机读取指定行，并在内部使用缓存优化存储，会使用utf-8字符集        常用函数：            linecache.getline(filename,lineno,module_globals=None)：读取指定模块中指定文件的指定行，filename指定文件名，lineno指定行号            linecache,clearcache() ：清空缓存            linecache.checkcache(filename=None) ：检查缓存是否有效，如没有指定文件名filename参数，默认检查所有缓存的数据pathlib模块    提供了一组面向对象的类，代表各种操作系统上的路径    PuraPath 的两个子类： PurePosixPath:Unix风格的路径  PureWindowsPath：Windows风格的路径PurePath ：使用此函数或他的子类来创建PurePath对象，创建时，可闯入单个路径字符串，也可传入多个路径字符串PurePath类的属性和方法：    操作路径字符串，[](http://c.biancheng.net/view/2541.html)    Path类功能和用法：    Path 是PurePath的子类，可访问底层的文件系统，判断Path对应的路径是否存在，可对文件进行读写os.path 模块函数    操作目录的方法，可操作系统的目录本身，如 exists():判断目录是否存在, getctime()：创建时间 getmtime()：修改时间  getatime()：访问时间  getsize()：文件大小fnmatch模块：文件名的匹配    匹配支持的通配符：        * ： 匹配任意个任意字符        ? ： 匹配一个任意字符        [字符序列] ：匹配中括号里字符序列中的任意字符，        [!字符序列] ： 匹配不在中括号里字符序列中的任意字符    fnmatch.fnmatch(filename,pattern)：判断指定文件名是否匹配指定pattern    fnmatch.fnmatchcase(filename,pattern)：匹配时不区分大小写    fnmatch.filter(names,pattern) ：对names列表进行过滤，返回names列表中匹配pattern的文件名组成的子集合。     fnmatch.translate(patteran)：将Unix shell风格的pattern转换为正则表达式patternos模块：    os模块与目录相关的函数：        os.getcwd()：获取当前目录        os.chdir(path) ： 改变当前目录        os.fchdir(fd) ：通过文件描述改变当前目录        os.chroot(path)：改变当前进程的根目录        os.listdir(path)：返回paht对应目录下的所有文件和子目录        os.mkdir(path[,mode])：创建path对应的目录，mode指定目录的权限        os.makedirs(path[,mode])：类似mkdir ，可递归创建目录，        os.rmdir(path)：删除path对应的空目录，如非空抛出 OSError异常，可先用os.remove()删除文件        os.removedirs(path) ：递归删除目录，类似rmdir        os.rename(src,dst)：重命名文件或目录，将src命名为dst        os.renames(old,new) ：对文件或目录进行递归重命名，类rename，os模块与权限相关的函数    os.access(path,mode)：检查path对应的文件或目录是否具有指定权限，第二参数的四个状态        os.F_OK ： 判断是否存在        os.R_OK ： 是否可读        os.W_OK ： 是否可写        os.X_OK ： 是否可执行    os.chrnod(path,mode) :更改权限，        stat.S_IXOTH ：其他用户有执行权限        [更多](http://c.biancheng.net/view/2558.html)                os.chown(path,uid,gid) ：更改文件的所有值，uid代表用户id，gid代表组id    os.fchmod(fd,mode) ：改变一个文件的访问权限，fd代表文件    os.fchown(fd,uid,gid) ：改变文件的所有者&apos;&apos;os模块与文件访问函数    os.open(file,flags[,mode]) ：打开一个文件，设置打开选项，flags表示打开文件的旗标，支持多个选项        os.O_RDONLY ： 只读方式打开        os.O_WRONLY ： 只写方式        os.O_RDWR ： 读写方式        os.O_NONBLOCK ： 打开时不阻塞        os.O_APPEND ： 追加方式打开        os.O_CREAT ；创建并打开一个新文件        [更多](http://c.biancheng.net/view/2558.html)    os.read(fd,n) ：从文件描述符fd中读取最多n个字符，返回读到的字符串    os.wirte(fd,str) ：将字符串写入文件描述符fd，返回写入的字符串长度    os.close(fd) : 关闭文件描述符fd    os.lseek(fd,pos,how) ： 用于移动文件指针，how指定从哪里开始移动，    os.fdopen(fd[,mode[,bufsize]]) ：通过fd打开，返回文件对象    os.closerange(fd_low,fd_high) : 关闭从fd_low 包含 到 fd_high 不包含范围的所有文件描述符    os.dup(fd) ： 复制文件描述符    os.dup2(fd,fd2) ： 讲一个fd 复制到另一个文件描述符 fd2中    os.ftruncate(fd,length) ： 将fd对应的文件截断到length长度，length参数不超文件大小    os.remove(path) ：删除path对应的文件    os.link(src,dst) ： 创建从src 到dst的硬连接    os.symlink(src,dst) ：创建从src到dst的符号链接tempfile模块：生成临时文件和临时目录    常用函数：        tempfile.TemporaryFile(mode=&apos;w+b&apos;,buffering=None,encoding=None,newline=None,suffix=None,prefix=None,dir=None) ：创建临时文件，返回类文件对象，支持I/O    [More](http://c.biancheng.net/view/2560.html)        tempfile.gettempdir() : 获取系统临时目录    创建临时文件的两种方式：        1. 手动创建临时文件，读写临时文件后需主动关闭，程序关闭时文件自动删除        2. 使用with语句创建临时文件，with语句自动关闭临时文件</code></pre><h2 id="数据库编程"><a href="#数据库编程" class="headerlink" title="数据库编程"></a>数据库编程</h2><h3 id="数据库API-DB-API"><a href="#数据库API-DB-API" class="headerlink" title="数据库API(DB API)"></a>数据库API(DB API)</h3><pre><code>全局变量    3个全局变量：        1. apilevel ： 显示数据库模块的API版本号        2. threadsafety ： 指定数据库模块的线程安全等级，等级值为 0～3，3代表模块完全是线程安全的，1:部分安全 ，0：  完全不能共享该模块        3. paramstyle ： 指定SQL语句需要参数时，使用风格的参数，返回如下变量值：            format ： 格式化字符串代表参数，使用 %s            pyformat ： 使用扩展的格式代码代表参数            qmark ： 使用 ？ 问号代表参数            numeric ： 使用数字占位符 :N 代表参数，1 代表一个参数，2 也代表参数            named ： 使用命名占位符 :name 代表参数数据库API的核心类    连接对象的方法和属性        cursor() ：            打开游标        commit() ：            提交事物        rollback()：        回滚事物        close() ：            关闭数据库连接        isolation_level:    返回或指定数据库连接中事物的隔离级别        in_transaction:        判断当前是否处于事物中cursor ： 返回游标对象，游标对象是 Python DB API的核心对象，用于执行各种SQL语句，包括DDL、DML、select 查询语句等，使用游标执行不同的SQL语句返回不同的数据。    游标对象的属性和方法：        execute(sql[,parameters]) ： 执行SQL语句，parameters 参数用于为SQL语句中的参数指定值        executemany(sql,seq_of_parameters) ：重复执行SQL语句，通过第二个参数指定值，序列有多少个元素，SQL语句被执行多少次        executescript(sql_script) ：直接执行包含多条SQL语句的SQL脚本        fetchone() : 获取查询结果集的下一行，如没有，则返回None        fetchmany(size=cursor.arraysize) ：返回查询结果集的下N行组成的列表，如没有，返回空        fetchall() : 返回查询结果集的全部行组成的列表        close() : 关闭游标        rowcount ： 只读属性返回受SQL语句影响的行数，修改的记录条数也可通过该属性获取        lastrowid ：获取最后修改行的rowid        arraysize ： 设置或获取fetchmany 默认获取的记录条数，默认为 1        desciption ： 获取最后一次查询返回所有列的信息，只读        connection ： 返回创建游标的数据库连接对象，属性只读    操作数据库的基本流程        1. 调用 connect 方法打开数据库连接，返回数据库连接对象        2. 通过数据库连接对象打开游标        3. 使用游标执行SQL语句 包括 DDL、DML、select查询语句，如执行的是查询语句，则处理查询数据        4. 关闭游标        5. 关闭数据库连接        [图示](http://c.biancheng.net/uploads/allimg/190301/2-1Z301153400E3.gif)SQLite 创建数据库表    是一种嵌入式数据库，数据库是一个文件，SQLite将整个数据库包括定义表、索引以及数据本身，作为一个单独的、可跨平台使用的文件存储在主机中。不需要安装。直接导入    连接数据库：        connect() 函数            conn = sqlite3.connect(&apos;xx.db&apos;)        // xx.db 是一个数据库,如不存在，在当前目录下创建对应的文件    创建数据库：        import sqlite3        conn = sqlite3.connect(&apos;xx.db &apos;)        c = conn.cursor()        c.execute(&apos;&apos;&apos; create table user_tb(            id interger primary key autoincrement,            name text,            pass text,        gender text)&apos;&apos;&apos;                )        c.execute(&apos;&apos;&apos; create table post_tb                id integer primary key autoincrement,                post_name text,                post_author text,                post_number real,                user_id integer,                foreign key(user_id) references user_tb(id)&apos;&apos;&apos;)        c.close()        conn.close()    SQLite 支持 NULL、INTEGER、REAL浮点数、TEXT文本、BLOD大二进制对象SQLite execute 和 executemany     游标的execute 方法可执行DML 操纵语言 的 insert 、update、delete 语句，对数据库执行插入、修改和删除数据操作    调用execute 方法执行insert 可向数据库插入数据    向数据库插入一条数据：        // 导入访问SQLite的模块        import sqlite3        // 打开或创建数据库， 可用 :memory: 代表创建内存中的数据库        conn = sqlite3.connect(&apos;xx.db&apos;)            // xx.db 指创建时指定的数据库文件        // 获取游标        c = conn.cursor()        //    调用执行 insert 语句插入数据        c.execute(&apos;insert into user_tb values (null,?,?,?)&apos;, (&apos;xxx&apos;,&apos;xxx&apos;,&apos;xxx&apos;))        c.execute(&apos;insert into xxx_tb values (null,?,?,?)&apos; (&apos;xx&apos;,&apos;xx&apos;,&apos;xx&apos;))        //    提交事物        conn.commit()        // 关闭游标        c.close()        // 关闭连接        conn.close() executemany ： 多次执行同一条SQl语句        import sqlite3        conn = sqlite3.connect(&apos;xx.db&apos;)        c = conn.cursor()        c.executemany(&apos;inert into xxx_tb values (null,?,?,?)&apos;,            (    (&apos;xx&apos;,&apos;xxx&apos;,&apos;xxxx&apos;),                (&apos;aa&apos;,&apos;aaa&apos;,&apos;aaaa&apos;),                (&apos;bb&apos;,&apos;bbb&apos;,&apos;bbbb&apos;),                (&apos;zz&apos;,&apos;zzz&apos;,&apos;zzzz&apos;)            ))        conn.commit()        c.close()        conn.close()update | delete    import sqlite3    conn = sqlite3.connect(&apos;xx.db&apos;)    c = conn.cursor()    c.execute(&apos; update user_tb set xxx=? where xx=? &apos;,                ((&apos;aa&apos;,1),                (&apos;bb&apos;,2)            ))    print(&apos;change numbers : &apos;, c.rowcount)    conn.commit()    c.close()    conn.close()SQLite : fetchone() , fetchmany() and fetchall:    select 语句执行查询结果， 通过游标的 fetchone 、fetchmany、fecthall获取查询结果，fetchone 获取一条，fetchmany 获取多条， fetchall 获取全部    import sqlite3    conn = sqlite3.connect(&apos;xx.db&apos;)    c = conn.cursor()    c.execute(&apos;select * from user_tb where xx &gt; ?&apos;,(2,))    print(&apos;result : &apos;, c.rowcount)    for col in (c.description):        print([col[0],end&apos;\t&apos;])    print(&apos;\n------&apos;)    where True:        row = c.fetchone()        if not row:            break        print(row)        print(row[1] + &apos; -&gt; &apos; + row[2])    c.close()    conn.close()可修改部分代码：    while True:        // 指定抓起的条数记录，返回由条数组成的列表        rows = c.fetchmany(3)        //    判断rows是否为None        if not row:            break        // 再次使用循环遍历获取的列表        for r in rows:            print(r)    避免使用fetchall获取查询的全部记录，如数据量过大，会导致内存开销过大，导致系统崩溃！SQLite： executescript     可执行一段SQL脚本        import sqlite3        conn = sqlite3.connect(&apos;xx.db&apos;)        c = conn.cursor()        c.executescript(&apos;&apos;&apos;            insert into user_tb values (null,&apos;aaa&apos;,&apos;aaa&apos;,&apos;aaaa&apos;),            insert into user_tb values (null,&apos;bbb&apos;,&apos;bbb&apos;,&apos;bbbb&apos;),            create table item_tb (id integer primary key autoincrement, name, price)        &apos;&apos;&apos;)        conn.commit()        c.close()        conn.close()    简化： SQLite 提供了3个方法为数据库连接对象        1.  execute(sql[,parameters]) : 执行一条SQL语句        2. executemany(sql[, parameters]) : 根据序列重复执行SQL语句        3. executescipt(sql_script) ： 执行SQL脚本        只是游标对象的3个方法的快捷方式                                 SQLite： create_function 方法： 注册自定义函数    create_function 方法包含的三个参数：        1. name ： 指定注册的自定义函数的名字        2. num_params ： 指定自定义函数所需参数的个数        3. func ： 指定自定义函数对应的函数        为SQL语句注册一个自定义函数，可在SQL语句中使用该自定义函数            import sqlite3            def reverse_ext(st):                return &apos;[&apos; + st[::-1] + &apos;]&apos;            conn = sqlite3.connect(&apos;xx.db&apos;)            // xx.db 代表数据库文件            conn.create_function(&apos;enc&apos;,reverse_ext)            c = conn.cursor()            c.execute(&apos;insert into user_tb values(null,?,enc(&gt;),?)&apos; ,                        (&apos;xx&apos;,&apos;xx&apos;,&apos;xxx&apos;))            conn.commit()            c.close()            conn.close()SQLite create_aggregate() : 自定以聚集函数    SQL提供的5个聚集函数：        1. sum() : 统计总和        2. avg()  ：统计平均值        3. count() ： 统计记录条数        4. max() ： 统计最大数        5. min() ： 统计最小数可使用数据库连接对象提供的 create_aggregate(name,num_params,aggregate_class)方法，用于注册一个自定义的聚集函数        create_aggregate 方法包含3个方法：                1. name ： 指定自定义聚集函数的名字                2. num_params ： 指定聚集函数所需的参数                3. aggregate_class ： 指定聚集函数的实现类，该类必须实现 step(self,pargams,..) 和 finalize(self) 方法，step方法返回每条记录各执行一次，finalize 方法只在最后执行一次，返回值作为聚集函数最后的返回值SQLite： create_collation ： 创建自定义比较函数    create_collation(name, callable) 注册一个自定义的比较函数        2个参数：            1. name ： 指定自定义比较函数的名字            2. callable ： 指定自定义比较函数对应的函数，包含两参数，对两个参数进行比较，如返回正整数，第一个参数更大，如是负整数，第二个参数更大，如返回0，则相等            import sqlite3            def my_collate(str1,str2):                if st1[1:-1] == str2[1:-1]:                    return 0;                elif ...            conn = sqlite3.connect(&apos;xx.db&apos;)            conn.creat_collation(&apos;sub_cmp&apos;,my_callate)            c = conn.cursor()            c.execute(&apos;seleft * from xxx_tb where field = ?&apos;, (1))            for row in c:                print(row)            conn.commit()            c.close            conn.close()MySQL 数据库    查看已安装的模块： pip list                       pip show packagename                       pip show mysql-connector-python    卸载已安装的模块： pip uninstall packagename    安装模块： pip install packagename                pip install mysql-connector-python                pip install packagename == 1.0    // 可指定版本    MySQL 数据库执行DDL 语句        import mysql.connector        conn = mysql.connector.connect(user=&apos;root&apos;,password=&apos;root&apos;, host=&apos;127.0.0.1|localhost&apos;,post=&apos;3306&apos;, database=&apos;python&apos;,use_unicode=True)        c = conn.cursor()        c.execute(&apos;&apos;&apos;    create table user_tb (                user_id int primary key auto_increment,                name varchar(100),                pass varchar(200),                gender varchar(100)            )&apos;&apos;&apos;)        c.execute(&apos;&apos;&apos; create table order_tb (            order_id int primary key auto_increment,            item_name varchar(100),            item_price double,            item_number double,            user_id  int,            foreign key(user_id) reference user_tb(user_id)        )&apos;&apos;&apos;)        c.close()        conn.close()MySQL 数据库执行DML 语句    可使用游标的execute 方法执行DML的 insert 、upadte、delete        import mysql-connector        conn = mysql-connector.connect(user=&apos;root&apos;,password=&apos;hale&apos;,host=&apos;localhost&apos;,port=&apos;3306&apos;,database=&apos;python&apos;,use_unicode=True)        c = conn.cursor()        c.execute(&apos;insert into user_tb values(null, %s,%s,$s)&apos;,(&apos;aa&apos;,&apos;aaa&apos;,&apos;aaaa&apos;))        c.executemany(&apos;insert into order_tb values (null,%s ,%s,%s,%s)&apos;,                 ((&apos;a&apos;,&apos;aa&apos;,&apos;aaa&apos;),(&apos;b&apos;,&apos;bb&apos;,&apos;bbb&apos;),(&apos;c&apos;,&apos;cc&apos;,&apos;ccc&apos;)))        conn.commit()        c.close()        conn.close()    使用 %s 作为占位符    update         c.executemany(&apos;update user_tb set name=%s where user_id = %s &apos;, ((&apos;e&apos;,&apos;ee&apos;,&apos;eee&apos;),(&apos;w&apos;,&apos;ww&apos;,&apos;www&apos;)))        print(&apos;change : &apos;, c.rowcount)        conn.comm    mysql数据库模块连接对象有一个 autocommit ，如属性设置为True ，则关闭连接的事物支持，每次执行DML语句后会自动提交，无需调用 commit 方法提交事物        import mysql.connector         conn = mysql.connector.connect(user=&apos;root&apos;,password=&apos;hale&apos;,host=&apos;localhost&apos;,port=&apos;3306&apos;,database=&apos;python&apos;,use_unicode=True)        conn.autocommit = TrueMySQL 数据库执行查询语句    import mysql.connector    conn = mysql.connector.connect(user=&apos;root&apos;,password=&apos;hale&apos;,host=&apos;localhost&apos;,port=&apos;3306&apos;,database=&apos;python&apos;,use_unicode=True)    c = conn.cursor()    c.execute(&apos;selecet * from user_tb where user_id &gt; %s&apos;, (1,))        for col in (c.description):        print(col[0],end=&apos;\t&apos;)    print(&apos;\n -------&apos;)    for row in c:        print(row)        print(row[1] + &apos; -&gt; &apos; + row[2])    c.close()    conn.close()    游标对象支持 fetchone() fetchmany() fetchall()     c.execute(&apos;select * from ueer_tb where user_id &gt; %s&apos;,(1,))    where True:        rows = c.fetchmany(3)        if not rows:            break        for r in rows:            print(r)MySQl callproc : 调用数据库存储过程    callproc(self,procname,args=0)        procname : 代表存储过程的名字， args 参数用于存储过程传入参数        result_args = c.callproc(&apos;add_pro&apos;,2,1,0)PyMySQl模块下载和安装    类Connector/Python、PyMySQL ，称为接口程序，通过此对象，可对另外一个对象操作    安装PyMySQL模块：        pip install PyMySQL            import pymysql    import pymysql    conn = pymysql.connect(host=&apos;localhost&apos;,root=&apos;root&apos;,password=&apos;pass&apos;,db=&apos;python&apos;,charset=&apos;utf8mb4&apos;)    c = conn.cursor()    c.execute(&apos;select  Version()&apos;)    while True:        rows = c.fetchmany(3):            if not rows:                break            for i in rows:                print(i)    c.close()    conn.close()创建数据库：        import pymysql    conn = pymysql.connect(&apos;localhost&apos;,&apos;root&apos;,&apos;root&apos;,&apos;python&apos;)    cursor = conn.cursor()    cursor.execute(&apos;Drop table if exists tb_name&apos;)    sql = &apos;&apos;&apos; create table user_tb (        user_id int primary key auto_increment,        name varchar(100),        email varchar(10),        pass varchar(100)    )&apos;&apos;&apos;    cursor.execute(sql)    cursor.close()    conn.close()数据库插入操作    import pymysql    conn = pymysql.connect(&apos;localhost&apos;,&apos;root&apos;,&apos;root&apos;,&apos;py_db&apos;)    cursor  = conn.cursor()    sql = &apos;&apos;&apos; insert into user_tb (name,pass) values (&apos;%s&apos;,&apos;%s&apos;) % (&apos;aa&apos;,&apos;aa&apos;)&apos;&apos;&apos;    try:         cursor.execute(sql)        conn.commit()    except:        conn.rollback()    conn.close()</code></pre><h2 id="并发编程-多进程、多线程"><a href="#并发编程-多进程、多线程" class="headerlink" title="并发编程(多进程、多线程)"></a>并发编程(多进程、多线程)</h2><h3 id="进程和线程-区别"><a href="#进程和线程-区别" class="headerlink" title="进程和线程 区别"></a>进程和线程 区别</h3><pre><code>进程： 操作系统资源分配的基本单位，通常是一个程序线程： 任务调度和执行的基本单位，是进程的组成部分    可运行多个进程(程序)，同一进程可多个线程同时执行(通过CPU调度，每个时间片中只有一个线程执行内存方面：进程分配不同的内存控件，线程不分配开销方面： 进程有独立的代码和数据空间程序上下文，进程切换开销大，线程是轻量级的进程，同一类线程共享代码和数据空间，有独立的运行栈和计数器，线程切换开销小单线程： 当一个进程中只有一个线程时多线程： 当一个进程中有多个线程时 </code></pre><h3 id="创建线程的两种方式："><a href="#创建线程的两种方式：" class="headerlink" title="创建线程的两种方式："></a>创建线程的两种方式：</h3><pre><code>相关模块：    1. _thread ： 提供低级别的原始的线程支持，及简单的锁，功能有限，不建议使用    2. threading ： 提供丰富的多线程支持，推荐使用创建方式：    1. 使用 threading 中的 Thread 类的构造器创建线程，直接对类 threding.Thread 进程实例化，并调用对象的 start 方法创建线程    2. 继承 threading 模块中的 Thread 类创建线程类，用 threading.Theread 派生出一个新的子类， 将新建类实例化，并调用 start 方法创建线程 调用Thread 类的构造器创建线程：    直接调用 threading.Thread 类构造器创建线程：        __init__(self,gourp=None,target=None,name=None,args=(),kwargs=None,*,daemon=None)            group: 指定该线程所属的线程组，            target： 指定该线程要调度的目标方法            args ： 指定一个元组，以位置参数形式为target 指定的函数传入参数，元组的第一个参数传给target函数的第一个参数，第二个传给target第二个参数，以此类推            kwargs ：指定一个字典，以关键字参数的形式为target指定的函数传参            daemon ： 指定所构建的线程是否为后代线程    通过Thread 类的构造器创建并启动多线程的步骤：        1. 调用Thread类的构造器创建线程对象，创建时，target参数指定的函数将作为线程执行体        2. 调用线程对象的start() 方法启动该线程            import threading            // 定义普通的action函数，作为线程执行体            def action(max):                for i in range(max):                    print(threading.current_thred().getName() + &quot; &quot; + str(i))            // 主程序、祝线程的执行体            for i range(100):                print(threading.current_thread().getName() + &quot; &quot; + str(i))                if i == 20:                    t1 = threading.Thread(target=action,args=(100,))                    t1.start()                    t2 = threading.Thread(target=action,args=(100,))                    t2.start()            print(&apos;master thread is run over !&apos;)            1. 创建一个Thread对象，线程的target 为 action， 将action函数作为线程主体执行，接下来的程序调用start 来启动t1线程            2. 再次创建线程，创建和启动与第一个线程完全相同            显式创建并启动了两个线程，但实际上有三个，当程序运行后，至少创建一个主线程，主线程的线程执行代码就是程序中的主程序，没放在任何函数中的代码                用到的函数和方法：                    threading.current_thread(): 是threading 模块的函数，总是返回当前正在执行的线程对象                    getName ：Thread类的实例方法，返回调用他的线程名字                在Threading模块中，经常用到的函数：                    threading.enumerate() : 正运行线程的list                    threading.activeCount ： 返回正在运行的线程数量，与 len(threading.enumerate())继承Thread类创建线程类    步骤：        1. 定义Thread 类的子类，并重写run方法，run方法方法体代表线程需要完成的任务，因此 run方法称为 线程执行体        2. 创建Thread 子类的实例，即创建线程对象        3. 调用线程对象的start 方法来启动线程            import threading            class FKThread(threading.Thread):                def __init__(self):                    threading.Thread.__init__(self)                    self.i = 0                 def run(self):                    while self.i &lt; 100:                        print(threading.current_thread().getName() + &quot; &quot; + str(self.i))                    self.i += 1            for i in range(100):                print(threading.current_thread().getName() + &quot; &quot; + str(i) )                if i == 20:                    ft1 = FKThread()                    ft1.start()                    ft2 = FKThread()                    ft2.start()            print(&apos;threading is ok !&apos;)</code></pre><h3 id="Python-线程的生命周日-新建、就绪、运行、阻塞、死亡"><a href="#Python-线程的生命周日-新建、就绪、运行、阻塞、死亡" class="headerlink" title="Python 线程的生命周日(新建、就绪、运行、阻塞、死亡)"></a>Python 线程的生命周日(新建、就绪、运行、阻塞、死亡)</h3><h4 id="线程的新建和就绪状态"><a href="#线程的新建和就绪状态" class="headerlink" title="线程的新建和就绪状态"></a>线程的新建和就绪状态</h4><pre><code>        [具体](http://c.biancheng.net/view/2606.html)            程序新建Thread对象或Thread子类的对象后，线程处于新建状态。 线程对象调用start 方法，会处于就绪状态，解释器会为其创建方法调用栈和程序计数器。启动线程用start 方法，不是run方法。 start 方法启动线程，系统把该run方法当成线程执行体处理。        import threading        def action(max):            for i in range(max):                print(threading.current_thread().name + &quot; &quot; + str(i))        for i in range(100):            print(threading.current_thread().name + &quot; &quot; + str(i))            if i == 20:                threading.Thread(target=action,args=(100,)).run()                threading.Thread(target=action,args=(100,)).run()        如果程序对同一线程重复调用start方法，会引发 RuntimeError警告    线程运行和阻塞状态        如处于就绪状态的线程获得了CPU，执行run方法的线程执行体，该线程处于运行状态        在一个具有多处理器的机器上，会有多个线程并行执行 Parallel。当线程数大于处理器时，依然存在多个线程在同一CPU上轮换    进入阻塞状态的情况：        1. 线程调用 sleep 方法主动放弃其所占用的处理器资源        2. 线程调用了一个阻塞式I/O方法，返回之前，线程被阻塞        3. 线程试图获取一个锁对象，但锁对象被其他线程持有        4. 线程在等待某个通知 Notify    解除阻塞，重新进入就绪状态的情况：        1. 调用sleep方法的线程经过了指定的时间        2. 线程调用的阻塞模式I/O方法已经返回        3. 线程成功获得了试图获取的锁对象        4. 线程等待某个通知时，其他线程发出通知Notify，线程死亡    线程死亡的方式：        1. run方法或代表线程执行体的target 函数执行完成，线程正常结束        2. 线程抛出一个未捕获的Exception 或 Error        测试某个线程是否四万过的方法：调用线程对象的is_alive()方法，当线程处于就绪、运行、阻塞三种状态，方法返回True，当线程处于新建、死亡状态时，方法返回False            import threading            def action(max):                for i in range(100):                    print(threading.current_thread().name + &quot; &quot; + str(i))            // 创建线程对象            sd = threading.Thread(target=action,args=(100,))            for i in range(300):                print(threading.current_thread().name + &quot; &quot; + str(i))                if i == 20:                    sd.start()                    print(sd.is_alive())            //    试图启动死亡线程                if i &gt; 20 and not(sd.is_alive()):                    sd.start()Thread join() 用法    让一个线程等待另一个线程完成的join方法，当在某个程序执行流中调用其他线程的join方法，调用线程将被阻塞，直接被join方法加入额join线程执行完成    import threading    def action(max):        for i in range(max):            print(threading.current_thread().name + &quot; &quot; + str(i))    threading.Thread(target=action,args=(100,),name=&quot;new threading&quot;).start()    for i in range(100):        if i == 20:            jt = threading.Thread(target=action, args=(100,), name=&quot;join threading&quot;)            jt.start()            jt.join()        print(threading.current_thread().name + &quot; &quot; + str(i))Python守护线程及作用    后台线程Daemon Thread： 后台运行，任务时为其他线程提供服务。又称 &quot;精灵线程&quot;。 特征：所有前台死亡，后台会自动死亡    调用Thread对象的daemon属性可将指定线程设置为后台线程，        import threading        def action(max):            for i in range(max):                print(threading.current_thread().naem + &quot; &quot; + str(i))    t = threading.Thread(target=action, args=(100.), name=&quot;daemon threading&quot;)    // 将此线程设置为后台线程    t.daemon = True    t.start()    for i in range(100):        print(threading.currenct_thread().name + &quot; &quot; + str(i))    创建线程的两种方法：        1. 主动将线程的daemon 属性设置为True        2. 后台线程启动的线程默认时后台线程    将daemon 属性设为True，必须在start方法调用之前进行，否则引发 RuntimeError异常sleep 函数用法： 线程睡眠    如需让当前线程暂停一段时间，并进入阻塞状态，可调用 time 模块的 sleep(secs)函数实现，secs参数为指定线程阻塞多少秒    import time    for i in range(10):        print(&quot;now time : %s&quot; % time.ctime())        time.sleep(1)互斥锁Lock: 解决多线程安全问题    多线程优势在于并发性，可同时运行多个任务， 互斥锁解决数据不同步问题        类银行取钱：            1. 用户输入账号、密码，系统判断用户输入信息是否匹配            2. 输入金额            3. 系统判断余额是否大于取款金额            4. 若大于，则成功，如小于，则失败        并发取款：            class Account:                def __init__(self,account_no,balance):                    self.account_no = account_no                    self.balanace = balance        取钱：            import threading            import time             import Account            def draw(account,draw_amount):                if account.blance &gt;= draw_amount:                    print(threading.current_thread().name + &quot; get RMB successful &quot; + str(draw_amount))                     account.balance -= draw_amount                    print(&apos;yu e &apos; + str(accnout.balance))                else:                    print(threading.current_thread().name + &apos;get RMB error &apos;)            user = Account.Account(&apos;12345&apos;,1000)            threading.Thread(name=&apos;A&apos;,target=draw, args=(user,100)).start()            threading.Thread(name=&apos;B&apos;,target=draw, args=(user,200)).start()            [LOCK](http://c.biancheng.net/view/5107.html)互斥锁同步线程    python的threading模块引入互斥锁，解决run方法体不具有线程安全性，threading模块提供了lock和Rlock两个类，提供了两个方法来加互斥锁和释放互斥锁：        1. acquire(blocking=True, timeout=-1):请求对lock或Rlock加锁，timeout参数指定加锁的秒数        2. release() : 释放锁    lock 和 Rlock 的区别：        threading.lock: 一个基本的锁对象，每次只能锁一次，其余的锁请求，徐等待锁释放后才能获取        threading.Rlock: 代表可重入锁，同一线程可多次锁定，也可多次释放，如使用Rlock，acquire和release 方法必须成对出现    class X:        def m():            self.lock.acquire()            try:                paxx            finally:                self.lock.release()    线程安全的类具有的特征：        1. 该类的对象可被多个线程安全地访问        2. 每个线程在调用该对象的任意方法后，可得到正确的结果        3. 每个线程在调用该对象的任意方法后，该对象依然保持合理的状态    减少线程安全带来的负面影响的策略：        1. 不对线程安全类的所有方法进行同步，只对改变竞争资源方法进行同步        2. 在单线程环境中使用线程不安全版本保证性能，在多线程环境中使用线程安全版本死锁： 如何避免死锁    当两个线程相互等待对方释放同步监视器时会发生死锁，在进行多线程编程时采取措施避免死锁    [死锁](http://c.biancheng.net/view/2620.html)避免死锁的方式：    1. 避免多次锁定，避免同一个线程对多个Lock进行锁定    2. 具有相同的加锁顺序    3. 使用定时锁    4. 死锁检测Python condition实现线程通信    线程调度具有一定的透明性，程序无法准确控制线程的轮换执行。如有需要，可通过线程通信保证线程协调运行，    Condition对象保持协调。Condition可让那些已经得到lock对象却无法继续执行的线程释放Lock对象，Condition可唤醒其他处于等待状态的线程    Condition类提供的方法：        1. acquire([timeout])/release(): 调用Condition 关联的lock的acquire或release 方法        2. wait([timeout]) : 导致当前进程进入Condition的等待池等待通知并释放锁，知道其他调用该Condition的Notify或notify_all() 方法来唤醒该线程        3. notify() : 唤醒在该Condition 等待池中的单个线程并通知它，收到通知自动调用acquire 方法尝试加锁。        4. notify_all() : 唤醒在该Condition 等待吃中等待的所有线程并通知他们        [More](http://c.biancheng.net/view/2622.html)    Queure 队列实现线程通信    queue模块提供阻塞队列，用于实现线程通信。主要提供三个类： 主要区别在于进队列、出队列的不同        1. queue.Queue(maxsize=0): 代表FIFO 先进先出的常规队列，maxsize 可限制队列的大小。 如maxsize为0 或负数，表示该队列的大小无限制        2. queue.LifoQueue(maxsize=0): 代表LIFO 后进先出，与Queue区别是出队列的顺序不同        3. PriorityQueue(maxsize=0): 代表优先级队列， 优先级最小的元素先出队列    三个队列类的属性和方法提供的属性和方法：        Queue.qsize(): 返回队列的实际大小，即该队列中包含的元素个数        Queue.empty(): 判断是否为空        Queue.full() : 判断队列是否已满        Queue.put(item,block=True,timeout=None): 向队列中放入元素，如已满，且block参数为True阻塞，timeout指定阻塞时间，如timeout为None，则代表一直阻塞，        Queue.put_nowait(item): 向队列中放入元素，不阻塞。        Queue.get(item,block=True,timeout=None):从队列中取出元素，如队列已满，则block参数为True阻塞。        Queue.get_nowait(item): 从队列中取出元素，不阻塞    普通的Queue的功能和用法：        import queue        bq = queue.Queue(3)        bq.put(&apos;Python&apos;)        bq.put(&apos;PHP&apos;)        print(&apos;123213&apos;)        bq.put(&apos;Queue&apos;)        print(&apos;2222&apos;)    利用Queue实现线程通信        import threading        import time         import queue        def product(qu):            str_tuple = (&apos;python&apos;,&apos;golang&apos;,&apos;php &apos;)            for i in range(9999):                print(threading.current_thread().name + &quot; Product Env&quot;)                time.sleep(0.2)                qu.put(str_tuple[i % 3])                print(threading.current_thread().name + &apos;product ok&apos;)        def consume(qu):            while True:                print(threading.current_thread().name + &apos;take money&apos; )                time.sleep(0.2)                t = qu.get()                print(threading.current_thread().name + &apos;take ok %s &apos;% t)        qu = queue.Queue(maxsize = 1)        threading.Thread(target=product,args=(qu,)).start()        threading.Thread(target=product,args=(qu,)).start()        threading.Thread(target=product,args=(qu,)).start()        threading.Thread(target=consume,args=(qu,)).start()Event 实现线程通信    间的线程通信机制，一个线程发出一个Evnet，另一个线程可通信该Evnet 被触发    Event 是一个内部旗标，可通过Event 的set方法将旗标设置为True，可调用clear方法将旗标设置为False，可调用wait 方法来阻塞当前进程。    Event方法：        1. is_set(): 返回Event 的内部旗标是否为True        2. set() : 把Event的内部旗标设置为True，并唤醒所有处于等待状态的进程        3. clear() : 将Event的内部旗标设置为False，调用wait方法阻塞当前进程        4. wait(timeout=None): 阻塞当前进程            import threading            import time            event = threading.Event()            def cal(name):                print(&apos;%s start &apos; % threading.currentThread().getName())                print(&apos;%s status&apos; % name)                event.wait()                print(&apos;%s get message&apos; % threading.currentThread().getName())                print(&apos;%s is status&apos; % name)            threading.Thread(target=cal,args=(&apos;Ai&apos;,)).start()            threading.Thread(target=cal,args=(&apos;Bi&apos;,)).start()            time.sleep(3)            print(&apos;=====&apos;)            print(&apos;master thread event&apos;)            event.set()            [More](http://c.biancheng.net/view/2626.html)线程池及其原理和使用    当启动新线程的时，使用线程池可提升性能 。线程池在系统启动时即创建大量空闲的线程。    线程池的使用：        基类是concurrent.futures模块中的Executor。提供两个子类，即 ThreadPoolExecutor 和 ProcessPoolExecutor。 ThreadPollExecutor 用于创建线程池，ProcessPoolExecutor创建进程池        Executor提供的常用方法：            submit(fn,args,**kwargs): 将fn函数提交给线程池， *args 代表传给fn函数的参数，*kwargs 代表以关键字参数的形式给fn函数传入参数            map(func,*iterables,timeout=None,chunksize=1):类全局函数            map(func,*iterables)，该函数加你个启动多个线程，以异步方式立即对iterables执行map处理            shotdown(wait=True): 关闭线程池        submit方法返回Future对象，Future 提供的方法            cancel()：取消该Future代表的线程任务，如任务正在执行，不可取消，返回False            cancelled ：返回线程任务是否被成功取消            running ： 如正在执行，不可取消，返回False            done ；如任务被成功取消，返回True            result(timeout=None) : 获取线程返回的结果，如任务还未完成，该方法会阻塞当前线程，timeout指定组赛的秒数            exception(timeout=None):任务引发的异常，如任务成功完成，没异常，则返回None            add_done_callback(fn):为该Future 的线程注册一个 回调函数，任务完成，自动出发fn函数。    使用线程池执行线程任务的步骤：            1. 调用ThreadPoolExecutor 类的构造器创建一个线程池            2. 定义一个普通函数作为线程任务            3. 调用ThreadPoolExecutor对象的submi方法来提交线程任务            4. 调用ThreadPoolExecutor对象的shutdown方法来关闭线程池                from concurrent.futures import ThreadPoolExecutor                import threading                import time                def action(max):                    sum = 0                    for i in range(max):                        print(threading.current_therad().name() + &apos; &apos; + str(i))                        sum += i                    return sum                pool = ThreadPoolExecutor(max_workers=2)                future1 = pool.submit(action,50)                future2 = pool.submit(action,100)                print(future1.done())                time.sleep(3)                print(future2.done())                print(future1.result())                pool.shutdown()    获取执行结果        1.调用result方法获取线程任务的返回值。        2.通过Future的add_done_callback()方法添加回调函数          线程池实现了上下文管理协议Context Manage Protocol，程序可用with语句来管理线程池，避免手动关闭线程池          map方法会为iterables的每个元素启动一个线程，以并发方式执行func函数，相当于启动len(iterables)个线程，并收集每个线程的执行结果。    threading local函数：返回线程局部变量            threding 提供local函数，可返回一个线程局部变量，使用线程局部变量可很简捷隔离多线程访问的竞争资源。            线程局部变量Thread local Variable，为每个使用该变量的线程提供一个变量的副本，    线程局部变量的作用：        import threading        from concurrent.futures import ThreadPoolExecutor        data = threading.local()        def action(max):            for i in range(max):                try:                    data.x += i                except:                    data.x = i                print(&quot; data %d&quot; % (threading.current_thread().name,data.x))         with ThreadPoolExecutor(max_workers=2) as pool:            pool.submit(action,10)            pool.submit(action,10)Timer 定时器：控制函数在特定时间执行    Thread类的子类Timer，可用于控制指定函数在特定时间内执行一次，        from threading import Timer        def hi():            print(&apos;hi&apos;)        t = Timer(10.0, hi)        t.start()    取消Timer的调度 cancel 函数schedule 任务调度及用法    如需执行更复杂的任务调度，使用sched模块，提供了 sched.scheduler类，该类代表一个任务调度器    sched.scheduler(timefunc=time.monotonic,delayfunc=time.sleep) 构造器支持两个参数：        1. timefunc : 指定生成时间戳的时间函数，默认使用time.monotonic 生成时间戳        2. delayfunc; 指定阻塞程序的函数，默认使用 time.sleep 函数阻塞程序        [More](http://c.biancheng.net/view/2630.html)    sched.scheduler 调度器常用属性和方法：        scheduler.enterabs(time,priority,action,argument=(),kwargs={}): 指定time时间点执行action函数，argument 和 kwargs 用于向 action函数传入参数，arg...使用位置的形式传入参数。 kwargs 使用关键字传入参数    scheduler.enter(delay,priority,action, argument=(),kwargs={}): delay 指定多少秒后执行action任务。作用同上    scheduler.cancel(event): 取消任务    scheduler.empty(): 判断调度器队列是否为空    scheduler.run(blocking=True): 运行所有需要调度的任务    scheduler.queue： 只读属性返回该调度器的调度队列        import sched,time        improt threading        s = sched.scheduler()        def print_time(name=&apos;default&apos;):            print(&apos; %$ de time %s&apos; % (name,time.ctime()))        print(&apos;master threading time&apos;, time.ctime())        s.enter(10,1,print_time)        s.enter(3,2,print_time,argument=(&apos;wei zhi hanshu &apos;))        s.enter(5,2,print_time,kwargs=[&apos;name&apos;:&apos;guanjianzi hanshu &apos;])        s.run()        print(&apos;master &apos;, time.ctime())os.fork方法：创建新进程    多进程实现并发编程    fork 方法作用： 程序会启动两个进程(一个主进程，一个fork出来的子进程)来执行从os.fork() 开始的所有代码        fork方法不需要函数,有返回值表明哪个进程在执行:            1. 如果fork返回0， 表明fork出来的子进程在执行            2. 如fork返回非0， 表明父进程在执行，返回fork出来的子进程的进程ID                import os                print(&apos;master %s &apos; % os.getpid())                pid = os.fork()                print(&apos;worker in %s &apos; % os.getpid())                if pid == 0:                    print(&apos;origin id  %s  master  id %s&apos; % (os.getpid(),os.getppid()))                else:                    print(&apos;me %s makr son id %s&apos; % (os.getpid(),pid))                print(&apos;thread over %s &apos; % os.getpid())Process 创建进程的2种方法    1. 指定函数作为target ，创建Process对象即可创建新进程    2. 继承Process 类，重写run方法来创建进程类，创建process子类的实例作为进程    Process 类的属性和方法：        1. run() : 实现进程的执行体        2. start ： 启动进程        3. join([timeout]) ： 类线程的join方法        4. name ： 设置和访问进程的名字        5. is_alive ：判断进程是否活着        6. daemon ： 判断是否设置进程的后台状态        7. pid ： 返回进程的ID        8. authkey ：返回进程的授权key        9. terminate ： 中断该进程    以指定函数作为target 创建新进程            import multiprocessing            import os            def action(max):                for i in range(max):                    print(&apos;%s subprocess paterprocess %s  id %d &apos; % (os.getpid(),os.getppid(), i))            if __name__ == &apos;__main__&apos;:                for i in range(100):                    print(&apos;parent %s id %d&apos; % (os.getpid(), i))                    if i == 20:                        mp1 = multiprocessing.Process(target=action,args=(100,))                        mp1.start()                        mp2 = multiprocessing.Process(target=action,args=(100,))                        mp2.start()                        mp2.join()                print(&apos;master process is ok&apos;)    继承Process 类 创建子进程        步骤：            1. 定义继承Process 的子类，重写run方法准备作为进程执行提            2. 创建Process 子类的实例            3. 调用 Process 子类的实例的start方法来启动进程                import multiprocessing                import os                class MyProcess(multiprocessing.Process):                    def __init__(self,max):                        self.max = max                        super().__init__()                    def run(self):                        for i in range(self.max):                            print(&apos;%s subprocess %s parent process %d &apos; % (os.getpid(),os.getppid(),i))                if __name__ == &apos;__main__&apos;:                   for i in range(100):                        print(&apos;%s master process %d &apos; % (os.getpid(),i))                        if i == 20:                            mp1 = MyProcess(100)                            mp1.start()                            mp2 = MyProcess(100)                            mp2.start()                            mp2.join()                    print(&apos;master process is ok!&apos;)设置进程启动的3种方式    1. spawn ：父进程启动解释器进程，子进程继承run方法所需的资源。不必要的文件描述和handler都不被继承，效率比fork或forkserver方式要低得多。 Windows 只支持spawn方式    2. fork： 通过os.fork 启动解释器， 子进程继承父进程所有资源，子进程等效于父进程    3. forkserver ： 启动一个服务器进程，当再次启动新进程，父进程会连接到该服务器进程。请求由服务器进程来fork新进程    multiprocessing 模块提供set_start_method 函数，用于设置启动进程的方式，必须将这行设置代码放在所有与多进程相关代码之前。     if __name__ == &apos;__main__&apos;:        multiprocessing.set_start_method(&apos;spawn&apos;)        q = multiprocessing.Queue()        mp = multiprocessing.Process(target=foo,args=(q,))        mp.start()        print(q.get())        mp.join()多进程和多线程优缺点    都使用并行机制提升系统运行效率，区别在于运行时所占内存分布不同，多线程共用一套内存的代码块区间，而多进程是各用一套独立的内存区间    多进程有点在于 稳定性好，一个子进程奔溃，不影响主进程和其余进程，此特性多用多进程来实现守护服务器的功能    多进程创建进程的代价非常大，操作系统会给每个进程分配固定的资源，会对进程的总数有一点的限制。    多线程效率高 ，用于批处理任务等功能。 不足：一个线程奔溃整个进程奔溃。    场景： 计算密集型的任务，多线程效率更高。 IO密集型的任务，如文件操作，网络爬虫，采用多线程    IO密集型操作，消耗时间是等待时间，Python会释放GIL供新的线程使用，实现线程间的切换。    将多进程程序分布运行在不同的计算机上协同工作，每一进程内部，由多个线程并行工作    最佳线程数量 = ()(线程等待时间+线程CPU时间) / 线程CPU时间) * CPU数量使用进程池管理进程    如需启动多个进程，可使用进程池管理进程，程序可通过multiprocess模块的pool函数创建进程池： multiprocessing.pool.Pool类    进程池常用方法：        1. apply(func[,args[,kwds]]) : 将func函数提交给进程池处理，args 传给func的位置参数， kwds代表传给func的关键字参数，会被阻塞直到func函数执行完成        2. apply_async(func[,args[,kwds[,callback[,error_callback]]]]): 异步，不被阻塞。callback指定func函数完成后的回调函数，error_callback 指定fun指定回调函数        3. map(func,iterable[,chunksize]) : 类python的map全局函数，使用新进程对iterable的每个元素执行func函数        4. imap(func,iterable[,chunksize]): map方法的延迟版本        5. imap_unordered(func,iterable[,chunksize]):类imap，不保证元素顺序一致        6. starmap(func,iterable[,chunksize]): 类map方法，要求iterable的元素是iterable对象，        7. close ： 关闭进程池，不再接收新任务，把进程池中的所有任务执行完后再关闭自己        8. terminate ： 立即中止进程池        9. join ： 等待所有进程完成        import multiprocessing        import time        import os        def action(name=&apos;default&apos;):            print(&apos;%s process param %s &apos; % (os.getpid(),name))            time.sleep(3)        if __name__ == &apos;__main__&apos;:            pool = multiprocessing.Pool(processes=4)            pool.apply_async(action)            pool.apply_async(actino,args=(&apos;location parame:&apos;,))            pool.apply_async(action,kwds={&apos;name&apos;:&apos;kwords params&apos;})            pool.join()        线程池同样实现上下文管理协议，可使用with子句来管理进程池，避免程序主动关闭进程池            import multiprocessing            import time            import os            def action(max):                sum = 0                for i in range(max):                    print(&apos;%s %d &apos; % (os.getpid(),i))                    sum += i                return sum            if __name__ == &apos;__main__&apos;:                with multiprocessing.Pool(processes=4) as pool:                    results = pool.map(action,(50,100,200))                    print(&apos;---&apos;)                    for r in results:                        print(r)进程间通信的2种实现方法 Queue Pipe    进程通信提供的2种机制：        1. Queue ： 一个进程向Queue中放入数据，另一个进程从Queue中读取数据        2. Pipe ： Pipe代表连接两个进程的管道，程序可调用Pipe函数时会产生两个连接段，分别交给两个进程，进程可从连接端读取数据，也可向该连接端写入数据    使用Queeu实现进程间通信        multiprocessing 模块下的Queue和queue 模块下的Queue类似，都提供qsize 、empyt、full、put、put_nowwait、get、get_nowait 等方法，区别： multiprecessing 模块下的Queue为进程提供服务， 而queue模块下的Queue为线程提供服务        import multiprecessing        def f(q):            print(&apos;%s &apos; % multiprocessing.current_process().pid)            q.quit(&apos;Python&apos;)        if __name__ == &apos;__main__&apos;:            q = multiprocessing.Queue()            p = multiprocessing.Process(target=f,args=(q,))            p.start()            print(&apos;%s &apos; % multiprocessing.current_process().pid)            print(q.get())            p.join使用Pipe实现进程间通信    程序调用 multiprocessing.Pipe() 创建一个管道，返回两个PipeConnection对象，代表管道的两个连接端，一个管道有两个连接端，分别用于连接通信的两个进程    PipeConnection对象包含的常用方法：        1. send(obj) : 发送一个obj给管道的另一端，另一端使用 recv方法接收， 该obj需是可picklable的python序列化机制，如该对象序列化超过32MB，可引发ValueError异常        2. recv ：接收另一端通过send方法发送过来的数据        3. fileno：关于连接所使用的问价描述器        4. close ： 关闭连接        5. poll([timeout]):返回连接中是否有数据可读取        6. send_types(buffer[,offset[,size]]: 发送字节数据，使用recv_bytes 或 recv_bytes_into 方法接收        7. recv_bytes([maxlength])):通过send_bytes方法发送的数据，maxlength指定最多接收的字节数，返回接收到的字节数据        8. recv_bytes_into(buffer[,offset]): 类recv_bytes方法，将接收到的数据放在buffer中            import multiprocessing            def f(conn):                print(&apos;%s &apos; % multiprocessing.current_process().pid)                conn.send(&apos;Python&apos;)            if __name__ == &apos;__main__&apos;:                parent_conn,child_conn = multiprocessing.Pipe()                p = multiprocessing.Process(target=f, args=(child_conn,))                p.start()                print(&apos;%s get data&apos; % multiprocessing.current_process().pid)                print(parent_conn.recv())                p.join()</code></pre><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><pre><code>计算机网路的功能：    1. 资源共享    2. 信息传输与集中处理    3. 均衡负荷与分布处理    4. 总和信息服务常见的类型有： 局域网LAN、城域网MAN、广域网WAN。通信协议：负责对传输速率、传输代码、代码结构、传输控制步骤、出错控制等指定处理标准。    通信协议由三部分组成：        1. 语义： 决定双方对话的类型        2. 语法： 决定双方对话的格式        3. 交换： 决定通信双方的应答关系        OSI ： Open System Interconnection ：将网络简化，以模块化的方式来设计网络        OSI七层： 物理层、链路层、网络层、传输层、会话层、表示层、应用层。    通信协议：是网络通信的基础，IP：Internet Protocol 称为 网际协议，支持网间互联的数据报协议，提供来网间连接的完善功能。TCP：Transmission Control Protocol，传输控制协议，规定一种可靠的数据信息传送服务，可单独使用，功能是互补的，两个协议统称为 TCP/IP 协议IP地址和端口号    IP地址用于唯一标识网络中的一个通信实体。 IP地址是数字型，是一额32位整数    NIC：Internet Network Information Center ： 统一负责全球IP地址的规划和管理，分为 InterNIC、APNIC、RIPE 三个网络信息中心负责IP地址分配。亚太地区通过APNIC，总部设在日本东京大学    IP地址分为 A、B、C、D、E五类。每个类别的网络标识和主机标识各有规则：        1. A 类： 10.0.0.0 ～ 10.255.255.255        2. B 类： 172.16.0.0 ～ 172.31.255.255        3. C 类： 192.168.0.0 ～ 192.168.255.255        IP地址是一个通信实体，每个通信实体可有多个通信程序同时提供网络服务，还需提供使用端口        端口：是一个16位整数，用于将数据交给哪个通信程序处理。端口是应用程序与外界交流的出入口，是一种抽象的软件结构，包括数据结构和 I/O 缓冲区        端口分为三类：            1. 公认端口(Well Known Port): 端口号为 0～1023，绑定特定的服务            2. 注册端口(Registered Port): 端口号为 1024～49151            3. 动态和/或私有端口(Dynamic and / or Private Port): 端口号为 49152～65535，是应用程序使用的动态端口网络编程模块    网络模型大致分为四层，各有对应的网络协议提供支持        1. 网络接口层： LAN、MAN、WAN        2. 网络层： ICMP、IGMP、IP、ARP、RARP        3. 传输层： TCP、UDP        4. 应用层： SMTP、FTP、DNS、SNMP、NFS、HTTP、TELNET    网络层协议主要是IP，是互联网协议的基础，ICMP、IGMP、ARP、RARP等协议是IP协议族的子协议，很少直接基于网络层进行应用程序编程    Python标准库中的网络相关模块        socket ： 基于传输层TCP、UDP协议进行网络编程的模块        asyncore ： socket 模块的异步版，支持基于传输层协议的异步通信        asynchat ： asyncore 的增强版        cgi ： 基于CGI：Common Gateway Interface，早期动态网站的技术支持        email ： E-mail 和MIME消息处理模块        ftplib ： 支持FTP协议的客户端模块        httplib、http.client ： 支持HTTP协议以及HTTP客户端的模块        imaplib ： 支持IMAP4协议的客户端模块        mailbox ： 操作不同格式邮箱的模块        mailcap ： 支持Mailcap文件        nntplib ： NTTP协议        smtplib ： SMTP 协议，发送邮件的客户端模块        poplib ： 支持POP3协议        telnetlib ： 支持TELNET 协议        urllib及其子模块： 支持URL处理的模块        xmlrpc、xmlrpc.server、xmlrpc.client ：支持XML-RPC协议的服务和客户端模块urllib.parset 模块：    URL：Uniform Resource Locator 对象代表统一资源定位器，指向互联网资源的指针。资源可以是文件、目录、或复杂对象的引用。 URL可由协议名、主机、端口和资源路径组成        protocol://host:port/path        1. urllib.request:最核心的子模块，包含打开和读取URL的各种函数        2. urllib.error ： 包含urllib.request 子模块所引发的各种异常        3. urllib.parset ： 解析URL        4. urllib.robotparset ： 解析robots.txt 文件        通过使用urllib模块可打开任意URl所指向的资源，可完整下载远程页面，与re模块结合使用，可提取页面中的各种信息，即网络爬虫的初步原理            urllib.parse 子模块中用于解析URL地址和查询字符串的函数：                1. urllib.parse.urlparset(urlstring,scheme=&quot;,allow_fragments=True&quot;):解析URL字符串，返回ParseResult 对象，获取解析出的数据                2. urllib.parse.urlunparse(parts): 是上一函数的反向操作，解析结果反向拼接URL地址                3. urllib,parse.parse_qs(qs,keep_blank_values=False,strict_parsing=False,encoding=&apos;utf-8&apos;,errors=&apos;replace&apos;):解析查询字符串(application/x-www-forn--=urlencoded 类型的数据)，以dict形式返回解析结果                                                                                                        4. urllib.parse.urlencode(query,deseq=False,safe=&apos;&apos;,encoding=None,errors=None,quote_via=quote_plus): 将字典形式或列表形式的请求参数恢复成请求字符串。相当与parse_qs、parse_qsl 的逆函数                                                                                                                                                                                                5. urllin.parse.urljoin(base,url,allow_fragments=True): 将一个base_url和另一个资源URL连接成代表绝对地址的URl                from urllib.parse import *                result = urlparse(&apos;https://www.baidu.com&apos;)                print(result)                print(&apos;scheme:&apos;, result.scheme,result[0])                print(&apos;hostname and port:&apos;, result.netloc,result[1])                ...                print(result.geturl())        ParseResult 各属性与元组索引的对应关系                scheme        0        返回URL的scheme                scheme参数                netloc        1        网络位置部分主机名和端口    空字符串                path        2        资源路径                    空字符串                params        3        资源路径的附加参数                    query        4        查询字符串                fragment    5        Fragment标识符                username            用户名                        None                password            密码                hostname            主机名                port                端口                        None        urlunparse ： 把一个 ParseResult 对象或元组恢复成URL字符串        result = urlunparse((&apos;http&apos;,&apos;www.baidu.com:80&apos;,&apos;index.php&apos;,&apos;text&apos;,&apos;name=hale&apos;,frag))        print(result)            parse_qs() parse_qsl() ： l代表list，用于解析查询字符串，返回值不同，        urljoin 负责将两个URL拼接在一起，返回代表绝对值的URL，可出现三种情况：            1. URL只是一个相对路径path            2. 被拼接的URl是一个根路径path            3. URL是一个绝对的pathurllib.requset 模块读取资源用法    urllib.request.urlopen(url,data=None)：用于打开url指定的资源，并从中读取数据，根据url的不同，返回值发生变化，如url是一个HTTP地址，该方法返回一个http.client.HTTPResponse对象    from urllib.request import *    // 打开URL对应的资源    result = urlopen(&apos;http://www.baidu.com/index.php&apos;)    // 按字节读取数据    data = result.read(333)    // 将字节数据恢复成字符串    print(data.decode(&apos;utf-8&apos;))    // 用context manager 管理打开的URL资源    with urlopen(&apos;http://www.baidu.com/index.php&apos;) as f:        // 按字节读取数据        data = f.read(333)        // 将字节数据恢复成字符串        print(data.decode(&apos;utf-8&apos;))    使用urlopen函数时，可通过data属性向被请求的URL发送数据：        from urllib.request import *         with urlopen(url=&apos;https://www.baidu.com/index.php&apos;,data=&apos;test&apos;.encode(&apos;utf-8&apos;)) as f:            print(f.read().decode(&apos;utf-8&apos;))    通过urlopen 函数发送POST请求参数，可通过data 属性来实现：        import urllib.parse        params = urllib.parse.urlencode({&apos;name&apos;:&apos;hale&apos;,&apos;password&apos;:&apos;password&apos;})        params = params.encode(&apos;utf-8&apos;)        with urlopen(&apos;https://www.baidu.com/index.php&apos;,data=params) as f:            print(f.read().decode(&apos;utf-8&apos;))    urllib.request.Request对象的构造函器：        urllib.request.Request(url,data=None,headers={},origin_req_host=None,unverifiable=False,method=None)            Request 可通过method指定请求方法，也可通过data指定请求方法，可通过 headers 指定请求头            from urllib.request import *            params = &apos;put request&apos;.encode(&apos;utf-8&apos;)            req = Request(url=&apos;https://www.baidu.com/index.php&apos;,data=params,method=&apos;PUT&apos;)             with urlopen(req) as f:                print(f.status)                print(f.read().decode(&apos;utf-8&apos;))    使用Request对象添加请求头        // 创建Request对象        req = Request(&apos;https://www.baidu.com/index.php&apos;)        // 添加请求头        req.add_header(&apos;Referer&apos;,&apos;https://www.baidu.com&apos;)        with urlopen(req) as f:            print(f.status)            print(f.read().decode(&apos;utf-8&apos;))        通过Request 的add_header 方法添加一个Referer 请求头，    实现多线程下载的步骤：        from urllib.request import *         import threading        class DownUtil:                def __init__(self,path,target_file,thread_num):                    self.path = path                    self.thread_num = thread_rum                     self.threads = []                def download(self):                    req = Request(url=self.path,method=&apos;GET&apos;)                    ...        1. 使用 urlopen 方法打开远程资源        2. 获取指定的URL对象所指向资源的大小，通过Content-Length响应头获取        3. 计算每个线程应该下载网络资源的哪个部分，从哪个节点开始，到哪个字节结束        4. 依次创建并启动多个线程            from DownUtil import *             du = DownUtil(&apos;https://www.baidu.com/&apos; + &apos;from/logo.png&apos;,&apos;a.png&apos;,3)            du.download()            def show_process():                print(&apos;ok : %.2f&apos; % du.get_complete_rate())                global t                if du.get_complete_rate() &lt; 1:                    t = threading.Timer(0.1,show_process)            t = threading.Timer(0.1,show_process)            t.start()http.cookiejar模块：管理cookie    如使用urllib.request 模块来访问被保护页面，维修与服务器之间的sesion，借助于 cookie 管理器    使用OpenerDirector 对象来发送请求，步骤：        1. 创建 http.cookiejar.CookieJar 对象或其子类的对象        2. 以CookieJar对象为参数，创建urllib.rquest.HTTPCookieProcessor对象，该对象负责调用CookieJar来管理cookie        3. 以HTTPCookieProcessor对象为参数，调用urllib.reques.build_opener()函数创建OpenerDirector对象        4. 使用OpenerDirector对象来发送请求，通过HTTPCookieProcessor调用CookieJar管理cookie            from urllib.request import *            import http.cookiejar, urllib.parse            cookie_jar = http.cookiejar.MozillaCookieJar(&apos;a.txt&apos;)            cookie_processor = HTTPCookieProcessor(cookie_jar)            opener = build_opener(cookie_processor)            user_agent = r&apos;Mozialla ...&apos;            header = {&apos;User-Agent&apos;:user_agent,&apos;Connection&apos;:&apos;keep-alive&apos;}        [More](http://c.biancheng.net/view/2646.html)TCP协议、IP协议的关系    TCP/IP通信协议是可靠的网络协议，在通信的两端各建立一个socket，形成虚拟的网络链路，建立虚拟的网络链路，两端的程序可通过该链路进行通信。 使用socket对象来代表两端的通信端口并通过socket进行网络通信    IP是Internet 的关键协议，全称：Internet Protocol，即Internet协议，简称：IP协议。IP协议负责将消息从一个主机传送到另一个主机，信息被分割成一个个小包    TCP：端对端协议，TCP协议让他们之间建立一个虚拟链路，用于发送和接收数据    TCP协议负责收集数据包，并按照顺序传送，接收端接收到数据包后再将其正确地还原。TCP协议保证数据包传送无误，采用重发机制，即当一个通信实体发送一个消息给另一个通信实体后，需要接收到的另一个通信实体的确认信息，如没有收到确认信息，则会重发信息    只有把TCP和IP两个协议结合，才能保证Internet在复杂的环境下正常运行。</code></pre><h3 id="socket-建立TCP连接"><a href="#socket-建立TCP连接" class="headerlink" title="socket 建立TCP连接"></a>socket 建立TCP连接</h3><pre><code>在使用socket之前，须建立socket对象，通过该类的构造器来创建socket实例：    socket.socket(family=AF_INET,type=SOCK_STREAM, proto=0,fileno=None)        1.family 参数用于指定网络类型，socket.AF_UNIX：UNIX网络、socket.AF_INET 基于IPv4协议的网络 和socket.AF_INET6 基于IPv6协议的网络 这三个变量        2. type参数用于指定网络的Sock类型，支持SOCK_STREAM默认值，创建基于TCP协议的socket、SOCK_DGRAM 创建基于UDP协议的socket 和SOCK_RAW 创建原始socket。常用 SOCK_STREAM和SOCK_DGRAM        3. proto参数用于指定协议号， 默认0，可忽略        socket 对象提供的常用方法：            1. socket.accept： 作为服务端使用的socket调用该方法接收来自客户端的连接            2. socket.bind(address)：将该socket绑定到指定address，address可是一个元组，包含IP地址和端口            3. socket.close ： 关闭连接，回收资源            4. socket.connect(address): 连接远程服务器            5. socket.connect_ex(address): 当程序出错时，不抛出异常，返回错误标识符            6. socket.listen([backlog]): 服务器使用socket调用该方法进行监听            7. socket.makefile(mode=&apos;r&apos;,buffering=None,*,encoding=None,errors=None,newline=None): 创建和该socket关联的文件对象            8. socket.recv(bufsize[,flags]): 返回值是(bytes,address)元组            9. socket.recvmsg(bufsize[,ancbufsize[,flags]]): 不仅接收来自socket的数据，还接收来自socket的辅助数据，返回值是一个长度为4的元组(data.ancdata,msg_flags,address).            10. socket.recvmg_into(butters[,nbytes[,flags]]):类socket.recvmsg ，将接收的数据放入buffers中            11. socket.recvfrom_into(buffer[,nbytes[,flags]]):将接收到的数据放入buffer中            12. socket.recv_into([buffer[,nbytes[,flags]]]): 类recv方法，将接收到的数据放入buffer中            13. socket.send(bytes[,flags]): 向socket发送数据，该socket必须与远程socket建立连接，基于TCP协议的网络中发送数据            14. socket.sendto(bytes,addresss)：向socket发送数据，没有与远程socket连接，基于UDP协议发送数据            15. socket.sendfile(file,offset=0,count=None):将整个文件内容发送出去，直到遇到EOF            16. socket.shutdown(how):关闭连接，how用于设置关闭方法    TCP通信的服务器端编程的基本步骤：        1. 服务器端先创建一个socket对象        2. 服务器端socket将自己绑定到指定IP地址和端口        3. 服务器端socket调用listen 方法监听网络        4. 程序采用循环不断调用socket 的accept方法接收来自客户端的连接            // 创建socket对象            s = socket.socket()            // 将socket 绑定到本机IP地址和端口            s.bind(&apos;192.168.0.123&apos;,8888)            // 服务器开始监听客户端的连接            s.listen()            while True:                c,addr = s.accept()    客户端先创建一个socket对象，将该socket绑定到指定的ip地址和端口号，然后调用connect方法建立与服务器的连接，就可建立一个基于TCP协议的网络连接        TCP通信的客户端的基本步骤如下：            1. 客户端先创建一个socket对象            2. 客户端socket调用connect方法连接到远程服务器    socket提供大量方法发送和接收数据：        1. 发送数据：使用send方法，注意：sendto方法用于UDP协议的通信        2. 接收数据：使用recv_xxx方法            import socket            s = socket.socket()            s.bind((&apos;192.168.1.88&apos;,999))            s.listen()            while True:                c, addr = s.accept()                print(c)                print(&apos;connect addrss&apos;, addr)                c.send(&apos;himessge &apos;.encode(&apos;utf-8&apos;))                c.close()    从socket中获取服务器发送的数据        import socket        s = socket.socket()        s.connect((&apos;192.168.1.88&apos;,999))        print(&apos;--%s--&apos;s.recv(1024).decode(&apos;utf-8&apos;))        s.close()多线程实现socket通信    由于socket的recv方法在成功读取到数据之前。线程会被阻塞，因此，服务器为每个socket单独启动一个线程，每个线程负责与一个客户端进行通信    服务器端使用list来保存所有的socket    import socket    import threading    socket_list = []    ss = scoket.socket()    ss.bind((&apos;192.168.1.14&apos;,999))    ss.listen()    def read_from_client(s):        try:            return s.recv(2048).decode(&apos;utf-8&apos;)        except:            socket_list.remove(s):    def server_target(s):        try:            while True:                content = read_from_client(s)                print(content)                if content is None:                        break                for client_s in socket_list:                    client_s.send(content.encode(&apos;utf-8&apos;))        except e:            print(e.strerror)    while True:        s,addr = ss.accept()        socket_list.append(s)        threading.Thread(target=server_target,args=(s,)).start()socket shutdown 方法    以bytes对象作为通信的最小数据单位，服务器端在处理信息时是针对每个bytes进行的，一些协议中，通信数据单位可需多个bytes对象    shutdown(how)方法，可只关闭socket的输入或输出部分，用以表示数据已经发送完成    shutdown方法的how参数的参数值：        SHUT_RD： 关闭socket的输入部分，可通过socket输出数据        SHUT_WR： 关闭socket的输出部分，通过该socket读取数据        SHUT_RDWR： 全关闭，该socket既不能读取数据，也不能写入数据        服务器端先向客户端发送数据发送多条数据，当数据发送完成后，该socket对象调用shutdown方法来关闭输出部分        import socket        s = socket.socket()        s.bind((&apos;192.168.1.88&apos;,999))        s.listen()        skt,addr = s.accept()        skt.send(&apos;server first data&apos;.encode(&apos;utf-8&apos;))        skt.send(&apos;server second data&apos;.encode(&apos;utf-8&apos;))        skt.shutdown(socket.SHUT_WR)        while True:            line = skt.recv(2048).decode(&apos;utf-8&apos;)            if line is None or line == &apos;&apos;:                break            print(line)        skt.close()        s.close()selectors 模块：实现非阻塞式编程    selectors 允许以非阻塞方式进行通信，selector相当于一个事件注册中心，只要将socket的所有事件注册给selectors管理，当检测到socket中的特定事件后，程序调用相应的监听方法进行处理    selectors主要支持两种事件：        1. selectros.EVENT_READ: 当socket有数据可读时触发该事件，有客户端连接时也触发        2. selectors.EVENT_WRITE： 当socket将要写数据时触发该事件    selectors实现非阻塞式编程的步骤如下：        1. 创建selectors对象        2. 通过selectors对象为socket的selectors.EVENT_READ或selectors.EVENT_WRITE事件注册监听器函数，当socket有数据读写时，系统负责触发所注册的监听器函数        3. 在监听器函数中处理socket通信    使用seletros实现非阻塞通信的服务器端：        import seletors, socket        sel = seletors.DefaultSelector()        def read(skt,mask):            try:                data = skt.recv(1024)                if data:                    for s in socket_list:                        s.send(data)                else:                    print(&apos;close &apos;,skt)                    sel.unregisters(skt)                    skt.close()                    socket_list.remove(skt)            except:                print(&apos;close&apos;)                sel.unregister(skt)                skt.close()                socket_list.remove(skt)        socket_list = []        def accept(sock, mask):            conn,addr = sock.accept()            socket_list.append(conn)            conn.setblocking(False)            sel.register(conn,selectors.EVENT_READ,read)        sock = socket.socket()        sock.bind((&apos;192.168.1.1&apos;,999))        sock.listen()        sock.setblocking(Flase)UDP协议及优缺点    UDP：User Datagram Protocol：用户数据报协议    UDP 面向非连接的协议，是在正式通信前不必与对象先建立连接，不管对方状态，直接发送数据， UDP协议无法控制，是一种不可靠的协议    UDP协议适用于一次只传送少量数据、对可靠性要求不高的应用环境    作用：完成网络数据流和数据报之间的转换在信息的发送端，UDP协议将网络数据流封装为数据报，然后将数据发送出去，在信息的接收端，UDP协议将数据报转换为实际数据内容    UDP协议和TCP协议的简单对比：        1. TCP协议：可靠，传输大小无限制，需要建立连接，差错控制开销大        2. UDP协议：不可靠，差错控制开销小，传输大小限制在64Kb以下，不需要建立连接。socket发送和接收数据：基于UDP协议    创建socket，通过type参数指定socket的类型，将参数指定为 SOCK_DGRAM，即创建基于UDP协议的socket    通过两个方法发送和接收数据        1. socket.sendto(bytes,address): 将bytes数据发送到address地址        2. socket.recvfrom(bufsize[,flags]):接收数据，返回socket中的数据和数来源地址            import socket            PORT = 999            DATA_LEN = 4096            books = (&apos;one&apos;,&apos;tow&apos;,&apos;three&apos;)            s = socket.socket(type=socket.SOCK_DGRAM)            s.bind((&apos;192.168.1.1&apos;,PORT))            for i in range(1000):                data ,addr = s.recvfrom(DATA_LEN)                print(data,decode(&apos;utf-8&apos;))                send_data = books[i % 4].encode(&apos;utf-8&apos;)                s.sendto(send_data,addr)            s.close()    来自服务器端的数据，客户端程序代码：            import socket            PORT = 3000            DATA_LEN = 4096            DEST_IP = &apos;192.168.1.1&apos;            s = socket.socket(type=socker.SOCK_DGRAM)            while True:                line = input(&apos;&apos;)                if line is None or line == &apos;exit&apos;:                    break                data = line.encode(&apos;utf-8&apos;)                s.sendto(data,(DEST_IP,PORT))                data = s.recv(DATA_LEN)                print(data.decode(&apos;utf-8&apos;))            s.close()UDP 多点广播原理及实现    多点广播，将数据以广播方式发送到多个客户端    创建socket对象后，将该socket加入指定的多点广播地址中，socket使用setsockopt 方法加入指定组    创建仅发送数据报的socket对象， 使用默认地址、随机端口即可。 如创建接收数据报的socket对象，将对象绑定到指定端口多点广播可设置广播信息的TTL(Time-To-Live)，TTL参数用于设置数据报最多可跨过的网络个数：    1. TTL的值为0：指定数据报应停留在本地主机中    2. 1: 指定将数据报发送到本地局域网中，此值为默认值    3. TTL的值为 32 时： 只能将数据报发送到本站点的网络上    4. 。。64 ： 数据报应被保留在本地区    5. 128 ： 被保留在本大洲    6. 255 ： 数据可被发送到所有地方    socket实现一个基于广播的多人聊天室，只需要一个socket、两个线程，socket用于发送数据、接收数据。主线程负责读取用户的键盘输入内容，并向socekt发送数据，子线程负责从socket中读取数据        import time,socket,threading, os        senderIP  = &apos;192.168.1.99&apos;        senderPORT = 999        myGroup = &apos;230.0.0.1&apos;        s = socket.socekt(type=socket.SOCK_DGRAM)        s.bind ((&apos;0.0.0.0&apos;,senderPORT))        s.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICASE_TTL,64)        s.setsockopt(socket.SOL_SOCKET. socket.SO_REUSEADDR, 1)        status = s.setsockopt(socket.IPPROTO_IP,                socket.IP_ADD_MEMBERSHIP,                socket.inet_aton(mygroup))        ...        [More](http://c.biancheng.net/view/2663.html)smtplib 模块： 发送邮件    底层的处理由smtplib封装，3步发送邮件：        1. 连接STMP服务器，使用用户名、密码登录服务器        2. 创建EmailMessage 对象，该对象代表邮件本身        3. 调用代表与SMTP服务器连接的对象的sendmail方法发送邮件            import smtplib            from email.message import EmailMessage            smtp_server = &apos;smtp.qq.com&apos;            from_addr = &apos;mr_hale@qq.com&apos;            password = &apos;password&apos;            to_addr = &apos;mr_hale@163.com&apos;            conn = smtplib.SMTP_SSL(smtp_server,465)            conn.set_debuglevel(1)            conn.login(from_addr,password)            msg = EmailMessage()            msg.set_content(&apos;hi&apos;,&apos;plain&apos;,&apos;utf-8&apos;)            conn.sendmail(from_addr,[to_add],msg.as_string())            conn.quit()        基于SSL的SMTP服务器的默认端口是465        常见参数：            1. maintype ：指定附件的主类型，如image代表附件图片            2. subtype ： 附件的子类型，如指定为png，代表附件是png图片，子类型受主类型的限制            3. filename ： 指定附件的文件名            4. cid = img ： 指定附件的资源ID，可通过资源ID引用该资源                import smtplib, email.utils                from emial.message import EmailMessage                smtp_server = &apos;smtp.qq.com&apos;                from_arrd = &apos;mr_hale@qq.com&apos;                password = &apos;pass&apos;                to_addr = &apos;mr_hale@163.com&apos;                conn = smtplib.SMTP_SSL(smtp_server,465)                conn.set_debuglevel(1)                conn.login(from_addr,password)                msg = EmailMessage()                first_id ,second_id  = email.util.make_msgid(), email.utils.make_msgid()                msg.set_connect(&apos;&lt;h1&gt;hi&lt;/hi&gt;&apos;)                msg[&apos;subject&apos;] = &apos;subject&apos;                msg[&apos;from&apos;] = &apos;mr_hale@qq.com&apos;                msg[&apos;to&apos;] = &apos;mr_hale@163.com&apos;                with open(&apos;file_Path:/xx.png&apos;,&apos;rb&apos;) as f:                    msg.add_attchment(f.read(),maintype=&apos;image&apos;,                        subtype=&apos;jpeg&apos;,filename=&apos;xxx.png&apos;,cid=first_id)                with open(&apos;path_dir/xx.gif&apos;,&apos;rb&apos;) as f:                    msg.add_attachment(f.read(),maintype=&apos;image&apos;,subtype=&apos;gif&apos;,filename=&apos;xxx.gif&apos;,cid=second_id)                with open(&apos;xxx.pdf&apos;,&apos;rb&apos;) as f:                    msg.add_attachment(f.read(),maintype=&apos;application&apos;,subtype=&apos;pdf&apos;,filename=&apos;xxx.pdf&apos;)                conn.sendmail(from_arrd,[to_addr],msg.as_string())                conn.quit()poplib 模块： 收取邮件    提供poplib.POP3 和poplib.POP3_SSL 两个类，用于连接POP服务器和基于SSL的POP服务器        POP3 协议属于请求，响应式交互协议，当客户端连接服务器后，客户端向POP服务器发送请求，而POP服务器对客户端生成响应数据，客户端可通过响应数据下载得到邮件内容    POP3的命令和数据都基于ASCII文本，以 CR 和 LF(/r/n)作为行结束符，响应数据包括一个表示返回状态的符号(+/)和描述信息    请求和响应的标准格式：        请求标准格式： 命令[参数] CRLF        响应标准格式： +OK /[-ERR] description CRLF    POP3协议客户端的命令和服务器端对象的响应数据：        1. user name ： 向POP服务器发送登录的用户名        2. pass string ： 向POP服务器发送登录的密码        3. quit： 退出POP服务器        4. stat ：统计邮件服务器状态，包括邮件数和总大小        5. list[msg_no] : 列出全部邮件或指定邮件，返回邮件编号和大小        6. retr msg_no : 获取指定邮件的内容，编号从1开始        7. del msg_no ： 删除指定邮件        8. noop ： 空操作，仅用于于服务器保持连接        9. rset ： 用于撤销dele命令    接收邮件的步骤：        1. 使用poplib.POP3 或 poplib.POP3_SSL 按 POP3 协议从服务器下载邮件        2. 使用 email.parser.Parset 或 email.parser.BytesParser解析邮件内容，得到EmailMessage对象，从EmailMessage 对象中读取邮件内容            import poplib,  os.path , mimetypes            from email.parser import BytesParser, Parser            from email.policy import default            emial = &apos;mr_hale@163.com&apos;            password = &apos;password&apos;            pop3_server = &apos;pop.qq.com&apos;            conn = poplib.POP3_SSL(pop3_server, 995)            conn.set_debuglevel(1)            print(conn.getwelcome().decode(&apos;utf-8&apos;))            conn.user(email)            conn.pass_(password)            message_num, total_size = conn.stat()            print(&apos;email num %s total %s&apos; % (message_num,total_size))            resp, mails, octets = conn.list()            print(resp, mails)            resp, data, octets = conn.retr(len(mails))            msg_data = b&apos;\r\n&apos;.join(data)            mg = BytesParser(policy=default).parsebytes(msg_data)            [More](http://c.biancheng.net/view/2667.html)            程序在创建BytesParser 解析字节串格式的邮件数据 或 Parser 解析字符串格式的邮件数据时，必须指定 policy=default， 否则 BytesParser或Parser 解析邮件数据得到的就是过时的Message对象</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Author : Hale Lv</span><br><span class="line">@Created Time : 2019-08-27 20:41:18</span><br><span class="line">@Description :</span><br></pre></td></tr></table></figure><h2 id="pydoc-模块：查看、生成帮助文档"><a href="#pydoc-模块：查看、生成帮助文档" class="headerlink" title="pydoc 模块：查看、生成帮助文档"></a>pydoc 模块：查看、生成帮助文档</h2><pre><code>在控制器中使用help 函数和 __doc__ 属性查看函数、类、方法的文档借助自带的pydoc模块，方便查看、生成帮助文档，是HTML格式创建名为 HI_doc.py 的文件    MY_NAME = &apos;Python DOC&apos;    def say_hi(name):        &apos;&apos;&apos;            定义一个say hi的函数            返回对指定用户打招呼的字符串        &apos;&apos;&apos;        print(&apos;run hi func&apos;)        return name + &apos;welcome !&apos;    def run(load):        &apos;&apos;&apos;            走路ing        &apos;&apos;&apos;        print(&apos;run run func&apos;)        return &apos;run &apos; + load    class User:        NAME = &apos;Hale&apos;        &apos;&apos;&apos;            定义一个用户的类            命名名字为Hale        &apos;&apos;&apos;        def __init__(self,name,age):            &apos;&apos;&apos;                name 为初始化的name值                age 初始化该用户的age            &apos;&apos;&apos;            self.name = name            self.age = age        def eat(food):            &apos;&apos;&apos;                定义用户在吃东西的方法                food 代表正在吃的东西            &apos;&apos;&apos;            print(&apos;%s eat %s&apos; % (self.user, food))        定义了一个HI_doc.py 源文件，即定义了一个HI_doc 模块， 该模块为函数、类、方法都提供文档    pydoc在控制台中查看文档        使用pydoc模块在控制台查看HTML文档            python -m pydoc 模块名                -m ： 选项，表示运行指定模块，运行pydoc模块，模块名参数代表程序要查看的模块                python -m pydoc HI_doc             pydoc 模块中的全部内容：                CLASSES 部分： 列出该模块所包含的全部类                FUINCTIONS ： 列出包含的全部函数                DATA ： 全部成员变量                FILE： 源文件    pydoc 生成HTML文档        python -m pydoc -w 模块名            -m ：代表模块0            -w 选项： 代表 write，表明输出HTML文档    pydoc 为指定目录生成HTML文档，为指定目录下的所有模块生成HTML文档：        python -m pydoc -w 目录名启动本地服务器查看文档信息    启动本地服务器产看文档信息的两个命令        1. python -m pydoc -p 端口号    指定端口启动HTTP服务器，通过浏览器查看Python的所有模块的文档信息：        2. python -m pydoc -b    第一部分：显示python内置的核心模块    第二部分：显示当前目录下的所有模块    第三部分：显示当前目录下的所有模块，pydoc 查找模块    python -m pydoc -k 被搜索的模块的部分内容</code></pre><h3 id="doctest模块：-文档测试"><a href="#doctest模块：-文档测试" class="headerlink" title="doctest模块： 文档测试"></a>doctest模块： 文档测试</h3><pre><code>文档测试工具可以提取说明文档中的测试用例，其中 &quot;&gt;&gt;&gt;&quot; 之后的内容表示测试用例，下一行代表测试用例的输出结果def squre(x):    &apos;&apos;&apos;    计算平方的函数    eg :    &gt;&gt;&gt; squre(2)    4    &gt;&gt;&gt; squre(4)    16     &apos;&apos;&apos;    return x * 2 # 故意写错的class User:    &apos;&apos;&apos;    定义一个代表用户的类，包括属性：    name - 代表名字    age - 代表年龄    例如：    &gt;&gt;&gt; u = User(&apos;hale&apos;,23)    &gt;&gt;&gt; u.name    &apos;hale&apos;    &gt;&gt;&gt; u.age    23ß    &apos;&apos;&apos;if __name__ == &apos;__main__&apos;:    import doctest    doctest.testmdo()测试结果包含的内容：    1. 第一部分：显示在哪个源文件的哪一行    2. 第二部分：Failed example，显示是哪个测试用例出错了    3. 第三部分：Expected 显示程序期望的输出结果，即在&quot;&gt;&gt;&gt;命令&quot;的下一行给出的运行结果    4. 第四部分：Got ，显示程序实际运行产生的输出结果，只有输出结果与期望结果一致，才表明测试用例通过可见：为文档注释提供doctest模块，程序只要导入该模块，并调用模块的testmod 函数即可。 testmod 自动提取模块的说明文档的测试用例，并执行这些测试用例，最终生成测试报告。</code></pre><h3 id="unittest-PyUnit-单元测试框架"><a href="#unittest-PyUnit-单元测试框架" class="headerlink" title="unittest(PyUnit)单元测试框架"></a>unittest(PyUnit)单元测试框架</h3><pre><code>    PyUnit unittest 是单元测试框架，编写和运行可重复的测试。 PyUnit 是xUnit体系的一个成员，xUnix是众多测试框架的总称。主要用于进行白盒测试和回归测试    好处：         可以使测试代码与产品代码分离        针对某一个类的测试代码只需要进行较少的改动，便于另一个类的测试        开源，方便对PyUnit的扩展    特征：        1. 使用断言方法判断期望值和实际值的差异，返回bool值        2. 测试驱动设备可使用共同的初始化变量或实例        3. 测试包结构便于组织和继承运行    PyUnit(unittest)用法：        通过给定参数执行函数，判断函数的实际输出结果和期望的输出结果是否一致，测试用例提供执行函数和方法， 获取他们的执行结果，然后使用断言方法来判断        开发方式称为：测试驱动开发，强调先编写测试用例，然后在编写函数和方法，例：开发A功能的fun_a函数，采用测试驱动开发的步骤：        1. 为fun_a 函数编写测试用例，使用大量不同的参数组合来执行fun_a函数，并断言该函数的执行结果与业务期望的执行结果匹配        2. 编写、修改fun_a 函数        3. 运行fun_a函数的测试用例，如不能完全通过，则重复第2步和第3步，直到fun_a的所有测试用例全部通过            开发一个简单的 fk_math.py 程序，包含两个函数，分别用于计算一元一次方程的解和二元一次方程的解                def one_equation(a,b):                    &apos;&apos;&apos;                    一元一次方程的解                    返回方程解                    &apos;&apos;&apos;                    if a == 0:                        raise ValueError(&apos;参数错误&apos;)                    else:                        return b / a                def two_equation(a,b,c):                    &apos;&apos;&apos;                    一元二次方程                     &apos;&apos;&apos;                    if a == 0:                        raise ValueError(&quot;参数错误&quot;)                    elif b * b - 4 * a * c &lt; 0:                        raise ValueError(&apos;方程在有理数范围内无解&apos;)                    elif b * b - 4 * a * c == 0:                        return -b / (2 * a)                    else:                        r1 = (-b + (b * b - 4 * a * c) ** 0.5 ) / 2 /a                         r2 = (-b + (b * b - 4 * a * c) ** 0.5 ) / 2 /a                         return r1, r2                unittest要求单元测试类必须继承 unittest.TestCase，该类中的测试方法需要满足：                    1. 测试方法应该没有返回值                    2. 测试方法不应该有任何参数                    3. 测试方法应以test开头                        import unittest                        from fk_math import *                         class TestFkMath(unittest.TestCase):                            def test_one_equation(self):                                self.assertEqual(one_equation(5,9), -1.8)                                with self.assertRaises(ValueError):                                    one_euqation(0,9)                            def test_two_equation(self):                                r1,r2 = two_equation(1,-3,2)                                self.assertCountEqual((r1,r2),(1.0,2.0),&apos;求解出错&apos;)                                ...                                with self.assertRaises(ValueError):                                    two_equation(0,9,3)                                    ...            unittest.TestCase内置大量assertXxx方法执行断言：                assertEqual(a,b)            a == b                assertNotEqual(a,b)            a != b                assertTrue(x)                bool(x) is True                assertFalse(x)                bool(x) is False                assertIsNot(a,b)            a is not b                assertIs(a,b)                a is b                assertIsNone(x)                x is None                assertIsNotNone(x)            x is not None                [More](http://c.biancheng.net/view/2679.html)            TestCase 包含断言方法                assertAlmostEqual(a,b)        round(a-b,7) == 0                assertNotAlmostEqual(a,b)    round(a-b,7) != 0                assertGreater(a,b)            a &gt; b             TestCase 包含针对特定类型的断言方法                assertMultiLineEqual(a,b)    字符串string                assertSequenceEqual(a,b)    序列sequence                assertListEqual(a,b)        列表list                assertTupleEqual(a,b)        元组tuple                assertSetEqual(a,b)            集合set 或 frozenset                assertDictEqual(a,b)        字典dict    运行测试        两种方式：            1. 通过代码调用测试用例，通过调用unittest.main() 运行当前源文件中所有测试用例                        if __name__ == &apos;__main__&apos;:                    unittest.main()            2. 使用unittest 模块运行测试用例，语法：                python -m unittest 测试文件        测试结果：            1. . ：代表测试通过            2. F ： 代表失败，F ： failure            3. E ： 出错    E ： error            4. s ： 跳过该测试    s ： skipTestSuite 测试包及用法    可组织多个测试用例， 还可嵌套测试包，使用测试运行器 TestRunner 来运行该测试包所包含的所有测试用例    // 开发一个程序 hello.py    def say_hello():        return &apos;hi&apos;    def add(a,b):        return a + b    // 为上面程序提供测试类 test_hello.py        import unittest        from hello improt *        class TestHello(unittest.TestCase):            def test_say_hell(self):                self.assertEqual(say_hello(),&apos;Hello world.&apos;)            def test_add(self):                self.assertEqual(add(2,1),5)                self.assertEqual(add(3,6),7)    将 test_fk_math 和 test_hello.py 放在同一目录，可通过TestSuite将他们组织在一起，然后使用TestRunner来运行该测试包        import unittest        from test_fk_math import TestFkMath        test_cases = (TestHello, TestFkMath)        def whole_suite():            // 创建测试加载器            loader = unittest.TestLoader()            // 创建测试包            suite = unittest.TestSuit()            // 遍历所有测试类            for test_class in test_cases:            // 从测试类中加载测试用例                tests = loaders.loadTestsFromTestCase(test_class)            // 将测试用例添加到测试包                suite.addTests(tests)            return suite        if __name__ == &apos;__main__&apos;:            // 创建测试运行器            runner = unittest.TexTestRunner(verbosity=2)            runner.run(whole_suite())    把测试报告输出到该类文件对象中        修改__main__ 部分代码：            if __name__ == &apos;__main__&apos;:                with open(&apos;fk_test_report.txt&apos;,&apos;a&apos;) as f:                    runner = unittest.TextTextRunner(verbosity=2,stream=f)                    runner.run(whole_suite())单元测试setUp 和 tearDown 用法    测试用例类：TestCase的子类、测试包TestSuit、测试运行器TestRunner、测试固件TestFixture的概念：        1. 测试用例类：是单个的测试单元，负责检查特定输入和对应的输出是否匹配，        2. 测试包： 组合多个测试用例， 可嵌套测试包        3. 测试运行器：负责组织、运行测试用例，向用户呈现测试结果        4. 测试固件： 代表执行一个或多个测试用例所需的准备工作，及相关联的准备操作，包括：创建临时数据库、创建目录、开启服务器进程等。        unittest.TestCase包含setUp 和 tearDown 两个方法，其实setUp方法用于初始化测试固件， tearDown 方法用于销毁测试固件。运行每个测试用例以 test_ 开头的方法之前自动执行setUp方法来初始化测试固件，并在每个测试用例结束后自动执行tearDown方法销毁测试固件        import unittest        from hello import *         class TestHello(unittest.TestCase):            def test_say_hello(unittest.TestCase):                self.assertEqual(say_hello(),&apos;Hello world&apos;)            def test_add(self):                self.assertEqual(add(3,5),7)            def setUp(self):                print(&apos;---- setUp model--- &apos;)            def tearDown(self):                print(&apos;----tearDown-----&apos;)        python -m unittest -v fixture_test.pyunittest跳过测试用例    unittest 自动测试每一个测试用例 以test开头的方法，如跳过某个测试用例，通过两种方式：        1. 使用 skipXxx 装饰器 跳过测试用例，unittest 提供3个装饰器，分别是 @unittest.skip(reason) , @unittest.skipif(condition,reason), @unittest.skipUnless(condition,reason),其中 skip 代表无条件跳过，skiplf 代表当condition为True时跳过，skipUnless 代表当condition为False时跳过        2. 使用TestCase 的skipTest 方法来跳过测试用例            import unittest            from hello import *             class TestHello(uniitest.TestCase):                def test_say_hello(self):                    self.assertEqual(say_hello(),&apos;hi hello&apos;)                @unittest.skip(say_hello(),&apos;hello world&apos;)                def test_add(self):                    self.assertEqual(add(3,4),7)                    ...            @unittest.skip装饰器跳过了test_add 测试方法            python -m unittest skip_test.py            测试结果中，s 代表跳过第一个测试用例，. 代表第二个测试用例通过        可使用TestCase 的skipTest 方法跳过测试用例：            import unittest            from hello import *             class TestHello(unittest.TestCase):                def test_say_hello(self):                    self.assertEqual(say_hello(),&apos;hi&apos;)                def test_add(self):                    self.skipTest(add(3,4),5)                    ...            python -m unittest -v skip_test.py                -v : 生成更详细的测试报告</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Author : Hale Lv</span><br><span class="line">@Created Time : 2019-08-28 12:01:48</span><br><span class="line">@Description :</span><br></pre></td></tr></table></figure><h2 id="打包和发布-zipapp-和-PyInstaller"><a href="#打包和发布-zipapp-和-PyInstaller" class="headerlink" title="打包和发布 zipapp 和 PyInstaller"></a>打包和发布 zipapp 和 PyInstaller</h2><pre><code>用于将Python 应用打包为一个 .pyz 文件，无论多少个源文件和依赖包，使用zipapp可将他们大包为一个 .pyz 文件。zipapp 模块： 将一个 python模块或多个模块打包为一个Python应用，可发布为Windows 的可执行程序生成可执行的Python档案包    zipapp 是一个可直接运行的模块，将单个python文件或整个目录下的所有文件打包为可执行的档案包        python -m zipapp source [options]            source ：代表要打包的Python源程序或目录，参数可是单个的pyhton文件，也可是文件夹。                    option 选项：                -o &lt;output&gt;, --output=&lt;output&gt;: 指定输出档案包的文件名，如不指定该选项，生成的档案包的文件名默认是source 参数值，并加上 .pyz后缀                -p &lt;interpreter&gt;, --python=&lt;interpreter&gt; : 指定Python解释器，                -m &lt;mainfn&gt;, --main=&lt;mainfn&gt; : 指定Python程序的入口函数，该选项应为： pkg.mod:fn 形式，pkg.mod 是一个档案包中的包或模块，fn是指定模块中的函数，如不指定，默认从模块中的 __main__.py 文件开始执行                -c ， --compress ： 指定是否对档案包进行压缩来减少文件的大小，默认不压缩                --info ： 用于诊断时显示档案包中的解释器                -h ， --help ： 该选项用于显示 zipapp 模块中的帮助信息    建立一个app 子目录， 包办多个python程序，如：say.py            def say(name):                return &apos;hi&apos; + name        在该目录下开发一个app.py 程序来使用 say 模块：            from say import *            def main():                    print(&apos;start run&apos;)                    print(say(&apos;hale&apos;))        在命令行中进入该目录(app目录的父目录)：            python -m zipapp app -o first.pyz -m &quot;app:main&quot;                指定将当前目录下的app子目下的所有Py源文件打包为一个档案包，-o 选项指定生成档案包的文件名为 first.pyz； -m ： 指定使用app.py 模块中的main函数作为程序入口            python -m zipapp app -m &quot;app:main&quot;                没有-o， 使用默认的输出文件名，生成一个 app.pyz文件</code></pre><h3 id="zipapp-创建独立应用"><a href="#zipapp-创建独立应用" class="headerlink" title="zipapp 创建独立应用"></a>zipapp 创建独立应用</h3><pre><code>如需使用第三方模块和包创建独立启动的应用 自带依赖模块和包，执行2个步骤：    1. 将应用依赖的模块和包下载到应用目录中    2. 使用zipapp将应用和依赖模块一起打包为档案包    在app目录中创建一个dbapp子目录，在dbapp中创建一个__main__.py 文件作为程序入口，打包档案包时不需指定入口        from exec_select import *        query_db()    exec_select.py 文件：        import mysql.connector        def query_db():            conn = conn.connector.connect(user=&apos;user&apos;,&apos;passwor&apos;=&apos;pass&apos;,host=&apos;localhost&apos;,port=&apos;3306&apos;,database=&apos;dbname&apos;,use_unicode=True)        c = conn.cursor()        c.execute(&apos;select * from user_tb where user_id &gt; %s&apos;,(2,))        for col in (c.description):            print(col[0],end=&apos;\t&apos;)        print(&apos;\n-----&apos;)        for row in c:            print(row)            print(row[1] + &apos;--&gt;&apos; + row[2])        c.close()        conn.close()    1.    将dbapp子目录下的应用打包为独立应用：        python -m pip install -r requirements.txt --target dbapp            使用 pip 安装模块，python -m pip install 表示安装模块， -target 指定要安装到指定目录下， 此处安装到dbapp子目录下。-r 指定安装哪些模块，使用requirements.txt 列出要安装的模块和包 -r 选项支持两个值：                1. 直接指定要安装的模块或包                2. 使用清单文件指定要安装的模块和包        如：pip 模块提示找不到 requirements.txt 文件，需在当前目录下添加一个requirements.txt 文件，在该文件中增加：  mysql-connector-python            如模块需要依赖多个模块，则在requirements.txt 文件中定义多行，每行定义一个模块。    2.    如pip在dbapp子目录生成 .dist-info 目录，删除即可    3.  使用zipap 模块执行打包操作，如dbapp子目录下包含了 __main__.py 文件，则不需指定 -m 选项         python -m zipapp dbapp    卸载在python目录下安装的mysql-connector-python 模块：        pip uninstall mysql-connector-python</code></pre><h3 id="PyInstaller-安装和使用"><a href="#PyInstaller-安装和使用" class="headerlink" title="PyInstaller 安装和使用"></a>PyInstaller 安装和使用</h3><pre><code>    默认不包含PyInstaller 模块， 需自行安装        pip install pyinstallerPyInstaller生成可执行程序    pyinstaller 选项 Python 源文件        单文件、多文件，使用pyinstaller 编译作为程序入口的python 程序即可        先创建一个app目录，在该目录下创建一个 app.py 文件            from say_hello import *            def main():                print(&apos;start run&apos;)                print(say_hello(&apos;hale&apos;))            if __name__ == &apos;__main__&apos;:                main()            进入此app目录，执行：                pyinstaller -F app.py                     执行完毕，会生成 dist目录、app.exe 文件                    -F 选项： 指定生成单独的EXE 文件， —D ：指定生成一个目录作为程序                pyinstaller -D app.py                    执行完毕，生成dist目录， 包含大量.dll 文件和 .pyz 文件        PyInstaller 支持的常用选项            -F， -onefile ：                产生单个的可执行文件            -D， --onedir ：                产生一个目录(包含多个文件)作为可执行程序            -a， --ascii  ：                不包含Unicode 字符集支持            -d， --debug  ：                产生debug 版本的可执行文件            -w， --windowed，--noconsolc ： 指定程序运行时不显示命令行窗口(仅对windwos有效)            -c， --nowindowed，-console ：    指定命令行窗口运行程序            -o DIR， --out=DIR ：            指定spec文件的生成目录，如没指定，默认使用当前目录来生成spec文件            -p DIR，--path=NAME    ：            设置python导入模块的路径，可用路径分隔符(win:&apos;,&apos;,unix:&apos;:&apos;来分割多个路径)            -n NAME，--name=NAME ：            指定项目的名字 如省略，第一个脚本的主文件名将作为spec的名字            -h ：        查看选项的详细信息    创建带图形的用户界面，可访问数据库的应用        在app所在目录创建一个dbapp目录，并在该目录下创建python程序，exec_select.py 负责查询数据， main.py 负责创建图形用户界面来显示查询结果            exec_select.py 代码：                import mysql.connector                def query_db():                    conn = mysql.connector.connect(user=&apos;root&apos;,password=&apos;pass&apos;,host=&apos;localhost&apos;,port=&apos;3306&apos;,database=&apos;dbname&apos;,use_unicode=True)                    c = conn.cursor()                    c.execute(&apos;select * from user_tb where user_id &gt; %s&apos;,(2,))                    description = c.description                    rows = c.fetchall()                    c.close()                    conn.close()                    return description, rows            main.py 文件代码：                from exec_select import *                from tkinkter import *                 def main():                    description,rows = query_db()                    win = Tk()                    win.title(&apos;query db&apos;)                    for i, col in enumerate(description):                        lb = Button(win,text=col[0],padx=50,pady=0)                        lb.grid(row=0,colunm=i)                    for i, row  in enumerate(rows):                        for j in range(len(row)):                            en = Label(win, text=row[j])                            en.grid(row=i+1,column=j)                    win.mainloop()                if __name__ == &apos;__main__&apos;:                   main()            Pyinstaller -F -w main.py</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Author : Hale Lv</span><br><span class="line">@Created Time : 2019-08-28 15:32:33</span><br><span class="line">@Description :</span><br></pre></td></tr></table></figure><h2 id="数据可视化-Matplotlib-Pygal"><a href="#数据可视化-Matplotlib-Pygal" class="headerlink" title="数据可视化 Matplotlib, Pygal"></a>数据可视化 Matplotlib, Pygal</h2><h3 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h3><pre><code>是Python 2D 绘图库，符号格式的数据，通过Matplotlib 方便制作折线图、柱状图、散点图等各种高质量的数据图安装：    1. pip install matplotlib    2. python -m pip install matplotlibpython -m pydoc -p 8899        //    文档Matplotlib plot 函数： 生成折线图    给出对应的 x轴、y轴数据， 调用pyplot子模块下的plot函数即可生成简单的折线图    如：生成2013年～2019年的销售数据        import matplotlib.pyplot as plt        x_data = [&apos;2013&apos;,&apos;2014&apos;,&apos;2015&apos;,&apos;2016&apos;,&apos;2017&apos;,&apos;2018&apos;,&apos;2019&apos;]        y_data = [123000,1232131,2131421,23532,453,645363,54654645]        plt.plot(x_data,y_data)        plt.show()    plot函数支持创建具有单条折线的折线图，也支持多条折线复式折线图，调用plot函数传入多个分别x轴和y轴数据的list列表即可。        import matplotlib.pyplot as plt         x_data = [&apos;2018&apos;,&apos;2019&apos;]        y_data = [5555555,666666]        y_data1 = [777777,8888888]        plt.plot(x_data,y_data,y_data1)        plt.show()    plot函数可传参数指定折线的样子，如 线宽、颜色、样式等，例：        import matplotlib.pyplot as plt        x_data = [&apos;2016&apos;,&apos;2017&apos;,&apos;2018&apos;,&apos;2019&apos;]        y_data = [100000,200000,300000,400000,500000]        y_data1 = [900000,800000,70000,40000,32222]        plt.plot(x_data,y_data,color=&apos;red&apos;,linewidth=2.0, linestyle=&apos;--&apos;)        plt.plot(x_data,y_data1,color=&apos;blue&apos;,linewidth=3.0,linestyle=&apos;-.&apos;)        plt.show()            color: 颜色，  linewidth ： 线宽 、 linestyle ： 折线样式            linestyle 折线样式，字符串参数值：                -  ： 代表实线，默认值                -- ： 代表虚线                .  ： 代表点线                -. :  代表短线、点相同的虚线    Matplotlib legend  : 为每条折线添加图例    对于复式折线图，应为每条折线添加图例，通过legend 函数实现，可传入两个list参数，第一个list参数 handles参数，用于引用折线图赏的每条折线，第二个list参数labels 代表为每条折线所添加的图形    为两条折线添加图例：        import matplotlib.plot as plt         x_data = [&apos;2018&apos;,&apos;2019&apos;]        y_data = [200000,3000000]        y_data1 = [30000,500000]        ln1 = plt.plot(x_data,y_data,color=&apos;red&apos;,linewidth=2.0, linestyle=&apos;--&apos;)        ln2 = plt.plot(x_data,y_data1,color=&apos;gary&apos;,linewidth=3.0,linestyle=&apos;-.&apos;)        plt.legend(handler=[ln2,ln1],labels=[&apos;Python&apos;,&apos;PHP&apos;],loc=&apos;lower right&apos;)        plt.show()loc参数指定图例的添加位置，参数支持的参数值：    &apos;base&apos;:     自动选择最佳位置    &apos;upper right&apos;: 将图例放在右上角    &apos;upper left&apos;:    左上角    &apos;lower left&apos;:    左下角    &apos;lower right&apos;:    右下角    &apos;right&apos;:    右边    &apos;center left&apos;:    左边剧中        &apos;center right&apos;:    右边剧中    &apos;lower center&apos;:    底部剧中    &apos;upper center&apos;: 顶部剧中    &apos;center&apos;:    将图例放在中心    在程序中修改 Matplotlib 的默认字体，步骤：        1. 使用 matplotlib.fnot_manager 子模块下的FontProperties 类加载中文字体        2. 在调用legend 函数时通过 prop 属性指定中文字体        improt matplotlin.font_manager as fm        my_font = fm.FontProperties(fname=&apos;/usr/font/powerline.ttf&apos;)        plt.legend(handles=[ln2,ln1], labels=[&apos;你好&apos;,&apos;Python基础&apos;],loc=&apos;lower right&apos;,prop=my_font)        使用 legend 函数时可不指定handles参数，只传入labels参数            plt.legend(labels=[&apos;Python 中文&apos;,&apos;PHP基础&apos;],loc=&apos;center&apos;,proc=my_font)        Matplotlib 可在调用 plot 函数时为每条折线分别传入label参数，        import matplotlib.pyplot as plt        x = [&apos;2018&apos;,&apos;2019&apos;]        y1 = [1233,312321]        y2 = [123213214,32131]        plt.plot(x,y1,color=&apos;red&apos;,linewidth=2.0,linestyle=&apos;-.&apos;,label=&apos;Python你好&apos;)        plt.plot(x,y2,color=&apos;blue&apos;,linewidth=3.0,linestyle=&apos;--&apos;,lebale=&apos;PHP再见&apos;)        import matplotlib.font_manager as fm        my_font = fm.FontProperties(fname=&apos;font dir&apos;)        plt.legend(loc=&apos;best&apos;)        plt.show()</code></pre><h3 id="Matplotlib-time-xlabel-ylabel-xticks-yticks-设置坐标轴"><a href="#Matplotlib-time-xlabel-ylabel-xticks-yticks-设置坐标轴" class="headerlink" title="Matplotlib time, xlabel, ylabel , xticks, yticks : 设置坐标轴"></a>Matplotlib time, xlabel, ylabel , xticks, yticks : 设置坐标轴</h3><pre><code>调用 xlabel 、 ylabel 函数设置x轴、y轴，通过title 函数设置整个数据图的标题，调用xticks 、yticks 改变x轴、y轴的刻度值    为数据图添加名称、标题、坐标轴刻度值    import matplotlib.pyplot as plt    x = [&apos;2018&apos;,&apos;2019&apos;]    y1 = [111111,2222]    y2 = [1233213,3213213213]    plt.plot(x,y1,color=&apos;red&apos;,linewidth=2.0,linestyle=&apos;--&apos;,label=&apos;Hi PYthon你好&apos;)    plt.plot(x,y2,color=&apos;blue&apos;,linewidth=3.0,linestyle=&apos;-.&apos;,label=&apos;PHP 再见&apos;)    import matplotlib.font_manager as fm    font = fm.FontProperties(fname=&apos;font dir .ttf&apos;)    plt.legend(loc=&apos;best&apos;)    plt.xlabel(&apos;年份&apos;)    plt.ylabel(&apos;教程销量&apos;)    plt.title(&apos;Python 开发指南&apos;)    plt.yticks([1000,100000,1000000],[r&apos;挺好&apos;,r&apos;优秀&apos;,r&apos;火爆&apos;)    plt.show()    如要对x轴、y轴进行更细致的控制，可调用 gca 函数来获取坐标轴信息对象，对坐标轴进行控制        对坐标轴的详细控制：            import matplotlib.pyplot as plt            x = ...            plt.yticks([1000,100000,10000],[r&apos;justsoso&apos;,r&apos;good&apos;,r&apos;great&apos;])            ax = plt.gca()            ax,xaxis.set_ticks_position(&apos;bottom&apos;)            ax.yaxis.set_ticks_position(&apos;left&apos;)            ax.spines[&apos;right&apos;].set_color(&apos;none&apos;)            ax.spines[&apos;top&apos;].set_color(&apos;none&apos;)            ax.spines[&apos;buttom&apos;].set_position((&apos;data&apos;,8000))            plt.show()    Matplotlin subplot : 创建子图        subplot(nrows,ncols,index,**kwargs) : nrows: 指定将数据区域分为多少行，ncols ：将数据图区域分为多少列，index 指定获取第几个区域。        subplot 支持直接传入一个三位数的参数， 第一位数为 nrows 参数，第二位数为 ncols，第三位数为 index 参数            import matplotlib.pyplot as plt            import numpy as np            plt.figure()            [More](http://c.biancheng.net/view/2711.html)        Matplotlib pie : 绘制饼图        [More](http://c.biancheng.net/view/2713.html)    Matplotlib 绘制柱状图 bar 、barh 函数        [More](http://c.biancheng.net/view/2716.html)    Matplotlib scatter : 绘制散点图        [More](http://c.biancheng.net/view/2718.html)        Matplotlib contour 、 contourf ： 绘制等高线        [More](http://c.biancheng.net/view/2718.html)    plot_surface(Axes3D): 绘制3D图形            X、Y数据决定坐标点， Z轴数据决定X、Y坐标点对应的高度            [More](http://c.biancheng.net/view/2720.html)Pygal 模块安装和使用    数据图库，以面向对象的方式创建各种数据图    Pygal 模块安装：        1. pip install pygal        2. python -m pip install pygal    查看文档：        python -m pydoc -p 9990    Pygal 数据图入门        生成数据图的步骤：            1. 创建Pygal 数据图对象，不同的数据图提供不同的类，如：柱状图使用pygal.Bar 类， 饼状图：pygal.Pie 类， 折线图：pygal.Line类，等等            2. 调用数据图对象的add 方法添加数据            3. 调用Config 对象的属性配置数据图            4. 调用数据图对象的render_to_xxx 方法将数据图渲染到指定的输出节点            import matplotlib.pyplot as plt            import numpy as np            from mpl_toolkits.mplot3d import Axes3D            fig = plt.figure(figsize=(12, 8))            ax = Axes3D(fig)            delta = 0.125            // 生成代表X轴数据的列表            x = np.arange(-3.0, 3.0, delta)            生成代表Y轴数据的列表            y = np.arange(-2.0, 2.0, delta)            对x、y数据执行网格化            X, Y = np.meshgrid(x, y)            Z1 = np.exp(-X**2 - Y**2)            Z2 = np.exp(-(X - 1)**2 - (Y - 1)**2)            计算Z轴数据（高度数据）            Z = (Z1 - Z2) * 2            绘制3D图形            ax.plot_surface(X, Y, Z,                        rstride=1,  # rstride（row）指定行的跨度                            cstride=1,  # cstride(column)指定列的跨度                                cmap=plt.get_cmap(&apos;rainbow&apos;))  # 设置颜色映射            设置Z轴范围            ax.set_zlim(-2, 2)            设置标题            plt.title(&quot;3D图&quot;)            plt.show()&quot;&quot;)&apos;&apos;))Pygal 模块安装和使用        以面向对象的方式创建各种数据图    Pygal 模块安装        1. pip install pygal        2. python -m pip install pygal        python -m pydoc -p 9999    Pygal 数据图        使用面向对象的方式生成数据图的步骤：            1. 创建pygal数据图对象，pygal 为不同的图像提供不同的类， 柱状图：pygal.Bar 。 饼状图：pygal.Pie类， 折线图: pygal.Line类            2. 调用数据图对象的add 方法添加数据            3. 调用 Config 对象的属性配置数据图            4. 调用数据对象的render_to_xxx 方法将数据渲染到指定的输出节点                import pygal                x_data = [&apos;2011&apos;, &apos;2012&apos;, &apos;2013&apos;, &apos;2014&apos;, &apos;2015&apos;, &apos;2016&apos;, &apos;2017&apos;]                y_data = [58000, 60200, 63000, 71000, 84000, 90500, 107000]                y_data2 = [52000, 54200, 51500,58300, 56800, 59500, 62700]                bar = pygal.Bar()                bar.add(&apos;C语言基础&apos;, y_data)                bar.add(&apos;Python语言基础&apos;, y_data2)                bar.x_labels = x_data                bar.title = &apos;编程教程的历年销量&apos;                bar.x_title = &apos;年份&apos;                bar.y_title = &apos;销量&apos;                bar.render_to_file(&apos;fk_books.svg&apos;)&apos;&apos;)&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;)&apos;&apos;)&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;&apos;]                虽然没有X、Y轴没有名称，都可通过pygal.Bar 对象来配置，为pygal.Bar对象的title、x_labels、x_title、y_title属性赋值                [More](http://c.biancheng.net/view/2721.html)    Pygal 常见数据图：折线图、柱状图、饼图、点图、仪表图、雷达图等        折线图：pygal.Line 类            [More](http://c.biancheng.net/view/2731.html)Python读取csv文件    csv: 以文本存储的表格数据,每行代表一行数据,每行数据中每个单元格内的数据以逗号隔开        使用csv模块读取csv文件:            1. 创建csv模块的读取器            2. 循环调用csv读取器的next方法逐行读取csv文件内容,next返回list列表代表一行数据,list列表的每个元素代表一个单元格数据            import csv            filename = &apos;xxx.csv&apos;            with open(filename) as f:                reader = csv.reader(f)                header_row = next(reader)                print(hreader_row)                first_row next(reader)                print(first_row)            [More](http://c.biancheng.net/view/2734.html)Python 读取 JSON 文件    JSON格式的数据会被转换为Python的list列表或dict字典        import json        filename = &apos;xxx.json&apos;        with open(filename) as f:            xx_list = json.load(f)        for xx_dict in xx_list:            if xx_dict[&apos;Year&apos;] == 2016 and xx_dict[&apos;Country Code&apos;] == &apos;CHN&apos;:                print(xx_dict[&apos;Country Name&apos;],xx_dict[&apos;Value&apos;])        调用json的load函数加载JSON数据，返回一个list列表，遍历该list列表即可访问到制定年份、国家的值Python 读取网络数据 request库和re模块    网络支持库:urllib.通过该库下的request模块向远程发送HTTP请求,获取服务器响应,思路:使用urllib.request 向 网站发送请求,获取该网站的响应,然后使用python的re模块来解析服务器响应,从中获得数据        import re         from datatime import datetime        from datatime import timedelta        from matplotlib import pyplot as plt        from urllib.request import *         def get_html(city,year,month):            url = &apos;http://lishi.tianqi.com/&apos; + &apos;city&apos; + &apos;/&apos; + str(year) + str(month) + &apos;.html&apos;            request = Request(url)            request.add_header(&apos;User-Agent&apos;,&apos;xx&apos;)            response = urlopen(request)            return response.read().decode(&apos;gbk&apos;)        dates,highs,lows = [], [], []        city = &apos;guangzhou&apos;        year = &apos;2019&apos;        months = [&apos;01&apos;,&apos;02&apos;,...,&apos;12&apos;]        prev_day = datetime(2019,2,14)        for month in months:            html = get_html(city,year,month)            text = &apos;&apos;.join(html.split())            pattern = re,compile(&apos;&lt;divclass=&quot;tqtong&quot;&apos;)            ...</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Author : Hale Lv</span><br><span class="line">@Created Time : 2019-08-29 13:27:28</span><br><span class="line">@Description :</span><br></pre></td></tr></table></figure><h2 id="Python-Scrapy-爬虫框架"><a href="#Python-Scrapy-爬虫框架" class="headerlink" title="Python Scrapy 爬虫框架"></a>Python Scrapy 爬虫框架</h2><pre><code>网络爬虫：自动获取多个页面中的所有天气信息，使用正则表达式、XPath 来提取页面中所有的链接 &lt;a.../&gt;元素，顺着这些链接递归打来对应的页面，然后提取页面中的信息    网路爬虫具体的核心工作：        1. 通过网络向指定的URL发送请求，获取服务器响应内容        2. 使用如正则表达式、XPath等提取页面中需要的信息        3. 高效地识别响应页面中的链接信息，顺着这些链接递归执行第1、2、3步        4. 使用多线程有效地管理网络通信交互    网络爬虫的核心工作:        1. 向URL发送请求,获取服务器响应内容,此核心工作是所有网络爬虫都需要做的通用工作,通用工作由爬虫框架来实现,可提供更稳定的性能.提高开发效率        2. 提取页面中感兴趣的信息.使用XPath提取信息的效率更高,正则表达式效率比较低        3. 识别响应页面中的链接信心,使用XPath效率高,正则表达式则底        4. 多线程管理: 核心工作是通用,由框架完成    Scrapy 是一个专业,高效的爬虫框架.试用专业的Twisted包,基于事件驱动的网络引擎包,使用lxml专业的XML处理包,cssselect高效地提取HTML页面的有效信息,同时也提供了有效的线程管理Scrapy 安装    pip install scrapy    python -m pip install scrapy     Scrapy需要依赖的第三方包：        1. pyOpenSSL: 用于支持SSL：Security Socket Layer         2. cryptography: 用于加密的包        3. CFFI ：调用C的接口库        4. zope.interface : 为Python缺少接口而提供扩展的库        5. lxml ：一个处理XML、HTML文档的库，比python内置的xml模块更好用        6. cssselect ： 处理css选择器的扩展包        7. Twisted ： 为python提供的基于事件驱动的网络引擎包        pip install Twisted-xxx-xxx-xxx.whlScrapy 项目创建    创建一个名为 xxxSplider的项目：        scrapy startproject xxxSplider        scrapy 是Scrapy框架提供的命令； startproject 是scrapy 的子命令，用于创建项目； xxxSplider是要创建的项目名            scrapy 提供的子命令：                 startproject: 创建项目                fetch ：从指定URL获取响应                gensplider ：生成蜘蛛                shell ：启动交互式控制台                version : 查看Scrapy版本        项目目录和文件:            scrapy.cfg: 项目的总配置文件，无需修改            xxxSplider :项目的Python模块，程序将从此处导入Python代码            xxxSplider/items.py ：用于定义项目用到的Item类，Item是一个DTO数据传输对象，定义N个属性，该类需由开发者来定义            xxxSplider/pipelines.py ：项目的管道文件，负责处理爬取到的信息            xxxSplider/settings.py : 项目的配置文件            xxxSplider/spiders : 存放项目所需的蜘蛛，负责抓取项目感兴趣的信息    Scrapy包含的核心组件：        调度器： 由Scrapy框架实现，负责调度下载中间件从网络上下载资源        下载器： 由Scrapy框架实现，负责从网络上下载数据，下载得到的数据会由Scrapy引擎自动交给蜘蛛        蜘蛛：由开发者实现，负责从下载数据中提取有效信息，提取到的信息会由Scrapy引擎以Item对象的形式转交给Pipeline        Pipeline：该组件由开发者实现，该组件接收到Item对象，包含蜘蛛提取的信息后，可将这些信息写入文件或数据库中    Scrapy Shell 调式工具及用法        使用shell调式工具抓取页面中的信息：            scrapy shell https://wwww.zhihu.com/xxx/xxx/        让Scrapy伪装为浏览器，需在发送请求时设置 User-Agent头            scrapy shell -s USER_AGENT=&apos;Mozilla/5.0/xxx/xxx&apos;             https://www.zhipin.com/xxx/xxx        使用XPath 或 CSS 选择器提取感兴趣的信息        XPath简化写法：            nodename            匹配此节点的所有内容            /                    匹配根字节            //                    匹配任意位置的节点            .                    匹配当前节点            ..                    匹配父节点            @                    匹配属性        使用//div匹配页面中任意位置处的&lt;div.../&gt;元素，也可使用//div/span匹配页面中任意位置处的 &lt;div...&gt;元素内的&lt;span.../&gt;子元素        XPath支持谓词，在节点后增加一个方括号，在方括号内放一个限制表达式对该节点进行限制        使用//div[@class]来匹配页面中任意位置处、由class属性的 &lt;div.../&gt;元素，也可使用 //div/span[1]匹配页面中任意位置处的 &lt;div.../&gt;元素内的最后一个 &lt;span.../&gt;子元素        使用 //div/span/[last()]来匹配页面中任意位置处的 &lt;div.../&gt;元素内的最后一个 &lt;span.../&gt;子元素        使用 //div/span[last()-1] 匹配页面中任意位置处的 &lt;div.../&gt;元素内的倒数第二个 &lt;span.../&gt;子元素         XPath :            //div[@class=&quot;job-primary&quot;]        extract() 提取节点的内容        [More](http://c.biancheng.net/view/2750.html)Scrapy 爬虫项目开发过程详解    步骤：        1. 定义 Item 类，该类仅用于定义项目需要爬虫的N个属性，如：名称、工资、公司等信息，可在items.py 中增加如下类定义：            import scrapy            class xxSpliderItem(scrapy.Item):                title = scrapy.Field()                salary = scrapy.Field()                company = scrapy.Field()                url = scrapy.Field()                addr = scrapy.Field()                industry = scrapy.Field()                publish = scrapy.Field()        2. 编写Spider类，将该Spider 类文件放在spiders目录下， 需要使用XPath或CSS选择器来提取HTML中感兴趣的信息            创建Splider：                scrapy genspider [options] &lt;name&gt; &lt;domain&gt;            在命令行中进入xxxSpider 目录下，执行如下命令行创建一个Spider：                scrapy genspider job_position &quot;xxx.com&quot;            可在xxSpider项目的xxxSpider/spider 目录下找到一个job_position.py，包含的内容如下：                import scrapy                 class JobPositionSpider(scrapy.Spider):                    name = &apos;job_position&apos;                    allowd_domains = [&apos;zhipin.com&apos;]                    start_urls = [&apos;https://zhipin.com/xxx/xx/&apos;]                def parse(self,response):                    pass                是Spider类的模板，该类的name属性用于指定该Spider的名字，allow_domains用于限制该Spider所爬取的域名，start_urls 指定该Spider会自动爬取的页面URl                Spider 需继承scrapy,Spider，并重写parse(slef,response)方法， 注意字符集问题                开发者要做的两件事情：                    1. 将要爬取的各页面URL定义在start_urls列表中                    2. 在parse(self,response)方法中通过XPath或CSS选择器提取项目感兴趣的信息                    import scrapy        3. 编写pipelines.py 文件，该文件负责将所爬取的数据写入文件或数据库中            [More](http://c.biancheng.net/view/2753.html)scrapy 爬虫数据保存到MySQL数据库    将爬虫的信息写入到文件中之外，也可通过修改Pipeline文件将数据库存到数据库中    创建数据库：    CREATE TABLE job_inf (        id int(11) not null primary key auto_increment,        title varchar(100),        salary varchar(100)        url varchar(100),        ...    )    修改Pipeline文件，将爬取到的信息保存到MySQL数据库中：        improt mysql.connector        class xxxPipeline(object):            def __init__(self):                self.conn = mysql.connector.connect(user=&apos;root&apos;,password=&apos;pass&apos;,host=&apos;localhost&apos;,port=&apos;3306&apos;,database=&apos;dbname&apos;,use_unicode=True)                self.cur = self.conn.cursor()            def close_spider(self,spider):                print(&apos;---------close mysql----&apos;)                self.cur.close()                slef.conn.close()            def process_item(self,item,spider):                self.cur.execute(&apos;insert into job_inf values(null,%s,%s,%s,%s,...%s)&apos;,(item[&apos;title&apos;],item[&apos;salary&apos;],item[&apos;company&apos;],...item[&apos;xxx&apos;]))                self.conn.commit()        程序为该Pipeline类定义了构造器，用于初始化数据库链接、游标，还为该Pipeline类重写了close_spider方法， 负责关闭构造器中初始化的数据库资源Scrapy 突破反爬虫机制</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;center&gt; Python &lt;/center&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
      <category term="Django" scheme="http://yoursite.com/categories/Python/Django/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Linux</title>
    <link href="http://yoursite.com/2019/08/09/Linux-Note/"/>
    <id>http://yoursite.com/2019/08/09/Linux-Note/</id>
    <published>2019-08-09T10:59:08.000Z</published>
    <updated>2019-08-19T13:28:09.246Z</updated>
    
    <content type="html"><![CDATA[<center> Linux </center> <a id="more"></a><h3 id="TODO-List"><a href="#TODO-List" class="headerlink" title="TODO List"></a>TODO List</h3><p><code>Centos Ubuntu</code> </p><h3 id="Linux-文件和目录管理"><a href="#Linux-文件和目录管理" class="headerlink" title="Linux 文件和目录管理"></a>Linux 文件和目录管理</h3><p>cd: 切换目录<br>    cd 选项<br>~ ： 当前用户的主目录    ~用户名：指定用户的主目录    - ： 上次所在的目录        . : 当前目录     ..: 上级目录</p><p>pwd：显示当前路径</p><p>whoami：当前登陆的用户</p><p>ls： 查看目录下文件<br>    ls 选项 文件<br>    -a:    全部文件    -A:    全部不包括. ..    -d:    目录本身    -f:    以文件名排序    -F:    再文件或目录后加上类型的指示符号    -h:    以易读方式显示    -i:显示inode节点信息<br>    -n:    以UID和GID代替用户名和群组    -r:    将排序结果反向输出    -R:    列出目录下所有文件    -S:    以文件容量大小排序    -t:    以时间排序    -l:    使用长格式列出文件和目录信息</p><p>ls:<br>第一列： 权限        第二列：计数(硬连接数)    第三列：所有者    第四列：所属组        第五列：大小    第六列：文件修改时间        第七列: 文件名和目录名</p><p>mkdir：创建目录文件夹<br>    mkdir 选项 文件目录名<br>    -p: 递归创立目录        -m: 自定义目录权限        </p><p>rmdir: 删除空目录<br>    rmdir 选项 文件目录名<br>    -p：递归删除空目录        rmdir</p><p>touch：创建文件及修改文件时间戳<br>    touch 选项 文件名<br>    选项：    -a：访问时间    -c：时间参数    -d：修订日期        -m：修改时间    -t：修订时间</p><p>ln：在文件之间建立链接(硬链接和软链接)<br>    ln 选项 源文件    目标文件<br>        -s：建立软链接文件，不加-s 则建立硬链接<br>        -f：强制  如果目标文件存在，则删除后再建立链接文件</p><p>cp：复制文件和目录<br>    cp 选项 源文件 目标文件<br>        -a：相当于 -d -p -r 的集合<br>        -d：如源文件为软链接，则复制出的目标文件也为软链接<br>        -i：询问 是否覆盖<br>        -l：把目标文件建立为源文件的硬链接，而不是复制源文件<br>        -s：把目标文件建立为源文件的软连接，而不是复制。。。<br>        -p：复制后目标文件保留源文件的属性 所有者、所属组、权限和时间<br>        -r：递归复制，用于复制父母<br>        -u：若目标文件比源文件有差异，则使用该选项更新目标文件，用于对文件的升级和备用</p><p>rm：删除文件或目录<br>    rm 选项 文件或目录<br>        -f： 强制删除<br>        -i:  删除前给出提示<br>        -r： 递归删除，用于目录</p><p>mv：移动文件或改名<br>    mv 选项 文件或目录<br>        -f：强制覆盖，不询问，直接覆盖<br>        -i：交互移动，询问是否覆盖<br>        -n：如果目标文件已存在，不会覆盖移动，也不询问<br>        -v: 显示文件或目录移动过程<br>        -u: 若目标文件存在，两者相比，源文件更新，对目标文件进行升级</p><h3 id="打包-归档-和压缩"><a href="#打包-归档-和压缩" class="headerlink" title="打包(归档)和压缩"></a>打包(归档)和压缩</h3><p>tar：打包<br>    tar 选项 源文件或目录<br>        -c：将多个文件或目录打包<br>        -A：追加tar文件到归档文件<br>        -f：指定包的文件名<br>        -v：显示打包过程<br>        -x：对tar包做 解压<br>        -C：指定解压包位置<br>        -z：压缩和解压缩”.tar.gz”<br>        -j：压缩和解压缩”.tar.bz2”</p><p>tar.gz:        -zxvf    -zcvf<br>tar.bz2:    -jxvf    -jcvf</p><p>zip: 压缩文件和目录<br>    zip 选项 压缩包名    源文件或源目录列表<br>        -r：    递归压缩目录，所有文件以及目录全部压缩<br>        -m：    压缩后，删除源文件<br>        -v：    显示详细的压缩过程<br>        -q：    不显示命令执行过程<br>        -压缩级别：    1~9        -1 代表压缩速度最快  -9 代表压缩效果更好<br>        -u：    更新压缩文件，往压缩文件添加新文件</p><p>unzip：解压zip文件<br>    unzip 选项 压缩包名<br>        -d 目录： 将压缩文件解压到指定目录下<br>        -n：      解压时不覆盖存在的文件<br>        -o：      解压时覆盖已经存在的文件，无需确认<br>        -v：      查看压缩文件的详细信息<br>        -t：      测试有无损坏，并不解压<br>        -x 文件列表: 解压文件，但不包含文件列表中指定的文件</p><p>gzip：压缩文件或目录<br>    gzip 选项 源文件<br>        -c：将压缩数据输出到标准输出中，保留源文件<br>        -d：对压缩文件解压<br>        -r：递归压缩指定目录下以及目录下的所有文件<br>        -l：对每一个压缩文件 显示字段  压缩文件大小  未压缩大小  压缩比  未压缩名称<br>        -数字 ：指定压缩等级， -1 等级最低，压缩比最差</p><p>gunzip：解压缩文件或目录<br>    gunzip 选项 文件<br>        -r：递归处理，解压缩指定目录下所有文件<br>        -c：把解压缩后的文件输出到标准设备<br>        -f：强制解压缩文件，不理会是否已存在<br>        -l：列出压缩文件内容<br>        -v：显示命令执行过程<br>        -t：测试压缩文件是否正常，不做任何操作</p><p>bzip2：压缩文件 bz2格式<br>    bzip2 选项 源文件<br>        -d: 执行解压缩<br>        -k: 解压缩完成后，删除源文件，要保留源文件，需使用此选项<br>        -f：再解压或解压缩时，若同名，默认不覆盖，此选项会强制覆盖现有文件<br>        -t：测试压缩或解压缩的完整性<br>        -v：显示详细信息<br>        -数字： -1 等级最低，压缩比最差 -9 压缩比最高</p><p>bunzip2 bz2 格式的及压缩命令<br>    bunzip2 选项<br>        -k:     解压缩后，默认删除压缩文件，若要保留，使用此参数<br>        -f： 解压缩时，若同名，默认不覆盖，若要覆盖，使用此参数<br>        -v： 显示命令执行过程<br>        -L:     列出压缩文件内容</p><h3 id="三剑客-grep-sed-awk"><a href="#三剑客-grep-sed-awk" class="headerlink" title="三剑客 grep        sed        awk"></a>三剑客 grep        sed        awk</h3><p>cat： 连接文件并打印输出到标准输出设备<br>    cat  选项    文件名<br>        -A：列出所有隐藏符号<br>        -E:    列出每行结尾的回车符$<br>        -n：对输出的所有行进行编号<br>        -b：只对非空行进行编号<br>        -T：把Tab键 ^| 显示<br>        -V：列出特殊字符<br>        -s：连续2行以上的空白行，替换为1行的空白行<br>        &gt;:    合并<br>        &gt;&gt;：追加</p><p>more：分屏显示文件内容<br>    more 选项 文件名<br>        -f：计算行数 实际的行数，<br>        -p：清屏后显示内容<br>        -c：先显示内容再清楚旧的资料<br>        -s：连续两行以上的空白行，就替换为一行的空白行<br>        -u：不显示下引号<br>        +n：从第n行开始显示文件内容，n代表数字<br>        -n：一次显示的行数，n表示数字<br>    交互指令及功能<br>        h或？：    帮助信息<br>        q或Q ：    退出<br>        v： 在当前行启动一个编辑器<br>        ：f 显示当前文件的文件名和行号<br>        !&lt;命令&gt;：在子shell中执行指定命令<br>        回车：向下移动一行<br>        空格：向上移动一行<br>        Ctrl+l：刷新屏幕<br>        =：    显示当前行的行号<br>        ‘： 转到上一次搜索开始的地方<br>        Ctrl+f： 向下滚动一页<br>        .：重复上次输入的命令<br>        /字符串：搜索指定的字符串<br>        d：向下移动半页<br>        b：向上移动半页</p><p>head：显示文件开头的内容<br>    head 选项 文件名<br>        -nK： K表示行数，除了文件最后K行外，显示剩余的全部内容<br>        -cK： K表示字节，除了文件最后K字节，显示剩余全部的内容<br>        -v：  显示文件名</p><p>less： 查看文件内容<br>    less 选项 文件名<br>        -N： 显示每行的行号<br>        -S： 行过长时舍弃超出部分<br>        -e： 文件显示结束后，自动离开<br>        -g： 只标志最后搜索到的关键词<br>        -Q： 不使用警告音<br>        -i： 忽略搜索时的大小写<br>        -m： 显示类似more的百分比<br>        -f:     强迫打开特殊文件<br>        -s:     显示连续行为一行<br>        -b： 设置缓冲区的大小<br>        -o： 将less输出的内容保存到指定文件中<br>        -x： 将tab键显示为规定的数字空格<br>    交互指令及功能<br>        /    ?    n    N    b    d    h|H        q|Q        y    空格键     回车键        PgDn   PgUp<br>        Ctrl + f    Ctrl + b    Ctrl + d    Ctrl + u    j    k    G    g    ZZ     v        [<br>            ]    p    u    </p><p>tail： 显示文件结尾的内容<br>    tail 选项  文件名<br>        -nK： K指行数，从文件的第K行开始输出<br>        -cK： K指字节数，从文件第K个字节开始输出<br>        -f：  输出文件变化后新增加的数据</p><h4 id="grep：-查找文件内容-正则表达式"><a href="#grep：-查找文件内容-正则表达式" class="headerlink" title="grep： 查找文件内容 正则表达式"></a>grep： 查找文件内容 正则表达式</h4><pre><code>正则表达式的通配符    c* ：  匹配0个空白或多个字符c(c为任一字符)    .  ：  匹配任何一个字符，只能是一个字符    [xyz]：匹配方括号中的任意一个字符    [^xyz]：匹配除方括号中字符外的所有字符    ^  ：  锁定行的开头    $  ：    锁定行的结尾    需结合反斜杠 \，grep 命令基本格式：    grep    选项    模式    文件名        -c ：列出文件中包含模式的行数        -i ：忽略模式中的字母大小写        -l ：列出带有匹配行的文件名        -n ：在每一行的最前面列出行号        -v ：列出没有匹配模式的行        -w ：把表达式当作一个完整的单字符来搜寻，忽略部分匹配的行</code></pre><h4 id="sed-根据脚本命令处理文本文件中的数据，命令从命令行输入，或存储在一个文本文件中，此命令执行数据顺序：-1-每次仅读取一行内容-2-根据规格命令匹配并修改数据-3-将执行结果输出"><a href="#sed-根据脚本命令处理文本文件中的数据，命令从命令行输入，或存储在一个文本文件中，此命令执行数据顺序：-1-每次仅读取一行内容-2-根据规格命令匹配并修改数据-3-将执行结果输出" class="headerlink" title="sed 根据脚本命令处理文本文件中的数据，命令从命令行输入，或存储在一个文本文件中，此命令执行数据顺序： 1.每次仅读取一行内容 2. 根据规格命令匹配并修改数据 3.将执行结果输出"></a>sed 根据脚本命令处理文本文件中的数据，命令从命令行输入，或存储在一个文本文件中，此命令执行数据顺序： 1.每次仅读取一行内容 2. 根据规格命令匹配并修改数据 3.将执行结果输出</h4><pre><code>sed 选项 脚本命令 文件名    -e 脚本命令： 将其后跟的脚本命令添加到已有的命令中    -f 脚本命令文件： 将其后文件中的脚本命令添加到已有的命令中    -n ： 所有脚本指定执行完毕后，自动输出处理后的内容，需使用print来输出    -i ： 直接修改源文件，慎用！sed 脚本命令    sed s 替换脚本命令： [address]s/pattern/reloacement/flags        address : 指定要操作的具体行        pattern ：需要替换的内容     replacement：要替换的新内容sed s 命令 flags 标记及功能    n ： 1-512 之间数字，表示指定要替换的字符串出现第n次时才进行替换    g ： 匹配到的所有内容进行替换    p ： 打印与替换命令中指定的模式匹配的行 与-n选项使用    w file ：将缓冲区中的内容写道指定的file文件中    &amp; ： 用正则表达式匹配到的内容进行替换    \n ： 匹配第n个字串，该字串之前在pattern中用 \(\) 指定        \ ： 转义sed d 替换脚本命令    需要删除文本中的特定行，用d脚本命令，删除指定行中的所有内容，如忘记指定具体行，删删除所有内容    [address]dsed a    | sed i 脚本命令    a 表示在指定行的后面附加一行，i表示在指定行的前面插入一行    [address]a(i或) \新文本内容sed c 替换脚本命令    c 表示将指定行中的所有内容，替换成该选项后面的字符串    [address]c\用于替换的新文本sed y 转换脚本命令    y 转换命令唯一可以处理单个字符    [address]y/inchars/outchars/sed p 打印脚本命令    p 搜索符号条件的行，输出该行的内容    [address]psed w 脚本命令    w 将文本中指定行的内容写入文件    [address]w filenamesed r 脚本命令    r 将一个独立文件的数据插入到当前数据流的指定位置    [address]r filename sed q 退出脚本命令    q 使sed命令在第一次匹配任务结束后，退出sed程序</code></pre><p>sed 脚本命令的寻址方式<br>    两种：<br>        1.[address]脚本命令 </p><pre><code>2.address{    多个脚本命令}</code></pre><h4 id="awk-文本数据处理工具"><a href="#awk-文本数据处理工具" class="headerlink" title="awk 文本数据处理工具"></a>awk 文本数据处理工具</h4><pre><code>基本格式：    awk 选项 &apos;脚本命令&apos; 文件名        -F fs ：指定以fs作为输入行的分隔符，默认以分隔符为空格或制表符        -f file ：从脚本文件中读取awk脚本指令，取代直接在命令行中输入指令        -v var=val：在执行前，设置一个变量var，初始值为 valawk 使用数据字段变量    $0 ：代表整个文本行    $1 ： 代表文本行的第1个数据字段    $2 :  。。。第2个数据字符按    $n : 代表第n个数据字段awk 脚本命令使用多个命令    awk &apos;{        $a = &quot;some text&quot;        print $0    }&apos;awk 从文件中读取程序    awk -F: -f awk.sh /etc/passwdawk BEGIN 关键字    awk &apos;BEGIN&apos; {print &quot;text&quot;}awk END 关键字    awk &apos;ENG&apos; {print &quot;text&quot;}</code></pre><h3 id="软件安装相关"><a href="#软件安装相关" class="headerlink" title="软件安装相关"></a>软件安装相关</h3><p>RPM 包安装、卸载、升级<br>    /etc/                ：配置文件安装目录<br>    /usr/bin/            ：可执行的命令安装目录<br>    /usr/lib/            ：程序所使用的函数库保存位置<br>    /usr/share/doc/        ：基本的软件使用手册保存位置<br>    /usr/share/man/        ：帮助文件保存位置<br>RPM 包的安装<br>    rpm -ivh 包名<br>        -i ：安装(install)<br>        -v ：显示详细信息(verbose)<br>        -h ：打印 # 显示安装进度(hash)<br>    rpm -ivh x.rpm xx.rpm xxx.rpm<br>    rpm 选项 包名<br>        -nodeps ： 不检测依赖性安装<br>        -replacefiles ：替换文件安装<br>        -replacepkgs ：替换软件包安装<br>        -force ：强制安装<br>        -test ：测试安装<br>        -prefix ：指定安装路径</p><h4 id="软件的启动和管理"><a href="#软件的启动和管理" class="headerlink" title="软件的启动和管理"></a>软件的启动和管理</h4><pre><code>service 服务名 start | stop | restart | status     stat: 启动服务    stop: 停止服务    restart:    重启服务    status:        查看服务状态检测端口：        netstat -tlun | grep 80</code></pre><p>RPM 包的升级<br>    rpm -Uvh 包名    ： 如没安装过则直接安装<br>    rpm -Fvh 包名    ： 如没有安装，则不安装</p><p>RPM 包的卸载    (e 时 erase)<br>    rpm -e 包名  </p><p>RPM 命令查询软件包 (-q, -qa, -i ,-p, -l, -f ,-R )<br>    rpm 选项 查询对象<br>        -q  ：表示查询， query<br>        -qa ：查询系统中所有安装的软件包<br>        -qi ：查询软件包的详细信息 i = information<br>        -ql ：查询软件包的文件列表<br>        -qf ：查询系统文件属于哪个RPM包<br>        -qR ：查询软件包的依赖关系</p><p>RPM 包验证和数字证书(数字签名)<br>    rpm 包校验<br>        -Va ：校验系统中已安装的软件包<br>        -V  ：校验已安装的包名<br>        -Vf ：校验某个系统文件是否被修改</p><p>提取RPM包文件(cpio命令)<br>    cpio 用于从归档包中存入和读取文件<br>        cpio 选项<br>            -o ： 指 copy-out 模式，把数据备份到文件库中<br>            -v ： 显示备份过程<br>            -c ： 使用较新的protable format 存储方式<br>            -B ： 设定输入/输出块为5120Bytes，而不是模式的512Bytes<br>            -i ： 指 copy-in ，把数据从文件库中恢复<br>            -d ： 还原时自动新建目录<br>            -u ： 自动使用较新的文件覆盖较旧的文件<br>            -p ： 指复制模式</p><p>YUM 源配置<br>    Yum 源配置文件： /etc/yum.repos.d/ ， 文件扩展名为：”*.repo”<br>        参数：<br>            [base]: 容器名称<br>            name：容器说明<br>            mirrorlist：镜像站点<br>            baseurl：源服务器的地址<br>            enable：此容器是否生效， 不写或写enable表示生效，0为不生效<br>            gpgcheck：为1表示RPM的数字证书生效，0为不生效<br>            gpgkey：数字证书的公钥文件保存位置<br>    Yum 查询、安装、升级、卸载<br>        yum list : 列出已安装的和可安装的软件名<br>        yum list 包名 : 查询安装情况<br>        yum search 关键字 : 查找与关键字相关的所有软件包<br>        yum info 包名 : 查询执行软件包的详细信息</p><p>Yum 安装命令<br>        yum -y install 包名<br>            install ： 安装<br>            -y ： 自动回答yes</p><p>Yum 升级命令<br>        yum -y update ： 升级所有软件包<br>        yum -y update 包名 ： 升级特定的软件包</p><p>Yum 卸载命令<br>        yum remote 包名 ：卸载指定的软件包</p><p>Yum 查询软件组包含的软件<br>        yum groupinfo 软件组名 ： 查询软件组包含的软件</p><p>Yum 安装软件组<br>        yum groupinstall 软件组名 ： 安装指定软件组，组名由grouplist查询出来</p><p>Yum 卸载软件组<br>        yum groupremove 软件组名 ： 卸载指定软件组</p><p>Linux 源码包安装和卸载<br>    首先安装 gcc 和 make<br>        rpm -q gcc   |   yum -y install gcc<br>        rpm -q make  |   yum -y install make<br>    下载源码包，如:  xxx.tar.gz<br>    解压： tar -zxvf xxx.tar.gz<br>    进入解压目录<br>    检测系统环境是否符合安装要求： ./configure<br>        定义需要的功能选项：<br>            ./configure –prefix=安装路径<br>        执行 ./configure–help 查询支持的功能<br>    编译： make<br>    正式安装软件： make install<br>    重装：在make前，要执行 make clean ，他会清空 Makefile 文件或编译产生的 .o 头文件</p><p>Linux 源码包卸载<br>    rm -rf /usr/local/xxx  ： 删除软件的安装目录，删除前需停止服务</p><p>Linux 源码包快速升级<br>    使用补丁更新源码包： 省去./configure 生成新的 Makefile文件，还省去了编译<br>    Linux 补丁文件的生成和使用<br>        diff 选项 old new<br>            -a ： 将任何文档当作文本文档处理<br>            -b ： 忽略空格造成的不同<br>            -B ： 忽略空白行造成的不同<br>            -l ： 忽略大小写造成的不同<br>            -N ： 比较两个目录时，如某个文件只在一个目录，则另一个目录视为空<br>            -r ： 比较目录时，递归比较子目录<br>            -u ： 使用同一输出格式<br>    1. 创建两个文件<br>        mkdir test  | cd test | vi old.txt  | vim new.txt  </p><pre><code>2. 利用diff命令，比较两个文件(old.txt 和 new.txt)的不同，并生成补丁文件 (txt.patch)，执行一下代码：    diff -Naur /roor/test/old.txt  /root/text/new.txt &lt; txt.patch</code></pre><p>给软件打入补丁<br>    1. 下载补丁文件<br>    2. 复制补丁文件到源码包解压目录中 cp xxx.diff 软件包名<br>    3. 给旧软件打入补丁  cd 软件目录    | vi xxx.diff<br>    4. 重新编译 软件包源码  make<br>    3. 安装 软件  make install</p><h3 id="Linux-用户和用户组管理"><a href="#Linux-用户和用户组管理" class="headerlink" title="Linux 用户和用户组管理"></a>Linux 用户和用户组管理</h3><p>UID 和 GID (用户ID 和 组ID)</p><p>/etc/passwd<br>        系统用户配置文件，存储系统所有用户的基本信息，所有用户有读操作<br>        表达的含义：<br>        用户名： 密码：UID(用户ID) ：GID(组ID) ：描述性信息 ： 主目录 ： 默认Shell</p><pre><code>用户名： 代表用户身份的字符串密 码 ：x 表示此用户设有密码， 真正的密码保存在 /etc/shadow 文件中UID ： 用户ID，识别不同的用户 0~655350 ： 超级用户 1 ~ 499 ： 系统用户500 ~ 65535 ： 普通用户GID ： Group ID ，组ID 初始组： 如：建立用户lamp的同时，建立 lamp组作为lamp用户的初始组附加组： 指用户可以加入多个其他的用户组，并拥有这些组的权限描述性信息： 主目录： 用户登陆后有操作权限的访问目录，用户的主目录默认的Shell：Linux的解释器，用户和Linux内核沟通的桥梁，默认 bash /bin/bash</code></pre><p>/etc/shadow (影子文件)<br>        用户名：加密密码：最后一次修改时间：最小修改时间间隔：密码有效期：密码需要变更前的警告天数：密码过期后的款期时间：账号失效时间：保留字段</p><pre><code>忘记密码：    1.重启进入单用户模式， 系统会提供root权限的bash 接口，用 passwd命令修改账号密码；    2.通过挂载根目录，修改 /etc/shadow，将账户的root密码清空</code></pre><p>/etc/group<br>    用户组配置文件，用户组的所有信息存放在此文件中<br>        组名：密码：GID：该用户组中的用户列表</p><p>/etc/gshadow<br>    组名：加密密码：组管理员：组附加用户列表</p><p>初始组和附加组<br>    添加新用户： useradd user<br>    添加新群组： groupadd group<br>    将用户xxx加入到xxx群组： usermod -G group user<br>    查找： grep ‘user’ /etc/passwd /etc/group /etc/gshadow</p><pre><code>一个用户可以所属多个附加组，但只能有一个初始组查看用户所属全部群组:    gourps</code></pre><p>/etc/login.defs :创建用户的默认设置文件</p><p>useradd ： 添加新的系统用户<br>    useradd 选项 用户名<br>        -u UID : 手工指定用户的UID，UID 不要小于500<br>        -d 主目录 ： 手工指定用户的主目录，必须是绝对路径，注意权限<br>        -c 用户说明 ： 手工指定 /etc/passwd 文件中各用户信息中第5哥字段的描述性内容，可随意配置<br>        -g 组名 ： 手工指定用户的初始组<br>        -G 组名 ： 指定用户的附加组<br>        -s shell ：手工指定用户的登录 Shell ，默认是 /bin/bash<br>        -e 日期 ： 指定用户的失效日期 格式为 “YYYY-MM-DD” /etc/shadow 文件的第八个字段<br>        -o ： 允许创建的用户的UID 相同，例如：useradd -u 0 -o usertest<br>        -m ： 建立用户时强制建立用户的家目录<br>        -r ： 创建系统用户 UID 在 1 ~ 499 </p><p>/etc/default/useradd 文件</p><p>passwd ：修改用户密码<br>    passwd 选项 用户名<br>        -S ：查询用户密码的状态 = /etc/shadow<br>        -l ：暂时锁定用户<br>        -u ：解锁用户<br>        –stdin ：通过管道符输出的数据作为用户的密码，主要用于批量添加用户<br>        -n ： 天数 不能修改密码期限 /etc/shadow 第4个字段<br>        -x ： 天数，设置密码有效期                第5个字段<br>        -w ： 天数 用户密码过期的警告天数        第6个字段<br>        -i ： 日期，用户密码失效日期            第7个字段</p><p>usermod ： 修改用户信息<br>    usermod 选项 用户名<br>        -c ： 用户说明：修改用户的说明信息 修改 /etc/paswd 文件目标用户信息的第5个字段<br>        -d ： 主目录： 修改用户的主目录        6<br>        -e ： 日期：修改用户的失效日期        8<br>        -g ： 组名：修改用户的初始组        4<br>        -u ： UID： 修改用户的UID            3<br>        -G ： 组名：修改用户的附加组，把用户加入其他用户组<br>        -l ： 修改用户名称<br>        -L ： 临时锁定用户<br>        -U ： 解锁用户<br>        -s ： shell： 修改用户的登录Shell</p><p>chage ： 修改用户密码状态<br>    chage    选项    用户名<br>        -l ： 列出用户的详细密码状态<br>        -d ： 日期   /etc/shadow 第3个字段<br>        -m ： 天数 修改密码最短保留天数  第4个字段<br>        -M ： 天数 修改密码的有效期  第5个字段<br>        -W ： 天数 修改密码过期前的警告天数 第6个字段<br>        -i ： 天数 修改密码过期后的宽限天数 第7个字段<br>        -E ： 日期 修改账号失效日期 第8个字段</p><p>userdel : 删除用户<br>    userdel -r 用户名<br>        -r : 在删除用户的同时删除用户的家目录</p><p>id ： 查看用户的UID 和GID<br>    id 用户名</p><p>su ： 用户间切换<br>    su    选项    用户名<br>        - ： 当前用户不仅切换为指定用户的身份，刚工作环境也切换为此用户的环境包括 PATH变量、MAIL变量等，可省略用户名，默认为root<br>        -l ： 同-，但后面需要添加欲切换的使用者账号<br>        -p ： 切换为指定用户的身份，但不改变当前的工作环境<br>        -m ： 同 -p<br>        -c ： 仅切换用户执行一次命令，执行后自动切换回来<br>    su 和 su - 的区别<br>        工作环境</p><p>groupadd ： 添加用户组<br>    groupadd 选项 用户<br>        -g GID ： 指定组ID<br>        -r ： 创建系统群组</p><p>groupmod ： 修改用户组<br>    groupmod    选项    用户名<br>        -g GID ： 修改组ID<br>        -n 新组名 ： 修改组名</p><p>groupdel ： 删除用户组<br>    groupdel    组名</p><p>gpasswd ： 把用户添加进组或从组中删除<br>    gpasswd        选项    组名<br>                ： 选项为空时，给群组设置密码，仅root用户可用<br>        - A user1,… ： 将群组控制权交给 user1，… 等用户管理， 是将 user1，等用户为群组的管理员，仅root用户可用<br>        -M user1，… ：将user1等加入到群组中，仅root可用<br>        -r ： 移除群组的密码，仅root可用<br>        -R ： 让群组的密码失效，仅root可用<br>        -a user ： 将user 用户加入到群组中<br>        -d user ： 将user 用户从群组中移除</p><p>newgrp ： 切换用户的有效组<br>    newgrp    组名</p><h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><pre><code>针对不同的用户，设置不同的文件访问权限，包括读、写、删除等ls -al    // 查看文件或目录的权限信息</code></pre><p>chgrp：修改文件和目录的所属组<br>    chgrp [-R] 所属组 文件名(目录名)<br>        -R: 递归 修改 所属组<br>chown：修改文件和目录的所有者和所属组<br>    chown [-R] 所有者 文件后目录<br>        -R: 递归 修改 所有者<br>    chown [-R] 所有者:所属组 文件或目录            </p><p>权限位<br>    文件权限 3 种， 文件 读(r), 写(w), 执行(x)<br>    每行的第一列表示权限，共11位，第一位表示具体类型，最后以为收SELinux安全规则管理<br>    读、写、执行 共 9 位字符<br>        rw-  r–  r–            // 所有者、所属群组、其他用户<br>        r ： 4<br>        w ： 2<br>        x ： 1</p><p>chmod： 修改文件或目录的权限<br>    chmod [-R] 权限值 文件名<br>        -R ：递归 设定 权限<br>    chmod [字母 u、g、o、a ] +|-|=  r|w|x 文件或目录<br>        u：用户<br>        g：群组<br>        o：其他<br>        a：所有<br>        +：加入<br>        -：删除<br>        =：设定</p><p>umask： 令新建文件和目录拥有默认权限<br>    umask                //    默认值：root用户 0022， 普通用户：0002<br>        默认权限由4个八进制数组成，第一个数代表所有者的特殊权限 (SetUID, SetGID, Sticky BIT) 最后3位022 才是真正用到的umask权限 可转换为 — -w- -w-<br>        文件或目录初始权限 = 文件或目录最大默认权限 - umask权限<br>            文件最大默认权限是666：-rw-rw-rw-            666 - 033 = 633<br>            目录最大权限默认是777 drwxrwxrwx            777 - 022 = 755<br>    默认权限修改方法：<br>        umask 022        umask 033</p><p>ACL 访问控制权限<br>    三种身份： 文件所有者、所属群组、其他用户<br>    三种权限： 读 r        、 写 w 、 访问 x<br>        权限前的字符，表示文件的具体类型，d：目录，-：普通文件，|：表示连接文件，b：设备文件<br>    ACL：Access Control List (访问控制列表)，ACL可实现单一用户设定访问文件的权限，除了传统方式，还可以用ACL进行设定<br>    mount    ：查看系统挂载的分区<br>    dumpe2fs -h /dev/sda1        // dumpe2fs 查询指定分区文件系统详细信息<br>            -h：仅显示超级块中的信息，不显示磁盘块组的信息<br>    mount -o remount,acl /                    // 重新挂载根分区，并加入ACL权限，针对分区</p><p>ACL权限设置(setfacl 和 getfacl)<br>    getfacl 文件名                //    查看文件或目录设定的ACl权限信息<br>    setfacl 选项 文件名            // 设定用户或群组对指定文件的访问权限<br>        -m ： 设定ACl权限        // setfacl -m u:user:rx /dir<br>        -x :  删除指定用户        // setfacl -x u:user    /dir<br>        -b :  删除所有的ACL权限    // setfacl -b /dir<br>        -d ： 设定默认ACL权限    // setfacl -m d:u:user:rwx 文件名    群组: d:g:group:rwx<br>        -R :  递归设定ACL权限    // setfacl -m u:user:rwx -R /dir<br>        -k ： 删除默认ACL权限</p><p>mask： 有效权限<br>    指用户或群组能拥有的最大ACL权限，给用户或群组设定的ACl权限不能超过mask规定的权限范围，超出部分无效</p><p>SetUID(SUID)文件特殊权限<br>    仅适用于可执行文件，对设有SUID的文件有执行权限，执行此文件时，会以文件所有者的身份去执行，执行结束，身份的切换也消失<br>    chmod u-s /usr/bin/passwd ： 取消SetUID<br>    SUID 特点：<br>        只有可执行文件才能设定SetUID权限，对目录无效<br>        对文件拥有执行(x)权限<br>        执行文件时，以文件所有者的身份执行<br>        SetUID 权限只在文件执行过程有效，执行完毕，也消失<br>    不要轻易设置SetUID权限，有重大安全隐患</p><p>Stick BIT (SBIT)文件特殊权限<br>    仅对目录有效，设定SBIT权限，目录下创建的文件和目录，只有自己和root有修改和删除权限</p><p>Chattr：修改文件系统的权限属性<br>    chattr [+-=] [属性] 文件或目录<br>        +：添加属性            -：移除拥有的属性        =：设定一些属性<br>        i：对文件设定i属性，不允许删除、改名、添加、修改。 对目录设置i属性，只能修改，不能建立、删除文件<br>        a：文件：只增加数据，不能修改、删除。 目录：在目录中只建立和修改文件，不能删除文件<br>        u：文件或目录：删除时，内容保存，能恢复。防止意外删除文件或目录<br>        s：与u相反，删除文件或目录，会彻底删除，不可恢复</p><p>lsattr：查看文件系统属性<br>    lsattr 选项 文件或目录名<br>        -a：不带文件或目录，显示所有文件和目录，包括隐藏<br>        -d: 目录：列出本身的隐藏属性，布列出包含文件或子目录的隐藏属性<br>        -R： 与-d相反， 目录：连同子目录隐藏信息数据一并显示</p><p>sudo：系统权限管理<br>    sudo [-b] [-u 新使用者账号] 要执行的命令<br>        -b:将后续的命令放到背景中让系统自行运行，对当前shell无影响<br>        -u： 后面+切换的用户名，无用户名则为root<br>        -l： sudo -l，用于显示当前用户可用sudo执行命令</p><h3 id="文件系统管理"><a href="#文件系统管理" class="headerlink" title="文件系统管理"></a>文件系统管理</h3><pre><code>Centos6.3 默认为Ext4     兼容Ext3            最大1EB文件系统和16TB文件    无限数量子目录    Extents 连续数据块概念    多块分配、延迟分配、持久项分配    快速FSCK、日志校验、无日志模式、在线碎片整理、inode增强、默认穷barrier等支持的文件系统                Ext：最早的文件系统    Ext2：1993年发布，最大支持16TB分区，2TB文件    Ext3：带日志功能    Ext4：上面以写    swap：交换分区，类似虚拟内存，当内存不够时，交换分区代替，必须分区    NFS： 网络文件系统Network File System，本地通过挂载使用远程共享的资源    iso9660：关盘的标准文件下体哦那个    fat： 类windows fatl6文件系统    vfat：类windows fat32文件系统 最大支持32G文曲和4G文件啊你    NTFS： windows 所有，2TB分区 64G文件    ufs：Sun公司系统Solaris SunOS采用的文件系统    proc：内存的虚拟文件系统，/proc    sysfs： =proc     tmpfs： 基于内存的虚拟文件系统，可使用swap交换分区</code></pre><p>df：查看文件系统硬盘使用情况<br>    df 选项 目录或文件名<br>        -a：显示所有系统信息<br>        -m: 以MB显示容量<br>        -k：以KB显示<br>        -h: 以KB、MB、GB等自行显示<br>        -T：显示分区的文件系统名称<br>        -i: 不用硬盘容量显示，以含有inode的数量显示<br>du: 统计目录或文件所占磁盘空间大小<br>    du 选项 目录或文件名<br>        -a： 显示每个子文件的磁盘占用量，默认统计子目录的磁盘占用量<br>        -h: 人性化显示磁盘占用量<br>        -s： 统计总磁盘占用量，不列出子目录和子文件的磁盘占用量</p><p>mount： 挂载Linux系统外的文件<br>    mount<br>        -l：mount显示系统已挂载的设备信息， -l 额外显示卷标名称<br>        -a： 自动检查 /etc/fstab 文件中有无疏漏被挂载的设备文件，有，则自动挂载。开机主动读取/etc/fstab 文件中的内容<br>    mount -t系统类型 -L卷标名 -o特殊选项 -n设备文件名挂载点<br>        -t：系统类型，指欲挂载的文件系统类型：Ext2、Ext3、Ext4等<br>        -L: 卷标名 利用文件系统的卷标名称进行挂载<br>        -n：系统将实际挂载的情况写入 /etc/mtab 文件中。若不写入，使用此选项<br>        -o：特殊选项：可指定挂载的额外选项，如读写权限、同步异步</p><p>umount：卸载文件系统<br>    umount 设备文件名或挂载点</p><p>fsck：检测和修复文件系统<br>    fsck 选项 分区设备文件名<br>        -a: 自动修复，不提示<br>        -r: 互助的修复模式，会询问<br>        -A： 按照/etc/fstab 配置文件的内容，检查文件内罗列的全部文件系统<br>        -t 文件系统类型： 指定要检查的文件系统类型<br>        -C： 显示检查分区的进度条<br>        -f： 强制检测<br>        -y： 自动修复=-a，但有些文件系统只支持-y</p><p>dumpe2fs：查看文件系统信息<br>    dumpe2fs -h 文件名<br>        -h： 仅列出superblock(超级块)的数据信息</p><p>fdisk： 给硬盘分区<br>    fdisk -l    ：列出系统分区 最高支持2TB的硬盘分区<br>    fdisk 设备文件名<br>    创建分区</p><p>parted：创建分区<br>    parted 硬盘设备文件名<br>        具体操作见 交互命令</p><p>mkfs： 格式化分区(为分区写入文件系统)<br>    mkfs -t 文件系统格式 分区设备文件名</p><p>mke2fs：格式化硬盘(给硬盘写入文件系统)<br>    mke2fs 选项 分区设备文件名<br>        -t    文件系统： 指定格式化为如： ext2、ext3、ext4<br>        -b 字节：指定block大小<br>        -i 字节：指定字节 inode 的比例<br>        -j： 建立带有ext3 日志功能的文件系统<br>        -L 卷标名： 给文件系统设置卷标名</p><p>swap： 分区及作用<br>    交换分区<br>    建立swap分区的步骤<br>        1. 分区    fdisk或parted<br>        2. 格式化    mkswap 格式化为 swap分区<br>        3. 使用swap分区<br>            分区：fdisk /dev/sdb<br>            格式化： mkswap /dev/sdb1<br>            使用： 加入swap分区 swapon 分区设备文件名</p><h3 id="高级文件系统管理"><a href="#高级文件系统管理" class="headerlink" title="高级文件系统管理"></a>高级文件系统管理</h3><pre><code>磁盘配额、 LVM(逻辑卷管理)、 RAID(磁盘阵列)    磁盘配额：限制普通用户在分区中使用的容量和文件个数    LVM： 在不停机和不损失数据的情况下修改分区带线啊哦    RAID：有多块硬盘或分区组成，拥有数据冗余功能，在某块硬盘或分区损坏时，硬盘或分区保存的数据不丢失</code></pre><p>磁盘配额<br>    Linux系统中限制特定的普通用户或用户组在指定的分区上占用的磁盘空间或文件个数<br>    满足磁盘配额的条件：<br>        1. 内核支持                grep CONFIG_QUOTA /boot/conrrfig-2…el6.i686<br>        2. 安装Quota工具        rpm -qa | grep quota<br>        3. 支持磁盘配额的分区必须开启磁盘配额功能<br>    常见概念<br>        用户配额和组配额<br>        磁盘容量限制和文件个数限制<br>        软限制和硬限制<br>        宽限时间<br>    磁盘配额启动的前期准备(设置挂载参数usrquota和grpquota)<br>        添加方式：<br>            1. 手动添加挂载参数：<br>                mount -o remout,usrquota,grpquota /home<br>                mount | grep home<br>            2. 修改/etc/fstab文件。将挂载参数写入配置中<br>                vi /etc/fstab<br>                    LABEL = /home    /home   ext3   defaults.usrquota,grpquota  1  2<br>                umount /home<br>                mount -a<br>                mount | grep home</p><p>quotacheck：扫描文件系统并建立Quota记录文件<br>    quotacheck [-avugfM] 文件系统<br>        -a：扫描所有在/etc/mtab 中含有quota支持的filesystem，此参数后边的文件系统可不写<br>        -u：针对使用者扫描文件与目录的使用情况，会创建 aquota.user<br>        -g：针对群组扫描文件与目录的使用情况，会创建aquota.group<br>        -v：显示扫描的详细过程<br>        -f：强制扫描文件系统，并写入新的quota记录文件<br>        -M：强制以读写的方式扫描文件系统，特殊情况下使用</p><p>quotaon：开始磁盘配额限制<br>    quotaon [-avug]<br>    quotaon [-vug] 文件系统名称<br>        -a：根据/etc/mtab 文件中对文件系统的配置，启动相关的Quota服务<br>        -u：针对用户启动Quota<br>        -g：针对群组启动Quota<br>        -v：显示启动服务过程的详细信息</p><p>quotaoff：关闭磁盘配额限制<br>    quotaoff [-avug]<br>    quotaoff [-vug] 文件系统名称<br>        -a：根据/etc/mtab 文件，关闭已启动的Quota服务，如不使用-a选项，则后面需要明确协商特定的文件系统名称<br>        -u：关闭针对用户启动的Quota服务<br>        -g：关系针对群组启动的Quota服务<br>        -v：显示服务过程的详细信息</p><p>edquota：修改用户(群组)的磁盘配额<br>    edquota [-u用户名] [-g群组名]<br>    edquota -t<br>    edquota -p 源用户名 -u 新用户名<br>        -u 用户名：进入配额的Vi编辑界面，修改针对用户的配置值<br>        -g 群组名：修改针对群组的配置值<br>        -t：       修改配额参数中的宽限时间<br>        -p：       将源用户(或群组)的磁盘配额设置，复制给其他用户(或群组)<br>    edquota 命令配额限制信息<br>        文件系统 filesystem：针对哪个文件系统或分区<br>        磁盘容量 blocks： quota自己算的，单位为Kbytes，不要手动修改<br>        磁盘容量的软限制 soft： 超过此限制值，登陆时会收到警告信息<br>        磁盘容量的硬显示 hard： 要求用户使用的磁盘空间不超此限制值，单位为KB<br>        文件数量 inodes：  当文件数量超过此值，会发出警告<br>        文件数量的硬限制 hard： 用户拥有的文件数量不超此值</p><p>setquota：非交互式设置磁盘配额<br>    setquota -u 用户名 容量软限制 容量硬限制 个数软限制 个数硬限制 分区名</p><p>quota和repquota查询磁盘配额方法<br>    quota 查询用户或用户组的配额<br>        quota 选项 用户名或组名<br>            -u 用户名： 查询用户配额<br>            -g 组名 ：    查询组配额<br>            -v： 显示详细信息<br>            -s： 以习惯单位显示容量大小 如 M、G<br>    repquota 查询整个分区的配额情况<br>        repquota 选项  分区名<br>            -a： 依据/etc/mtab 文件查询配额，如不加-a，就得加分区名<br>            -u： 查询用户配额<br>            -g： 查询组配额<br>            -v： 显示详细信息<br>            -s： 以易读单位显示容量大小</p><h3 id="LVM逻辑卷管理机制-硬盘分区管理机制"><a href="#LVM逻辑卷管理机制-硬盘分区管理机制" class="headerlink" title="LVM逻辑卷管理机制(硬盘分区管理机制)"></a>LVM逻辑卷管理机制(硬盘分区管理机制)</h3><pre><code>LVM：Logical Volume Manager，逻辑卷管理，Linux下对硬盘分区的一种管理机制    物理卷(Physical Volume, PV)：真正的物理硬盘或分区    卷组(Volume Group, VG)：将多个物理卷组成了卷组，把卷组想象为一块逻辑硬盘    逻辑卷(Logical Volume, LV)：逻辑卷可被格式化和写入数据，可想象为分区    物理扩展(Physical Extend,PE)：PE保存数据的最小单元，默认是4MB建立LVM的步骤：    1. 把物理硬盘分成分区    2. 把物理分区建立为物理卷PV    3. 把物理卷整合为卷组VG    4. 把卷组划分为逻辑卷LV</code></pre><p>PV物理卷：创建、查看、删除<br>    1. 建立所需的物理分区，方式使用fdisk交互命令<br>    建立物理卷；<br>        pvcreate 设备文件名<br>    查看物理卷：<br>        pvscan<br>        pvdisplay<br>    删除物理卷：<br>        pvremove /dev/sdb7</p><p>VG卷组：创建、激活、查看、扩容、减小、删除<br>    建立卷组：<br>        vgcreate [-s PE 大小] 卷组名 物理卷名<br>    激活卷组：<br>        激活：vgchange -a y 卷组名<br>        停用：vgchange -a n 卷组名<br>    查看卷组：<br>        vgscan ： 查看系统中是否有卷组<br>        vgdisplay： 查看卷组的详细状态<br>    增加卷组容量：<br>        vgextend scvg /dev/sdb7<br>    减少卷组容量：<br>        vgreduce  scvg /dev/sdb7<br>    删除卷组：<br>        vgremove scvg </p><p>LV逻辑卷：创建、查看、调整大小、删除<br>    建立逻辑卷：<br>        lvcreate 选项 -n 逻辑卷名 卷组名<br>            -L：容量，逻辑大小，单位为MB、GB、TB<br>            -l：个数，按照PE个数指定逻辑大小<br>            -n：逻辑卷名<br>    查看逻辑卷：<br>        lvscan        ： 查看系统中是否拥有逻辑卷<br>        lvdisplay    ： 查看逻辑卷的详细信息<br>    调整逻辑卷大小：<br>        lvresie 选项 逻辑卷的设备文件名<br>            -L: 容量<br>            -l: 个数<br>    删除逻辑卷：<br>        lvremove 逻辑卷的设备文件名<br>LVM(逻辑卷管理) 删除</p><p>RAID(磁盘列阵)</p><p>图形界面配置RAID</p><p>mdadm配置RAID</p><h3 id="启动管理"><a href="#启动管理" class="headerlink" title="启动管理"></a>启动管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line">启动流程：</span><br><span class="line">Upstart 启动服务 取代了 System V init</span><br><span class="line">1. 服务器加点，加载BIOS信息，BIOS进行系统检测，依照BIOS设定，找到第一个可以启动的设备(硬盘)</span><br><span class="line">2. 读取第一个启动设备的MBR(主引导记录)，加载MBR中的Boot Loader(启动引导程序，最常见为GRUB)</span><br><span class="line">3. 依照Boot Loader的设置加载内核，内核再进行一遍系统检测，系统一般会采用内核检测硬件的信息，而不一定采用BIOS的自检信息。内核再检测硬件的同时，还会通过加载动态模板的形式加载硬件的驱动</span><br><span class="line">4. 内核启动系统的第一进程，也就是 /sbin/init</span><br><span class="line">5. 由 /sbin/init 进程调用 /etc/init/rcS.conf 配置文件，通过这个配置调用/etc/rc.d/rc.sysint 配置文件。 而/etc/rc.d/rc.sysinit 配置文件是用来进行系统初始化的，主要用于配置计算机的初始化环境</span><br><span class="line">6. 通过/etc/init/rcS.conf 配置文件调用 /etc/inittab 配置文件。 通过 /etc/inittab 配置文件来确定系统的默认运行级别</span><br><span class="line">7. 确定默认运行级别后，调用/etc/init/rc.conf 配置文件</span><br><span class="line">8. 通过/etc/init/rc.conf 配置文件调用并执行 /etc/rc.d/rc 脚本，并传入运行级别参数</span><br><span class="line">9. /etc/rc.d/rc 确定传入的运行级别，然后运行相应的运行级别目录 /etc/rc[0-6].d/ 中的脚本</span><br><span class="line">10. /etc/rc[0-6].d/ 目录中的脚本依据设定好的优先级一次启动和关闭</span><br><span class="line">11. 最后执行/etc/rc.d/rc.local 中的程序</span><br><span class="line">12. 如果是字符界面启动，就可以看到登陆界面，如是图形界面启动，则调用相应的X Window 接口</span><br><span class="line">归纳：BIOS自检 -&gt; 启动GRUB -&gt; 加载内核 -&gt; 执行第一个进程 -&gt; 配置系统初始环境 </span><br><span class="line"></span><br><span class="line">BIOS 开机自检</span><br><span class="line">通电后，进入BIOS： Basic Input/Ouput System 基本输入/输出系统</span><br><span class="line">BIOS初始化的工作：</span><br><span class="line">1. 检查硬件和外围设备， CPU、内存、风扇灯。 自建过程称为 POST(Power On Self Test)</span><br><span class="line">2. 对硬件进行初始化，规定当前启动设备的先后顺序，选择由哪个设备来开机</span><br><span class="line">3. 选择好开机设备后，会从该设备的MBR(主引导目录)读取Boot Loader(启动引导程序)并执行，启动引导程序用于引导操作系统启动，Linux系统默认使用GRUB</span><br><span class="line">当MBR被加载到RAM之后，BIOS将控制权交给RAM，进入系统第二阶段</span><br><span class="line">[MBR](http://c.biancheng.net/uploads/allimg/181022/2-1Q0221G321149.jpg)</span><br><span class="line">启动引导程序的作用：</span><br><span class="line">BIOS作用是自检，从MBR读取启动引导程序。</span><br><span class="line">启动引导程序作用：</span><br><span class="line">1. 加载操操作系统的内核</span><br><span class="line">2. 可选择的系统菜单，如双系统</span><br><span class="line">3. 调用其他的启动引导程序，多系统启动的关键</span><br><span class="line">[启动引导程序](http://c.biancheng.net/uploads/allimg/181022/2-1Q0221G60U34.jpg)</span><br><span class="line"></span><br><span class="line">Linux内核(内核模块)的加载过程</span><br><span class="line">内存存放位置： /boot 的启动目录中</span><br><span class="line">GRUB加载内核后，内核进行二次系统自检，内核替代BIOS接管Linux启动。</span><br><span class="line">内核完成后，采用动态方式加载每个硬件的模块，模块为硬件的驱动。</span><br><span class="line">initramfe虚拟文件系统</span><br><span class="line">通过initramfs虚拟文件系统再内存中模拟处一个根目录，然后加载SCSI等硬件驱动，可加载真正的跟目录，之后调用Linux的第一个进程/sbin/init</span><br><span class="line">优点：</span><br><span class="line">initramfs随着数据的增减自动增减容量</span><br><span class="line">再initramfas和页面缓存之间没有重复数据</span><br><span class="line">initramfs重复利用Linux caching的代码，没有增加内核尺寸</span><br><span class="line">不需要额外的文件系统驱动</span><br><span class="line">[](http://c.biancheng.net/uploads/allimg/181023/2-1Q023093PD60.jpg)</span><br><span class="line"></span><br><span class="line">Linux /sbin/init 初始化系统环境</span><br><span class="line">内核加载完，完成硬件检测与驱动程序加载后，内核主动呼叫第一个进程/sbin/init, 此配置主要功能准备软件执行的环境：主机名、网络设定、语言、文件系统格式及其他服务的启动</span><br><span class="line">/etc/rc.d/rc.sysinit 配置文件的工作：</span><br><span class="line">获得网络环境和主机类型</span><br><span class="line">测试设备：侦测系统上是否有usb设备，如有主动加载usb驱动程序，并挂载usb文件系统</span><br><span class="line">开机启动画面Plymouth</span><br><span class="line">判断是否启用SELinux</span><br><span class="line">显示开机过程的欢迎画面</span><br><span class="line">初始化硬件</span><br><span class="line">用户自定义模块的加载</span><br><span class="line">配置内核的参数</span><br><span class="line">设置主机名</span><br><span class="line">同步存储器</span><br><span class="line">设备映射器及相关的初始化</span><br><span class="line">初始化软件磁盘阵列(RAID)</span><br><span class="line">初始化LVM的文件系统功能</span><br><span class="line">检验磁盘文件系统(fsck)</span><br><span class="line">设置磁盘配置(quota)</span><br><span class="line">重新以可读写模式挂载系统磁盘</span><br><span class="line">更新quota(非必要)</span><br><span class="line">启动系统虚拟随机数生成器</span><br><span class="line">配置机器(非必要)</span><br><span class="line">清除开机过程中的临时文件</span><br><span class="line">创建ICE目录</span><br><span class="line">启动交换分区(swap)</span><br><span class="line">将开机信息写入 /var/log/dmesg 文件中</span><br><span class="line"></span><br><span class="line">Linux /etc/inittab：设置(修改)系统默认运行级别</span><br><span class="line">Linux有7个级别：</span><br><span class="line">0 ：关机</span><br><span class="line">1 ：单用户模式，类Windows安全模式，系统修复</span><br><span class="line">2 ：不完全的命令行模式，不含NFS服务</span><br><span class="line">3 ：完全的命令行模式，标准字符界面</span><br><span class="line">4 ：系统保留</span><br><span class="line">5 ：图形模式</span><br><span class="line">6 ：重新启动</span><br><span class="line">runlevel：查看系统的运行级别</span><br><span class="line">系统默认运行级别：/etc/inittab 配置文件功能：确定系统的默认运行级别，即开机进入哪个运行级别</span><br><span class="line"></span><br><span class="line">Linux /etc/rc.d/rc.local 配置文件</span><br><span class="line">在 /etc/rc[06].d/ 目录中的程序启动后，系统启动完成。</span><br><span class="line">[启动流程](http://c.biancheng.net/uploads/allimg/181023/2-1Q02310563a22.jpg)</span><br><span class="line"></span><br><span class="line">Linux 启动引导程序(GRUB)加载内核</span><br><span class="line">GRUB加载内核的过程</span><br><span class="line">加载操作系统的内核</span><br><span class="line">可选择的操作系统菜单</span><br><span class="line">调用其他启动引导程序，实现多系统引导</span><br><span class="line">1. 执行GRUB主引导</span><br><span class="line">1.5 识别不同的文件系统</span><br><span class="line">2. 加载GRUB的配置文件</span><br><span class="line"></span><br><span class="line">Linux /boot/grub/ 目录分</span><br><span class="line">1. 第一阶段启动引导的主程序</span><br><span class="line">2. 第二阶段为主程序加载配置文件，包括环境参数文件</span><br><span class="line"></span><br><span class="line">GRUB磁盘分区表示法</span><br><span class="line">ha：硬盘</span><br><span class="line">第一个0：系统查找到的第一块硬盘，第二块为1|2？</span><br><span class="line">第二个0：硬盘的第一个分区</span><br><span class="line">硬盘分区设备文件名GRUB设备文件名</span><br><span class="line">第一块SCSI硬盘</span><br><span class="line">[内容太多](http://c.biancheng.net/view/1030.html)</span><br><span class="line"></span><br><span class="line">/boot/grub/grub.conf(GRUB配置文件)内容</span><br><span class="line">[内容太多](http://c.biancheng.net/view/1032.html)</span><br><span class="line"></span><br><span class="line">多系统并存的GRUB配置文件内容分析</span><br><span class="line">[多系统](http://c.biancheng.net/view/1033.html)</span><br><span class="line"></span><br><span class="line">GRUB手动安装方法</span><br><span class="line">手动安装GRUB的情况</span><br><span class="line">1. 不使用GRUB作为引导程序，而想要GRUB作为引导程序</span><br><span class="line">2. MBR中的引导程序被覆盖，如安装linux后安windows，引导被覆盖</span><br><span class="line">步骤：</span><br><span class="line">1. 使用grul-install 命令 在启动分区安装GRUB相关文件</span><br><span class="line">2. 修改GRUB的配置文件</span><br><span class="line">3. 安装GRUB到/dev/sdb1分区的启动扇区中</span><br><span class="line"></span><br><span class="line">Linux GRUB加密方法</span><br><span class="line">启动选项按 e 进入编辑模式，通过命令grub-md5-crypt</span><br><span class="line">模式：</span><br><span class="line">1. 给每个启动菜单加密</span><br><span class="line">2. 给GRUB菜单整体加密</span><br><span class="line"></span><br><span class="line">字符界面调整分比率</span><br><span class="line">[文章](http://c.biancheng.net/view/1037.html)</span><br><span class="line"></span><br><span class="line">Linux内核模块管理(查看、添加、删除)</span><br><span class="line">模块：动态可加载内核模块，有独立功能的程序，可被单独编译，但不能独立运行</span><br><span class="line">安装模块的方法：</span><br><span class="line">1. 在编译内核时，手工调整内核模块功能，加入所需的模块</span><br><span class="line">2. 下载厂商发布的新硬件的驱动模块，或下载驱动程序，在编译</span><br><span class="line">内核模块保存位置与模块保存文件</span><br><span class="line">内核模块保存：</span><br><span class="line">/lib/modules/内核版本/kernel/目录中</span><br><span class="line">depmod 选项</span><br><span class="line">-a：扫描所有模块</span><br><span class="line">-A: 扫描新模块，有新模块，更新moudles.dep 文件</span><br><span class="line">-n：扫描结果不写入modules.dep 文件，直接输出到屏幕</span><br><span class="line">内核模块的查看：</span><br><span class="line">lsmod 命令指定结果：</span><br><span class="line">Module：模块名</span><br><span class="line">Size：模块大小</span><br><span class="line">Used by：模块是否被其他模块调用</span><br><span class="line">内核模块的添加与删除：</span><br><span class="line">modprobe 选项 模块名</span><br><span class="line">-l：列出所有模块的文件名，依赖modules.dep文件</span><br><span class="line">-f：强制加载模块</span><br><span class="line">-r：删除模块</span><br><span class="line"></span><br><span class="line">Linux NTFS文件系统安装</span><br><span class="line">方法有三：</span><br><span class="line">一. 重新编译内核</span><br><span class="line">二. 下载编译内核</span><br><span class="line">三. 第三方插件 NTFS-3G</span><br><span class="line">二. </span><br><span class="line">1.下载内核</span><br><span class="line">2.解压内核</span><br><span class="line">3.生成内核编译所需的.config文件</span><br><span class="line">4.编译模块</span><br><span class="line">5.模块安装</span><br><span class="line">三：</span><br><span class="line">1.下载NTFS-3G插件</span><br><span class="line">2.安装NTFS-3G插件</span><br><span class="line"></span><br><span class="line">Linux单用户模块(修改密码、运行级别)方法</span><br><span class="line">如何进入单用户模式：</span><br><span class="line">开机、e 进入GRUB</span><br><span class="line">kernel、e 进入编辑界面，然后输入 空格 single，代表启动单用户模式</span><br><span class="line">单用户模式常见错误修复：</span><br><span class="line">root密码:</span><br><span class="line">单用户模式、passwd root</span><br><span class="line">修改系统默认运行级别：</span><br><span class="line">直接修改配置文件/etc/inittab. 系统的默认运行级别只能使用3或5</span><br><span class="line"></span><br><span class="line">光盘修复模式使用方法：</span><br><span class="line">[光盘修复](http://c.biancheng.net/view/1042.html)</span><br><span class="line"></span><br><span class="line">Linux系统安全性分析</span><br><span class="line">[密码安全](http://c.biancheng.net/uploads/allimg/181024/2-1Q024111633X7.jpg)</span><br></pre></td></tr></table></figure><h3 id="系统服务管理"><a href="#系统服务管理" class="headerlink" title="系统服务管理"></a>系统服务管理</h3><pre><code>服务是后台运行的应用程序，提供本地系统或网络的功能，Service，Daemon：守护神、守护进程守护进程：为了实现服务、功能的进程，是服务在后台运行的真实进程系统服务及分类    [服务分类](http://c.biancheng.net/uploads/allimg/181024/2-1Q02413195AP.jpg)软件安装方式：1. RPM包         2. 源码包服务分为两种：    独立的服务：可自动启动，不依赖管理服务，如 Nginx服务、FTP服务等    基于Xinetd的服务：依靠管理服务来调用，管理服务是xinetd服务，是系统的超级守护进程，作用：管理不能独立启动的服务，当有客户端请求时，先请求xinetd服务，由xinetd服务去唤醒相对应的服务。</code></pre><p>查询已安装的服务与区分服务<br>    RPM包默认安装到系统默认位置，可被服务管理命令(service、chkconfig)识别<br>    chkconfig –list 服务名        //    管理RPM包默认安装服务的自启动命令，列出所有服务的自启动状态</p><p>Linux端口及查询方法<br>    协议：<br>        面向连接的可靠的TCP协议(Transmission Control Protocol,传输控制协议)<br>        面向无连接的不可靠的UDP协议(User Datagram Protocol, 用户数据报协议)<br>    查询系统中已启动的服务：<br>        netstat 选项<br>            -a： 列出系统中所有网络连接，包括：网络服务、监听的网络服务、Socket套接字<br>            -t： 列出TCP 数据<br>            -u： 列出UDP 数据<br>            -l： 列出正在监听的网络服务(不包含已连接的网络服务)<br>            -n： 用端口号来显示而不用服务名<br>            -p： 列出该服务的进程ID(PID)<br>    执行结果字段解析：<br>        Proto： 数据包的协议<br>        Revc-Q：收到的数据已在本地接受缓冲<br>        Send-Q：对方没有收到的数据包数量<br>        Local Address：本地IP：端口，通过端口知道本机开启的服务<br>        Foreign Address：远程主机：端口，<br>        State： 连接状态，已建立连接(ESTABLISED)和监听(LISTEN)<br>        PID/Program name: 进程ID和进程命令<br>    Socket套接字的解析：<br>        Proto：协议，一般是Unix<br>        RefCnt： 连接到此Socket的进程数量<br>        Flags：连接标识<br>        Type： Socket访问类型<br>        State：状态 Listening：监听    Connected：已建立连接<br>        l-Node：程序文件的i节点号<br>        Path：Socket程序的路径、或者相关数据的输出路径</p><p>独立服务的启动管理(RPM包的启动与自启动)<br>    两种方式：<br>        1. 使用/etc/init.d/ 目录中的启动脚本来启动独立的服务<br>            /etc/init.d/独立服务名 start|stop|status|restart|…<br>                start：启动服务<br>                stop ：停止服务<br>                status：服务状态<br>                restart：重启服务<br>        2. 使用service命令来启动独立的服务<br>            service 只是一个脚本，调用/etc/init.d/ 中的启动脚本来启动独立服务<br>            service 独立服务名 start|stop|restart|…<br>                –status-all :列出所有独立服务的启动状态<br>独立服务的自启动管理<br>    三种方式：<br>        1. 使用chkconfig服务自启动管理命令<br>            chkconfig –list    // 查询自启动状态<br>                chkconfig –list | grep nginx<br>            chkconfig [–level 运行级别][独立服务名][on|off]<br>                –level：设定在哪个运行级别中开机自启动(on)，关闭自启动(off)<br>                chkconfig –level 2345 nginx on        // 修改2345这4个级别为启用<br>            /etc/init.d/nginx status    //    查看服务状态<br>        2. 修改 /etc/rc.d/rc.local 文件，设置服务自启动<br>            修改 rc.local 文件，添加服务的启动命令，注：/etc/rc.d/rc.local 和 /etc/rc.local 文件时软连接，修改哪个都可以，这个文件中的命令会在启动时调用<br>            vi /etc/rc.d/rc.local<br>                /etc/rc.d/init.d/nginx start<br>                # 在文件中加入nginx的启动命令<br>            好处：<br>                1. 集中管理<br>                2. 服务启动唯一性，不管哪种方式都通过 /etc/rc.d/rc.local 文件实现<br>        3. 使用ntsysv 命令管理自启动<br>            ntsysv：调用窗口模式管理服务的自启动<br>            ntsysv [–level 运行级别]<br>                ntsysv –level 234<br>                # 设定234级别的服务自启动</p><p>Linux基于xinetd服务的管理方法<br>    基于xinetd服务的启动<br>        xinetd 服务的配置文件保存在 /etc/xinetd.d/ 目录中<br>            telnet： /etc/xinetd.d/telnet<br>            如果要启动telnet服务，只需把 /etc/xinetd.d/telnet 文件中的disable=yes 改为 disable=no    ，disable:代表取消<br>    基于xinetd服务的自启动<br>        1. 使用chkconfig 命令管理自启动<br>            chkconfig 服务名 on|off<br>        2. 使用ntsysv命令管理自启动</p><p>Linux源码包服务管理(启动与自启动)<br>    源码包服务的启动管理：<br>        /usr/local/apache2/bin/apachectl start|stop|restart|status|…<br>    源码包服务的自启动管理：<br>        vim /etc/rc.d/rc.local            // 修改自启动文件<br>            touch /var/lock/subsys/local /usr/local/apache2/bin/apachectl start<br>            # 加入源码包服务的标准启动命令<br>    让源码包服务被服务管理命令识别：<br>        1. 卸载RPM包默认安装的apache服务<br>            yum -y remove httpd<br>        2. 安装源码包的apache服务，并启动<br>            /usr/local/apache2/bin/apachectl start<br>            netst -tlun | grep 80<br>        3. 让源码包安装的apache服务能被service命令管理启动<br>            ln -s /usr/local/apache2/bin/apachectl /etc/init.d/apache<br>            # 把源码包的启动脚本连接到 /etc/init.d/目录中，能被service命令管理<br>        4. 让源码包安装的apache服务能被chkconfig命令管理自启动<br>            vi /etc/init.d/apache<br>                # 修改源码包安装的apache服务的启动脚本，此文件是软连接，实际修改的是源码包的启动脚本<br>                chkconfig: 运行级别 启动顺序 关闭顺序<br>            chkconfig –add apache<br>            chkconfig –list | grep apache<br>        5. 让ntsysv命令可以管理源码包安装的apache服务<br>                把服务的启动脚本链接到/etc/init.d/目录中，在启动脚本中加入：<br>                #chkconfig:运行级别 启动顺序 关闭<br>                #description:说明<br>                然后使用： chkconfig –add 服务名<br>                    chkconfig 选项服务名<br>                        -add： 把服务加入chkconfig命令的管理中<br>                        -del： 把服务从chkconfig命令的管理中删除<br>                        chkconfig -del|httpd</p><p>Linux常见服务类被及功能<br>    acpid：    电源管理接口<br>    anacron：    系统的定时任务，是cron的子系统<br>    alsasound： alsa声卡驱动<br>    apmd：    电源管理模块<br>    atd：指定系统在特定时间执行某个任务，只能执行一次<br>    auditd：审核子系统<br>    autofs：让服务器可自动挂载网络中其服务器的共享数据，挂载NFS服务<br>    avahi-daemon：avahi是zeroconf协议的实现<br>    bluetooth：蓝牙设备支持<br>    capi：仅对ISND设备用户有用<br>    chargen-dgram：使用UDP协议的chargen server，类远程打字功能<br>    chargen-stream： 同上<br>    cpuspeed：调整CPU频率<br>    crond：系统定时任务<br>    cvs：版本控制系统<br>    … More<br>    <a href="http://c.biancheng.net/view/1059.html" target="_blank" rel="noopener">常见服务</a></p><h3 id="Linux-命令行快捷键"><a href="#Linux-命令行快捷键" class="headerlink" title="Linux 命令行快捷键"></a>Linux 命令行快捷键</h3><pre><code>Tab：补全Ctrl + c ：    中断命令或进程Ctrl + z ：    同 &amp; ，将程序送到后台Ctrl + d ：    退出终端Ctrl + l ：    清空终端Ctrl + a ：    光标移到行首Ctrl + e ：    光标移到行尾Ctrl + u ：    擦除整行命令Ctrl + k ：    擦除所在未到行尾Ctrl + y ：    粘贴擦除的命令Ctrl + p ：    查看上一个命令，可看历史命令Ctrl + n ： 下一个命令Ctrl + h ： 擦除前面一个字符Ctrl + r ： 搜索历史命令Ctrl + 左右键： 在单词间跳转Ctrl + t ： 交换光标所在处的两个字符的位置esc + b ： 移到单词的开头esc + f ： 移到单词的结尾esc + w ： 删除光标前的字符esc + t ： 颠倒光标所在处相邻字符位置Ctrl + x + u ： 按Ctrl 同时按 x u，撤销操作Bang(!)命令：!! ： 执行上一条命令^foo^bar ： 把上一条命令的foo替换为bar，并执行!wget ： 执行最近的以 wget 开头的命令!wget:p ： 仅打印最近的以wget开头的命令，但不执行!$ ： 上一条命令的最后一个参数!* ： 上一条命令的所有参数!*p ： 执行上一条命令的所有参数^abc ： 删除上一条命令中的abc!-n  ： 执行前 n 条命令， eg：!-3 执行前3条命令</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;center&gt; Linux &lt;/center&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="Ubuntu" scheme="http://yoursite.com/categories/Linux/Ubuntu/"/>
    
      <category term="Centos" scheme="http://yoursite.com/categories/Linux/Ubuntu/Centos/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>PHP</title>
    <link href="http://yoursite.com/2019/08/09/PHP-Note/"/>
    <id>http://yoursite.com/2019/08/09/PHP-Note/</id>
    <published>2019-08-09T10:58:59.000Z</published>
    <updated>2019-08-11T07:03:06.536Z</updated>
    
    <content type="html"><![CDATA[<center> iFaithFreedom </center><a id="more"></a><h3 id="TODO-List"><a href="#TODO-List" class="headerlink" title="TODO List"></a>TODO List</h3><p>PHP基础<br>PHP进阶<br>PHP高阶<br>More…</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt; iFaithFreedom &lt;/center&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
      <category term="Laravel" scheme="http://yoursite.com/categories/PHP/Laravel/"/>
    
      <category term="ThinkPHP" scheme="http://yoursite.com/categories/PHP/Laravel/ThinkPHP/"/>
    
      <category term="Yii" scheme="http://yoursite.com/categories/PHP/Laravel/ThinkPHP/Yii/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>Vim</title>
    <link href="http://yoursite.com/2019/08/09/Vim-Note/"/>
    <id>http://yoursite.com/2019/08/09/Vim-Note/</id>
    <published>2019-08-09T10:58:51.000Z</published>
    <updated>2019-08-16T13:53:01.574Z</updated>
    
    <content type="html"><![CDATA[<center> iFaithFreedom </center><a id="more"></a><h3 id="6-种模式"><a href="#6-种模式" class="headerlink" title="6 种模式"></a>6 种模式</h3><p>普通模式    插入模式    可视模式    选择模式    命令行模式        Ex模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- 普通模式</span><br><span class="line">dd </span><br><span class="line">ndd </span><br><span class="line">dj</span><br><span class="line">dG</span><br><span class="line">dgg</span><br><span class="line">db </span><br><span class="line">dw</span><br><span class="line"></span><br><span class="line">- 插入模式</span><br><span class="line">i </span><br><span class="line">I </span><br><span class="line">a</span><br><span class="line">A</span><br><span class="line">x</span><br><span class="line">X</span><br><span class="line">s</span><br><span class="line">S</span><br><span class="line"></span><br><span class="line">- 可视模式</span><br><span class="line">与普通模式相似</span><br><span class="line"></span><br><span class="line">- 选择模式</span><br><span class="line">Ctrl + v</span><br><span class="line">Shift + v</span><br><span class="line"></span><br><span class="line">- 命令行模式</span><br><span class="line">:：执行命令</span><br><span class="line">/：搜索</span><br><span class="line">?：搜索</span><br><span class="line">!：过滤命令</span><br><span class="line"></span><br><span class="line">- Ex模式</span><br><span class="line">与命令行模式相似，在使用 :visual 命令离开Ex模式前，可一次执行多条命令</span><br></pre></td></tr></table></figure><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">filename = x.x</span><br><span class="line">-r x.x:</span><br><span class="line">-R x.x:</span><br><span class="line">+ x.x:</span><br><span class="line">+n x.x:</span><br><span class="line">+ /pattern x.x:</span><br><span class="line">-c command x.x</span><br></pre></td></tr></table></figure><h3 id="编辑操作"><a href="#编辑操作" class="headerlink" title="编辑操作"></a>编辑操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">i:光标所在处插入</span><br><span class="line">I:所在行的第一个非空格符处开始插入</span><br><span class="line">o:光标所在行的下一行输入新的一行</span><br><span class="line">O:  光标所在行的上一行输入新的一行</span><br><span class="line">a:光标所在的下一个字符处开始输入</span><br><span class="line">A:光标所在行的最后一个字符处开始输入</span><br><span class="line">r:取代光标所在的那个一字符一次</span><br><span class="line">R:取代光标所在的文字，直到按下 ESC为止</span><br><span class="line"></span><br><span class="line">查找文本</span><br><span class="line">/abc:</span><br><span class="line">/^abc:</span><br><span class="line">/abc$:</span><br><span class="line">?abc:</span><br><span class="line">n:</span><br><span class="line">N:</span><br><span class="line"></span><br><span class="line">替换文本</span><br><span class="line">r:</span><br><span class="line">R:</span><br><span class="line">:s/x/x1/g:</span><br><span class="line">:x1,x2s/y1/y2/g:</span><br><span class="line">:g/x1/x2/g</span><br><span class="line"></span><br><span class="line">删除文本</span><br><span class="line">x: 向后删除一个字符X: 向前删除一个字符nx：连续向后删除n个字符</span><br><span class="line">dd:删除光标所在的一整行</span><br><span class="line">ndd: 删除光标所在的向下n行</span><br><span class="line">dG: 删除光标所在到最后一行的所有数据</span><br><span class="line">d$:删除光标所在处到最后一个字符</span><br><span class="line">d0:删除光标所在处到该行的最前面一个字符</span><br><span class="line">D:删除光标末尾的字符</span><br><span class="line">:x1,x2d</span><br><span class="line"></span><br><span class="line">p: 粘贴被删除的文本内容</span><br><span class="line"></span><br><span class="line">复制文本</span><br><span class="line">p: 粘贴通过复制下的行数和字符</span><br><span class="line">P: 会增加行数</span><br><span class="line">yy: 复制光标所在的那一行</span><br><span class="line">nyy: 复制光标所在的向下n行</span><br><span class="line">y1G: 复制光标所在行的第一行的所有数据</span><br><span class="line">y0:复制光标所在的那个字符到该行行首的所有数据</span><br><span class="line">y$: 复制光标所在的那个字符到该行行尾的所有数据</span><br><span class="line">yw: </span><br><span class="line">J:将光标所在行与下一行的数据结合成同一行</span><br><span class="line">c:重复删除多个数据</span><br><span class="line">u:  复原前一个动作</span><br><span class="line">Ctrl+r:重做上一个动作</span><br><span class="line"></span><br><span class="line">保存退出</span><br><span class="line">:wq保存并退出</span><br><span class="line">:wq! 强制保存并退出</span><br><span class="line">:q  离开vim</span><br><span class="line">:q! 强制退出不保存</span><br><span class="line">:w将文本保存</span><br><span class="line">:w!若文件为只读时，强制写入该档案。但取决于权限</span><br><span class="line">:w xxx.xx:  将编辑的数据保存成另一个档案，类似于另存</span><br><span class="line">:x! </span><br><span class="line">:n1,n2 w filename:将n1到n2的内容存储成filename这个档案</span><br><span class="line">ZZ: 文件没有改动，则不保存离开，若改动，则保存后离开</span><br><span class="line">:! command: 暂时离开vim到指令模式下执行命令</span><br></pre></td></tr></table></figure><h3 id="方向键"><a href="#方向键" class="headerlink" title="方向键"></a>方向键</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">h:向左H:屏幕上方那一行的第一个字符</span><br><span class="line">j:向下M:屏幕中央那一行的第一个字符</span><br><span class="line">k:向上L:屏幕下方...</span><br><span class="line">l:向右G:移到档案的最后一行</span><br><span class="line">Ctrl + f:屏幕向下一页</span><br><span class="line">Ctrl + b:屏幕向上一页</span><br><span class="line">Ctrl + d:屏幕向下移动半页</span><br><span class="line">Ctrl + u:屏幕向上移动半页</span><br><span class="line">+:光标移动到非空格符的下一行</span><br><span class="line">-：光标移动到非空格符的上一行</span><br><span class="line">n&lt;space&gt;:n 表示数字，按下数字再按空格键</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">光标以单词位单位移动</span><br><span class="line">w|W:</span><br><span class="line">b|B:</span><br><span class="line">e|E:</span><br><span class="line">nw|nW:</span><br><span class="line">nb|nB:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">光标移动至行首或行尾</span><br><span class="line">0 | ^:光标移动到行首</span><br><span class="line">$:光标移动到行尾</span><br><span class="line">n$:</span><br><span class="line"></span><br><span class="line">光标移动到指定字符</span><br><span class="line">fx:</span><br><span class="line">Fx:</span><br><span class="line"></span><br><span class="line">光标移动到指定行</span><br><span class="line">gg:移到档案第一行</span><br><span class="line">G:移到档案最后一行</span><br><span class="line">nG:移动到档案的第n行</span><br><span class="line">:n:光标向下移动n行</span><br><span class="line"></span><br><span class="line">光标移动到匹配的括号处</span><br><span class="line">%: 将光标先定位到 &quot;&#123;&quot; ,然后再使用 &quot; % &quot; 命令，可定位到 &quot; &#125; &quot; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">批量注释和自定义注释快捷键</span><br><span class="line">s/^/#/g:</span><br><span class="line">eg: :1,10s/^/#/g:</span><br><span class="line"></span><br><span class="line">取消连续行注释</span><br><span class="line">:1,10s/^#//g:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">:map 快捷键 执行命令</span><br></pre></td></tr></table></figure><p><a href="http://c.biancheng.net/view/813.html" target="_blank" rel="noopener">Vim map </a></p><p><a href="https://www.runoob.com/wp-content/uploads/2015/10/vi-vim-cheat-sheet-sch.gif" target="_blank" rel="noopener">Vim</a></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt; iFaithFreedom &lt;/center&gt;
    
    </summary>
    
      <category term="Vim" scheme="http://yoursite.com/categories/Vim/"/>
    
    
      <category term="Vim" scheme="http://yoursite.com/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="http://yoursite.com/2019/08/09/Git-Note/"/>
    <id>http://yoursite.com/2019/08/09/Git-Note/</id>
    <published>2019-08-09T10:58:44.000Z</published>
    <updated>2019-08-31T12:42:37.586Z</updated>
    
    <content type="html"><![CDATA[<center> iFaithFreedom </center><a id="more"></a> <h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><h3 id="建Git仓库"><a href="#建Git仓库" class="headerlink" title="建Git仓库"></a>建Git仓库</h3><p>两种场景：</p><h4 id="1-把已有的项目代码纳入Git管理"><a href="#1-把已有的项目代码纳入Git管理" class="headerlink" title="1. 把已有的项目代码纳入Git管理"></a>1. 把已有的项目代码纳入Git管理</h4><p>cd 项目代码所在的文件夹<br>git init</p><h4 id="2-新建的项目直接用Git管理"><a href="#2-新建的项目直接用Git管理" class="headerlink" title="2. 新建的项目直接用Git管理"></a>2. 新建的项目直接用Git管理</h4><p>cd 某个文件夹<br>git init your_project    # 会在当前路径下创建和项目名称同名的文件夹<br>cd your_project</p><h3 id="Git-分离头指针"><a href="#Git-分离头指针" class="headerlink" title="Git 分离头指针"></a>Git 分离头指针</h3><pre><code>在没有绑定分支的情况下，git status 会显示 HEAD， 后面需要 git branch xxx head_id    如果没有保存，会被当作垃圾清理掉</code></pre><h3 id="HEAD-branch"><a href="#HEAD-branch" class="headerlink" title="HEAD  branch"></a>HEAD  branch</h3><pre><code>git checkout -b xxx yyy                 // 基于yyy 创建 xxx 分支HEAD 可脱离分支，独立存在</code></pre><p>git diff        // 比较两个commit 的不同        git diff HEAD HEAD^ | HEAD～n</p><h3 id="查看不同提交的指定文件的差异"><a href="#查看不同提交的指定文件的差异" class="headerlink" title="查看不同提交的指定文件的差异"></a>查看不同提交的指定文件的差异</h3><pre><code>git diff 分支1 分支2 -- 文件            //      比较不同分支的差异git diff 分支指针1 分支指针2 -- 文件     // 用分支比较文件的差异</code></pre><h3 id="正确删除文件的方法"><a href="#正确删除文件的方法" class="headerlink" title="正确删除文件的方法"></a>正确删除文件的方法</h3><pre><code>git rm xxx                      //      删除xxx 文件</code></pre><h3 id="开发中临时加塞了紧急任务的处理方法"><a href="#开发中临时加塞了紧急任务的处理方法" class="headerlink" title="开发中临时加塞了紧急任务的处理方法"></a>开发中临时加塞了紧急任务的处理方法</h3><pre><code>git stash                       // 把现在做的工作任务存放到不影响接下来要做的工作环境中去git stash list          //      查看所有的stash 任务的列表git statusgit stash apply         //      弹出最新的stash， 不保留stash 的任务git stash pop           //      弹出最新的stash 工作，存放起来的任务还在</code></pre><h3 id="指定不需要Git管理的文件"><a href="#指定不需要Git管理的文件" class="headerlink" title="指定不需要Git管理的文件"></a>指定不需要Git管理的文件</h3><pre><code>.gitignore                      // 文件中添加不需要被提交的文件类型</code></pre><h3 id="将Git仓库备份到本地"><a href="#将Git仓库备份到本地" class="headerlink" title="将Git仓库备份到本地"></a>将Git仓库备份到本地</h3><pre><code>git clone --bare        // 不在工作区的仓库哑协议： git clone --bare 本地仓库.git  新建仓库name.git</code></pre><h3 id="添加公钥到Github-SSH-and-GPG-keys"><a href="#添加公钥到Github-SSH-and-GPG-keys" class="headerlink" title="添加公钥到Github SSH and GPG keys"></a>添加公钥到Github SSH and GPG keys</h3><h3 id="在Github-创建个人仓库"><a href="#在Github-创建个人仓库" class="headerlink" title="在Github 创建个人仓库"></a>在Github 创建个人仓库</h3><h3 id="把本地仓库同步到Github"><a href="#把本地仓库同步到Github" class="headerlink" title="把本地仓库同步到Github"></a>把本地仓库同步到Github</h3><pre><code>git remote add xxx git@github.com:aspire_8/xxx.git              // 新增远程Github仓库git remote remove xxx                           //      删除远程Github仓库git remote rename oldName newName                               // 更改远程Github仓库的名称git push xxx -all               // 提交本地所有分支到远端</code></pre><h4 id="一般出错的情况"><a href="#一般出错的情况" class="headerlink" title="一般出错的情况"></a>一般出错的情况</h4><pre><code>在推送前，需要先 拉取 远程仓库到本地git pull                //      拉取远程到本地并且合并，等同于 git fetch + git mergegit fetch               // 仅仅把远端的拉到本地git merge 远端分支/本地分支(master)             // 合并分支</code></pre><h4 id="把不相干的两个分支合并"><a href="#把不相干的两个分支合并" class="headerlink" title="把不相干的两个分支合并"></a>把不相干的两个分支合并</h4><pre><code>git merge --allow-unrelater-histories 远端仓库/本地仓库</code></pre><h3 id="不同人修改了同文件的不同区域的处理方案"><a href="#不同人修改了同文件的不同区域的处理方案" class="headerlink" title="不同人修改了同文件的不同区域的处理方案"></a>不同人修改了同文件的不同区域的处理方案</h3><pre><code>git push</code></pre><h3 id="不同人修改了同文件的同一区域的处理方案"><a href="#不同人修改了同文件的同一区域的处理方案" class="headerlink" title="不同人修改了同文件的同一区域的处理方案"></a>不同人修改了同文件的同一区域的处理方案</h3><pre><code>global: git pull        vim xxx.xx              git pushlocal : git pull        vim xxx.xx              git push会出错，local没办法提交，解决方案vim xxx.xx              //      把修改的同一地方，删除其中一个人的修改，删除git的提示信息git status              -&gt;              git commit -am &apos;解决冲突&apos;  -&gt;  git push</code></pre><h3 id="同时变更了文件名和文件内容的处理方案"><a href="#同时变更了文件名和文件内容的处理方案" class="headerlink" title="同时变更了文件名和文件内容的处理方案"></a>同时变更了文件名和文件内容的处理方案</h3><pre><code>global 在更改同一文件名和内容之后local  在本地修改文件内容， git pull 的时候，git会弹出界面提示修改的信息，同时也会在被更改</code></pre><p>文件中，添加local修改的内容</p><h3 id="把同一文件改成不同文件名的处理方案"><a href="#把同一文件改成不同文件名的处理方案" class="headerlink" title="把同一文件改成不同文件名的处理方案"></a>把同一文件改成不同文件名的处理方案</h3><pre><code>global: 修改xxx.xx 为 xxxa.xx，local:  修改  xxx.xx 为 xxb.xxglobal: git push                local: git pull , git rm xxx.xx, git rm xxa.xx, git add xxb.xx, git commit -m &apos;delete xxx.xx xxa.xx&apos;      git push</code></pre><h3 id="禁止向集成分支执行push-f-操作"><a href="#禁止向集成分支执行push-f-操作" class="headerlink" title="禁止向集成分支执行push -f 操作"></a>禁止向集成分支执行push -f 操作</h3><pre><code>git push -f示例:        git log --oneline                               // 查看历史日志        git reset --hard commitID               // 在本地使用reset 恢复到 任意一个commit的历史，如</code></pre><p>果使用 -f 提交的话，远程仓库所有被提交的commit之前的改动都会被删除掉，很危险！！！</p><h3 id="禁止向集成分支执行变更历史的操作"><a href="#禁止向集成分支执行变更历史的操作" class="headerlink" title="禁止向集成分支执行变更历史的操作"></a>禁止向集成分支执行变更历史的操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Author : Hale Lv</span><br><span class="line">@Created Time : 2019-08-31 19:27:26</span><br><span class="line">@Description :</span><br></pre></td></tr></table></figure><h2 id="Git-1"><a href="#Git-1" class="headerlink" title="Git"></a>Git</h2><h3 id="Git-简介"><a href="#Git-简介" class="headerlink" title="Git 简介"></a>Git 简介</h3><pre><code>最先进的分布式版本控制系统安装 Git    Linux：         Centos: yum install -y git        Ununtu: apt install -y git配置：        git config --global user.name &apos;Hale&apos;    git config --global user.email &apos;Aspire_8@163.com&apos;创建版本库    创建仓库文件夹： mkdir Git        cd Git    初始化仓库：git init    // 初始化仓库，把这个目录变成Git可管理的仓库    添加文件到仓库： git add xxx.xx    编写提交信息： git commit -m &apos;xxxxx&apos;</code></pre><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><pre><code>版本回退：    查看仓库当前的状态：git status     比较文件修改的不同：git diff xxx.xx查看历史记录：     git log    git log --pretty=oneline  // 简化输出的日子信息回退到上一个版本：    git reset --hard HEAD^|Commit_IDGit命令历史：    git reflog工作区和暂存区    工作区：管理修改    如新建一个文件：readme.txt    git add readme.txt    vim readme.txt 修改readme.txt 文件    git commit -m &apos;add readme.txt&apos;    git status     比较工作和版本库文件的区别：        git diff HEAD --readme.txt 撤销修改    git status     把readme.txt在工作去的修改全部撤销        git checkout -- file            git checkout -- readme.txt    git add readme.txt    git status    把暂存区的修改撤销掉，从新放回工作区：        git reset HEAD readme.txt    git status     丢弃工作区的修改：        git checkout -- readme.txt删除文件    git add readme.txt    git commit -m &apos;add readme.txt&apos;    rm readme.txt     git status    git rm readme.txt    git commit -m &apos;remove readme.txt&apos;    把误删的文件回复到最新版本:        git checkout -- readme.txt</code></pre><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><pre><code>ssh-keygen -t rsa -C &apos;aspire_8@163.com&apos;    cat ~/.ssh/id_ras.pub复制公钥到github SSH-KEY添加远程库    git remote add origin git@github.com:i-china/2048.git    git remote add origin git@github.com:i-china/1024.git推送本地库所有内容到远程库    git push -u origin master            // 把当前分支master推送到远程    git push origin master    git push 从远程库克隆    git clone git@github.com:i-china/4096.git</code></pre><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><pre><code>    创建与合并分支        git checkout -b dev                    // 创建dev分支，并切换到dev分支            =    git branch dev                =+    git ckekout dev         查看当前分支            git branch         git checkout master    把dev分支的工作成果合并到master分支：        git merge dev    删除分支        git branch -d dev    Switch        创建并切换到新的dev分支：            git switch -c dev        直接切换到已有master分支：            git switch master    解决冲突        创建新的分支 dev            git checkout -b new                编写readme.txt内容            git add readme.txt        切换到master分支            git checkout master                编写readme.txt内容            git add readme.txt        把各自修改合并起来            git merge dev            此时会报冲突            git status             查看readme.txt 文件内容                Git 用 &lt;&lt;&lt;&lt;&lt; ===== &gt;&gt;&gt;&gt;&gt; 标记不同分支的内容，修改保存即可                git add readme.txt                git log            删除dev分支                git branch -d dev            查看分支合并图                git log --graph    分支管理策略        git checkout -b dev        git add readme.txt        git checkout master        git merge --no-off -m &apos;merge with no-off&apos; dev         git log    Bug 分支        git status        git stash         git checkout master        git checkout -b issue-dev        git add readme.txt        git checkout master        git merge --no-off -m &apos;merged bug fix dev&apos; issue-dev        git checkout dev        git status         git stash list         git stash apply | git stash pop        git stash list        复制一个特定的提交到当前分支            git branch            git cherry-pick commit_id    Feature 分支        git checkout -b work        git add readme.txt        git commit -m &apos;add readme.txt&apos;        git checkout dev        删除work 分支            git branch -d work         强行删除            git branch -D work    多人协作        git remote         git remote -v         git push origin master        git push origin dev        抓取分支            git clone git@github.com:i-china/2048.git        git branch         git checkout -b dev origin/dev        git add readme.txt        git push origin dev        git pul         git branch --set-upstream-to=origin/dev dev        git pull         git commit -m &apos;fix dev readme.txt&apos;        git push origin dev     Rebase        git log --graph --pretty=oneline --abbrev-commit        git push origin master        git pull         git staus         git log --graph --pretty=oneline --abbrev-commit        git rebase        git log --graph --pretty=oneline --abbrev-commit        git push origin master        git log --graph --pretty=oneline --abbrev-commit标签管理    创建标签：        git branch         git checkout master        git tar v1.0        git tag         git log --pretty=oneline --abbrev-commit        git tag v0.9 &lt;commit_id&gt;        git tag         git show v0.9        git tag -a v1.0 -m &apos;version 1.0 released&apos; &lt;commit_id&gt;        git show v1.0    操作标签        删除标签：            git tag -d v1.0         git push origin v1.0         git push origin --tags         删除本地标签：            git tag -d v0.9        删除一个远程标签            git push origin :refs/tags/v0.9</code></pre><h3 id="使用码云"><a href="#使用码云" class="headerlink" title="使用码云"></a>使用码云</h3><pre><code>git remote add origin git@gitee.com:aspire_8/2048.gitgit remote -vgit remote rm origingit remote add github git@github.com:i-china/2048.gitgit remote -vgit remote rm origin git remote add gitee git@gitee.com:aspire_8/4096.gitgit remote -vgit push origin master git push gitee master</code></pre><h3 id="自定义Git"><a href="#自定义Git" class="headerlink" title="自定义Git"></a>自定义Git</h3><pre><code>    git config --global color.ui true    忽略特殊文件        .gitignore            *.xx        git add remade.xx        git add -f readme.xx        git check-ignore -v readme.xx    配置别名        git config --global alias.st status        git config --global alias.ci commit        git config --global alias.br branch        git config --global alias.unstage &apos;reset HEAD&apos;        git config --global alias.last &apos;log-l&apos;        把配置别名放在一个文件中，方便管理            cat ~/.git/config            vim ~/.git/config                [alias]                    last = log -1                    co = checkout                    ci = commit                    br = branch                     st = status                [user]                     name = Hale                    email = Aspire_8@163.com搭建Git服务器    apt install git    adduser git    收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个。    git init --bare git.git     chown -R git:git git.git    git clone git@server:/srv/git.git[Git Cheat Sheet](https://gitee.com/liaoxuefeng/learn-java/raw/master/teach/git-cheatsheet.pdf)</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;center&gt; iFaithFreedom &lt;/center&gt;
    
    </summary>
    
      <category term="Git" scheme="http://yoursite.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Life</title>
    <link href="http://yoursite.com/2019/08/08/Life-Note/"/>
    <id>http://yoursite.com/2019/08/08/Life-Note/</id>
    <published>2019-08-07T18:15:28.000Z</published>
    <updated>2019-09-02T14:25:15.049Z</updated>
    
    <content type="html"><![CDATA[<center> Hale's Life </center><a id="more"></a><hr><p>记： 七夕节，回家做晚饭，吃完饭大概八点多，躺了一会，出去散了个步，回到家十点半，洗了个澡，十一点。<br>然后闲着无聊，开始着手部署博客项目。到现在是8.8号凌晨 两点多。阿哈，真累！</p><p>以后要养成记笔记的习惯，哈哈，不然学会的东西很快就会忘记的额～！</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt; Hale&#39;s Life &lt;/center&gt;
    
    </summary>
    
      <category term="Life" scheme="http://yoursite.com/categories/Life/"/>
    
      <category term="Year" scheme="http://yoursite.com/categories/Life/Year/"/>
    
      <category term="Month" scheme="http://yoursite.com/categories/Life/Year/Month/"/>
    
      <category term="Day" scheme="http://yoursite.com/categories/Life/Year/Month/Day/"/>
    
    
      <category term="Life" scheme="http://yoursite.com/tags/Life/"/>
    
  </entry>
  
</feed>
